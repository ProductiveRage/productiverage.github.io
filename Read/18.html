<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Productive Rage - Extendable LINQ-compilable Mappers</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta name="theme-color" content="#393939" />
	<link rel="stylesheet" type="text/css" media="all" href="/Content/Styles.css" />
	<!--[if lt IE 9]>
	<link rel="stylesheet" type="text/css" href="/Content/IEBefore9.css" />
	<![endif]-->
	<link rel="stylesheet" type="text/css" media="print" href="/Content/PrintOverrides.css" />
	<link rel="canonical" href="http://www.productiverage.com/extendable-linqcompilable-mappers" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.productiverage.com/feed" />
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', "UA-32312857-1"]);
		_gaq.push(['_setSiteSpeedSampleRate', 100]);
		_gaq.push(['_trackPageview']);
		(function () {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="productiverage" />
    <meta name="twitter:title" content="Extendable LINQ-compilable Mappers" />
    <meta name="twitter:image" content="http://www.productiverage.com/Content/Images/Grouch.jpg" />
    <meta name="twitter:description" content="To pick up from where I left off in a previous post, I was trying to write something that could automatically generate LINQ Expressions that could translate from (for example) -" />
</head>

<body>

	<div class="Header">
		<div class="HeaderContent">
			<h1>
				<a href="/">Productive Rage</a>
			</h1>
			<span class="Tagline">Dan's techie ramblings</span>
		</div>
	</div>

	<div class="WrapperOuter">
		<div class="Wrapper">
			<div class="Main HasSideBar">
				

        <script type="text/javascript">
			var disqus_shortname = "productiverage";
			function executeWhen(fncAction, fncConditional, intDelayBetweenRetries) {
				if (fncConditional()) { fncAction(); return; }
				setTimeout(function () { executeWhen(fncAction, fncConditional, intDelayBetweenRetries); }, intDelayBetweenRetries);
			}
			function whenjQueryIsAvailable(fncAction) {
				executeWhen(
					fncAction,
					function () { return (typeof ($) !== "undefined") },
					10
				);
			}
			(function () {
				whenjQueryIsAvailable(
					function () { $("div.Content p.Comments").show(); }
				);
			}());
        </script>

    <div class="Content SinglePost">
        <h3 class="PostDate">2 January 2012</h3><h2><a id="extendable-linqcompilable-mappers" href="/extendable-linqcompilable-mappers">Extendable LINQ-compilable Mappers</a></h2>
<p>To pick up from where I left off in a <a href="/automapperbyconstructor-without-automapper-and-faster">previous post</a>, I was trying to write something that could automatically generate LINQ Expressions that could translate from (for example) -</p>
<pre><code>public class SourceEmployee
{
    public string Name { get; set; }
    public SourceRole Role { get; set; }
}

public class SourceRole
{
    public string Description { get; set; }
}
</code></pre>
<p>to</p>
<pre><code>public class DestEmployee
{
    public DestEmployee(string name, DestRole role)
    {
        Name = name;
        Role = role;
    }
    public string Name { get; private set; }
    public DestRole Role { get; private set; }
}

public class DestRole
{
    public DestRole(string description)
    {
        Description = description;
    }
    public string Description { get; private set; }
}
</code></pre>
<p>by applying name matching logic between properties on the source types and constructor arguments on the destination types. Having this all performed by LINQ Expressions should allow the final conversion to be comparatively fast to hand-rolled code.</p>
<p>This was all kicked off initially since I was using <a href="http://automapper.codeplex.com/">AutoMapper</a> for some work and wasn't happy with its approach to mapping to types that have to be initialised with verbose constructors (as opposed to a parameter-less constructor and then the setting of individual properties). This much was achieved and the solution can be found here -</p>
<p><a href="https://github.com/ProductiveRage/AutoMapper-By-Constructor-1/tree/FirstImplementation">https://github.com/ProductiveRage/AutoMapper-By-Constructor-1/tree/FirstImplementation</a>.</p>
<p>But I wanted to see if I could improve the performance by removing AutoMapper from the equation and using LINQ Expressions.</p>
<h3>A more detailed recap</h3>
<p>Where we left the code as of</p>
<p><a href="https://github.com/ProductiveRage/AutoMapper-By-Constructor-1/tree/LinqExpressionPropertyGetters">https://github.com/ProductiveRage/AutoMapper-By-Constructor-1/tree/LinqExpressionPropertyGetters</a></p>
<p>we had the class</p>
<pre><code>public class CompilableTypeConverterByConstructor&lt;TSource, TDest&gt;
    : ITypeConverterByConstructor&lt;TSource, TDest&gt;
{
    // ..
    private Lazy&lt;Func&lt;TSource, TDest&gt;&gt; _converter;
    public CompilableTypeConverterByConstructor(
        IEnumerable&lt;ICompilablePropertyGetter&gt; propertyGetters,
        ConstructorInfo constructor)
    {
        // ..
        _converter = new Lazy&lt;Func&lt;TSource, TDest&gt;&gt;(generateCompiledConverter, true);
    }

    public ConstructorInfo Constructor
    {
        get
        {
            // ..
        }
    }

    public TDest Convert(TSource src)
    {
        if (src == null)
            throw new ArgumentNullException(&quot;src&quot;);

        return _converter.Value(src);
    }

    private Func&lt;TSource, TDest&gt; generateCompiledConverter()
    {
        var srcParameter = Expression.Parameter(typeof(TSource), &quot;src&quot;);
        var constructorParameterExpressions = new List&lt;Expression&gt;();
        foreach (var constructorParameter in _constructor.GetParameters())
        {
            var index = constructorParameterExpressions.Count;
            constructorParameterExpressions.Add(
                _propertyGetters[index].GetPropertyGetterExpression(srcParameter)
            );
        }

        return Expression.Lambda&lt;Func&lt;TSource, TDest&gt;&gt;(
            Expression.New(
                _constructor,
                constructorParameterExpressions.ToArray()
            ),
            srcParameter
        ).Compile();
    }
}

public interface ITypeConverterByConstructor&lt;TSource, TDest&gt;
{
    ConstructorInfo Constructor { get; }
    TDest Convert(TSource src);
}
</code></pre>
<p>which took a set of &quot;Compilable Property Getters&quot; that matched the arguments for a specified ConstructorInfo</p>
<pre><code>public interface ICompilablePropertyGetter : IPropertyGetter
{
    Expression GetPropertyGetterExpression(Expression param);
}

public interface IPropertyGetter
{
    Type SrcType { get; }
    PropertyInfo Property { get; }
    Type TargetType { get; }
    object GetValue(object src);
}
</code></pre>
<p>and generated an internal conversion using LINQ Expressions.</p>
<p>There were only two Compilable Property Getters - CompilableAssignableTypesPropertyGetter, which would work with property-to-constructor-arguments where no conversion was required (eg. the available property was a string array and the constructor argument was an IEnumerable&lt;string&gt;) and CompilableEnumConversionPropertyGetter, which mapped one enum to another using an INameMatcher implementation. (The enum mapping LINQ Expression is generated by first coming up with a set of mappings and then generating a LINQ Expression consisting of a set of nested &quot;if&quot; statements for each mapped enum value).</p>
<pre><code>public class CompilableAssignableTypesPropertyGetter&lt;TSourceObject, TPropertyAsRetrieved&gt;
    : AbstractGenericCompilablePropertyGetter&lt;TSourceObject, TPropertyAsRetrieved&gt;
{
    private PropertyInfo _propertyInfo;
    public CompilableAssignableTypesPropertyGetter(PropertyInfo propertyInfo)
    {
        if (propertyInfo == null)
            throw new ArgumentNullException(&quot;propertyInfo&quot;);
        if (!propertyInfo.DeclaringType.Equals(typeof(TSourceObject)))
            throw new ArgumentException(&quot;Invalid propertyInfo - DeclaringType must match TSourceObject&quot;);

        _propertyInfo = propertyInfo;
    }

    public override PropertyInfo Property
    {
        get { return _propertyInfo; }
    }

    public override Expression GetPropertyGetterExpression(Expression param)
    {
        if (param == null)
            throw new ArgumentNullException(&quot;param&quot;);
        if (!typeof(TSourceObject).IsAssignableFrom(param.Type))
            throw new ArgumentException(&quot;param.Type must be assignable to typeparam TSourceObject&quot;);

        Expression getter = Expression.Property(
            param,
            _propertyInfo
        );

        var targetType = typeof(TPropertyAsRetrieved);
        if (!targetType.IsAssignableFrom(_propertyInfo.PropertyType))
            getter = Expression.Convert(getter, targetType);

        if (!targetType.IsValueType &amp;&amp; _propertyInfo.PropertyType.IsValueType)
            getter = Expression.TypeAs(getter, typeof(object));

        return getter;
    }
}

public abstract class AbstractGenericCompilablePropertyGetter&lt;TSourceObject, TPropertyAsRetrieved&gt;
    : ICompilablePropertyGetter
{
    private Lazy&lt;Func&lt;TSourceObject, TPropertyAsRetrieved&gt;&gt; _getter;
    public AbstractGenericCompilablePropertyGetter()
    {
        _getter = new Lazy&lt;Func&lt;TSourceObject, TPropertyAsRetrieved&gt;&gt;(generateGetter, true);
    }

    public Type SrcType
    {
        get { return typeof(TSourceObject); }
    }

    public abstract PropertyInfo Property { get; }

    public Type TargetType
    {
        get { return typeof(TPropertyAsRetrieved); }
    }

    object IPropertyGetter.GetValue(object src)
    {
        if (src == null)
            throw new ArgumentNullException(&quot;src&quot;);
        if (!src.GetType().Equals(typeof(TSourceObject)))
            throw new ArgumentException(&quot;The type of src must match typeparam TSourceObject&quot;);
        return GetValue((TSourceObject)src);
    }

    public TPropertyAsRetrieved GetValue(TSourceObject src)
    {
        if (src == null)
            throw new ArgumentNullException(&quot;src&quot;);
        return _getter.Value(src);
    }

    public abstract Expression GetPropertyGetterExpression(Expression param);

    private Func&lt;TSourceObject, TPropertyAsRetrieved&gt; generateGetter()
    {
        var param = Expression.Parameter(typeof(TSourceObject), &quot;src&quot;);
        return Expression.Lambda&lt;Func&lt;TSourceObject, TPropertyAsRetrieved&gt;&gt;(
            GetPropertyGetterExpression(param),
            param
        ).Compile();
    }
}

public interface ICompilablePropertyGetter : IPropertyGetter
{
    /// &lt;summary&gt;
    /// This Linq Expression will retrieves the value from SrcType.Property as TargetType,
    /// the specified &quot;param&quot; Expression must have a type that is assignable to SrcType.
    /// &lt;/summary&gt;
    Expression GetPropertyGetterExpression(Expression param);
}

public interface IPropertyGetter
{
    /// &lt;summary&gt;
    /// This is the type whose property is being accessed
    /// &lt;/summary&gt;
    Type SrcType { get; }

    /// &lt;summary&gt;
    /// This is the property on the source type whose value is to be retrieved
    /// &lt;/summary&gt;
    PropertyInfo Property { get; }

    /// &lt;summary&gt;
    /// This is the type that the property value should be converted to and returned as
    /// &lt;/summary&gt;
    Type TargetType { get; }

    /// &lt;summary&gt;
    /// Try to retrieve the value of the specified Property from the specified object
    /// (which must be of type SrcType)
    /// &lt;/summary&gt;
    object GetValue(object src);
}
</code></pre>
<p>and to generate instances of these classes we had some factories (CompilableTypeConverterByConstructorFactory, CompilableAssignableTypesPropertyGetterFactory and CompilableEnumConversionPropertyGetterFactory). These would do the work of examining the properties and constructors of specified source and destination type pairs and determining the best constructor that could be satisfied (if any) with the Compilable Property Getters. The code in these factories is none too exciting.</p>
<h3>The problem</h3>
<p>If the mappings we want to generate are for very simple structures (in this case, &quot;simple&quot; means that all property-to-constructor-argument mappings are either directly assignable-to or are enum mappings) then everything's rosy - eg.</p>
<pre><code>public class SourceEmployee
{
    public string Name { get; set; }
    public SourceRole Role { get; set; }
}

public enum SourceRole
{
    big_boss_man,
    worker_bee
}
</code></pre>
<p>to</p>
<pre><code>public class DestEmployee
{
    public DestEmployee(string name, DestRole role)
    {
        Name = name;
        Role = role;
    }
    public string Name { get; private set; }
    public DestRole Role { get; private set; }
}

public enum DestRole
{
    BigBossMan,
    WorkerBee
}
</code></pre>
<p>(The enum mapping in this example would be handled by specifying a CaseInsensitiveSkipUnderscoreNameMatcher for the CompilableEnumConversionPropertyGetterFactory).</p>
<p>But the problem I opened with does <em>not</em> come under this &quot;simple structure&quot; umbrella as in that case SourceRole and DestRole are types for which we have no Compilable Property Getter! Oh nos!</p>
<h3>The CompilableTypeConverterPropertyGetter</h3>
<p>For inspiration, I go back to AutoMapper since it too can not magically handle nested types -</p>
<pre><code>class Program
{
    static void Main(string[] args)
    {
        AutoMapper.Mapper.CreateMap&lt;SourceTypeSub1, DestTypeSub1&gt;();
        AutoMapper.Mapper.CreateMap&lt;SourceType, DestType&gt;();
        var dest = AutoMapper.Mapper.Map&lt;SourceType, DestType&gt;(
            new SourceType()
            {
                Value = new SourceTypeSub1() { Name = &quot;N1&quot; }
            }
        );
    }
}

public class SourceType
{
    public SourceTypeSub1 Value { get; set; }
}

public class SourceTypeSub1
{
    public string Name { get; set; }
}

public class DestType
{
    public DestTypeSub1 Value { get; set; }
}

public class DestTypeSub1
{
    public string Name { get; set; }
}
</code></pre>
<p>without the CreateMap call for SourceTypeSub1 to DestTypeSub1, the Map call from SourceType to DestType would fail with an AutoMapperMappingException.</p>
<p>Following the same tack, a way to create a new Compilable Property Getter from a CompilableTypeConverterByConstructor (which could then be used alongside the existing AssignableType and Enum Compilable Property Getters) should solve the problem. A plan!</p>
<p>Step one is going to be to expose a way to request the LINQ Expression that the CompilableTypeConverterByConstructor uses in its conversion. To address this we'll update CompilableTypeConverterByConstructor to implement a new interface ICompilableTypeConverterByConstructor which in turn implements ITypeConverterByConstructor (which is all that CompilableTypeConverterByConstructor implemented previously) -</p>
<pre><code>public interface ICompilableTypeConverterByConstructor&lt;TSource, TDest&gt;
    : ICompilableTypeConverter&lt;TSource, TDest&gt;,
      ITypeConverterByConstructor&lt;TSource, TDest&gt; { }

public interface ICompilableTypeConverter&lt;TSource, TDest&gt;
    : ITypeConverter&lt;TSource, TDest&gt;
{
    /// &lt;summary&gt;
    /// This Linq Expression will generate a new TDest instance - the specified &quot;param&quot;
    /// Expression must have a type that is assignable to TSource
    /// &lt;/summary&gt;
    Expression GetTypeConverterExpression(Expression param);
}

public interface ITypeConverterByConstructor&lt;TSource, TDest&gt; : ITypeConverter&lt;TSource, TDest&gt;
{
    ConstructorInfo Constructor { get; }
}

public interface ITypeConverter&lt;TSource, TDest&gt;
{
    TDest Convert(TSource src);
}
</code></pre>
<p>The ITypeConverterByConstructor has now become a specialised form of ITypeConverter (with corresponding Compilable variants) which inherently makes sense but will also be useful where we're going (but let's not get ahead of ourselves, that's coming up later in the post).</p>
<p>More importantly is the ICompilableTypeConverter GetTypeConverterExpression method which allows the creation of a Compilable Property Getter that is based upon a conversion that we want to feed back into the mapper -</p>
<pre><code>public class CompilableTypeConverterPropertyGetter&lt;TSourceObject, TPropertyOnSource, TPropertyAsRetrieved&gt;
    : AbstractGenericCompilablePropertyGetter&lt;TSourceObject, TPropertyAsRetrieved&gt;
{
    private PropertyInfo _propertyInfo;
    private ICompilableTypeConverter&lt;TPropertyOnSource, TPropertyAsRetrieved&gt; _compilableTypeConverter;
    public CompilableTypeConverterPropertyGetter(
        PropertyInfo propertyInfo,
        ICompilableTypeConverter&lt;TPropertyOnSource, TPropertyAsRetrieved&gt; compilableTypeConverter)
    {
        if (propertyInfo == null)
            throw new ArgumentNullException(&quot;propertyInfo&quot;);
        if (!propertyInfo.DeclaringType.Equals(typeof(TSourceObject)))
            throw new ArgumentException(&quot;Invalid propertyInfo - DeclaringType must match TSourceObject&quot;);
        if (!propertyInfo.PropertyType.Equals(typeof(TPropertyOnSource)))
            throw new ArgumentException(&quot;Invalid propertyInfo - PropertyType must match TPropertyOnSource&quot;);
        if (compilableTypeConverter == null)
            throw new ArgumentNullException(&quot;compilableTypeConverter&quot;);

        _propertyInfo = propertyInfo;
        _compilableTypeConverter = compilableTypeConverter;
    }

    public override PropertyInfo Property
    {
        get { return _propertyInfo; }
    }

    /// &lt;summary&gt;
    /// This Linq Expression will retrieves the value from SrcType.Property as TargetType,
    /// the specified &quot;param&quot; Expression must have a type that is assignable to SrcType.
    /// &lt;/summary&gt;
    public override Expression GetPropertyGetterExpression(Expression param)
    {
        if (param == null)
            throw new ArgumentNullException(&quot;param&quot;);
        if (typeof(TSourceObject) != param.Type)
            throw new ArgumentException(&quot;param.NodeType must match typeparam TSourceObject&quot;);

        // Get property value (from object of type TSourceObject) without conversion (this
        // will be as type TPropertyOnSource)
        // - If value is null, return default TPropertyAsRetrieved (not applicable if a
        //   value type)
        // - Otherwise, pass through type converter (to translate from TPropertyOnSource
        //   to TPropertyAsRetrieved)
        var propertyValue = Expression.Property(param, _propertyInfo);
        var conversionExpression = _compilableTypeConverter.GetTypeConverterExpression(propertyValue);
        if (typeof(TPropertyOnSource).IsValueType)
            return conversionExpression;
        return Expression.Condition(
            Expression.Equal(
                propertyValue,
                Expression.Constant(null)
            ),
            Expression.Constant(default(TPropertyAsRetrieved), typeof(TPropertyAsRetrieved)),
            conversionExpression
        );
    }
}
</code></pre>
<p>A corresponding CompilableTypeConverterPropertyGetterFactory is straight-forward to write. Like the other Property Getter Factories, it doesn't do a huge amount - it will determine whether a named property can be retreived from a specified type and converted <em>into</em> a specified type based upon name match rules and what kind of Property Getter that Factory can generate)</p>
<pre><code>public class CompilableTypeConverterPropertyGetterFactory&lt;TPropertyOnSource, TPropertyAsRetrieved&gt;
    : ICompilablePropertyGetterFactory
{
    private INameMatcher _nameMatcher;
    private ICompilableTypeConverter&lt;TPropertyOnSource, TPropertyAsRetrieved&gt; _typeConverter;
    public CompilableTypeConverterPropertyGetterFactory(
        INameMatcher nameMatcher,
        ICompilableTypeConverter&lt;TPropertyOnSource, TPropertyAsRetrieved&gt; typeConverter)
    {
        if (nameMatcher == null)
            throw new ArgumentNullException(&quot;nameMatcher&quot;);
        if (typeConverter == null)
            throw new ArgumentNullException(&quot;typeConverter&quot;);

        _nameMatcher = nameMatcher;
        _typeConverter = typeConverter;
    }

    /// &lt;summary&gt;
    /// This will return null if unable to return an ICompilablePropertyGetter for the
    /// named property that will return a value as the requested type
    /// &lt;/summary&gt;
    public ICompilablePropertyGetter Get(
        Type srcType,
        string propertyName,
        Type destPropertyType)
    {
        if (srcType == null)
            throw new ArgumentNullException(&quot;srcType&quot;);
        propertyName = (propertyName ?? &quot;&quot;).Trim();
        if (propertyName == &quot;&quot;)
            throw new ArgumentException(&quot;Null/empty propertyName specified&quot;);
        if (destPropertyType == null)
            throw new ArgumentNullException(&quot;destPropertyType&quot;);

        // If destination type does not match type converter's destination type then can
        // not handle the request; return null
        if (destPropertyType != typeof(TPropertyAsRetrieved))
            return null;

        // Try to get a property we CAN retrieve and convert as requested..
        var property = srcType.GetProperties().FirstOrDefault(p =&gt;
            p.GetIndexParameters().Length == 0
            &amp;&amp; _nameMatcher.IsMatch(propertyName, p.Name)
            &amp;&amp; p.PropertyType == typeof(TPropertyOnSource)
        );
        if (property == null)
            return null;

        // .. if successful, use to instantiate a CompilableTypeConverterPropertyGetter
        return (ICompilablePropertyGetter)Activator.CreateInstance(
            typeof(CompilableTypeConverterPropertyGetter&lt;,,&gt;).MakeGenericType(
                srcType,
                property.PropertyType,
                destPropertyType
            ),
            property,
            _typeConverter
        );
    }

    IPropertyGetter IPropertyGetterFactory.Get(
        Type srcType,
        string propertyName,
        Type destPropertyType)
    {
        return Get(srcType, propertyName, destPropertyType);
    }
}
</code></pre>
<p>Note: I skipped over actually altering the CompilableTypeConverterByConstructor class to implement the GetTypeConverterExpression but it wasn't anything too complex, the generateCompiledConverter method was changed from</p>
<pre><code>private Func&lt;TSource, TDest&gt; generateCompiledConverter()
{
    var srcParameter = Expression.Parameter(typeof(TSource), &quot;src&quot;);
    var constructorParameterExpressions = new List&lt;Expression&gt;();
    foreach (var constructorParameter in _constructor.GetParameters())
    {
        var index = constructorParameterExpressions.Count;
        constructorParameterExpressions.Add(
            _propertyGetters[index].GetPropertyGetterExpression(srcParameter)
        );
    }

    return Expression.Lambda&lt;Func&lt;TSource, TDest&gt;&gt;(
        Expression.New(
            _constructor,
            constructorParameterExpressions.ToArray()
        ),
        srcParameter
    ).Compile();
}
</code></pre>
<p>and expanded into</p>
<pre><code>private Func&lt;TSource, TDest&gt; generateCompiledConverter()
{
    var srcParameter = Expression.Parameter(typeof(TSource), &quot;src&quot;);
    return Expression.Lambda&lt;Func&lt;TSource, TDest&gt;&gt;(
        GetTypeConverterExpression(srcParameter),
        srcParameter
    ).Compile();
}

/// &lt;summary&gt;
/// This Linq Expression will generate a new TDest instance - the specified &quot;param&quot;
/// Expression must have a type that is assignable to TSource
/// &lt;/summary&gt;
public Expression GetTypeConverterExpression(Expression param)
{
    if (param == null)
        throw new ArgumentNullException(&quot;param&quot;);
    if (!typeof(TSource).IsAssignableFrom(param.Type))
        throw new ArgumentException(&quot;param.Type must be assignable to typeparam TSource&quot;);

    // Instantiate expressions for each constructor parameter by using each of the
    // property getters against the source value
    var constructorParameterExpressions = new List&lt;Expression&gt;();
    foreach (var constructorParameter in _constructor.GetParameters())
    {
        var index = constructorParameterExpressions.Count;
        constructorParameterExpressions.Add(
            _propertyGetters[index].GetPropertyGetterExpression(param)
        );
    }

    // Return an expression that to instantiate a new TDest by using property getters
    // as constructor arguments
    return Expression.Condition(
        Expression.Equal(
            param,
            Expression.Constant(null)
        ),
        Expression.Constant(default(TDest), typeof(TDest)),
        Expression.New(
            _constructor,
            constructorParameterExpressions.ToArray()
        )
    );
}
</code></pre>
<p>The only notable difference is that GetTypeConverterExpression should return an Expression that can deal with null values - we need this so that null properties can be retrieved from source types and passed to destination type constructors. Previously there was a null check against the &quot;src&quot; parameter passed to the Convert method, but this can be relaxed now that nulls have to be supported for this class to work as part of a Property Getter.</p>
<h3>Almost there!</h3>
<p>With the introduction of a CombinedCompilablePropertyGetterFactory (which will run through a set a Compilable Property Getter Factories for each request until one of the returns a non-null value to the Get request), we end up with this structure:</p>
<pre><code>var nameMatcher = new CaseInsensitiveSkipUnderscoreNameMatcher();
var converterFactory = new CompilableTypeConverterByConstructorFactory(
    new ArgsLengthTypeConverterPrioritiserFactory(),
    new CombinedCompilablePropertyGetterFactory(
        new ICompilablePropertyGetterFactory[]
        {
            // Insert Compilable Property Getter Factories here..
        }
    )
);
</code></pre>
<p>which finally allows a setup such as:</p>
<pre><code>var nameMatcher = new CaseInsensitiveSkipUnderscoreNameMatcher();

var roleConverterFactory = new CompilableTypeConverterByConstructorFactory(
    new ArgsLengthTypeConverterPrioritiserFactory(),
    new CombinedCompilablePropertyGetterFactory(
        new ICompilablePropertyGetterFactory[]
        {
            new CompilableAssignableTypesPropertyGetterFactory(nameMatcher),
            new CompilableEnumConversionPropertyGetterFactory(nameMatcher)
        }
    )
);

var employeeConverterFactory = new CompilableTypeConverterByConstructorFactory(
    new ArgsLengthTypeConverterPrioritiserFactory(),
    new CombinedCompilablePropertyGetterFactory(
        new ICompilablePropertyGetterFactory[]
        {
            new CompilableAssignableTypesPropertyGetterFactory(nameMatcher),
            new CompilableEnumConversionPropertyGetterFactory(nameMatcher),
            new CompilableTypeConverterPropertyGetterFactory&lt;SourceRole, DestRole&gt;(
                nameMatcher,
                roleConverterFactory.Get&lt;SourceRole, DestRole&gt;()
            )
        }
    )
);

var employeeConverter = employeeConverterFactory.Get&lt;SourceEmployee, DestEmployee&gt;();

var dest = employeeConverter.Convert(
    new SourceEmployee()
    {
        Name = &quot;Richard&quot;,
        Role = new SourceRole() { Description = &quot;Penguin Cleaner&quot; }
    }
);
</code></pre>
<p>Hoorah!</p>
<p>Now, there's a slight refinement that I want to look at <a href="/the-lesseffort-extendable-linqcompilable-mappers">next time</a> but I think this post has gone on more than long enough.</p>
<h3>Footnote</h3>
<p>For the super-observant, I mentioned that the use of ITypeConverter (as opposed to necessarily requiring ITypeConverterByConstructor) would be touched on again in this post. Since I've run out of steam that will be covered <a href="/the-lesseffort-extendable-linqcompilable-mappers">next time</a> too.</p>
<p class="PostTime">Posted at 14:11</p><div class="PreviousAndNext"><div class="Previous"><h3>Last time:</h3><a class="Previous" href="/dynamically-applying-interfaces-to-objects-part-3">Dynamically applying interfaces to objects - Part 3</a></div><div class="Next"><h3>Next:</h3><a class="Next" href="/the-lesseffort-extendable-linqcompilable-mappers">The Less-Effort Extendable LINQ-compilable Mappers</a></div></div><div class="Related"><h3>You may also be interested in:</h3><ul><li><a href="/reflection-and-c-sharp-optional-constructor-arguments">Reflection and C# optional constructor arguments</a></li><li><a href="/the-artist-previously-known-as-the-automapperbyconstructor">The artist previously known as the AutoMapper-By-Constructor</a></li><li><a href="/the-lesseffort-extendable-linqcompilable-mappers">The Less-Effort Extendable LINQ-compilable Mappers</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/AutoMapper" title="8 Posts">AutoMapper</a></li><li><a href="/Archive/Tag/LINQ" title="12 Posts">LINQ</a></li><li><a href="/Archive/Tag/Reflection" title="15 Posts">Reflection</a></li></ul></div>
                <div id="disqus_thread"></div>
                <script type="text/javascript">
					var disqus_identifier = "18";
					var disqus_title = "Extendable LINQ-compilable Mappers";
					(function () {
						whenjQueryIsAvailable(
							function () {
								$(function () {
									loadCommentsIfHalfwayDownAndNotAlreadyLoaded();
									$(window).scroll(loadCommentsIfHalfwayDownAndNotAlreadyLoaded);
								});
							}
						);

						var bStartedLoadingComments = false;
						function loadCommentsIfHalfwayDownAndNotAlreadyLoaded() {
							if (bStartedLoadingComments) {
								return;
							}
							var $post = $("div.Content.SinglePost");
							var bottomOfPost = $post.position().top + $post.height();
							var $window = $(window);
							if (($window.scrollTop() + $window.height()) >= (bottomOfPost / 2)) {
								bStartedLoadingComments = true;
								loadComments();
							}
						}

						function loadComments() {
							var dsq = document.createElement("script");
							dsq.type = "text/javascript";
							dsq.async = true;
							dsq.src = "https://" + disqus_shortname + ".disqus.com/embed.js";
							(document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]).appendChild(dsq);
						}
					}());
                </script>
    </div>


				<div class="Footer">
					Â© Productive Rage 2011 - 2021
				</div>
			</div>

			<div class="SideBar">
				<div class="About">
					<h2>About</h2>
					<p>Dan is a big geek who likes making stuff with computers! He can be quite outspoken so clearly needs a blog :)</p>
					<p>In the last few minutes he seems to have taken to referring to himself in the third person. He's quite enjoying it.</p>
					<p><a href="mailto:dangger36@gmail.com" class="Email">dangger36@gmail.com</a></p>
				</div>
				<div class="Search">
<form action="/Search" method="get">						<div>
							<input type="text" class="SiteSearch" name="term" value="" />
							<input type="submit" class="SiteSearchSubmit" value="Search" />
						</div>
</form>				</div>
				<div class="Recent"><h2>Recent Posts</h2><ul><li><a href="/automating-suggested-related-posts-links-for-my-blog-posts-part-2">Automating &quot;suggested / related posts&quot; links for my blog posts - Part 2</a></li><li><a href="/automating-suggested-related-posts-links-for-my-blog-posts">Automating &quot;suggested / related posts&quot; links for my blog posts</a></li><li><a href="/language-detection-and-wordsinsentence-classification-in-c-sharp">Language detection and words-in-sentence classification in C#</a></li><li><a href="/monitoring-my-gardens-limited-sunlight-time-period-with-an-arduino-and-some-tupperware">Monitoring my garden&#x27;s limited sunlight time period with an Arduino (and some tupperware)</a></li><li><a href="/how-are-barcodes-read-libraryless-image-processing-in-c-sharp">How are barcodes read?? (Library-less image processing in C#)</a></li></ul><div class="RSSFeedLink"><a href="https://www.productiverage.com/feed">RSS Feed</a></div></div>
				<div class="Featured"><h2>Highlights</h2><ul><li><a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face (finding faces in photos using C# and Accord.NET)</a></li><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/translating-vbscript-into-c-sharp">Translating VBScript into C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div>
				<div class="History"><h2>Archives</h2><ul><li><a href="/Archive/4/2021">April 2021 (2)</a></li><li><a href="/Archive/3/2021">March 2021 (1)</a></li><li><a href="/Archive/8/2020">August 2020 (3)</a></li><li><a href="/Archive/7/2019">July 2019 (2)</a></li><li><a href="/Archive/9/2018">September 2018 (1)</a></li><li><a href="/Archive/4/2018">April 2018 (1)</a></li><li><a href="/Archive/3/2018">March 2018 (1)</a></li><li><a href="/Archive/7/2017">July 2017 (1)</a></li><li><a href="/Archive/6/2017">June 2017 (1)</a></li><li><a href="/Archive/2/2017">February 2017 (1)</a></li><li><a href="/Archive/11/2016">November 2016 (1)</a></li><li><a href="/Archive/9/2016">September 2016 (2)</a></li><li><a href="/Archive/8/2016">August 2016 (1)</a></li><li><a href="/Archive/7/2016">July 2016 (1)</a></li><li><a href="/Archive/6/2016">June 2016 (1)</a></li><li><a href="/Archive/5/2016">May 2016 (3)</a></li><li><a href="/Archive/3/2016">March 2016 (3)</a></li><li><a href="/Archive/2/2016">February 2016 (2)</a></li><li><a href="/Archive/12/2015">December 2015 (1)</a></li><li><a href="/Archive/11/2015">November 2015 (2)</a></li><li><a href="/Archive/8/2015">August 2015 (3)</a></li><li><a href="/Archive/7/2015">July 2015 (1)</a></li><li><a href="/Archive/6/2015">June 2015 (1)</a></li><li><a href="/Archive/5/2015">May 2015 (2)</a></li><li><a href="/Archive/4/2015">April 2015 (1)</a></li><li><a href="/Archive/3/2015">March 2015 (1)</a></li><li><a href="/Archive/1/2015">January 2015 (2)</a></li><li><a href="/Archive/12/2014">December 2014 (1)</a></li><li><a href="/Archive/11/2014">November 2014 (1)</a></li><li><a href="/Archive/10/2014">October 2014 (2)</a></li><li><a href="/Archive/9/2014">September 2014 (2)</a></li><li><a href="/Archive/8/2014">August 2014 (1)</a></li><li><a href="/Archive/7/2014">July 2014 (1)</a></li><li><a href="/Archive/6/2014">June 2014 (1)</a></li><li><a href="/Archive/5/2014">May 2014 (2)</a></li><li><a href="/Archive/2/2014">February 2014 (1)</a></li><li><a href="/Archive/1/2014">January 2014 (1)</a></li><li><a href="/Archive/12/2013">December 2013 (1)</a></li><li><a href="/Archive/11/2013">November 2013 (1)</a></li><li><a href="/Archive/10/2013">October 2013 (1)</a></li><li><a href="/Archive/8/2013">August 2013 (3)</a></li><li><a href="/Archive/7/2013">July 2013 (3)</a></li><li><a href="/Archive/6/2013">June 2013 (1)</a></li><li><a href="/Archive/5/2013">May 2013 (2)</a></li><li><a href="/Archive/4/2013">April 2013 (1)</a></li><li><a href="/Archive/3/2013">March 2013 (8)</a></li><li><a href="/Archive/2/2013">February 2013 (2)</a></li><li><a href="/Archive/1/2013">January 2013 (2)</a></li><li><a href="/Archive/12/2012">December 2012 (3)</a></li><li><a href="/Archive/11/2012">November 2012 (4)</a></li><li><a href="/Archive/9/2012">September 2012 (1)</a></li><li><a href="/Archive/8/2012">August 2012 (1)</a></li><li><a href="/Archive/7/2012">July 2012 (3)</a></li><li><a href="/Archive/6/2012">June 2012 (3)</a></li><li><a href="/Archive/5/2012">May 2012 (2)</a></li><li><a href="/Archive/2/2012">February 2012 (3)</a></li><li><a href="/Archive/1/2012">January 2012 (4)</a></li><li><a href="/Archive/12/2011">December 2011 (7)</a></li><li><a href="/Archive/8/2011">August 2011 (2)</a></li><li><a href="/Archive/7/2011">July 2011 (1)</a></li><li><a href="/Archive/5/2011">May 2011 (1)</a></li><li><a href="/Archive/4/2011">April 2011 (2)</a></li><li><a href="/Archive/3/2011">March 2011 (3)</a></li></ul><div class="EveryTitle"><a href="/Archive/All">Every Post Title</a></div></div>
			</div>

		</div>
	</div>

	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
	<script type="text/javascript" src="/Scripts/jquery.autocomplete.min.js"></script>
	<script type="text/javascript" src="/Scripts/prettify.js"></script>
	<script type="text/javascript" src="/Scripts/Site.js"></script>
	<script type="text/javascript" src="/Scripts/IndexSearchGenerator.js"></script>
	<script type="text/javascript" src="/Scripts/SearchTermHighlighter.js"></script>
	<script type="text/javascript" src="/Scripts/SearchPage.js"></script>
	<script type="text/javascript" src="/Scripts/LZString.js"></script>

</body>
</html>
