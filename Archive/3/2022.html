<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Productive Rage - March 2022</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta name="theme-color" content="#393939" />
	<link rel="stylesheet" type="text/css" media="all" href="/Content/Styles.css" />
	<link rel="stylesheet" type="text/css" media="print" href="/Content/PrintOverrides.css" />
	<meta name="robots" content="noindex, follow" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.productiverage.com/feed" />
	<script type="text/javascript">
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

		ga('create', "UA-32312857-1", { 'storage': 'none' });
		ga('send', 'pageview');
	</script>
	<script type="text/javascript">
		var darkModeEnabledLocalStorageKey = "DarkMode";
		var darkModeHtmlWrapperClassName = "DarkMode";
		function IsDarkModeEnabled() {
			return localStorage.getItem(darkModeEnabledLocalStorageKey) !== null;
		}
		if (IsDarkModeEnabled()) {
			document.querySelector("html").classList.add(darkModeHtmlWrapperClassName);
		}
	</script>

    <meta name="description" content="Archive for March 2022" />
</head>

<body>

	<div class="Header">
		<div class="HeaderContent">
			<h1>
				<a href="/">Productive Rage</a>
			</h1>
			<span class="Tagline">Dan's techie ramblings</span>
		</div>
	</div>

	<div class="WrapperOuter">
		<div class="Wrapper">
			<div class="Main HasSideBar">
				

        <script type="text/javascript">
            var disqus_shortname = "productiverage";
            document.addEventListener(
                "DOMContentLoaded",
                function () {
                    var commentsLinks = document.querySelectorAll("div.Content p.Comments");
                    for (var i = 0; i < commentsLinks.length; i++) {
                        commentsLinks[i].style.display = "block";
                    }
                }
            );
        </script>

    <div class="Content ArchiveByMonth">
        <p class="PostDate">29 March 2022</p><h2 id="approximately-correcting-perspective-with-c-fixing-a-blurry-presentation-video-part-two"><a href="/approximately-correcting-perspective-with-c-sharp-fixing-a-blurry-presentation-video-part-two">(Approximately) correcting perspective with C# (fixing a blurry presentation video - part two)</a></h2>
<h3 id="tldr"><a href="/approximately-correcting-perspective-with-c-sharp-fixing-a-blurry-presentation-video-part-two#tldr">TL;DR</a></h3>
<p>I have a video of a presentation where the camera keeps losing focus such that the slides are unreadable. I have the original slide deck and I want to fix this.</p>
<p>Step one was <a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one">identifying the area in each frame that it seemed likely was where the slides were being projected</a>, now step two is to correct the perspective of the projection back into a rectangle to make it easier to perform comparisons against the original slide deck images and try to determine which slide was being projected.</p>
<p>(<strong>An experimental TL;DR approach:</strong> See this <a href="https://dotnetfiddle.net/pEzbHD">small scale .NET Fiddle demonstration</a> of what I'll be discussing)</p>
<p><img src="/Content/Images/Posts/PerspectiveCorrectedSlide.jpg" alt="A slide extracted from a frame of a video presentation and 'perspective-corrected' back into a rectangle" title="A slide extracted from a frame of a video presentation and 'perspective-corrected' back into a rectangle" /></p>
<h3 id="the-basic-approach"><a href="/approximately-correcting-perspective-with-c-sharp-fixing-a-blurry-presentation-video-part-two#the-basic-approach">The basic approach</a></h3>
<p>An overview of the processing to do this looks as follows:</p>
<ol>
<li>Load the original slide image into a <code>Bitmap</code></li>
<li>Using the projected-slide-area region calculated in step one..
<ol>
<li>Take the line from the top left of the region to the top right</li>
<li>Take the line from the bottom left of the region to the bottom right (note that this line may be a little longer or shorter than the first line)</li>
<li>Create vertical slices of the image by stepping through the first line (the one across the top), connecting each pixel to a pixel on the bottom line</li>
</ol>
</li>
<li>These vertical slices will not all be the same height and so they'll need to be adjusted to a consistent size (the further from the camera that a vertical slice of the projection is, the smaller it will be)</li>
<li>The height-adjusted vertical slices are then combined into a single rectangle, which will result in an approximation of a perspective-corrected version of the projection of the slide</li>
</ol>
<p><strong>Note:</strong> The reason that this process is only going to be an approximation is due to the way that the height of the output image will be determined -</p>
<ol>
<li>For my purposes, it will be fine to use the largest of the top-left-to-bottom-left length (ie. the left-hand edge of the projection) and the top-right-to-bottom-right length (the right-hand edge of the projected) but this will always result in an output whose aspect ratio is stretched vertically slightly because the largest of those two lengths will be &quot;magnified&quot; somewhat due to the perspective effect</li>
<li>What might seem like an obvious improvement would be to take an average of the left-hand-edge-height and the right-hand-edge-height but I decided not to do this because I would be losing some fidelity from the vertical slices that would be shrunken down to match this average <em>and</em> because this would <em>still</em> be an approximation as..</li>
<li>The correct way to determine the appropriate aspect ratio for the perspective-corrected image is to use some clever maths to try to determine that angle of the wall that the projection is on (look up perspective correction and vanishing points if you're really curious!) and to use <em>that</em> to decide what ratio of the left-hand-edge-height and the right-hand-edge-height to use
<ul>
<li>(The reason that the take-an-average approach is still an approximation is that perspective makes the larger edge grow more quickly than the smaller edge shrinks, so this calculation would still skew towards a vertically-stretched image)</li>
</ul>
</li>
</ol>
<h3 id="slice-dice"><a href="/approximately-correcting-perspective-with-c-sharp-fixing-a-blurry-presentation-video-part-two#slice-dice">Slice &amp; dice!</a></h3>
<p>So if we follow the plan above then we'll generate a list of vertical slices a bit like this:</p>
<p><img src="/Content/Images/Posts/PerspectiveCorrectionSlices.jpg" alt="An illustration of how the vertical slices are taken from a projected image" title="An illustration of how the vertical slices are taken from a projected image" /></p>
<p>.. which, when combined would look like this:</p>
<img class="AlwaysFullWidth" src="/Content/Images/Posts/PerspectiveCorrectionSlicesOriginalHeights.jpg" alt="The vertical slices of the projected image before their heights are normalised" title="The vertical slices of the projected image before their heights are normalised" />
<p>This is very similar to the original projection except that:</p>
<ul>
<li>The top edge is now across the top of the rectangular area</li>
<li>The bottom left corner is aligned with the left-hand side of the image</li>
<li>The bottom right corner is aligned with the right-hand side of the image</li>
</ul>
<p>We're not done yet but this has brought things much closer!</p>
<p>In fact, all that is needed is to stretch those vertical slices so that they are all the same length and; ta-da!</p>
<img class="AlwaysFullWidth" src="/Content/Images/Posts/PerspectiveCorrectionFinal.jpg" alt="The projected image contorted back into a rectangle" title="The projected image contorted back into a rectangle" />
<h3 id="implementation-for-slicing-and-stretching"><a href="/approximately-correcting-perspective-with-c-sharp-fixing-a-blurry-presentation-video-part-two#implementation-for-slicing-and-stretching">Implementation for slicing and stretching</a></h3>
<p>So, from <a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one">previous analysis</a>, I know that the bounding area for the projection of the slide in the frames of my video is:</p>
<pre><code>topLeft: (1224, 197)
topRight: (1915, 72)

bottomLeft: (1229, 638)
bottomRight: (1915, 662)
</code></pre>
<p>Since I'm going to walk along the top edge and create vertical slices from that, I'm going to need the length of that edge - which is easy enough with some Pythagoras:</p>
<pre><code>private static int LengthOfLine((PointF From, PointF To) line)
{
    var deltaX = line.To.X - line.From.X;
    var deltaY = line.To.Y - line.From.Y;
    return (int)Math.Round(Math.Sqrt((deltaX * deltaX) + (deltaY * deltaY)));
}
</code></pre>
<p>So although it's only 691px horizontally from the top left to the top right (1915 - 1224), the actual length of that edge is 702px (because it's not a line that angles up slightly rather than being a flat horizontal one).</p>
<p>This edge length determines how many vertical slices that we'll take and we'll get them by looping across this top edge, working out where the corresponding point on the bottom edge should be and joining them together into a line; one vertical slice. Each time that the loop increments, the current point on the top edge is going to move slightly to the right and even more slightly upwards while each corresponding point on the bottom edge will also move slightly to the right but it will move slightly <em>down</em> as the projection on the wall gets closer and closer to the camera.</p>
<p>One way to get all of these vertical slice lines is a method such as the following:</p>
<pre><code>private sealed record ProjectionDetails(
    Size ProjectionSize,
    IEnumerable&lt;((PointF From, PointF To) Line, int Index)&gt; VerticalSlices
);

private static ProjectionDetails GetProjectionDetails(
    Point topLeft,
    Point topRight,
    Point bottomRight,
    Point bottomLeft)
{
    var topEdge = (From: topLeft, To: topRight);
    var bottomEdge = (From: bottomLeft, To: bottomRight);
    var lengthOfEdgeToStartFrom = LengthOfLine(topEdge);
    var dimensions = new Size(
        width: lengthOfEdgeToStartFrom,
        height: Math.Max(
            LengthOfLine((topLeft, bottomLeft)),
            LengthOfLine((topRight, bottomRight))
        )
    );
    return new ProjectionDetails(dimensions, GetVerticalSlices());

    IEnumerable&lt;((PointF From, PointF To) Line, int Index)&gt; GetVerticalSlices() =&gt;
        Enumerable
            .Range(0, lengthOfEdgeToStartFrom)
            .Select(i =&gt;
            {
                var fractionOfProgressAlongPrimaryEdge = (float)i / lengthOfEdgeToStartFrom;
                return (
                    Line: (
                        GetPointAlongLine(topEdge, fractionOfProgressAlongPrimaryEdge),
                        GetPointAlongLine(bottomEdge, fractionOfProgressAlongPrimaryEdge)
                    ),
                    Index: i
                );
            });
}
</code></pre>
<p>This returns the dimensions of the final perspective-corrected projection (which is as wide as the top edge is long and which is as high as the greater of the left-hand edge's length and the right-hand edge's length) as well as an <code>IEnumerable</code> of the start and end points for each slice that we'll be taking.</p>
<p>The dimensions are going to allow us to create a bitmap that we'll paste the slices into when we're ready - but, before that, we need to determine pixel values for every point on every vertical slice. As the horizontal distance across the top edge is 691px and the vertical distance is 125px but its actual length is 702px, each time we move one along in that 702px loop the starting point for the vertical slice will move (691 / 702) = 0.98px across and (125 / 702) = 0.18px up. So almost all of these vertical slices are going to have start and end points that are not whole pixel values - and the same applies to each point <em>on</em> that vertical slice. This means that we're going to have to take average colour values for when we're dealing with fractional pixel locations.</p>
<p>For example, if we're at the point (1309.5, 381.5) and the colours at (1309, 381), (1310, 381), (1309, 382), (1310, 382) are all white then the averaging is really easy - the &quot;averaged&quot; colour is white! If we're at the point (1446.5, 431.5) and the colours at (1446, 431), (1447, 431), (1446, 432), (1447, 432) are #BCA6A9, #B1989C, #BCA6A9, #B1989C then it's also not too complicated - because (1446.5, 431.5) is at the precise midpoint between all four points then we can take a really simple average by adding all four R values together, all four G values together, all four B values together and diving them by 4 to get a combined result. It gets a little more complicated where it's not 0.5 of a pixel and it's slightly more to the left or to the right and/or to the top or to the bottom - eg. (1446.1, 431.9) would get more of its averaged colour from the pixels on the left than on the right (as 1446.1 is only just past 1446) while it would get more of its averaged colour from the pixels on the bottom than the top (as 431.9 is practically ay 432). On the other hand, on the rare occasion where it <em>is</em> a precise location (with no fractional pixel values), such as (1826, 258), then it's the absolute simplest case because no averaging is required!</p>
<pre><code>private static Color GetAverageColour(Bitmap image, PointF point)
{
    var (integralX, fractionalX) = GetIntegralAndFractional(point.X);
    var x0 = integralX;
    var x1 = Math.Min(integralX + 1, image.Width);

    var (integralY, fractionalY) = GetIntegralAndFractional(point.Y);
    var y0 = integralY;
    var y1 = Math.Min(integralY + 1, image.Height);

    var (topColour0, topColour1) = GetColours(new Point(x0, y0), new Point(x1, y0));
    var (bottomColour0, bottomColour1) = GetColours(new Point(x0, y1), new Point(x1, y1));

    return CombineColours(
        CombineColours(topColour0, topColour1, fractionalX),
        CombineColours(bottomColour0, bottomColour1, fractionalX),
        fractionalY
    );

    (Color c0, Color c1) GetColours(Point p0, Point p1)
    {
        var c0 = image.GetPixel(p0.X, p0.Y);
        var c1 = (p0 == p1) ? c0 : image.GetPixel(p1.X, p1.Y);
        return (c0, c1);
    }

    static (int Integral, float Fractional) GetIntegralAndFractional(float value)
    {
        var integral = (int)Math.Truncate(value);
        var fractional = value - integral;
        return (integral, fractional);
    }

    static Color CombineColours(Color x, Color y, float proportionOfSecondColour)
    {
        if ((proportionOfSecondColour == 0) || (x == y))
            return x;

        if (proportionOfSecondColour == 1)
            return y;

        return Color.FromArgb(
            red: CombineComponent(x.R, y.R),
            green: CombineComponent(x.G, y.G),
            blue: CombineComponent(x.B, y.B),
            alpha: CombineComponent(x.A, y.A)
        );

        int CombineComponent(int x, int y) =&gt;
            Math.Min(
                (int)Math.Round((x * (1 - proportionOfSecondColour)) + (y * proportionOfSecondColour)),
                255
            );
    }
}
</code></pre>
<p>This gives us the capability to split the wonky projection into vertical slices, to loop over each slice and to walk <em>down</em> each slice and get a list of pixel values for each point down that slice. The final piece of the puzzle is that we then need to resize each vertical slice so that they all match the projection height returned from the <code>GetProjectionDetails</code> method earlier. Handily, the .NET <code>Bitmap</code> drawing code has <code>DrawImage</code> functionality that can resize content, so we can:</p>
<ol>
<li>Create a <code>Bitmap</code> whose dimensions are those returned from <code>GetProjectionDetails</code></li>
<li>Loop over each vertical slice (which is an <code>IEnumerable</code> also returned from <code>GetProjectionDetails</code>)</li>
<li>Create a bitmap just for that slice - that is 1px wide and only as tall as the current vertical slice is long</li>
<li>Use <code>DrawImage</code> to paste that slice's bitmap onto the full-size projection <code>Bitmap</code></li>
</ol>
<p>In code:</p>
<pre><code>private static void RenderSlice(
    Bitmap projectionBitmap,
    IEnumerable&lt;Color&gt; pixelsOnLine,
    int index)
{
    var pixelsOnLineArray = pixelsOnLine.ToArray();

    using var slice = new Bitmap(1, pixelsOnLineArray.Length);
    for (var j = 0; j &lt; pixelsOnLineArray.Length; j++)
        slice.SetPixel(0, j, pixelsOnLineArray[j]);

    using var g = Graphics.FromImage(projectionBitmap);
    g.DrawImage(
        slice,
        srcRect: new Rectangle(0, 0, slice.Width, slice.Height),
        destRect: new Rectangle(index, 0, 1, projectionBitmap.Height),
        srcUnit: GraphicsUnit.Pixel
    );
}
</code></pre>
<h3 id="pulling-it-all-together"><a href="/approximately-correcting-perspective-with-c-sharp-fixing-a-blurry-presentation-video-part-two#pulling-it-all-together">Pulling it all together</a></h3>
<p>If we combine all of this logic together then we end up with a fairly straightforward static class that does all the work - takes a <code>Bitmap</code> that is a frame from a video where there is a section that should be extracted and then &quot;perspective-corrected&quot;, takes the four points that describe that region and then returns a new <code>Bitmap</code> that is the extracted content in a lovely rectangle!</p>
<pre><code>/// &lt;summary&gt;
/// This uses a simple algorithm to try to undo the distortion of a rectangle in an image
/// due to perspective - it takes the content of the rectangle and stretches it into a
/// rectangle. This is only a simple approximation and does not guarantee accuracy (in
/// fact, it will result in an image that is slightly vertically stretched such that its
/// aspect ratio will not match the original content and a more thorough approach would
/// be necessary if this is too great an approximation)
/// &lt;/summary&gt;
internal static class SimplePerspectiveCorrection
{
    public static Bitmap ExtractAndPerspectiveCorrect(
        Bitmap image,
        Point topLeft,
        Point topRight,
        Point bottomRight,
        Point bottomLeft)
    {
        var (projectionSize, verticalSlices) =
            GetProjectionDetails(topLeft, topRight, bottomRight, bottomLeft);

        var projection = new Bitmap(projectionSize.Width, projectionSize.Height);
        foreach (var (lineToTrace, index) in verticalSlices)
        {
            var lengthOfLineToTrace = LengthOfLine(lineToTrace);

            var pixelsOnLine = Enumerable
                .Range(0, lengthOfLineToTrace)
                .Select(j =&gt;
                {
                    var fractionOfProgressAlongLineToTrace = (float)j / lengthOfLineToTrace;
                    var point = GetPointAlongLine(lineToTrace, fractionOfProgressAlongLineToTrace);
                    return GetAverageColour(image, point);
                });

            RenderSlice(projection, pixelsOnLine, index);
        }
        return projection;

        static Color GetAverageColour(Bitmap image, PointF point)
        {
            var (integralX, fractionalX) = GetIntegralAndFractional(point.X);
            var x0 = integralX;
            var x1 = Math.Min(integralX + 1, image.Width);

            var (integralY, fractionalY) = GetIntegralAndFractional(point.Y);
            var y0 = integralY;
            var y1 = Math.Min(integralY + 1, image.Height);

            var (topColour0, topColour1) = GetColours(new Point(x0, y0), new Point(x1, y0));
            var (bottomColour0, bottomColour1) = GetColours(new Point(x0, y1), new Point(x1, y1));

            return CombineColours(
                CombineColours(topColour0, topColour1, fractionalX),
                CombineColours(bottomColour0, bottomColour1, fractionalX),
                fractionalY
            );

            (Color c0, Color c1) GetColours(Point p0, Point p1)
            {
                var c0 = image.GetPixel(p0.X, p0.Y);
                var c1 = (p0 == p1) ? c0 : image.GetPixel(p1.X, p1.Y);
                return (c0, c1);
            }

            static (int Integral, float Fractional) GetIntegralAndFractional(float value)
            {
                var integral = (int)Math.Truncate(value);
                var fractional = value - integral;
                return (integral, fractional);
            }

            static Color CombineColours(Color x, Color y, float proportionOfSecondColour)
            {
                if ((proportionOfSecondColour == 0) || (x == y))
                    return x;

                if (proportionOfSecondColour == 1)
                    return y;

                return Color.FromArgb(
                    red: CombineComponent(x.R, y.R),
                    green: CombineComponent(x.G, y.G),
                    blue: CombineComponent(x.B, y.B),
                    alpha: CombineComponent(x.A, y.A)
                );

                int CombineComponent(int x, int y) =&gt;
                    Math.Min(
                        (int)Math.Round(
                            (x * (1 - proportionOfSecondColour)) +
                            (y * proportionOfSecondColour)
                        ),
                        255
                    );
            }
        }
    }

    private sealed record ProjectionDetails(
        Size ProjectionSize,
        IEnumerable&lt;((PointF From, PointF To) Line, int Index)&gt; VerticalSlices
    );

    private static ProjectionDetails GetProjectionDetails(
        Point topLeft,
        Point topRight,
        Point bottomRight,
        Point bottomLeft)
    {
        var topEdge = (From: topLeft, To: topRight);
        var bottomEdge = (From: bottomLeft, To: bottomRight);
        var lengthOfEdgeToStartFrom = LengthOfLine(topEdge);
        var dimensions = new Size(
            width: lengthOfEdgeToStartFrom,
            height: Math.Max(
                LengthOfLine((topLeft, bottomLeft)),
                LengthOfLine((topRight, bottomRight))
            )
        );
        return new ProjectionDetails(dimensions, GetVerticalSlices());

        IEnumerable&lt;((PointF From, PointF To) Line, int Index)&gt; GetVerticalSlices() =&gt;
            Enumerable
                .Range(0, lengthOfEdgeToStartFrom)
                .Select(i =&gt;
                {
                    var fractionOfProgressAlongPrimaryEdge = (float)i / lengthOfEdgeToStartFrom;
                    return (
                        Line: (
                            GetPointAlongLine(topEdge, fractionOfProgressAlongPrimaryEdge),
                            GetPointAlongLine(bottomEdge, fractionOfProgressAlongPrimaryEdge)
                        ),
                        Index: i
                    );
                });
    }

    private static PointF GetPointAlongLine((PointF From, PointF To) line, float fraction)
    {
        var deltaX = line.To.X - line.From.X;
        var deltaY = line.To.Y - line.From.Y;
        return new PointF(
            (deltaX * fraction) + line.From.X,
            (deltaY * fraction) + line.From.Y
        );
    }

    private static int LengthOfLine((PointF From, PointF To) line)
    {
        var deltaX = line.To.X - line.From.X;
        var deltaY = line.To.Y - line.From.Y;
        return (int)Math.Round(Math.Sqrt((deltaX * deltaX) + (deltaY * deltaY)));
    }

    private static void RenderSlice(
        Bitmap projectionBitmap,
        IEnumerable&lt;Color&gt; pixelsOnLine,
        int index)
    {
        var pixelsOnLineArray = pixelsOnLine.ToArray();

        using var slice = new Bitmap(1, pixelsOnLineArray.Length);
        for (var j = 0; j &lt; pixelsOnLineArray.Length; j++)
            slice.SetPixel(0, j, pixelsOnLineArray[j]);

        using var g = Graphics.FromImage(projectionBitmap);
        g.DrawImage(
            slice,
            srcRect: new Rectangle(0, 0, slice.Width, slice.Height),
            destRect: new Rectangle(index, 0, 1, projectionBitmap.Height),
            srcUnit: GraphicsUnit.Pixel
        );
    }
}
</code></pre>
<h3 id="coming-next"><a href="/approximately-correcting-perspective-with-c-sharp-fixing-a-blurry-presentation-video-part-two#coming-next">Coming next</a></h3>
<p>So step one was to take frames from a video and to work out what the bounds were of the area where slides were being projected (and to filter out any intro and outro frames), step two has been to be able to take the bounded area from any slide and project it back into a rectangle to make it easier to match against the original slide images.. step three will be to use these projections to try to guess what slide is being displayed on what frame!</p>
<p>The frame that I've been using as an example throughout this post probably looks like a fairly easy case - big blocks of white or black and not actually <em>too</em> out of focus.. but some of the frames look like this and that's a whole other kettle of fish!</p>
<p><img src="/Content/Images/Posts/OutOfFocusFrame.jpg" alt="An out of focus frame from a presentation" title="An out of focus frame from a presentation" /></p>
<p class="PostTime">Posted at 19:02</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one">Finding the brightest area in an image with C# (fixing a blurry presentation video - part one)</a></li><li><a href="/how-are-barcodes-read-libraryless-image-processing-in-c-sharp">How are barcodes read?? (Library-less image processing in C#)</a></li><li><a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face (finding faces in photos using C# and Accord.NET)</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Image%20Processing" title="4 Posts">Image Processing</a></li></ul></div>
            <p class="Comments">
                <a href="/approximately-correcting-perspective-with-c-sharp-fixing-a-blurry-presentation-video-part-two#disqus_thread" data-disqus-identifier="125">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByMonth">
        <p class="PostDate">15 March 2022</p><h2 id="finding-the-brightest-area-in-an-image-with-c-fixing-a-blurry-presentation-video-part-one"><a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one">Finding the brightest area in an image with C# (fixing a blurry presentation video - part one)</a></h2>
<h3 id="tldr"><a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one#tldr">TL;DR</a></h3>
<p>I have a video of a presentation where the camera keeps losing focus such that the slides are unreadable. I have the original slide deck and I want to fix this.</p>
<p>The first step is analysing the individual frames of the video to find a common &quot;most illuminated area&quot; so that I can work out where the slide content was being projected, and that is what is described in this post.</p>
<p>(<strong>An experimental TL;DR approach:</strong> See this <a href="https://dotnetfiddle.net/X8IPgQ">small scale .NET Fiddle demonstration</a> of what I'll be discussing)</p>
<p><img src="/Content/Images/Posts/OutOfFocusFrame.jpg" alt="An out of focus frame from a presentation" title="An out of focus frame from a presentation" /></p>
<h3 id="the-basic-approach"><a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one#the-basic-approach">The basic approach</a></h3>
<p>An overview of the processing to do this looks as follows:</p>
<ol>
<li>Load the image into a <code>Bitmap</code></li>
<li>Convert the image to greyscale</li>
<li>Identify the lightest and darkest values in the greyscale range</li>
<li>Calculate a 2/3 threshold from that range and create a mask of the image where anything below that value is zero and anything equal to or greater is one
<ul>
<li>eg. If the darkest value was 10 and the lightest was 220 then the difference is 220 - 10 = 210 and the cutoff point would be 2/3 of this range on top of the minimum, so the threshold value would equal ((2/3) * range) + minimum = ((2/3) * 210) + 10 = 140 + 10 = 150</li>
</ul>
</li>
<li>Find the largest bounded area within this mask (if there is one) and presume that that's the projection of the slide in the darkened room!</li>
</ol>
<p>Before looking at code to do that, I'm going to toss in a few other complications that arise from having to process a <em>lot</em> of frames from throughout the video, rather than just one..</p>
<p>Firstly, the camera loses focus at different points in the video and to different extents and so some frames are blurrier than others. Following the steps above, the blurrier frames are likely to report a larger projection area for the slides. I would really like to identify a common projection area that is reasonable to use across all frames because this will make later processing (where I try to work out what slide is currently being shown in the frame) easier.</p>
<p>Secondly, this video has intro and outro animations and it would be nice if I was able to write code that worked out when they stopped and started.</p>
<h3 id="the-implementation-for-a-single-image"><a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one#the-implementation-for-a-single-image">The implementation for a single image</a></h3>
<p>To do this work, I'm going to introduce a variation of my old friend the <code>DataRectangle</code> (from &quot;<a href="/how-are-barcodes-read-libraryless-image-processing-in-c-sharp">How are barcodes read?</a>&quot; and &quot;<a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face</a>&quot;) -</p>
<pre><code>public static class DataRectangle
{
    public static DataRectangle&lt;T&gt; For&lt;T&gt;(T[,] values) =&gt; new DataRectangle&lt;T&gt;(values);
}

public sealed class DataRectangle&lt;T&gt;
{
    private readonly T[,] _protectedValues;
    public DataRectangle(T[,] values) : this(values, isolationCopyMayBeBypassed: false) { }
    private DataRectangle(T[,] values, bool isolationCopyMayBeBypassed)
    {
        if ((values.GetLowerBound(0) != 0) || (values.GetLowerBound(1) != 0))
            throw new ArgumentException(&quot;Both dimensions must have lower bound zero&quot;);
        var arrayWidth = values.GetUpperBound(0) + 1;
        var arrayHeight = values.GetUpperBound(1) + 1;
        if ((arrayWidth == 0) || (arrayHeight == 0))
            throw new ArgumentException(&quot;zero element arrays are not supported&quot;);

        Width = arrayWidth;
        Height = arrayHeight;

        if (isolationCopyMayBeBypassed)
            _protectedValues = values;
        else
        {
            _protectedValues = new T[Width, Height];
            Array.Copy(values, _protectedValues, Width * Height);
        }
    }

    public int Width { get; }

    public int Height { get; }

    public T this[int x, int y]
    {
        get
        {
            if ((x &lt; 0) || (x &gt;= Width))
                throw new ArgumentOutOfRangeException(nameof(x));
            if ((y &lt; 0) || (y &gt;= Height))
                throw new ArgumentOutOfRangeException(nameof(y));
            return _protectedValues[x, y];
        }
    }

    public IEnumerable&lt;(Point Point, T Value)&gt; Enumerate()
    {
        for (var x = 0; x &lt; Width; x++)
        {
            for (var y = 0; y &lt; Height; y++)
            {
                var value = _protectedValues[x, y];
                var point = new Point(x, y);
                yield return (point, value);
            }
        }
    }

    public DataRectangle&lt;TResult&gt; Transform&lt;TResult&gt;(Func&lt;T, TResult&gt; transformer)
    {
        var transformed = new TResult[Width, Height];
        for (var x = 0; x &lt; Width; x++)
        {
            for (var y = 0; y &lt; Height; y++)
                transformed[x, y] = transformer(_protectedValues[x, y]);
        }
        return new DataRectangle&lt;TResult&gt;(transformed, isolationCopyMayBeBypassed: true);
    }
}
</code></pre>
<p>For working with <code>DataRectangle</code> instances that contain <code>double</code> values (as we will be here), I've got a couple of convenient extension methods:</p>
<pre><code>public static class DataRectangleOfDoubleExtensions
{
    public static (double Min, double Max) GetMinAndMax(this DataRectangle&lt;double&gt; source) =&gt;
        source
            .Enumerate()
            .Select(pointAndValue =&gt; pointAndValue.Value)
            .Aggregate(
                seed: (Min: double.MaxValue, Max: double.MinValue),
                func: (acc, value) =&gt; (Math.Min(value, acc.Min), Math.Max(value, acc.Max))
            );

    public static DataRectangle&lt;bool&gt; Mask(this DataRectangle&lt;double&gt; values, double threshold) =&gt;
        values.Transform(value =&gt; value &gt;= threshold);
}
</code></pre>
<p>And for working with <code>Bitmap</code> instances, I've got some extension methods for those as well:</p>
<pre><code>public static class BitmapExtensions
{
    public static Bitmap CopyAndResize(this Bitmap image, int resizeLargestSideTo)
    {
        var (width, height) = (image.Width &gt; image.Height)
            ? (resizeLargestSideTo, (int)((double)image.Height / image.Width * resizeLargestSideTo))
            : ((int)((double)image.Width / image.Height * resizeLargestSideTo), resizeLargestSideTo);

        return new Bitmap(image, width, height);
    }

    /// &lt;summary&gt;
    /// This will return values in the range 0-255 (inclusive)
    /// &lt;/summary&gt;
    // Based on http://stackoverflow.com/a/4748383/3813189
    public static DataRectangle&lt;double&gt; GetGreyscale(this Bitmap image) =&gt;
        image
            .GetAllPixels()
            .Transform(c =&gt; (0.2989 * c.R) + (0.5870 * c.G) + (0.1140 * c.B));

    public static DataRectangle&lt;Color&gt; GetAllPixels(this Bitmap image)
    {
        var values = new Color[image.Width, image.Height];
        var data = image.LockBits(
            new Rectangle(0, 0, image.Width, image.Height),
            ImageLockMode.ReadOnly,
            PixelFormat.Format24bppRgb
        );
        try
        {
            var pixelData = new byte[data.Stride];
            for (var lineIndex = 0; lineIndex &lt; data.Height; lineIndex++)
            {
                Marshal.Copy(
                    source: data.Scan0 + (lineIndex * data.Stride),
                    destination: pixelData,
                    startIndex: 0,
                    length: data.Stride
                );
                for (var pixelOffset = 0; pixelOffset &lt; data.Width; pixelOffset++)
                {
                    // Note: PixelFormat.Format24bppRgb means the data is stored in memory as BGR
                    const int PixelWidth = 3;
                    values[pixelOffset, lineIndex] = Color.FromArgb(
                        red: pixelData[pixelOffset * PixelWidth + 2],
                        green: pixelData[pixelOffset * PixelWidth + 1],
                        blue: pixelData[pixelOffset * PixelWidth]
                    );
                }
            }
        }
        finally
        {
            image.UnlockBits(data);
        }
        return DataRectangle.For(values);
    }
}
</code></pre>
<p>With this code, we can already perform those first steps that I've described in the find-projection-area-in-image process.</p>
<p>Note that I'm going to throw in an extra step of shrinking the input images if they're larger than 400px because we don't need pixel-perfect accuracy when the whole point of this process is that a lot of the frames are too blurry to read (as a plus, shrinking the images means that there's less data to process and the whole thing should finish more quickly).</p>
<pre><code>using var image = new Bitmap(&quot;frame_338.jpg&quot;);
using var resizedImage = image.CopyAndResize(resizeLargestSideTo: 400);
var greyScaleImageData = resizedImage.GetGreyscale();
var (min, max) = greyScaleImageData.GetMinAndMax();
var range = max - min;
const double thresholdOfRange = 2 / 3d;
var thresholdForMasking = min + (range * thresholdOfRange);
var mask = greyScaleImageData.Mask(thresholdForMasking);
</code></pre>
<p>This gives us a <code>DataRectangle</code> of boolean values that represent the brighter points as true and the less bright points as false.</p>
<p>In the image below, you can see the original frame on the left. In the middle is the content that would be masked out by hiding all but the brightest pixels. On the right is the &quot;binary mask&quot; (where we discard the original colour of the pixel and make them all either black or white) -</p>
<p><img src="/Content/Images/Posts/VideoFrameWithMask.jpg" alt="A frame from the video with the brightest third of the pixels masked out" title="A frame from the video with the brightest third of the pixels masked out" /></p>
<p>Now we need to identify the largest &quot;object&quot; within this mask - wherever bright pixels are adjacent to other bright pixels, they will be considered part of the same object and we would expect there to be several such objects within the mask that has been generated.</p>
<p>To do so, I'll be reusing some more code from &quot;<a href="/how-are-barcodes-read-libraryless-image-processing-in-c-sharp">How are barcodes read?</a>&quot; -</p>
<pre><code>private static IEnumerable&lt;IEnumerable&lt;Point&gt;&gt; GetDistinctObjects(DataRectangle&lt;bool&gt; mask)
{
    // Flood fill areas in the mask to create distinct areas
    var allPoints = mask
        .Enumerate()
        .Where(pointAndIsMasked =&gt; pointAndIsMasked.Value)
        .Select(pointAndIsMasked =&gt; pointAndIsMasked.Point).ToHashSet();
    while (allPoints.Any())
    {
        var currentPoint = allPoints.First();
        var pointsInObject = GetPointsInObject(currentPoint).ToArray();
        foreach (var point in pointsInObject)
            allPoints.Remove(point);
        yield return pointsInObject;
    }

    // Inspired by code at
    // https://simpledevcode.wordpress.com/2015/12/29/flood-fill-algorithm-using-c-net/
    IEnumerable&lt;Point&gt; GetPointsInObject(Point startAt)
    {
        var pixels = new Stack&lt;Point&gt;();
        pixels.Push(startAt);

        var valueAtOriginPoint = mask[startAt.X, startAt.Y];
        var filledPixels = new HashSet&lt;Point&gt;();
        while (pixels.Count &gt; 0)
        {
            var currentPoint = pixels.Pop();
            if ((currentPoint.X &lt; 0) || (currentPoint.X &gt;= mask.Width)
            || (currentPoint.Y &lt; 0) || (currentPoint.Y &gt;= mask.Height))
                continue;

            if ((mask[currentPoint.X, currentPoint.Y] == valueAtOriginPoint)
            &amp;&amp; !filledPixels.Contains(currentPoint))
            {
                filledPixels.Add(new Point(currentPoint.X, currentPoint.Y));
                pixels.Push(new Point(currentPoint.X - 1, currentPoint.Y));
                pixels.Push(new Point(currentPoint.X + 1, currentPoint.Y));
                pixels.Push(new Point(currentPoint.X, currentPoint.Y - 1));
                pixels.Push(new Point(currentPoint.X, currentPoint.Y + 1));
            }
        }
        return filledPixels;
    }
}
</code></pre>
<p>As the code mentions, this is based on an article &quot;<a href="https://simpledevcode.wordpress.com/2015/12/29/flood-fill-algorithm-using-c-net/">Flood Fill algorithm (using C#.NET)</a>&quot; and its output is a list of objects, where each object is a list of points within that object. So the way to determine which object is largest is to take the one that contains the most points!</p>
<p><img src="/Content/Images/Posts/VideoFrameWithLargestBinaryMaskObject.jpg" alt="A binary mask of a frame in the video with all but the single largest areas hidden" title="A binary mask of a frame in the video with all but the single largest areas hidden" /></p>
<pre><code>var pointsInLargestHighlightedArea = GetDistinctObjects(mask)
    .OrderByDescending(points =&gt; points.Count())
    .FirstOrDefault();
</code></pre>
<p><em>(<strong>Note:</strong> If <code>pointsInLargestHighlightedArea</code> is null then we need to escape out of the method that we're in because the source image didn't produce a mask with any highlighted objects - this could happen if the image has every single with the same colour, for example; an edge case, surely, but one that we should handle)</em></p>
<p>From this largest object, we want to find a bounding quadrilateral, which we do by looking at every point and finding the one closest to the top left of the image (because this will be the top left of the bounding area), the point closest to the top right of the image (for the top right of the bounding area) and the same for the points closest to the bottom left and bottom right.</p>
<p>This can be achieved by calculating, for each point in the object, the distances from each of the corners to the points and then determining which points have the shortest distances - eg.</p>
<pre><code>var distancesOfPointsFromImageCorners = pointsInLargeHighlightedArea
    .Select(p =&gt;
    {
        // To work out distance from the top left, you would use Pythagoras to take the
        // squared horizontal distance of the point from the left of the image and add
        // that to the squared vertical distance of the point from the top of the image,
        // then you would square root that sum. In this case, we only want to be able to
        // compare determine which distances are smaller or larger and we don't actually
        // care about the precise distances themselves and so we can save ourselves from
        // performing that final square root calculation.
        var distanceFromRight = greyScaleImageData.Width - p.X;
        var distanceFromBottom = greyScaleImageData.Height - p.Y;
        var fromLeftScore = p.X * p.X;
        var fromTopScore = p.Y * p.Y;
        var fromRightScore = distanceFromRight * distanceFromRight;
        var fromBottomScore = distanceFromBottom * distanceFromBottom;
        return new
        {
            Point = p,
            FromTopLeft = fromLeftScore + fromTopScore,
            FromTopRight = fromRightScore + fromTopScore,
            FromBottomLeft = fromLeftScore + fromBottomScore,
            FromBottomRight = fromRightScore + fromBottomScore
        };
    })
    .ToArray(); // Call ToArray to avoid repeating this enumeration four times below
    
var topLeft = distancesOfPointsFromImageCorners.OrderBy(p =&gt; p.FromTopLeft).First().Point;
var topRight = distancesOfPointsFromImageCorners.OrderBy(p =&gt; p.FromTopRight).First().Point;
var bottomLeft = distancesOfPointsFromImageCorners.OrderBy(p =&gt; p.FromBottomLeft).First().Point;
var bottomRight = distancesOfPointsFromImageCorners.OrderBy(p =&gt; p.FromBottomRight).First().Point;
</code></pre>
<p>Finally, because we want to find the bounding area of the largest object in the original image, we may need to multiply up the bounds that we just found because we shrank the image down if either dimension was larger than 400px and we were performing calculations on that smaller version.</p>
<p>We can tell how much we reduced the data by looking at the width of the original image and comparing it to the width of the greyScaleImageData <code>DataRectangle</code> that was generated from the shrunken version of the image:</p>
<pre><code>var reducedImageSideBy = (double)image.Width / greyScaleImageData.Width;
</code></pre>
<p>Now we only need a function that will multiply the bounding area that we've got according to this value, while ensuring that none of the point values are multiplied such that they exceed the bounds of the original image:</p>
<pre><code>private static (Point TopLeft, Point TopRight, Point BottomRight, Point BottomLeft) Resize(
    Point topLeft,
    Point topRight,
    Point bottomRight,
    Point bottomLeft,
    double resizeBy,
    int minX,
    int maxX,
    int minY,
    int maxY)
{
    if (resizeBy &lt;= 0)
        throw new ArgumentOutOfRangeException(&quot;must be a positive value&quot;, nameof(resizeBy));

    return (
        Constrain(Multiply(topLeft)),
        Constrain(Multiply(topRight)),
        Constrain(Multiply(bottomRight)),
        Constrain(Multiply(bottomLeft))
    );

    Point Multiply(Point p) =&gt;
        new Point((int)Math.Round(p.X * resizeBy), (int)Math.Round(p.Y * resizeBy));

    Point Constrain(Point p) =&gt;
        new Point(Math.Min(Math.Max(p.X, minX), maxX), Math.Min(Math.Max(p.Y, minY), maxY));
}
</code></pre>
<p>The final bounding area for the largest bright area of an image is now retrieved like this:</p>
<pre><code>var bounds = Resize(
    topLeft,
    topRight,
    bottomRight,
    bottomLeft,
    reducedImageSideBy,
    minX: 0,
    maxX: image.Width - 1,
    minY: 0,
    maxY: image.Height - 1
);
</code></pre>
<p>For the example image that we're looking at, this area is outlined liked this:</p>
<img alt="An outline around the largest object within the binary mask of a frame from the video" src="/Content/Images/Posts/VideoFrameWithLargestBinaryMaskObjectOutlined.jpg" class="AlwaysFullWidth" title="An outline around the largest object within the binary mask of a frame from the video" />
<h3 id="applying-the-process-to-multiple-images"><a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one#applying-the-process-to-multiple-images">Applying the process to multiple images</a></h3>
<p>Say that we put all of the above functionality into a method called <code>GetMostHighlightedArea</code> that took a <code>Bitmap</code> to process and returned a tuple of the four points that represented the bounds of the brightest area, we could then easily prepare a LINQ statement that ran that code and found the most common brightest-area-bounds across all of the source images that I have. <em>(As I said before, the largest-bounded-area will vary from image to image in my example as the camera recording the session gained and lost focus)</em></p>
<pre><code>var files = new DirectoryInfo(&quot;Frames&quot;).EnumerateFiles(&quot;*.jpg&quot;);
var (topLeft, topRight, bottomRight, bottomLeft) = files
    .Select(file =&gt;
    {
        using var image = new Bitmap(file.FullName);
        return IlluminatedAreaLocator.GetMostHighlightedArea(image);
    })
    .GroupBy(area =&gt; area)
    .OrderByDescending(group =&gt; group.Count())
    .Select(group =&gt; group.Key)
    .FirstOrDefault();
</code></pre>
<p>Presuming that there is a folder called &quot;Frames&quot; in the output folder of project*, this will read them all, look for the largest bright area on each of them individually, then return the area that appears most often across all of the images. <em>(Note: If there are no images to read then the <code>FirstOrDefault</code> call at the bottom will return a default tuple-of-four-Points, which will be 4x (0,0) values)</em></p>
<p>* <em>(Since you probably don't happen to have a bunch of images from a video of my presentation lying around, see the next section for some code that will download some in case you want to try this all out!)</em></p>
<p>This ties in nicely with my recent post &quot;<a href="/parallelising-linq-work-in-c-sharp">Parallelising (LINQ) work in C#</a>&quot; because the processing required for each image is..</p>
<ol>
<li>Completely independent from the processing of the other images (important for parallelising work)</li>
<li>Expensive enough that the overhead from splitting the work into multiple threads and then combining their results back together would be overshadowed by the work performed (which is also important for parallelising work - if individual tasks are too small and the computer spends more time scheduling the work on threads and then pulling all the results back together than it does on actually performing that work then using multiple threads can be <em>slower</em> than using a single one!)</li>
</ol>
<p>All that we would have to change in order to use multiple threads to process multiple images is the addition of a single line:</p>
<pre><code>var files = new DirectoryInfo(&quot;Frames&quot;).EnumerateFiles(&quot;*.jpg&quot;);
var (topLeft, topRight, bottomRight, bottomLeft) = files
    .AsParallel() // &lt;- WOO!! This is all that we needed to add!
    .Select(file =&gt;
    {
        using var image = new Bitmap(file.FullName);
        return IlluminatedAreaLocator.GetMostHighlightedArea(image);
    })
    .GroupBy(area =&gt; area)
    .OrderByDescending(group =&gt; group.Count())
    .Select(group =&gt; group.Key)
    .FirstOrDefault();
</code></pre>
<p><em>(<strong>Parallelisation sidebar:</strong> When we split up the work like this, if the processing for each image was solely in memory then it would be a no-brainer that using more threads would make sense - however, the processing for each image involves LOADING the image from disk and THEN processing it in memory and if you had a spinning rust hard disk then you may fear that trying to ask it to read multiple files simultaneously would be slower than asking it to read them one at a time because its poor little read heads have to physically move around the plates.. it turns out that this is not necessarily the case and that you can find more information in this article that I found interesting; &quot;<a href="https://pkolaczk.github.io/disk-parallelism/">Performance Impact of Parallel Disk Access</a>&quot;)</em></p>
<h3 id="testing-the-code-on-your-own-computer"><a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one#testing-the-code-on-your-own-computer">Testing the code on your own computer</a></h3>
<p>I haven't quite finished yet but I figured that there may be <em>some</em> wild people out there that would like to try running this code locally themselves - maybe just to see it work or maybe even to get it working and then chop and change it for some new and exciting purpose!</p>
<p>To this end, I have some sample frames available from this video that I'm trying to fix - with varying levels of fuzziness present. To download them, use the following method:</p>
<pre><code>private static async Task EnsureSamplesAvailable(DirectoryInfo framesfolder)
{
    // Note: The GitHub API is rate limited quite severely for non-authenticated apps, so we just
    // only call use it if the framesFolder doesn't exist or is empty - if there are already files
    // in there then we presume that we downloaded them on a previous run (if the API is hit too
    // often then it will return a 403 &quot;rate limited&quot; response)
    if (framesfolder.Exists &amp;&amp; framesfolder.EnumerateFiles().Any())
    {
        Console.WriteLine(&quot;Sample images have already been downloaded and are ready for use&quot;);
        return;
    }

    Console.WriteLine(&quot;Downloading sample images..&quot;);
    if (!framesfolder.Exists)
        framesfolder.Create();

    string namesAndUrlsJson;
    using (var client = new WebClient())
    {
        // The API refuses requests without a User Agent, so set one before calling (see
        // https://docs.github.com/en/rest/overview/resources-in-the-rest-api#user-agent-required)
        client.Headers.Add(HttpRequestHeader.UserAgent, &quot;ProductiveRage Blog Post Example&quot;);
        namesAndUrlsJson = await client.DownloadStringTaskAsync(new Uri(
            &quot;https://api.github.com/repos/&quot; +
            &quot;ProductiveRage/NaivePerspectiveCorrection/contents/Samples/Frames&quot;
        ));
    }

    // Deserialise the response into an array of entries that have Name and Download_Url properties
    var namesAndUrls = JsonConvert.DeserializeAnonymousType(
        namesAndUrlsJson,
        new[] { new { Name = &quot;&quot;, Download_Url = (Uri?)null } }
    );
    if (namesAndUrls is null)
    {
        Console.WriteLine(&quot;GitHub reported zero sample images to download&quot;);
        return;
    }

    await Task.WhenAll(namesAndUrls
        .Select(async entry =&gt;
        {
            using var client = new WebClient();
            await client.DownloadFileTaskAsync(
                entry.Download_Url,
                Path.Combine(framesfolder.FullName, entry.Name)
            );
        })
    );

    Console.WriteLine($&quot;Downloaded {namesAndUrls.Length} sample image(s)&quot;);
}
</code></pre>
<p>.. and call it with the following argument, presuming you're trying to read images from the &quot;Frames&quot; folder as the code earlier illustrated:</p>
<pre><code>await EnsureSamplesAvailable(new DirectoryInfo(&quot;Frames&quot;));
</code></pre>
<h3 id="filtering-out-introoutro-slides"><a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one#filtering-out-introoutro-slides">Filtering out intro/outro slides</a></h3>
<p>So I said earlier that it would also be nice if I could programmatically identify which frames were part of the intro/outro animations of the video that I'm looking at.</p>
<p>It feels logical that any frame that is of the actual presentation will have a fairly similarly-sized-and-located bright area (where a slide is being projected onto a wall in a darkened room) while any frame that is part of an intro/outro animation won't. So we should be able to take the <strong>most-common</strong>-largest-brightest-area and then look at every frame and see if <em>its</em> largest bright area is approximately the same - if it's similar enough then it's probably a frame that is part of the projection but if it's too dissimilar then it's probably <em>not</em>.</p>
<p>Rather than waste time going too far down a rabbit hole that I've found won't immediately result in success, I'm going to use a slightly altered version of that plan (I'll explain why in a moment). I'm still going to take that common largest brightest area and compare the largest bright area on each frame to it but, instead of saying &quot;largest-bright-area-is-close-enough-to-the-most-common = presentation frame / largest-bright-area-<strong>not</strong>-close-enough = intro or outro&quot;, I'm going to find the <em>first</em> frame whose largest bright area is close enough and the <em>last</em> frame that is and declare that that range is probably where the frames for the presentation are.</p>
<p>The reason that I'm going to do this is that I found that there are some slides with more variance that can skew the results if the first approach was taken - if a frame in the middle of the presentation is so blurry that the range in intensity from darkest pixel to brightest pixel is squashed down too far then it can result in it identifying a largest bright area that isn't an accurate representation of the image. It's quite possible that I could still have made the first approach work by tweaking some other parameters in the image processing - such as considering changing that arbitrary &quot;create a mask where the intensity threshold is 2/3 of the range of the brightness of all pixels&quot; (maybe 3/4 would have worked better?), for example - but I know that this second approach works for my data and so I didn't pursue the first one too hard.</p>
<p>To do this, though, we are going to need to know what order the frames are supposed to appear in - it's no longer sufficient for there to simply be a list of images that are frames out of the video, we now need to know what were they appeared relative to each other. This is simple enough with my data because they all have names like &quot;frame_1052.jpg&quot; where 1052 is the frame index from the original video.</p>
<p>So I'm going to change the frame-image-loading code to look like this:</p>
<pre><code>// Get all filenames, parse the frame index from them and discard any that don't
// match the filename pattern that is expected (eg. &quot;frame_1052.jpg&quot;)
var frameIndexMatcher = new Regex(@&quot;frame_(\d+)\.jpg&quot;, RegexOptions.IgnoreCase);
var files = new DirectoryInfo(&quot;Frames&quot;)
    .EnumerateFiles()
    .Select(file =&gt;
    {
        var frameIndexMatch = frameIndexMatcher.Match(file.Name);
        return frameIndexMatch.Success
            ? (file.FullName, FrameIndex: int.Parse(frameIndexMatch.Groups[1].Value))
            : default;
    })
    .Where(entry =&gt; entry != default);

// Get the largest bright area for each file
var allFrameHighlightedAreas = files
    .AsParallel()
    .Select(file =&gt;
    {
        using var image = new Bitmap(file.FullName);
        return (
            file.FrameIndex,
            HighlightedArea: IlluminatedAreaLocator.GetMostHighlightedArea(image)
        );
    })
    .ToArray()

// Get the most common largest bright area across all of the images
var (topLeft, topRight, bottomRight, bottomLeft) = allFrameHighlightedAreas
    .GroupBy(entry =&gt; entry.HighlightedArea)
    .OrderByDescending(group =&gt; group.Count())
    .Select(group =&gt; group.Key)
    .FirstOrDefault();
</code></pre>
<p><em>(Note that I'm calling <code>ToArray()</code> when declaring <code>allFrameHighlightedAreas</code> - that's to store the results now because I know that I'm going to need every result in the list that is generated and because I'm going to enumerate it twice in the work outlined here, so there's no point leaving <code>allFrameHighlightedAreas</code> to be a lazily-evaluated <code>IEnumerable</code> that would be recalculated each time it was looped over; then it would be doing all of the <code>IlluminatedAreaLocator.GetMostHighlightedArea</code> calculations for each image twice if enumerated the list twice, which would just be wasteful!)</em></p>
<p>Now to look at the <code>allFrameHighlightedAreas</code> list and try to decide if each <code>HighlightedArea</code> value is close enough to the most common area that we found. I'm going to use a very simple algorithm for this - I'm going to:</p>
<ol>
<li>Take all four points from the <code>HighlightedArea</code> on each entry in <code>allFrameHighlightedAreas</code></li>
<li>Take all four points from the most common area (which are the <code>topLeft</code>, <code>topRight</code>, <code>bottomRight</code>, <code>bottomLeft</code> values that we already have in the code above)</li>
<li>Take the differences in <code>X</code> value between all four points in these two areas and add them up</li>
<li>Compare this difference to the width of the most common highlighted area - if it's too big of a proportion (say if the sum of the <code>X</code> differences is greater than 20% of the width of the entire area) then we'll say it's not a match and drop out of this list</li>
<li>If the <code>X</code> values aren't too bad then we'll take the differences in <code>Y</code> value between all four points in these two areas and add <em>those</em> up</li>
<li>That total will be compared to the height of the most common highlighted area - if it's more than the 20% threshold then we'll say that it's not a match</li>
<li>If we got to here then we'll say that the highlighted area in the current frame <em>is</em> close enough to the most common highlighted area and so the current frame probably is part of the presentation - yay!</li>
</ol>
<p>In code:</p>
<pre><code>var highlightedAreaWidth = Math.Max(topRight.X, bottomRight.X) - Math.Min(topLeft.X, bottomLeft.X);
var highlightedAreaHeight = Math.Max(bottomLeft.Y, bottomRight.Y) - Math.Min(topLeft.Y, topRight.Y);
const double thresholdForPointVarianceComparedToAreaSize = 0.2;
var frameIndexesThatHaveTheMostCommonHighlightedArea = allFrameHighlightedAreas
    .Where(entry =&gt;
    {
        var (entryTL, entryTR, entryBR, entryBL) = entry.HighlightedArea;
        var xVariance =
            new[]
            {
                entryBL.X - bottomLeft.X,
                entryBR.X - bottomRight.X,
                entryTL.X - topLeft.X,
                entryTR.X - topRight.X
            }
            .Sum(Math.Abs);
        var yVariance =
            new[]
            {
                entryBL.Y - bottomLeft.Y,
                entryBR.Y - bottomRight.Y,
                entryTL.Y - topLeft.Y,
                entryTR.Y - topRight.Y
            }
            .Sum(Math.Abs);
        return
            (xVariance &lt;= highlightedAreaWidth * thresholdForPointVarianceComparedToAreaSize) &amp;&amp;
            (yVariance &lt;= highlightedAreaHeight * thresholdForPointVarianceComparedToAreaSize);
    })
    .Select(entry =&gt; entry.FrameIndex)
    .ToArray();
</code></pre>
<p>This gives us a <code>frameIndexesThatHaveTheMostCommonHighlightedArea</code> array of frame indexes that have a largest brightest area that is fairly close to the most common one. So to decide which frames are probably the start of the presentation and the end, we simply need to say:</p>
<pre><code>var firstFrameIndex = frameIndexesThatHaveTheMostCommonHighlightedArea.Min();
var lasttFrameIndex = frameIndexesThatHaveTheMostCommonHighlightedArea.Max();
</code></pre>
<p>Any frames whose index is less than <code>firstFrameIndex</code> or greater than <code>lastFrameIndex</code> is probably part of the intro or outro sequence - eg.</p>
<p><img src="/Content/Images/Posts/VideoFrameWithMask-Intro.jpg" alt="A frame from the intro of the video - the largest bright area is not near the slide projection" title="A frame from the intro of the video - the largest bright area is not near the slide projection" /></p>
<p>Any frames whose index is within the <code>firstFrameIndex</code> / <code>lastFrameIndex</code> range is probably part of the presentation - eg.</p>
<p><img src="/Content/Images/Posts/VideoFrameWithMask-Alternate.jpg" alt="A frame from the presentation part of the video - the largest bright area IS the slide projection" title="A frame from the presentation part of the video - the largest bright area IS the slide projection" /></p>
<h3 id="coming-soon"><a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one#coming-soon">Coming soon</a></h3>
<p>As the title of this post strongly suggests, this is only the first step in my desire to fix up my blurry presentation video. What I'm going to have to cover in the future is to:</p>
<ol>
<li>Extract the content from the most-common-brightest-area in each frame of the video that is part of the presentation and contort it back into a rectangle - undoing the distortion that is introduced by perspective due to the position of the camera and where the slides were projected in the room (I'll be tackling this in a slightly approximate-but-good-enough manner because to do it super accurately requires lots of complicated maths and I've managed to forget nearly all of the maths degree that I got twenty years ago!)</li>
<li>Find a way to compare the perspective-corrected projections from each frame against a clean image of the original slide deck and work out which slide each frame is most similar to (this should be possible with some surprisingly rudimentary calculations inspired by some of the image preprocessing that I've mentioned in a couple of my <a href="/Archive/Tag/Machine%20Learning">posts that touch on machine learning</a> but without requiring any machine learning itself)</li>
<li>Some tweaks that were required to get the best results with my particular images (for example, when I described the <code>GetMostHighlightedArea</code> function earlier, I picked 400px as an arbitrary value to resize images to before greyscaling them, masking them and looking for their largest bright area; maybe it will turn out that smaller or larger values for that process result in improved or worsened results - we'll find out!)</li>
</ol>
<p>Once this is all done, I will take the original frame images and, for each one, overlay a clean version of the slide that appeared blurrily in the frame (again, I'll have clean versions of each slide from the original slide deck that I produced, so that should be an easy part) - then I'll mash them all back together into a new video, combined with the original audio. To do this (the video work), I'll likely use the same tool that I used to extract the individual frame files from the video in the first place - the famous <a href="https://www.ffmpeg.org/">FFmpeg</a>!</p>
<p>I doubt that I'll have a post on this last section as it would only be a small amount of C# code that combines two images for each frame, writes the results to disk, followed by me making a command line call to FFmpeg to produce the video - and I don't think that there's anything particularly exciting there! If I get this all completed, though, I will - of course - link to the fixed-up presentation video.. because why not shameless plug myself given any opportunity!</p>
<p class="PostTime">Posted at 21:06</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/approximately-correcting-perspective-with-c-sharp-fixing-a-blurry-presentation-video-part-two">(Approximately) correcting perspective with C# (fixing a blurry presentation video - part two)</a></li><li><a href="/how-are-barcodes-read-libraryless-image-processing-in-c-sharp">How are barcodes read?? (Library-less image processing in C#)</a></li><li><a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face (finding faces in photos using C# and Accord.NET)</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Image%20Processing" title="4 Posts">Image Processing</a></li></ul></div>
            <p class="Comments">
                <a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one#disqus_thread" data-disqus-identifier="124">Comments</a>
            </p>
    </div>

        <script type="text/javascript">
            (function () {
                var s = document.createElement("script");
                s.type = "text/javascript";
                s.async = true;
                s.src = "https://" + disqus_shortname + ".disqus.com/count.js";
                (document.getElementsByTagName("HEAD")[0] || document.getElementsByTagName("BODY")[0]).appendChild(s);
            }());
        </script>

				<div class="Footer">
					© Productive Rage 2011 - 2022
				</div>
			</div>

			<div class="SideBar">
				<div class="About">
					<h2>About</h2>
					<p>Dan is a big geek who likes making stuff with computers! He can be quite outspoken so clearly needs a blog :)</p>
					<p>In the last few minutes he seems to have taken to referring to himself in the third person. He's quite enjoying it.</p>
					<p><a href="mailto:dangger36@gmail.com" class="Email">dangger36@gmail.com</a></p>
				</div>
				<div class="Search">
<form action="/Search" autocomplete="off" class="Search" method="get">						<div>
							<label class="SearchField">
								<span class="text">Site Search</span>
								<input type="text" class="SiteSearch" name="term" value="" />
							</label>
							<input type="submit" class="SiteSearchSubmit" value="Search" />
						</div>
</form>				</div>
				<div class="Recent"><h2>Recent Posts</h2><ul><li><a href="/approximately-correcting-perspective-with-c-sharp-fixing-a-blurry-presentation-video-part-two">(Approximately) correcting perspective with C# (fixing a blurry presentation video - part two)</a></li><li><a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one">Finding the brightest area in an image with C# (fixing a blurry presentation video - part one)</a></li><li><a href="/so-what-is-machine-learning-nocodeintro">So.. what is machine learning? (#NoCodeIntro)</a></li><li><a href="/parallelising-linq-work-in-c-sharp">Parallelising (LINQ) work in C#</a></li><li><a href="/automating-suggested-related-posts-links-for-my-blog-posts-part-2">Automating &quot;suggested / related posts&quot; links for my blog posts - Part 2</a></li></ul><div class="RSSFeedLink"><a href="https://www.productiverage.com/feed">RSS Feed</a></div></div>
				<div class="Featured"><h2>Highlights</h2><ul><li><a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face (finding faces in photos using C# and Accord.NET)</a></li><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/translating-vbscript-into-c-sharp">Translating VBScript into C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div>
				<div class="History"><h2>Archives</h2><ul><li><a href="/Archive/3/2022">March 2022 (2)</a></li><li><a href="/Archive/2/2022">February 2022 (1)</a></li><li><a href="/Archive/8/2021">August 2021 (1)</a></li><li><a href="/Archive/4/2021">April 2021 (2)</a></li><li><a href="/Archive/3/2021">March 2021 (1)</a></li><li><a href="/Archive/8/2020">August 2020 (3)</a></li><li><a href="/Archive/7/2019">July 2019 (2)</a></li><li><a href="/Archive/9/2018">September 2018 (1)</a></li><li><a href="/Archive/4/2018">April 2018 (1)</a></li><li><a href="/Archive/3/2018">March 2018 (1)</a></li><li><a href="/Archive/7/2017">July 2017 (1)</a></li><li><a href="/Archive/6/2017">June 2017 (1)</a></li><li><a href="/Archive/2/2017">February 2017 (1)</a></li><li><a href="/Archive/11/2016">November 2016 (1)</a></li><li><a href="/Archive/9/2016">September 2016 (2)</a></li><li><a href="/Archive/8/2016">August 2016 (1)</a></li><li><a href="/Archive/7/2016">July 2016 (1)</a></li><li><a href="/Archive/6/2016">June 2016 (1)</a></li><li><a href="/Archive/5/2016">May 2016 (3)</a></li><li><a href="/Archive/3/2016">March 2016 (3)</a></li><li><a href="/Archive/2/2016">February 2016 (2)</a></li><li><a href="/Archive/12/2015">December 2015 (1)</a></li><li><a href="/Archive/11/2015">November 2015 (2)</a></li><li><a href="/Archive/8/2015">August 2015 (3)</a></li><li><a href="/Archive/7/2015">July 2015 (1)</a></li><li><a href="/Archive/6/2015">June 2015 (1)</a></li><li><a href="/Archive/5/2015">May 2015 (2)</a></li><li><a href="/Archive/4/2015">April 2015 (1)</a></li><li><a href="/Archive/3/2015">March 2015 (1)</a></li><li><a href="/Archive/1/2015">January 2015 (2)</a></li><li><a href="/Archive/12/2014">December 2014 (1)</a></li><li><a href="/Archive/11/2014">November 2014 (1)</a></li><li><a href="/Archive/10/2014">October 2014 (2)</a></li><li><a href="/Archive/9/2014">September 2014 (2)</a></li><li><a href="/Archive/8/2014">August 2014 (1)</a></li><li><a href="/Archive/7/2014">July 2014 (1)</a></li><li><a href="/Archive/6/2014">June 2014 (1)</a></li><li><a href="/Archive/5/2014">May 2014 (2)</a></li><li><a href="/Archive/2/2014">February 2014 (1)</a></li><li><a href="/Archive/1/2014">January 2014 (1)</a></li><li><a href="/Archive/12/2013">December 2013 (1)</a></li><li><a href="/Archive/11/2013">November 2013 (1)</a></li><li><a href="/Archive/10/2013">October 2013 (1)</a></li><li><a href="/Archive/8/2013">August 2013 (3)</a></li><li><a href="/Archive/7/2013">July 2013 (3)</a></li><li><a href="/Archive/6/2013">June 2013 (1)</a></li><li><a href="/Archive/5/2013">May 2013 (2)</a></li><li><a href="/Archive/4/2013">April 2013 (1)</a></li><li><a href="/Archive/3/2013">March 2013 (8)</a></li><li><a href="/Archive/2/2013">February 2013 (2)</a></li><li><a href="/Archive/1/2013">January 2013 (2)</a></li><li><a href="/Archive/12/2012">December 2012 (3)</a></li><li><a href="/Archive/11/2012">November 2012 (4)</a></li><li><a href="/Archive/9/2012">September 2012 (1)</a></li><li><a href="/Archive/8/2012">August 2012 (1)</a></li><li><a href="/Archive/7/2012">July 2012 (3)</a></li><li><a href="/Archive/6/2012">June 2012 (3)</a></li><li><a href="/Archive/5/2012">May 2012 (2)</a></li><li><a href="/Archive/2/2012">February 2012 (3)</a></li><li><a href="/Archive/1/2012">January 2012 (4)</a></li><li><a href="/Archive/12/2011">December 2011 (7)</a></li><li><a href="/Archive/8/2011">August 2011 (2)</a></li><li><a href="/Archive/7/2011">July 2011 (1)</a></li><li><a href="/Archive/5/2011">May 2011 (1)</a></li><li><a href="/Archive/4/2011">April 2011 (2)</a></li><li><a href="/Archive/3/2011">March 2011 (3)</a></li></ul><div class="EveryTitle"><a href="/Archive/All">Every Post Title</a></div></div>
			</div>

		</div>
	</div>

	<script type="text/javascript" src="/Scripts/autocomplete.js"></script>
	<script type="text/javascript" src="/Scripts/prettify.js"></script>
	<script type="text/javascript" src="/Scripts/Site.js"></script>
	<script type="text/javascript" src="/Scripts/IndexSearchGenerator.js"></script>
	<script type="text/javascript" src="/Scripts/SearchTermHighlighter.js"></script>
	<script type="text/javascript" src="/Scripts/SearchPage.js"></script>
	<script type="text/javascript" src="/Scripts/LZString.js"></script>

</body>
</html>
