<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Productive Rage - Writing React apps using Bridge.NET - The Dan Way (from first principles)</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta name="theme-color" content="#393939" />
	<link rel="stylesheet" type="text/css" media="all" href="/Content/Styles.css" />
	<link rel="stylesheet" type="text/css" media="print" href="/Content/PrintOverrides.css" />
	<link rel="canonical" href="http://www.productiverage.com/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.productiverage.com/feed" />
	<script type="text/javascript">
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

		ga('create', "UA-32312857-1", { 'storage': 'none' });
		ga('send', 'pageview');
	</script>
    <meta name="description" content="(This is part one of a three part series, each post is longer than the last so strap yourself in if you&#x27;re thinking of playing along - hopefully you&#x27;ll think that it was worth it by the end! :)" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="productiverage" />
    <meta name="twitter:title" content="Writing React apps using Bridge.NET - The Dan Way (from first principles)" />
    <meta name="twitter:image" content="http://www.productiverage.com/Content/Images/Grouch.jpg" />
    <meta name="twitter:description" content="(This is part one of a three part series, each post is longer than the last so strap yourself in if you&#x27;re thinking of playing along - hopefully you&#x27;ll think that it was worth it by the end! :)" />
</head>

<body>

	<div class="Header">
		<div class="HeaderContent">
			<h1>
				<a href="/">Productive Rage</a>
			</h1>
			<span class="Tagline">Dan's techie ramblings</span>
		</div>
	</div>

	<div class="WrapperOuter">
		<div class="Wrapper">
			<div class="Main HasSideBar">
				

        <script type="text/javascript">
			var disqus_shortname = "productiverage";
			function executeWhen(fncAction, fncConditional, intDelayBetweenRetries) {
				if (fncConditional()) { fncAction(); return; }
				setTimeout(function () { executeWhen(fncAction, fncConditional, intDelayBetweenRetries); }, intDelayBetweenRetries);
			}
			function whenjQueryIsAvailable(fncAction) {
				executeWhen(
					fncAction,
					function () { return (typeof ($) !== "undefined") },
					10
				);
			}
			(function () {
				whenjQueryIsAvailable(
					function () { $("div.Content p.Comments").show(); }
				);
			}());
        </script>

    <div class="Content SinglePost">
        <p class="PostDate">15 March 2016</p><h2><a id="writing-react-apps-using-bridgenet-the-dan-way-from-first-principles" href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">Writing React apps using Bridge.NET - The Dan Way (from first principles)</a></h2>
<p><em>(This is part one of a three part series, each post is longer than the last so strap yourself in if you're thinking of playing along - hopefully you'll think that it was worth it by the end! :)</em></p>
<p>I've had a request from someone to write about how I think that someone from a .net background should write a web-based application. The short answer is that I strongly believe that using Bridge.NET with React, using a Flux-like architecture is the way forward. I think that React changed the game by trying to introduce a way to write applications that addressed the big challenges, rather than what many of the other frameworks did, which was to try to make some aspects of development easier but without tackling the underlying problems. We're going to be using these technologies to create some big applications where I work and some resources as to how best to do this will be valuable. I'm going to try to roll this all together into a short series of posts about creating Bridge / React / Flux apps, where I'll try to start from the simplest approach at each point and only introduce something new when I can explain why it's valuable. So, initially, Flux will be nowhere to be seen - but, hopefully, when it <em>is</em> introduced, it will be clear why.</p>
<p>(I'm not going to expel any effort on convincing you that writing C# in Visual Studio is incredibly powerful, and that it's fantastic to be able to do this while writing browser-based applications, nor am I going to try to sell you any more on React - if you're not on board with these ideas already then there's a <em>chance</em> that these posts will sell you on it, but that's not going to be my main focus).</p>
<h3>From the very start</h3>
<p>I'm going to begin from a completely fresh project, so if you've got any experience with Bridge then these steps will be familiar. But I'll go through them quickly and then start building the application itself. It's going to be extremely simple but will illustrate how to work with React and how to deal with user input and Virtual DOM re-rendering, how and where to implement validation and how to make <em>all the things</em> asynchronous so that async is not only used for scary edge cases and can be seen as a valuable tool to decouple code (and, in doing so, async will become a not-at-all-scary thing).</p>
<p>All that the application will do will be to allow the user to write a message, entering  Title and Content strings, and to save this message. There will be a &quot;Message API&quot;, which will emulate reading and writing to a remote endpoint, for data persistence, but the implementation will all be kept in-memory / in the browser, just to make things simple. It will look something like this:</p>
<img alt="The proposed example app" src="/Content/Images/Posts/ReactTutorial1.png" class="NoBorder AlwaysFullWidth" title="The proposed example app" />
<p>As more messages are written, more entries will appear in the &quot;Message History&quot;. Seems simple.</p>
<h3>React components</h3>
<p>Before getting into any React-with-Bridge specifics, I want to talk a little about React components; how to arrange them into a hierarchy and how they should and shouldn't talk to each other.</p>
<p>Almost all of the time, components that you use will be &quot;<a href="https://facebook.github.io/react/docs/forms.html#controlled-components">controlled components</a>&quot; -</p>
<blockquote>
<p>A Controlled component does not maintain its own internal state; the component renders purely based on props.</p>
</blockquote>
<p>This means that when you render a text input, you give it a &quot;value&quot; property and an &quot;onChange&quot; property - when the user tries to change what's in the text box (whether by pressing a number or letter, or by pressing backspace or by pasting something in) then the &quot;onChange&quot; callback is executed. The text box is <em>not</em> updated automatically, all that happens is that a callback is made that indicates that the user has done something that means that the text input probably <em>should</em> be updated.</p>
<p>This seems odd at the very start since you may be used to events being driven by html elements and the updates being broadcast elsewhere; with React, events arise from components that describe the desire for a change to be made, but the change does not happen automatically. This is what is meant in the quote above when it says that a controlled component &quot;does not maintain its own internal state&quot;.</p>
<p>This hints at one of the key aims of React - to make code explicit and easy to reason about. If a component <em>only</em> varies based upon its props, then it's very easy to reason about; given this props data, draw in this manner. (If user-entered changes to a text input were automatically reflected in the text box then the component would <em>not</em> solely vary by its props, it would vary according to its props and whatever else the user has done to it).</p>
<p>The only way for a component to update / re-render itself (and any child components that it may have) is for it to changes its &quot;state&quot;. This is a special concept in React - if &quot;SetState&quot; is called then the component will re-render, but now it may have to consider both its props <em>and</em> its new state. If we really wanted to have a text input that would automatically update its own value as well as raise a change event, we could write a component to do so -</p>
<p><em>(Note: if you're coming into this fresh, don't worry about how to compile this C# code into a React application, I'll be getting to that after I've finished giving my view on React components).</em></p>
<pre><code>public class TextInput : Component&lt;TextInput.Props, TextInput.State&gt;
{
  public TextInput(Props props) : base(props) { }

  public override ReactElement Render()
  {
    return DOM.Input(new InputAttributes
    {
      Type = InputType.Text,
      Value = (state == null) ? props.InitialValue : state.Value,
      OnChange = ev =&gt;
      {
        var newValue = ev.CurrentTarget.Value;
        SetState(new State { Value = newValue });
        props.OnChange(newValue);
      }
    });
  }

  public class Props
  {
    public string InitialValue;
    public Action&lt;string&gt; OnChange;
  }

  public class State
  {
    public string Value;
  }
}
</code></pre>
<p>The problem here is that now the component depends upon two things whenever it has to render - its props <em>and</em> its state. It can change its own state but it can't change its props (React demands that a components props be considered to be immutable).</p>
<p><em>This</em> means that the component becomes more difficult to reason about, it was much easier when it didn't have to worry about state. (Granted, there may have been some question as to who would receive that OnChange callback to get the component to re-render, but we're going to get to that shortly).</p>
<p>Partly for this reason, it's strongly recommended that the vast majority of components be stateless - meaning that they render according to their props and nothing else.</p>
<p>Another reason that it is strongly recommended that components not update themselves (meaning that they are stateless, since the only way for a component to update itself is to change its state) is that it makes the handling of events much clearer. In the example application that I'm going to refer to in this series, the &quot;Title&quot; value that is entered by the user is reflected in the fieldset legend -</p>
<img alt="Fieldset legend mirros the Title input value" src="/Content/Images/Posts/ReactTutorial2.png" class="NoBorder AlwaysFullWidth" title="Fieldset legend mirros the Title input value" />
<p>If the &quot;Title&quot; input box was to maintain its own state and update itself when its contents change, there still needs to be something listening for changes in order to update the fieldset legend text. If it was common for components to maintain their own state then things would quickly get out of hand as more and more components have to listen for (and react to) changes in other components. Just in the example here, there is a validation message that needs to be hidden if the &quot;Title&quot; input has a non-blank value, so that component would need to listen for the change event on the input. (Alternatively, the <strong>TextInput</strong> component could be provided with validation logic and <em>it</em> would be responsible for showing or hiding the validation message - which would complicate the <strong>TextInput</strong> class). On top of this, there is the &quot;Save&quot; button which should be disabled if either of the &quot;Title&quot; or &quot;Content&quot; input boxes have no value - so the Save button component would need to listen to change events from both text inputs and decide whether or not it should be enabled based upon their states. Maybe the input form itself wants to add an &quot;invalid&quot; class to itself for styling purposes if either of the inputs are invalid - now the form component has to listen to changes to the text inputs and add or remove this class. This way lies madness.</p>
<p>In summary, most components should <em>not</em> try to update themselves and so do not need state. The React bindings make it easy to write components that don't use state (again, I'll talk about using these bindings more shortly, I just wanted to point out now that the distinction between stateful and stateless components is an important one and that the bindings reflect this) -</p>
<pre><code>public class TextInput : StatelessComponent&lt;TextInput.Props&gt;
{
  public TextInput(Props props) : base(props) { }

  public override ReactElement Render()
  {
    return DOM.Input(new InputAttributes
    {
      Type = InputType.Text,
      Value = props.Value,
      OnChange = ev =&gt; props.OnChange(ev.CurrentTarget.Value)
    });
  }

  public class Props
  {
    public string Value;
    public Action&lt;string&gt; OnChange;
  }
}
</code></pre>
<p>The component code is much more succinct this way, as well as helping us avoid the nightmare scenario described above.</p>
<p>It does leave one big question, though.. if these components don't update themselves, <em>then what does?</em></p>
<p>Answer: There should be a top-level &quot;Container Component&quot; that maintains state for the application. This should be the only stateful component, all components further down the hierarchy should be stateless.</p>
<p>In the sample application here -</p>
<img alt="The proposed example app" src="/Content/Images/Posts/ReactTutorial1.png" class="NoBorder AlwaysFullWidth" title="The proposed example app" />
<p>The component hierarchy will look something like this:</p>
<pre><code>AppContainer
  MessageEditor
    Span (&quot;Title&quot;)
    ValidatedTextInput
      Input
    Span (&quot;Content&quot;)
    ValidatedTextInput
      Input
    Button
  MessageHistory
    Div
      Span (Message Title)
      Span (Message Content)
    Div
      Span (Message Title)
      Span (Message Content)
</code></pre>
<p>The <strong>MessageHistory</strong> will be a read-only component tree (it just shows saved messages) and so is very simple (there are no callbacks to handle). The <strong>MessageEditor</strong> will render Span labels (&quot;Title&quot; and &quot;Content&quot;), two <strong>ValidatedTextInput</strong> components and a &quot;Save&quot; button. The <strong>ValidatedTextInput</strong> has props for a current text input value, an on-change callback and an optional validation message.</p>
<p>When an input component's on-change callback is executed, it is an action with a single argument; the html element. In the <strong>TextInput</strong> example class above, the new value is extracted from that element (&quot;ev.CurrentTarget.Value&quot;) and then passed into the on-change callback of the <strong>TextInput</strong>, which is an action with a simple string argument. <strong>ValidatedTextInput</strong> will be very similar (it will wrap the <strong>Action&lt;InputElement&gt;</strong> callback that the input raises in a simpler <strong>Action&lt;string&gt;</strong>). The only difference between it and the <strong>TextInput</strong> example class earlier is that it  will also be responsible for rendering a validation message element if its props value has a non-blank validation message to show (and it may apply an &quot;invalid&quot; class name to its wrapper if there is a validation message to show).</p>
<p>When the Title or Content <strong>ValidatedTextInput</strong> raise an on-change event, the <strong>MessageEditor</strong> will execute some code that translates this callback further. The <strong>MessageEditor</strong> will have an on-change props value whose single argument is a <strong>MessageDetails</strong> - this will have have values for the current &quot;Title&quot; and &quot;Content&quot;. Just as an on-change from an input element resulted in an on-change being raised by a <strong>ValidatedTextInput</strong>, an on-change by a <strong>ValidatedTextInput</strong> will result in an on-change from the <strong>MessageEditor</strong>. Each on-change event changes the type of value that the on-change describes (from an input element to a string to a <strong>MessageDetails</strong>). The <strong>MessageEditor</strong>'s on-change will be received by the <strong>AppContainer</strong> Component, which is where the change will result in the component tree being re-rendered.</p>
<p>The <strong>AppContainer</strong> component will re-render by calling &quot;SetState&quot; and creating a new state reference for itself that include the new <strong>MessageDetails</strong> reference (that was passed up in the on-change callback from the <strong>MessageEditor</strong>). The call to &quot;SetState&quot; will result in the component being re-rendered, which will result in it rendering a new version of the <strong>MessageEditor</strong>. When the <strong>MessageEditor</strong> is rendered, the current &quot;Title&quot; value will be used to populate the text input <em>and</em> to set the text in the legend of the fieldset that wraps the editor's input boxes. This is how the &quot;nightmare scenario&quot; described earlier is avoided - instead of having lots of components listen out to events from lots of <em>other</em> components, all components just pass their events up to the top and then the entire UI is re-rendered in React's Virtual DOM.</p>
<p>I'm going to repeat that part about event-handling because it's important; events are passed <em>up</em> from where they occur, up to the top-level component. This will trigger a re-render, which works all the way <em>down</em> through the component tree, so that the requested change is then reflected in the UI.</p>
<p>The Virtual DOM determines what (if anything) needs to change in the browser's DOM and applies those changes - this works well because the Virtual DOM is very fast (and so we can do these &quot;full Virtual DOM re-renders&quot; frequently) and it minimises changes to the browser DOM (which is much slower).</p>
<p><em>(The Facebook tutorial <a href="https://facebook.github.io/react/docs/thinking-in-react.html">Thinking in React</a> talks about how to mentally break down a UI into components and talks about passing state up the tree, but I wanted to try to really drive home how components should be put together and how they should communicate before fobbing you off with a Facebook link)</em>.</p>
<p>I have some more recommendations on how to decide what to put into props and what into state when creating stateful container components, but I'll cover that ground after some more practical work.</p>
<h3>Let's start coding then!</h3>
<p>Open up Visual Studio (the version isn't too important, but if you're using 2015 then bear in mind that Bridge.NET doesn't yet support C# 6 syntax). Create a new &quot;Class Library&quot; project. Using NuGet, add the &quot;Bridge&quot; and the &quot;Bridge.React&quot; packages. This will bring in bindings for React as well as pulling in Bridge itself - the Bridge package removes the usual System, System.Collections, etc.. references and replaces them with a single &quot;Bridge&quot; reference, which re-implements those framework methods in code that has JavaScript translations.</p>
<p>The Bridge package also adds some README files and a bridge.json file (under the Bridge folder in the project), which instructs Bridge how to compile your C# code into JavaScript. Change bridge.json's content to:</p>
<pre><code>{
  &quot;output&quot;: &quot;Bridge/output&quot;,
  &quot;combineScripts&quot;:  true
}
</code></pre>
<p>This will tell it create a single JavaScript file when translating, including the Bridge library content and the React bindings and JavaScript generated from code that you write. The name of the file that it generates is based upon the name of your project. I named mine &quot;BridgeReactTutorial&quot; and so the Bridge compiler will generate &quot;BridgeReactTutorial.js&quot; and &quot;BridgeReactTutorial.min.js&quot; files in the &quot;Bridge/output&quot; folder on each build of the project.</p>
<p>Now create an empty html file in the project root called &quot;demo.html&quot; and paste in the following:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;title&gt;Bridge.React Tutorial&lt;/title&gt;
  &lt;link rel=&quot;Stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot; media=&quot;screen&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;noscript&gt;JavaScript is required&lt;/noscript&gt;
  &lt;div id=&quot;main&quot; class=&quot;loading&quot;&gt;Loading..&lt;/div&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-dom.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;Bridge/output/BridgeReactTutorial.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><em>(If you called your project something other than &quot;BridgeReactTutorial&quot; then you might have to change the filename in that last script tag).</em></p>
<p>This file will load in the latest (0.14.7, as of March 2016) version of the React library along with the Bridge / React-bindings / your-code bundle. All we need to do now is write some &quot;your-code&quot; content.</p>
<p>When you created the class library project, a Class1.cs file will have been added to the project. Change its contents -</p>
<pre><code>using System.Linq;
using Bridge.Html5;
using Bridge.React;

namespace BridgeReactTutorial
{
  public class Class1
  {
    [Ready]
    public static void Main()
    {
      var container = Document.GetElementById(&quot;main&quot;);
      container.ClassName = string.Join(
        &quot; &quot;,
        container.ClassName.Split().Where(c =&gt; c != &quot;loading&quot;)
      );
      React.Render(
        DOM.Div(new Attributes { ClassName = &quot;welcome&quot; }, &quot;Hi!&quot;),
        container
      );
    }
  }
}
</code></pre>
<p>Build the solution and then right-click on the &quot;demo.html&quot; file in the project and click on &quot;View in Browser&quot;. You should see a happy little &quot;Hi!&quot; welcome message, rendered using React by JavaScript that was translated from C# - an excellent start!</p>
<p>There are some subtle touches here, such as the &quot;JavaScript is required&quot; message that is displayed if the browser has JavaScript disabled (just in case you ever turn it off and forget!) and a &quot;loading&quot; message that is displayed while the JavaScript sorts itself out (usually this will be a barely-perceptibe amount of time but if the CDN host that the React library is coming from is being slow then it may not be instantaneous). The &quot;main&quot; div initially has a &quot;loading&quot; class on it, which is removed when the code above executes. Note that the [Ready] attribute on the &quot;Main&quot; function is a Bridge attribute, indicating code that should be called when the page has loaded (similar in principle to on-DOM-ready, frequently used by jQuery code).</p>
<p>To take advantage of the &quot;loading&quot; class' presence / absence, it would be a nice touch to have the &quot;loading&quot; text quite pale initially (it's reassuring to know that the app is, in fact, loading, but it doesn't need to be right in your face). To do so, add a file &quot;styles.css&quot; alongside the &quot;demo.html&quot; file. It's already referenced by the markup we've pasted into &quot;demo.html&quot;, so it will be picked up when you refresh the page. Since we're creating a stylesheet, it makes sense to include some style resets (my go-to for this is by Eric Meyer) -</p>
<pre><code>/* http://meyerweb.com/eric/tools/css/reset/ v2.0b1 | 201101 NOTE: WORK IN PROGRESS
 USE WITH CAUTION AND TEST WITH ABANDON */
html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote,
pre,a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s,
samp, small, strike, strong, sub, sup, tt, var,b, u, i, center, dl, dt, dd, ol, ul,
li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, figcaption, figure, footer, header, hgroup, menu,
nav, section, summary, time, mark, audio, video
{
  margin: 0;
  padding: 0;
  border: 0;
  outline: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav,
section { display: block; }
body { line-height: 1; }
ol, ul { list-style: none; }
blockquote, q { quotes: none; }
blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; }
/* remember to highlight inserts somehow! */ ins { text-decoration: none; }
del { text-decoration: line-through; }
table { border-collapse: collapse; border-spacing: 0; }

div#main.loading { color: #f1f1f1; }
</code></pre>
<p>At this point, I also tend to remove the &quot;App_Readme&quot; folder that the Bridge package adds to my project - if I'm going to write some code and check it into source control somewhere then I don't think there's a lot of point in storing a copy of the Bridge README and LICENSE each time.</p>
<h3>Creating the Message Editor</h3>
<p>That's the theory and the project scaffolding out of the way. Now to create a form that actually does something.</p>
<p>We've already seen how a <strong>TextInput</strong> component is helpful for wrapping a text input and simplifying the &quot;OnChange&quot; callback. So create a &quot;Components&quot; folder with a &quot;TextInput.cs&quot; file and paste in the following content -</p>
<pre><code>using System;
using Bridge.Html5;
using Bridge.React;

namespace BridgeReactTutorial.Components
{
  public class TextInput : StatelessComponent&lt;TextInput.Props&gt;
  {
    public TextInput(Props props) : base(props) { }

    public override ReactElement Render()
    {
      return DOM.Input(new InputAttributes
      {
        Type = InputType.Text,
        ClassName = props.ClassName,
        Value = props.Content,
        OnChange = e =&gt; props.OnChange(e.CurrentTarget.Value)
      });
    }

    public class Props
    {
      public string ClassName;
      public string Content;
      public Action&lt;string&gt; OnChange;
    }
  }
}
</code></pre>
<p><em>(Note: When adding a new &quot;.cs&quot; file to a project, sometimes &quot;System&quot; will sneak back into the list of references in the project - this can confuse Bridge, so ensure that you remove the reference again if it gets added).</em></p>
<p>Now create another folder in the root of the project called &quot;ViewModels&quot;. Add a new file to it; &quot;MessageDetails.cs&quot; and paste in the following content -</p>
<pre><code>namespace BridgeReactTutorial.ViewModels
{
  public class MessageDetails
  {
    public string Title;
    public string Content;
  }
}
</code></pre>
<p>Now add another file to the &quot;Components&quot; folder; &quot;MessageEditor.cs&quot; and paste in this:</p>
<pre><code>using System;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class MessageEditor : StatelessComponent&lt;MessageEditor.Props&gt;
  {
    public MessageEditor(Props props) : base(props) { }

    public override ReactElement Render()
    {
      return DOM.FieldSet(new FieldSetAttributes { ClassName = props.ClassName },
        DOM.Legend(null, string.IsNullOrWhiteSpace(props.Title) ? &quot;Untitled&quot; : props.Title),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Title&quot;),
        new TextInput(new TextInput.Props
        {
          ClassName = &quot;title&quot;,
          Content = props.Title,
          OnChange = newTitle =&gt; props.OnChange(new MessageDetails
          {
            Title = newTitle,
            Content = props.Content
          })
        }),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Content&quot;),
        new TextInput(new TextInput.Props
        {
          ClassName = &quot;content&quot;,
          Content = props.Content,
          OnChange = newContent =&gt; props.OnChange(new MessageDetails
          {
            Title = props.Title,
            Content = newContent
          })
        })
      );
    }

    public class Props
    {
      public string ClassName;
      public string Title;
      public string Content;
      public Action&lt;MessageDetails&gt; OnChange;
    }
  }
}
</code></pre>
<p>Now things are getting interesting!</p>
<p>This is still a stateless component and so what is rendered depends solely and reliably upon its props data. When it renders, the &quot;Title&quot; value from its props is used to populate both the legend of the fieldset that it renders (unless &quot;Title&quot; is null, blank or white-space-only, in which case the legend text will be &quot;Untitled) and it's used to populate the &quot;Title&quot; <strong>TextInput</strong>. When either of its <strong>TextInput</strong>s raises an on-change event, the <strong>MessageEditor</strong> raises its on-change events with a new <strong>MessageDetails</strong> instance.</p>
<p>Note that there's no validation yet. We'll get this rough version working first and then add that later.</p>
<p>There are still a few more steps until we have an application, though. We need a container component to render the form in the first place and to deal with on-change events that bubble up. Create another class file within the &quot;Components&quot; folder named &quot;AppContainer.cs&quot; -</p>
<pre><code>using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class AppContainer : Component&lt;object, AppContainer.State&gt;
  {
    public AppContainer() : base(null) { }

    protected override State GetInitialState()
    {
      return new State
      {
        Message = new MessageDetails { Title = &quot;&quot;, Content = &quot;&quot; }
      };
    }

    public override ReactElement Render()
    {
      return new MessageEditor(new MessageEditor.Props
      {
        ClassName = &quot;message&quot;,
        Title = state.Message.Title,
        Content = state.Message.Content,
        OnChange = newMessage =&gt; SetState(new State { Message = newMessage })
      });
    }

    public class State
    {
      public MessageDetails Message;
    }
  }
}
</code></pre>
<p>This is the <em>stateful</em> component that will trigger re-renders when required. It doesn't actually require any props data at this time, so the &quot;TProps&quot; type parameter specified on the <strong>Component&lt;TProps, TState&gt;</strong> base class is just &quot;object&quot;.</p>
<p>When the <strong>MessageEditor</strong> raises an on-change event, the <strong>AppContainer</strong> will call SetState to replace its current <strong>MessageDetails</strong> instance with the new one. This will trigger a re-render of the <strong>MessageEditor</strong>, which will be given the new <strong>MessageDetails</strong> instance as part of a new props value. It might seem a bit silly to have the <strong>MessageEditor</strong> pass up a new <strong>MessageDetails</strong> instance and then to just pass this back down into another <strong>MessageEditor</strong>, but the idea is to consider the first <strong>MessageEditor</strong> to be dead now and for the new <strong>MessageEditor</strong> (with the new <strong>MessageDetails</strong>) to exist in its place. And each time a stateless component is rendered, it renders simply from its props - there is no data shared between the new instance and the instance it replaces. This, again, makes the components very easy to reason about. And code that is easy to reason about is easy to write and easy to maintain.</p>
<p><em>Note: If you're au fait with React then you might know that components written as ES6 classes - which seems to be the way that is encouraged at the moment - don't support &quot;GetInitialState&quot; and, instead, specify initial state in the constructor. In the Bridge React bindings, &quot;GetInitialState&quot; should be used and the constructor should NOT be used - the way that the components are initialised by React means that constructors on component classes are not actually executed, so it is important that the constructor ONLY be used to pass the props and/or state to the base class.</em></p>
<p>The penultimate step is to change &quot;Class1.cs&quot; to render the <strong>AppContainer</strong> instead of just rendering a &quot;Hi!&quot; div. While we're editing it, let's give it a more official-sounding name. I like the starting point of my application to be called &quot;App&quot; -</p>
<pre><code>using System.Linq;
using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.Components;

namespace BridgeReactTutorial
{
  public class App
  {
    [Ready]
    public static void Go()
    {
      var container = Document.GetElementById(&quot;main&quot;);
      container.ClassName = string.Join(
        &quot; &quot;,
        container.ClassName.Split().Where(c =&gt; c != &quot;loading&quot;)
      );
      React.Render(new AppContainer(), container);
    }
  }
}
</code></pre>
<p>All that's required now is to make it look a little nicer when you view &quot;demo.html&quot;, so add the following to &quot;styles.css&quot; -</p>
<pre><code>body
{
  font-family: 'Segoe UI';
  padding: 8px;
}

fieldset
{
  padding: 8px;
  border: 1px solid #f1f1f1;
  border-radius: 4px;
}
fieldset legend
{
  color: blue;
  padding: 0 8px;
}
fieldset.message span.label { padding: 0 8px; }
</code></pre>
<p>That's the first major milestone reached! A very basic framework for constructing component hierarchies has been demonstrated, along with a way to handle events and re-render as required. There's nothing very radical, it's just what was described earlier; but it's good to see the theory executed in practice.</p>
<p>I'm far from finished for today, though - I want to add a way to persist messages, a message history component and some validation. Best get cracking!</p>
<h3>Message persistence</h3>
<p>While I want to simulate a server-based API, where read / write requests aren't instantaneous and we need to think about how to deal with async calls, I don't want the overhead of needing an endpoint to be configured somewhere. So we'll go with a simple interface that will be implemented in an entirely client-side class, that introduces artifical delays to mimic server-calling time.</p>
<p>Create a new folder in the project root called &quot;API&quot; and add a new .cs file &quot;IReadAndWriteMessages.cs&quot;, the contents of which should be:</p>
<pre><code>using System.Threading.Tasks;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.API
{
  public interface IReadAndWriteMessages
  {
    Task SaveMessage(MessageDetails message);
  }
}
</code></pre>
<p>We'll be using dependency injection to provide the <strong>AppContainer</strong> with an API implementation. In order to enable unit testing (which will come later) we need to be able to work against an interface. For now, the interface only has a &quot;SaveMessage&quot; method, we'll work on reading message history data later.</p>
<p>Add another file into the &quot;API&quot; folder, &quot;MessageApi.cs&quot; -</p>
<pre><code>using System;
using System.Threading.Tasks;
using Bridge.Html5;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.API
{
  public class MessageApi : IReadAndWriteMessages
  {
    public Task SaveMessage(MessageDetails message)
    {
      if (message == null)
        throw new ArgumentNullException(&quot;message&quot;);
      if (string.IsNullOrWhiteSpace(message.Title))
        throw new ArgumentException(&quot;A title value must be provided&quot;);
      if (string.IsNullOrWhiteSpace(message.Content))
        throw new ArgumentException(&quot;A content value must be provided&quot;);

      var task = new Task&lt;object&gt;(null);
      Window.SetTimeout(
        () =&gt; task.Complete(),
        1000 // Simulate a roundtrip to the server
      );
      return task;
    }
  }
}
</code></pre>
<p>Bridge supports the C# &quot;async&quot; keyword and provides its own implementation of Tasks, which are used above to pretend that this class is communicating with a server when a save is requested.</p>
<p>In order to enable saving, the <strong>MessageEditor</strong> needs a &quot;Save&quot; button and it needs an &quot;on-save&quot; callback to be specified on its props. While saving, the form should be disabled, so the <strong>MessageEditor</strong> props need a &quot;Disabled&quot; flag as well.</p>
<p><em>When designing an SPA like this, you need to think about whether you will support &quot;optimistic updates&quot;, where clicking Save clears the form and acts as if the save action was instanteously accepted - but brings it to the user's attention somehow if the save failed or was rejected. I'm going to go for a simpler &quot;pessimistic update&quot; flow, where the form is disabled until the save is acknowledged, at which point the form will be cleared and re-enabled so that a further entry may be written and then saved.</em></p>
<p>The <strong>MessageEditor</strong> should now looks like this:</p>
<pre><code>using System;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class MessageEditor : StatelessComponent&lt;MessageEditor.Props&gt;
  {
    public MessageEditor(Props props) : base(props) { }

    public override ReactElement Render()
    {
      return DOM.FieldSet(new FieldSetAttributes { ClassName = props.ClassName },
        DOM.Legend(null, string.IsNullOrWhiteSpace(props.Title) ? &quot;Untitled&quot; : props.Title),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Title&quot;),
        new TextInput(new TextInput.Props
        {
          ClassName = &quot;title&quot;,
          Disabled = props.Disabled,
          Content = props.Title,
          OnChange = newTitle =&gt; props.OnChange(new MessageDetails
          {
            Title = newTitle,
            Content = props.Content
          })
        }),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Content&quot;),
        new TextInput(new TextInput.Props
        {
          ClassName = &quot;content&quot;,
          Disabled = props.Disabled,
          Content = props.Content,
          OnChange = newContent =&gt; props.OnChange(new MessageDetails
          {
            Title = props.Title,
            Content = newContent
          })
        }),
        DOM.Button(
          new ButtonAttributes { Disabled = props.Disabled, OnClick = e =&gt; props.OnSave() },
          &quot;Save&quot;
        )
      );
    }

    public class Props
    {
      public string ClassName;
      public string Title;
      public string Content;
      public Action&lt;MessageDetails&gt; OnChange;
      public Action OnSave;
      public bool Disabled;
    }
  }
}
</code></pre>
<p>The &quot;Disabled&quot; flag needs to be able to be applied to the <strong>TextInput</strong> components, so <strong>TextInput</strong> needs to look like this:</p>
<pre><code>using System;
using Bridge.Html5;
using Bridge.React;

namespace BridgeReactTutorial.Components
{
  public class TextInput : StatelessComponent&lt;TextInput.Props&gt;
  {
    public TextInput(Props props) : base(props) { }

    public override ReactElement Render()
    {
      return DOM.Input(new InputAttributes
      {
        Type = InputType.Text,
        ClassName = props.ClassName,
        Disabled = props.Disabled,
        Value = props.Content,
        OnChange = e =&gt; props.OnChange(e.CurrentTarget.Value)
      });
    }

    public class Props
    {
      public string ClassName;
      public bool Disabled;
      public string Content;
      public Action&lt;string&gt; OnChange;
    }
  }
}
</code></pre>
<p>This enables the <strong>MessageEditor</strong> to initiate a save request and for a &quot;Message API&quot; to process the request. Now the <strong>AppContainer</strong> needs to tie these two aspects together.</p>
<p><em>Note that the OnSave action on the <strong>MessageEditor</strong> doesn't provide a new <strong>MessageDetails</strong> instance - that is because the Title and Content value that are rendered in the <strong>MessageEditor</strong> could not have been changed since the component was rendered, otherwise an OnChange callback would have been made before OnSave.</em></p>
<p>Now, the <strong>AppContainer</strong> gets a bit more interesting because it requires props <em>and</em> state. Its props will be external dependencies that it requires access to, while its state will be a copy of all data that is required to render the form. This is a good time to introduce my React (stateful) component guidelines -</p>
<ol>
<li>A stateful component's &quot;props&quot; data should <em>only</em> consist of references to external dependencies</li>
<li>A stateful component's &quot;state&quot; data should include <em>everything</em> required to render the component tree, though the props may be required to deal with child components' events</li>
</ol>
<p>At this point, these rules are going to seem very straight-forward. Later, however, things will get a little more nuanced and I'll re-visit them at that point.</p>
<p>The <strong>AppContainer</strong> will now become the following -</p>
<pre><code>using Bridge.React;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class AppContainer : Component&lt;AppContainer.Props, AppContainer.State&gt;
  {
    public AppContainer(AppContainer.Props props) : base(props) { }

    protected override State GetInitialState()
    {
      return new State
      {
        Message = new MessageDetails { Title = &quot;&quot;, Content = &quot;&quot; },
        IsSaveInProgress = false
      };
    }

    public override ReactElement Render()
    {
      return new MessageEditor(new MessageEditor.Props
      {
        ClassName = &quot;message&quot;,
        Title = state.Message.Title,
        Content = state.Message.Content,
        OnChange = newMessage =&gt; SetState(new State
        {
          Message = newMessage,
          IsSaveInProgress = state.IsSaveInProgress
        }),
        OnSave = async () =&gt;
        {
          SetState(new State { Message = state.Message, IsSaveInProgress = true });
          await props.MessageApi.SaveMessage(state.Message);
          SetState(new State
          {
            Message = new MessageDetails { Title = &quot;&quot;, Content = &quot;&quot; },
            IsSaveInProgress = false
          });
        },
        Disabled = state.IsSaveInProgress
      });
    }

    public class Props
    {
      public IReadAndWriteMessages MessageApi;
    }

    public class State
    {
      public MessageDetails Message;
      public bool IsSaveInProgress;
    }
  }
}
</code></pre>
<p>You will need to update App.cs to pass a props reference with a <strong>MessageApi</strong> instance to the <strong>AppContainer</strong> constructor -</p>
<pre><code>using System.Linq;
using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.API;
using BridgeReactTutorial.Components;

namespace BridgeReactTutorial
{
  public class App
  {
    [Ready]
    public static void Go()
    {
      var container = Document.GetElementById(&quot;main&quot;);
      container.ClassName = string.Join(
        &quot; &quot;,
        container.ClassName.Split().Where(c =&gt; c != &quot;loading&quot;)
      );
      React.Render(
        new AppContainer(new AppContainer.Props { MessageApi = new MessageApi() }),
        container
      );
    }
  }
}
</code></pre>
<p>With this final piece, we have the outline of a fully functioning application! Granted, its functionality is not particular magnificent, but it <em>has</em> illustrated some important principles. We've seen how a component hierarchy should have a top-level <em>stateful</em> component, with a component tree beneath it of state<em>less</em> components (note that there are no guidelines required regarding what to put into props and what to put into state when writing a stateless component because props is your only option - another reason why stateless components are so much simpler!). We've also seen how we can deal with dependency injection for these top level components, which are the only point at which more complicated logic appears such as &quot;a save request involves disabling the form, calling a method on the API, waiting for the result and then re-enabling the form&quot;. It's worth noting that in the next post, this logic will be moved out of the top-level component in a quest to make components as dumb as possible - but that's jumping ahead, and I want the format of these posts to be that we start simple and then get more complicated only as the benefits of doing so can be made clear.</p>
<p>At this point, however, we have something of a problem. If the &quot;Title&quot; and &quot;Content&quot; text inputs do not both have values, then an exception will be raised by the <strong>MessageApi</strong> when a save is attempted. To avoid this, we need some..</p>
<h3>Validation</h3>
<p>I mentioned in the &quot;React components&quot; section that there would be a <strong>ValidatedTextInput</strong>, but no code had been presented yet. So here we go, nothing in it should be particularly surprising -</p>
<pre><code>using System;
using Bridge.React;

namespace BridgeReactTutorial.Components
{
  public class ValidatedTextInput : StatelessComponent&lt;ValidatedTextInput.Props&gt;
  {
    public ValidatedTextInput(Props props) : base(props) { }

    public override ReactElement Render()
    {
      var className = props.ClassName;
      if (!string.IsNullOrWhiteSpace(props.ValidationMessage))
        className = (className + &quot; invalid&quot;).Trim();

      return DOM.Span(new Attributes { ClassName = className },
        new TextInput(new TextInput.Props
        {
          ClassName = props.ClassName,
          Disabled = props.Disabled,
          Content = props.Content,
          OnChange = props.OnChange
        }),
        string.IsNullOrWhiteSpace(props.ValidationMessage)
          ? null
          : DOM.Span(
            new Attributes { ClassName = &quot;validation-message&quot; },
            props.ValidationMessage
          )
      );
    }

    public class Props
    {
      public string ClassName;
      public bool Disabled;
      public string Content;
      public Action&lt;string&gt; OnChange;
      public string ValidationMessage;
    }
  }
}
</code></pre>
<p>This allows the <strong>MessageEditor</strong> to be changed to use these <strong>ValidatedTextInput</strong>s instead of regular <strong>TextInput</strong>s, setting the &quot;ValidationMessage&quot; values according to whether the &quot;Content&quot; string has a value -</p>
<pre><code>using System;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class MessageEditor : StatelessComponent&lt;MessageEditor.Props&gt;
  {
    public MessageEditor(Props props) : base(props) { }

    public override ReactElement Render()
    {
      var formIsInvalid =
        string.IsNullOrWhiteSpace(props.Title) ||
        string.IsNullOrWhiteSpace(props.Content);

      return DOM.FieldSet(new FieldSetAttributes { ClassName = props.ClassName },
        DOM.Legend(null, string.IsNullOrWhiteSpace(props.Title) ? &quot;Untitled&quot; : props.Title),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Title&quot;),
        new ValidatedTextInput(new ValidatedTextInput.Props
        {
          ClassName = &quot;title&quot;,
          Disabled = props.Disabled,
          Content = props.Title,
          OnChange = newTitle =&gt; props.OnChange(new MessageDetails
          {
            Title = newTitle,
            Content = props.Content
          }),
          ValidationMessage = string.IsNullOrWhiteSpace(props.Title)
            ? &quot;Must enter a title&quot;
            : null
        }),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Content&quot;),
        new ValidatedTextInput(new ValidatedTextInput.Props
        {
          ClassName = &quot;content&quot;,
          Disabled = props.Disabled,
          Content = props.Content,
          OnChange = newContent =&gt; props.OnChange(new MessageDetails
          {
            Title = props.Title,
            Content = newContent
          }),
          ValidationMessage = string.IsNullOrWhiteSpace(props.Content)
            ? &quot;Must enter message content&quot;
            : null
        }),
        DOM.Button(
          new ButtonAttributes
          {
            Disabled = props.Disabled || formIsInvalid,
            OnClick = e =&gt; props.OnSave()
          },
          &quot;Save&quot;
        )
      );
    }

    public class Props
    {
      public string ClassName;
      public string Title;
      public string Content;
      public Action&lt;MessageDetails&gt; OnChange;
      public Action OnSave;
      public bool Disabled;
    }
  }
}
</code></pre>
<p>Now, the &quot;Save&quot; button is disabled if the <strong>MessageEditor</strong> is disabled (according to its props flag) <em>or</em> if the form entry is invalid. Now, it's not possible for the user to attempt a save that we will know will fail!</p>
<p><em>(Moving validation logic out of the components is another thing that will come in the move towards dumb-as-possible components, but that's for part two).</em></p>
<p>To keep things looking pretty, adding the following to &quot;styles.css&quot; -</p>
<pre><code>fieldset.message span.title, fieldset.message span.content { position: relative; }
fieldset.message span.validation-message
{
  position: absolute;
  top: -6px;
  right: 2px;
  padding: 2px 4px;
  font-size: 70%;
  background: #FFF9D8;
  border: 1px solid #EFE9CB;
  border-radius: 2px;
  color: #A8A390;
}
fieldset.message button { margin-left: 8px; }
</code></pre>
<h3>Message History</h3>
<p>What's the point in saving messages if we can't read them back out again? To enable this, the <strong>IReadAndWriteMessages</strong> needs a &quot;GetMessages&quot; method to accompany &quot;SaveMessage&quot; -</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.API
{
  public interface IReadAndWriteMessages
  {
    Task SaveMessage(MessageDetails message);
    Task&lt;IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt;&gt; GetMessages();
  }
}
</code></pre>
<p>This needs implementing in <strong>MessageApi</strong> -</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Bridge.Html5;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.API
{
  public class MessageApi : IReadAndWriteMessages
  {
    private readonly List&lt;Tuple&lt;int, MessageDetails&gt;&gt; _messages;
    public MessageApi()
    {
      _messages = new List&lt;Tuple&lt;int, MessageDetails&gt;&gt;();
    }

    public Task SaveMessage(MessageDetails message)
    {
      if (message == null)
        throw new ArgumentNullException(&quot;message&quot;);
      if (string.IsNullOrWhiteSpace(message.Title))
        throw new ArgumentException(&quot;A title value must be provided&quot;);
      if (string.IsNullOrWhiteSpace(message.Content))
        throw new ArgumentException(&quot;A content value must be provided&quot;);

      var task = new Task&lt;object&gt;(null);
      Window.SetTimeout(
        () =&gt;
        {
          _messages.Add(Tuple.Create(_messages.Count, message));
          task.Complete();
        },
        1000 // Simulate a roundtrip to the server
      );
      return task;
    }

    public Task&lt;IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt;&gt; GetMessages()
    {
      // ToArray is used to return a clone of the message set - otherwise, the caller would
      // end up with a list that is updated when the internal reference within this class
      // is updated (which sounds convenient but it's not the behaviour that would be
      // exhibited if this was really persisting messages to a server somewhere)
      var task = new Task&lt;IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt;&gt;(null);
      Window.SetTimeout(
        () =&gt; task.Complete(_messages.ToArray()),
        1000 // Simulate a roundtrip to the server
      );
      return task;
    }
  }
}
</code></pre>
<p>Now, we'll need a way to render this information -</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class MessageHistory : StatelessComponent&lt;MessageHistory.Props&gt;
  {
    public MessageHistory(Props props) : base(props) { }

    public override ReactElement Render()
    {
      var className = props.ClassName;
      if (!props.Messages.Any())
        className = (className + &quot; zero-messages&quot;).Trim();

      // Any time a set of child components is dynamically-created (meaning that the
      // numbers of items may vary from one render to another), each must have a unique
      // &quot;Key&quot; property set (this may be a int or a string). Here, this is simple as
      // each message tuple is a unique id and the contents of that message (and the
      // unique id is ideal for use as a unique &quot;Key&quot; property).
      var messageElements = props.Messages
        .Select(idAndMessage =&gt; DOM.Div(new Attributes { Key = idAndMessage.Item1 },
          DOM.Span(new Attributes { ClassName = &quot;title&quot; }, idAndMessage.Item2.Title),
          DOM.Span(new Attributes { ClassName = &quot;content&quot; }, idAndMessage.Item2.Content)
        ));

      return DOM.FieldSet(new FieldSetAttributes { ClassName = className },
        DOM.Legend(null, &quot;Message History&quot;),
        DOM.Div(null, messageElements)
      );
    }

    public class Props
    {
      public string ClassName;
      public IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt; Messages;
    }
  }
}
</code></pre>
<p>This highlights an important React principle - where there are sets of dynamic child components, each must be provided a unique key. In the component above, we take &quot;props.Messages&quot; and map the data onto a set of Div elements. It's very possible that different messages will be rendered each time and so this is precisely what is meant by &quot;dynamic child components&quot;.</p>
<p>There are two reasons why it's important to provide unique keys - the first is performance; the task of React's Virtual DOM is to take the last component tree and the new component tree and work out what changed, so that the minimum changes may be applied to the browser DOM. In order to do this, it is very helpful for React to be able to track components as they move around within a dynamic set - it can allow it to reuse data internally instead of having to throw away representations of components and recreate them:</p>
<blockquote>
<p>When React reconciles the keyed children, it will ensure that any child with key will be reordered (instead of clobbered) or destroyed (instead of reused).</p>
</blockquote>
<p>The quote above is from <a href="https://facebook.github.io/react/docs/multiple-components.html#dynamic-children">Facebook's docs about Dynamic Children</a> - and so &quot;clobbered&quot; must be an official term!</p>
<p>The second reason why it's important is that component state can only be tracked with a component if the component itself can be tracked by React when dynamic elements move around. I'm not going to dwell too long on this because it's only applicable if you are relying on dynamic components having state, which you shouldn't be since only the top-level component should be stateful (and any component that may be created as a dynamic child component should be stateless).</p>
<p>For our purposes here, providing a unique key for each <strong>MessageHistory</strong> row is easy because the &quot;GetMessages&quot; method in the API returns a set of tuples, where each pair is a combination of id for the message and the message itself. This was easy to implement with the in-memory message store that we're using for this sample app, but it's also often easy when persisting by sending the data over the wire to a database somewhere; it's common for the database to generate unique ids for each record, and this would be returned in the data from &quot;GetMessages&quot;.</p>
<p>Now we have to return to the <strong>AppContainer</strong> to tie everything together; we need to add the message history data to the <strong>AppContainer</strong>'s state, we need to read the message history after we save and we need to render the message history -</p>
<pre><code>using System;
using System.Collections.Generic;
using Bridge.React;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class AppContainer : Component&lt;AppContainer.Props, AppContainer.State&gt;
  {
    public AppContainer(AppContainer.Props props) : base(props) { }

    protected override State GetInitialState()
    {
      return new State
      {
        Message = new MessageDetails { Title = &quot;&quot;, Content = &quot;&quot; },
        IsSaveInProgress = false,
        MessageHistory = new Tuple&lt;int, MessageDetails&gt;[0]
      };
    }

    public override ReactElement Render()
    {
      return DOM.Div(null,
        new MessageEditor(new MessageEditor.Props
        {
          ClassName = &quot;message&quot;,
          Title = state.Message.Title,
          Content = state.Message.Content,
          OnChange = newMessage =&gt; SetState(new State
          {
            Message = newMessage,
            IsSaveInProgress = state.IsSaveInProgress,
            MessageHistory = state.MessageHistory
          }),
          OnSave = async () =&gt;
          {
            // Set SaveInProgress to true while the save operation is requested
            SetState(new State {
              Message = state.Message,
              IsSaveInProgress = true,
              MessageHistory = state.MessageHistory
            });
            await props.MessageApi.SaveMessage(state.Message);

            // After the save has completed, clear the message entry form and reset
            // SaveInProgress to false
            SetState(new State {
              Message = new MessageDetails { Title = &quot;&quot;, Content = &quot;&quot; },
              IsSaveInProgress = false,
              MessageHistory = state.MessageHistory
            });

            // Then re-load the message history state and re-render when that data arrives
            var allMessages = await props.MessageApi.GetMessages();
            SetState(new State {
              Message = state.Message,
              IsSaveInProgress = state.IsSaveInProgress,
              MessageHistory = allMessages
            });
          },
          Disabled = state.IsSaveInProgress
        }),
        new MessageHistory(new MessageHistory.Props
        {
          ClassName = &quot;history&quot;,
          Messages = state.MessageHistory
        })
      );
    }

    public class Props
    {
      public IReadAndWriteMessages MessageApi;
    }

    public class State
    {
      public MessageDetails Message;
      public bool IsSaveInProgress;
      public IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt; MessageHistory;
    }
  }
}
</code></pre>
<p>The logic in this component is getting more complicated now, which is down to the event-handling; what needs to happen when this happens and then this happens and then this happens (eg. the user clicks save, we initiate a save request, the API completes the request, we update the UI to clear the form and then start loading the updated message history, then we update the UI with the new message content).</p>
<p>One of the goals going forward will be to separate out this logic, away from the React components. The reason that I've made a couple of mentions of moving towards &quot;dumb components&quot; is that it makes unit testing much easier - everything outside of the React components will be simple C# / JavaScript code, which is always easier to test than UI elements, even when the UI is created using the React library. Another benefit of separating application logic from the UI components is that it makes both sides easier to reason about - and this is another theme that I'll be re-visiting during this mini-series.</p>
<p>It's worth mentioning that, even though it's gotten more complicated, the <strong>AppContainer</strong> (the only stateful component in the application) still adheres to the stateful component guidelines:</p>
<ol>
<li>A stateful component's &quot;props&quot; data should <em>only</em> consist of references to external dependencies</li>
<li>A stateful component's &quot;state&quot; data should include <em>everything</em> required to render the component tree, though the props may be required to deal with child components' events</li>
</ol>
<p><em>All</em> of the data required to render the UI is present in the state. The props data is only required within &quot;Render&quot; in order to process some of the callbacks from the child components. Any changes that must then be reflected in the UI come through a call to SetState - at the point of the SetState-triggered re-render, all of the data required to generate the child components will, once again, be present entirely within the state data.</p>
<p>To keep things look nice, add the following to &quot;styles.css&quot; -</p>
<pre><code>fieldset.history
{
  opacity: 1;
  transition: opacity .5s ease-in-out;
}
fieldset.history.zero-messages { opacity: 0; }
fieldset.history span.title
{
  padding: 0 8px;
  font-weight: bold;
}
</code></pre>
<p>This will have the <strong>MessageHistory</strong> invisible to begin with, fading in when the first message is available to display.</p>
<h3>Coming in Part Two..</h3>
<p>I think this makes a good point at which to draw the first part of this series to a close. To be honest, we haven't got very close at all yet to the &quot;The Dan Way&quot; of writing React applications - so far, it's been fairly straight-forward and in-line with the basic React guidelines from Facebook.</p>
<p>Which isn't to save that we haven't covered a lot of good ground! This will serve as a good base from which we can improve things. But we haven't seen the &quot;Flux architecture&quot; at all yet, and have only hinted at why we would want it. I'm not happy with how many of the properties on the various props, state and other data types are presented - one of my pet peeves with APIs is not knowing what can and can't be null; on the <strong>TextInput</strong>'s <strong>Props</strong> class, the &quot;ClassName&quot; string <em>may</em> be null but the &quot;OnChange&quot; callback must not be. These facts are not clear from just looking at the class. Similarly, it would be nice to know whether or not there are any guarantees about the &quot;Title&quot; and &quot;Content&quot; strings on the <strong>MessageDetails</strong> class (is it ever really acceptable for them to be null?). Finally, the reading and writing of messages through the <strong>MessageApi</strong> implementation we have here works fine for one person doing all the writing, but how could we deal with it if the <strong>MessageApi</strong> simulated a server-based API that received new messages from <em>other</em> uses, either through some sort of polling or through a push mechanism? This is an important question for systems that have to support multiple users.</p>
<p>All of these questions will be answered in later posts, along with further advice to try to help you do what I think React does best - write code that is easier to reason about, and thus easier to read, maintain and extend.</p>
<p class="PostTime">Posted at 23:55</p><div class="PreviousAndNext"><div class="Previous"><h3>Last time:</h3><a class="Previous" href="/easy-purecomponent-react-performance-boosts-for-bridgenet">Easy &quot;PureComponent&quot; React performance boosts for Bridge.Net</a></div><div class="Next"><h3>Next:</h3><a class="Next" href="/writing-react-apps-using-bridgenet-the-dan-way-part-two">Writing React apps using Bridge.NET - The Dan Way (Part Two)</a></div></div><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/writing-react-apps-using-bridgenet-the-dan-way-part-three">Writing React apps using Bridge.NET - The Dan Way (Part Three)</a></li><li><a href="/writing-react-apps-using-bridgenet-the-dan-way-part-two">Writing React apps using Bridge.NET - The Dan Way (Part Two)</a></li><li><a href="/easy-purecomponent-react-performance-boosts-for-bridgenet">Easy &quot;PureComponent&quot; React performance boosts for Bridge.Net</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/React" title="11 Posts">React</a></li></ul></div>
                <div id="disqus_thread"></div>
                <script type="text/javascript">
					var disqus_identifier = "96";
					var disqus_title = "Writing React apps using Bridge.NET - The Dan Way (from first principles)";
					(function () {
						whenjQueryIsAvailable(
							function () {
								$(function () {
									loadCommentsIfHalfwayDownAndNotAlreadyLoaded();
									$(window).scroll(loadCommentsIfHalfwayDownAndNotAlreadyLoaded);
								});
							}
						);

						var bStartedLoadingComments = false;
						function loadCommentsIfHalfwayDownAndNotAlreadyLoaded() {
							if (bStartedLoadingComments) {
								return;
							}
							var $post = $("div.Content.SinglePost");
							var bottomOfPost = $post.position().top + $post.height();
							var $window = $(window);
							if (($window.scrollTop() + $window.height()) >= (bottomOfPost / 2)) {
								bStartedLoadingComments = true;
								loadComments();
							}
						}

						function loadComments() {
							var dsq = document.createElement("script");
							dsq.type = "text/javascript";
							dsq.async = true;
							dsq.src = "https://" + disqus_shortname + ".disqus.com/embed.js";
							(document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]).appendChild(dsq);
						}
					}());
                </script>
    </div>


				<div class="Footer">
					© Productive Rage 2011 - 2022
				</div>
			</div>

			<div class="SideBar">
				<div class="About">
					<h2>About</h2>
					<p>Dan is a big geek who likes making stuff with computers! He can be quite outspoken so clearly needs a blog :)</p>
					<p>In the last few minutes he seems to have taken to referring to himself in the third person. He's quite enjoying it.</p>
					<p><a href="mailto:dangger36@gmail.com" class="Email">dangger36@gmail.com</a></p>
				</div>
				<div class="Search">
<form action="/Search" autocomplete="off" class="Search" method="get">						<div>
							<label class="SearchField">
								<span class="text">Site Search</span>
								<input type="text" class="SiteSearch" name="term" value="" />
							</label>
							<input type="submit" class="SiteSearchSubmit" value="Search" />
						</div>
</form>				</div>
				<div class="Recent"><h2>Recent Posts</h2><ul><li><a href="/so-what-is-machine-learning-nocodeintro">So.. what is machine learning? (#NoCodeIntro)</a></li><li><a href="/parallelising-linq-work-in-c-sharp">Parallelising (LINQ) work in C#</a></li><li><a href="/automating-suggested-related-posts-links-for-my-blog-posts-part-2">Automating &quot;suggested / related posts&quot; links for my blog posts - Part 2</a></li><li><a href="/automating-suggested-related-posts-links-for-my-blog-posts">Automating &quot;suggested / related posts&quot; links for my blog posts</a></li><li><a href="/language-detection-and-wordsinsentence-classification-in-c-sharp">Language detection and words-in-sentence classification in C#</a></li></ul><div class="RSSFeedLink"><a href="https://www.productiverage.com/feed">RSS Feed</a></div></div>
				<div class="Featured"><h2>Highlights</h2><ul><li><a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face (finding faces in photos using C# and Accord.NET)</a></li><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/translating-vbscript-into-c-sharp">Translating VBScript into C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div>
				<div class="History"><h2>Archives</h2><ul><li><a href="/Archive/2/2022">February 2022 (1)</a></li><li><a href="/Archive/8/2021">August 2021 (1)</a></li><li><a href="/Archive/4/2021">April 2021 (2)</a></li><li><a href="/Archive/3/2021">March 2021 (1)</a></li><li><a href="/Archive/8/2020">August 2020 (3)</a></li><li><a href="/Archive/7/2019">July 2019 (2)</a></li><li><a href="/Archive/9/2018">September 2018 (1)</a></li><li><a href="/Archive/4/2018">April 2018 (1)</a></li><li><a href="/Archive/3/2018">March 2018 (1)</a></li><li><a href="/Archive/7/2017">July 2017 (1)</a></li><li><a href="/Archive/6/2017">June 2017 (1)</a></li><li><a href="/Archive/2/2017">February 2017 (1)</a></li><li><a href="/Archive/11/2016">November 2016 (1)</a></li><li><a href="/Archive/9/2016">September 2016 (2)</a></li><li><a href="/Archive/8/2016">August 2016 (1)</a></li><li><a href="/Archive/7/2016">July 2016 (1)</a></li><li><a href="/Archive/6/2016">June 2016 (1)</a></li><li><a href="/Archive/5/2016">May 2016 (3)</a></li><li><a href="/Archive/3/2016">March 2016 (3)</a></li><li><a href="/Archive/2/2016">February 2016 (2)</a></li><li><a href="/Archive/12/2015">December 2015 (1)</a></li><li><a href="/Archive/11/2015">November 2015 (2)</a></li><li><a href="/Archive/8/2015">August 2015 (3)</a></li><li><a href="/Archive/7/2015">July 2015 (1)</a></li><li><a href="/Archive/6/2015">June 2015 (1)</a></li><li><a href="/Archive/5/2015">May 2015 (2)</a></li><li><a href="/Archive/4/2015">April 2015 (1)</a></li><li><a href="/Archive/3/2015">March 2015 (1)</a></li><li><a href="/Archive/1/2015">January 2015 (2)</a></li><li><a href="/Archive/12/2014">December 2014 (1)</a></li><li><a href="/Archive/11/2014">November 2014 (1)</a></li><li><a href="/Archive/10/2014">October 2014 (2)</a></li><li><a href="/Archive/9/2014">September 2014 (2)</a></li><li><a href="/Archive/8/2014">August 2014 (1)</a></li><li><a href="/Archive/7/2014">July 2014 (1)</a></li><li><a href="/Archive/6/2014">June 2014 (1)</a></li><li><a href="/Archive/5/2014">May 2014 (2)</a></li><li><a href="/Archive/2/2014">February 2014 (1)</a></li><li><a href="/Archive/1/2014">January 2014 (1)</a></li><li><a href="/Archive/12/2013">December 2013 (1)</a></li><li><a href="/Archive/11/2013">November 2013 (1)</a></li><li><a href="/Archive/10/2013">October 2013 (1)</a></li><li><a href="/Archive/8/2013">August 2013 (3)</a></li><li><a href="/Archive/7/2013">July 2013 (3)</a></li><li><a href="/Archive/6/2013">June 2013 (1)</a></li><li><a href="/Archive/5/2013">May 2013 (2)</a></li><li><a href="/Archive/4/2013">April 2013 (1)</a></li><li><a href="/Archive/3/2013">March 2013 (8)</a></li><li><a href="/Archive/2/2013">February 2013 (2)</a></li><li><a href="/Archive/1/2013">January 2013 (2)</a></li><li><a href="/Archive/12/2012">December 2012 (3)</a></li><li><a href="/Archive/11/2012">November 2012 (4)</a></li><li><a href="/Archive/9/2012">September 2012 (1)</a></li><li><a href="/Archive/8/2012">August 2012 (1)</a></li><li><a href="/Archive/7/2012">July 2012 (3)</a></li><li><a href="/Archive/6/2012">June 2012 (3)</a></li><li><a href="/Archive/5/2012">May 2012 (2)</a></li><li><a href="/Archive/2/2012">February 2012 (3)</a></li><li><a href="/Archive/1/2012">January 2012 (4)</a></li><li><a href="/Archive/12/2011">December 2011 (7)</a></li><li><a href="/Archive/8/2011">August 2011 (2)</a></li><li><a href="/Archive/7/2011">July 2011 (1)</a></li><li><a href="/Archive/5/2011">May 2011 (1)</a></li><li><a href="/Archive/4/2011">April 2011 (2)</a></li><li><a href="/Archive/3/2011">March 2011 (3)</a></li></ul><div class="EveryTitle"><a href="/Archive/All">Every Post Title</a></div></div>
			</div>

		</div>
	</div>

	<script type="text/javascript" src="/Scripts/autocomplete.js"></script>
	<script type="text/javascript" src="/Scripts/prettify.js"></script>
	<script type="text/javascript" src="/Scripts/Site.js"></script>
	<script type="text/javascript" src="/Scripts/IndexSearchGenerator.js"></script>
	<script type="text/javascript" src="/Scripts/SearchTermHighlighter.js"></script>
	<script type="text/javascript" src="/Scripts/SearchPage.js"></script>
	<script type="text/javascript" src="/Scripts/LZString.js"></script>

</body>
</html>
