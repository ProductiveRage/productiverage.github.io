<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Productive Rage - September 2014</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta name="theme-color" content="#393939" />
	<link rel="stylesheet" type="text/css" media="all" href="/Content/Styles.css" />
	<!--[if lt IE 9]>
	<link rel="stylesheet" type="text/css" href="/Content/IEBefore9.css" />
	<![endif]-->
	<link rel="stylesheet" type="text/css" media="print" href="/Content/PrintOverrides.css" />
	<meta name="robots" content="noindex, follow" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.productiverage.com/feed" />
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', "UA-32312857-1"]);
		_gaq.push(['_setSiteSpeedSampleRate', 100]);
		_gaq.push(['_trackPageview']);
		(function () {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>

<body>

	<div class="Header">
		<div class="HeaderContent">
			<h1>
				<a href="/">Productive Rage</a>
			</h1>
			<span class="Tagline">Dan's techie ramblings</span>
		</div>
	</div>

	<div class="WrapperOuter">
		<div class="Wrapper">
			<div class="Main HasSideBar">
				

        <script type="text/javascript">
			var disqus_shortname = "productiverage";
			function executeWhen(fncAction, fncConditional, intDelayBetweenRetries) {
				if (fncConditional()) { fncAction(); return; }
				setTimeout(function () { executeWhen(fncAction, fncConditional, intDelayBetweenRetries); }, intDelayBetweenRetries);
			}
			function whenjQueryIsAvailable(fncAction) {
				executeWhen(
					fncAction,
					function () { return (typeof ($) !== "undefined") },
					10
				);
			}
			(function () {
				whenjQueryIsAvailable(
					function () { $("div.Content p.Comments").show(); }
				);
			}());
        </script>

    <div class="Content ArchiveByMonth">
        <h3 class="PostDate">24 September 2014</h3><h2><a id="writing-react-components-in-typescript" href="/writing-react-components-in-typescript">Writing React components in TypeScript</a></h2>
<p><strong>Whoops..</strong> <em>I started writing this post a while ago and have only just got round to finishing it off. Now I realise that it applies to React 0.10 but the code here doesn't work in the now-current 0.11. On top of this,</em> hopefully <em>this will become unnecessary when 0.12 is released. I talk about this in the last part of the post. But until 0.12 is out (and confirmed to address the problem), I'm going to stick to 0.10 and use the solution that I talk about here.</em></p>
<p><strong>Update (29th January 2015):</strong> React 0.13 beta has been released and none of this workaround is required any more - I've written about it here: <a href="/typescript-es6-classes-for-react-components-without-the-hacks">TypeScript / ES6 classes for React components - without the hacks!</a></p>
<p>I've been playing around with React recently, putting together some prototypes to try to identify any pitfalls in what I think is an excellent idea and framework, with a view to convincing everyone else at work that we should consider it for new products. I'm no JavaScript hater but I do strongly believe in strongly typed code being easier to maintain in the long run for projects of significant size. Let's not get into an argument about whether strong or &quot;weak&quot; typing is best - before we know it we could end up worrying about what <a href="http://ericlippert.com/2012/10/15/is-c-a-strongly-typed-or-a-weakly-typed-language">strongly typed even means</a>! If you don't agree with me then you probably don't see any merit to TypeScript and you probably already guessed that this post will not be of interest to you! :)</p>
<p>So I wanted to try bringing together the benefits of React with the benefits of TypeScript.. I'm clearly not the only one since there is already a type definition available in NuGet: <a href="https://www.nuget.org/packages/React.TypeScript.DefinitelyTyped">React.TypeScript.DefinitelyTyped</a>. This seems to be the recommended definition and appears to be in active development. I'd love it even more if there was an official definition from Facebook themselves (they have one for their <a href="https://github.com/facebook/immutable-js">immutable-js</a> library) but having one here is a great start. This allows us to call methods in the React library and know what types the arguments should be and what they will return (and the compiler will tell us if we break these contracts by passing the wrong types or trying to mistreat the return values).</p>
<p>However, there are a few problems. Allow me to venture briefly back to square one..</p>
<h3>Back to basics: A React component</h3>
<p>This is a very simple component in React -</p>
<pre><code>var MyButton = React.createClass({
  _clickHandler: function() {
    alert('Clicked MyButton with message &quot;' + this.props.message + '&quot;');
  },
  render: function() {
    return &lt;button onClick={this._clickHandler}&gt;{this.props.message}&lt;/button&gt;;
  }
});
</code></pre>
<p>It's pretty boring but it illustrates a few principles. Firstly, it's written in &quot;jsx&quot; - a format like JavaScript but that needs some processing to actually become JavaScript. The &lt;button&gt; declaration looks like html, for example, and needs altering to become real JavaScript. If we're going to write components in TypeScript then we can't use this format since Visual Studio doesn't understand it (granted I'm making a bit of a leap assuming that you're using Visual Studio for this - it's not necessary, but I suspect most people writing TypeScript <em>will</em> use it since the TypeScript support is so good).</p>
<p>The good news is that the translation from &quot;jsx&quot; to JavaScript is not a complex one*. It results in slightly longer code but it's still easily readable (and writable). So the above would be, written in native JavaScript -</p>
<pre><code>var MyButton = React.createClass({
  _clickHandler: function() {
    alert('Clicked MyButton with message &quot;' + this.props.message + '&quot;');
  },
  render: function() {
    return React.DOM.button({ onClick: this._clickHandler }, this.props.message);
  }
});
</code></pre>
<p>* <em>(It</em> can <em>do other clever stuff like translate &quot;fat arrow&quot; functions into JavaScript that is compatible with older browsers, but let's not get bogged down with that here - since I want to use TypeScript rather than jsx, it's not that relevant right now).</em></p>
<p>This simple example is illustrating something useful that can be taken for granted since React 0.4; <em>autobinding</em>. When &quot;_clickHandler&quot; is called, the &quot;this&quot; reference is bound to the component instance, so &quot;this.props.message&quot; is accessible. Before 0.4, you had to use the &quot;React.autoBind&quot; method - eg.</p>
<pre><code>var MyButton = React.createClass({
  _clickHandler: React.autoBind(function() {
    alert('Clicked MyButton with message &quot;' + this.props.message + '&quot;');
  }),
  render: function() {
    return React.DOM.button({ onClick: this._clickHandler }, this.props.message);
  }
});
</code></pre>
<p>but these days it just works as you would expect (or as you would hope, perhaps). This happened back in July 2013 - see <a href="http://facebook.github.io/react/blog/2013/07/02/react-v0-4-autobind-by-default.html">New in React v0.4: Autobind by Default</a>.</p>
<h3>A TypeScript React component: Take 1</h3>
<p>If we naively try to write TypeScript code that starts off with the JavaScript above then we find we have no intellisense. The editor has no idea about &quot;this.props&quot; - no idea that it is defined, certainly no idea that it has a property &quot;message&quot; that should be a string. This shouldn't really be a surprise since the &quot;this&quot; in this case is just an anonymous object that we're passing to &quot;React.createClass&quot;; no information about the type has been specified, so it is considered to be of type &quot;any&quot;.</p>
<img alt="TypeScript React Component 'this' issue" src="/Content/Images/Posts/TypeScriptComponentThisIsAny.png" class="AlwaysFullWidth" />
<p>If we continue like this then we're going to miss out on the prime driver for using TypeScript in the first place - we might as well just write the components in JavaScript or &quot;jsx&quot;! (In fairness, this is something that I considered.. with React, and particularly the recommended Flux architecture, the &quot;view components&quot; are a relatively thin layer over components that could easily be written in TypeScript and so benefit from being strongly typed.. the view components could remain &quot;more dynamic&quot; and be covered by the class of unit tests that are often used to cover cases that are impossible with the guarantees of strong typing).</p>
<p>The obvious thing to try was to have a TypeScript class along the lines of</p>
<pre><code>class MyButton {
  props: { message: string };
  private _clickHandler() {
    alert('Clicked MyButton with message &quot;' + this.props.message + '&quot;');
  }
  public render() {
    return React.DOM.button({ onClick: this._clickHandler }, this.props.message);
  }
}

var MyButtonReactComponent = React.createClass(new MyButton());
</code></pre>
<p>This would solve the internal type specification issue (where &quot;this&quot; is &quot;any&quot;). However, when the &quot;React.createClass&quot; function is called at runtime, an error is thrown..</p>
<blockquote>
<p>Error: Invariant Violation: createClass(...): Class specification must implement a <code>render</code> method.</p>
</blockquote>
<p>I'm not completely sure, but I suspect that the React framework code is expecting an object with a property that is a function named &quot;render&quot; while the class instance passed to it has a function &quot;render&quot; on its prototype rather than a property on the reference itself.</p>
<h3>Looking for help elsewhere</h3>
<p>When I got to this point, I figured that someone else must have had encountered the same problem - particularly since there exists this TypeScript definition for React in the first place! I came across a GitHub project <a href="https://github.com/fdecampredon/react-typescript">React TypeScript</a> which describes itself as a</p>
<blockquote>
<p>React wrapper to make it play nicely with typescript.</p>
</blockquote>
<p>An example in the README shows</p>
<pre><code>import React = require('react');
import ReactTypescript = require('react-typescript');

class HelloMessage extends ReactTypescript.ReactComponentBase&lt;{ name: string; }, {}&gt; {
  render() {
    return React.DOM.div(null, 'Hello ' + this.props.name);
  }
}

React.renderComponent(new HelloMessage({ name: 'Jhon' }), mountNode);
</code></pre>
<p>which looks like exactly what I want!</p>
<p>The problems are that it clearly states..</p>
<blockquote>
<p>warning: ReactTypescript can actually only be used with commonjs modules and browserify, if someone does want AMD I'll gladly accept any PR that would packages it for another format.</p>
</blockquote>
<p>.. and I'm very interesting in using AMD and require.js to load modules &quot;on demand&quot; (so that if I develop a large app then I have a way to prevent the &quot;megabyte-plus initial JavaScript download&quot;).</p>
<p>Also, I'm concerned that the maintained TypeScript definition that I referenced earlier claims to be</p>
<blockquote>
<p>Based on TodoMVC sample by @fdecampredon, improved by @wizzard0, MIT licensed.</p>
</blockquote>
<p>fdecampredon is the author of this &quot;React TypeScript&quot; repo.. which hasn't been updated in seven months. So I'm concerned that the definitions might not be getting updated here - there are already a lot of differences between the <a href="https://github.com/fdecampredon/react-typescript/blob/master/declarations/react.d.ts">react.d.ts</a> in this project and that in the maintained NuGet package's <a href="https://github.com/wizzard0/react-typescript-definitions/blob/master/react.d.ts">react.d.ts</a>.</p>
<p>In addition to this, the README states that</p>
<blockquote>
<p>In react, methods are automatically bound to a component, this is not the case when using ReactTypeScript, to activate this behavious you can use the autoBindMethods function of ReactTypeScript</p>
</blockquote>
<p>This refers to what I talked about earlier; the &quot;auto-binding&quot; convenience to make writing components more natural. There are two examples of ways around this. You can use the ReactTypeScript library's &quot;autoBindMethods&quot; function -</p>
<pre><code>class MyButton extends ReactTypeScript.ReactComponentBase&lt;{ message: string}, any&gt; {
  clickHandler(event: React.MouseEvent) {
    alert(this.props.message);
  }
  render() {
    return React.DOM.button({ onClick: this.clickHandler }, 'Click Me');
  }
}

// If this isn't called then &quot;this.props.message&quot; will error in clickHandler as &quot;this&quot; is not
// bound to the instance of the class
ReactTypeScript.autoBindMethods(MyButton);
</code></pre>
<p>or you can use the TypeScript &quot;fat arrow&quot; to bind the function to the &quot;this&quot; reference that you would expect:</p>
<pre><code>class MyButton extends  ReactTypeScript.ReactComponentBase&lt;{ message: string}, any&gt; {
  // If the fat arrow isn't used for the clickHandler definition then &quot;this.props.message&quot; will
  // error in clickHandler as &quot;this&quot; is not bound to the instance of the class
  clickHandler = (event: React.MouseEvent) =&gt; {
    alert(this.props.message);
  }
  render() {
    return React.DOM.button({ onClick: this.clickHandler }, 'Click Me');
  }
}
</code></pre>
<p>The first approach feels a bit clumsy, that you must always remember to call this method for all component classes. The second approach doesn't feel too bad, it's just a case of being vigilant and always using fat arrows - but if you forget, you won't find out until runtime. Considering that I want to use to TypeScript to catch more errors at compile time, this still doesn't feel ideal.</p>
<p>The final concern I have is that the library includes a large-ish <a href="https://github.com/fdecampredon/react-typescript/blob/master/third_party/react-internal.js">react-internal.js</a> file. What I'm going to suggest further down does unfortunately dip its toe into React's (undocumented) internals but I've tried to keep it to the bare minimum. This &quot;react-internal.js&quot; worries me as it might be relying on a range of implementation details, any of which (as far as I know) could potentially change and break my code.</p>
<p>In case I'm sounding down on this library, I don't mean to be - I've tried it out and it does actually work, and there are not a lot of successful alternatives out there. So I've got plenty of respect for this guy, getting his hands dirty and inspiring me to follow in his footsteps!</p>
<h3><s>Stealing</s> Taking inspiration - A TypeScript React component: Take 2</h3>
<p>So I want a way to</p>
<ol>
<li>Write a TypeScript class that can be used as a React component</li>
<li>Use the seemingly-maintained <a href="https://www.nuget.org/packages/React.TypeScript.DefinitelyTyped">NuGet-delivered type definition</a> and limit access to the &quot;internals&quot; as much as possible</li>
<li>Have the component's methods always be auto-bound</li>
</ol>
<p>I'd better say this up-front, though: I'm willing to sacrifice the support for mixins here.</p>
<p>fdecampredon's &quot;React TypeScript&quot; library <em>does</em> support mixins so it's technically possible but I'm not convinced at this time that they're worth the complexity required by the implementation since I don't think they fit well with the model of a TypeScript component.</p>
<p>The basic premise is that you can name mixin objects which are &quot;merged into&quot; the component code, adding properties such as functions that may be called by the component's code. Since TypeScript wouldn't be aware of the properties added by mixins, it would think that there were missing methods / properties and flag them as errors if they were used within the component.</p>
<p>On top of this, I've not been convinced by the use cases for mixins that I've seen so far. In the official <a href="http://facebook.github.io/react/docs/reusable-components.html#mixins">React docs section about mixins</a>, it uses the example of a timer that is automatically cleared when the component is unmounted. There's a question on Stack Overflow &quot;<a href="http://stackoverflow.com/questions/21854938">Using mixins vs components for code reuse in Facebook React</a>&quot; where the <a href="http://stackoverflow.com/a/21857309">top answer</a> talks about using mixins to perform common form validation work to display errors or enable or disable inputs by directly altering internal state on the component. As I understand the Flux architecture, the one-way message passing should result in validation being done in the store rather than the view / component. This allows the validation to exist in a central (and easily-testable) location and to <em>not</em> exist in the components. This also goes for the timer example, the logic-handling around whatever events are being raised on a timer should not exist within the components.</p>
<p>What I have ended up with is this:</p>
<pre><code>import React = require('react');

// The props and state references may be passed in through the constructor
export class ReactComponentBase&lt;P, S&gt; {
  constructor(props?: P, state?: S) {

    // Auto-bind methods on the derived type so that the &quot;this&quot; reference is as expected
    // - Only do this the first time an instance of the derived class is created
    var autoBoundTypeScriptMethodsFlagName = '__autoBoundTypeScriptMethods';
    var autoBindMapPropertyName = '__reactAutoBindMap'; // This is an internal React value
    var cp = this['constructor'].prototype;
    var alreadyBoundTypeScriptMethods = (cp[autoBoundTypeScriptMethodsFlagName] === true)
      &amp;&amp; cp.hasOwnProperty(autoBoundTypeScriptMethodsFlagName);
    if (!alreadyBoundTypeScriptMethods) {
      var autoBindMap = {};
      var parentAutoBindMap = cp[autoBindMapPropertyName];
      var functionName;
      if (parentAutoBindMap) {
        // Maintain any binding from an inherited class (if the current class being dealt
        // with doesn't directly inherit from ReactComponentBase)
        for (functionName in parentAutoBindMap) {
          autoBindMap[functionName] = parentAutoBindMap[functionName];
        }
      }
      for (functionName in cp) {
        if (!cp.hasOwnProperty(functionName) || (functionName === &quot;constructor&quot;)) {
          continue;
        }
        var fnc = cp[functionName];
        if (typeof (fnc) !== 'function') {
          continue;
        }
        autoBindMap[functionName] = fnc;
      }
      cp[autoBindMapPropertyName] = autoBindMap;
      cp[autoBoundTypeScriptMethodsFlagName] = true;
    }

    this['construct'].apply(this, arguments); // This is an internal React method
  }

  props: P;
  state: S;
}
ReactComponentBase.prototype = React.createClass({
  // The component must share the &quot;componentConstructor&quot; that is present on the prototype of
  // the return values from React.createClass
  render: function () {
    return null;
  }
})['componentConstructor'].prototype; // Also an internal React method

// This must be used to mount component instances to avoid errors due to the type definition
// expecting a React.ReactComponent rather than a ReactComponentBase (though the latter is
// able to masquerade as the former and when the TypeScript compiles down to JavaScript,
// no-one will be any the wiser)
export function renderComponent&lt;P, S&gt;(
    component: ReactComponentBase&lt;P, S&gt;,
    container: Element,
    callback?: () =&gt; void) {
  var mountableComponent = &lt;React.ReactComponent&lt;any, any&gt;&gt;&lt;any&gt;component;
  React.renderComponent(
    mountableComponent,
    container,
    callback
    );
}
</code></pre>
<p>This allows the following component to be written:</p>
<pre><code>import React = require('react');
import ReactComponentBridge = require('components/ReactComponentBridge');

class MyButton extends ReactComponentBridge.ReactComponentBase&lt;{ message: string }, any&gt; {
  myButtonClickHandler(event: React.MouseEvent) {
    alert('Clicked MyButton with message &quot;' + this.props.message + '&quot;');
  }
  render() {
    return React.DOM.button({ onClick: this.myButtonClickHandler }, 'Click Me');
  }
}

export = MyButton;
</code></pre>
<p>which may be rendered with:</p>
<pre><code>import ReactComponentBridge = require('components/ReactComponentBridge');
import MyButton = require('components/MyButton');

ReactComponentBridge.renderComponent(
  new MyButton({ message: 'Click Me' }),
  document.getElementById('container')
);
</code></pre>
<p>Hurrah! Success! All is well with the world! I've got the benefits of TypeScript <em>and</em> the benefits of React and the Flux architecture (ok, the last one doesn't need any of this or even require React - it could really be used with whatever framework you chose). There's just one thing..</p>
<h3>I'm out of date</h3>
<p>Like I said at the start of this post, as I got to rounding it out to publish, I realised that I wasn't on the latest version of React (current 0.11.2, while I was still using 0.10) and that this code didn't actually work on that version. Sigh.</p>
<p>However, the good news is that it sounds like 0.12 (still in alpha at the moment) is going to make things a lot easier. The changes in 0.11 appear to be paving the way for 0.12 to shakes things up a bit. Changes are documented at <a href="https://gist.github.com/sebmarkbage/d7bce729f38730399d28">New React Descriptor Factories and JSX</a> which talks about how the problem they're trying to solve with the new code is a</p>
<blockquote>
<p>Simpler API for ES6 classes</p>
</blockquote>
<p>.. and there is a note in the <a href="https://github.com/reactjs/react-future/blob/master/01%20-%20Core/05%20-%20Elements.js">react-future</a> GitHub repo (&quot;Specs &amp; docs for potential future and experimental React APIs and JavaScript syntax&quot;) that</p>
<blockquote>
<p>A React component module will no longer export a helper function to create virtual elements. Instead it's the responsibility of the consumer to efficiently create the virtual element.</p>
<p>Languages that compile to JS can choose to implement the element signature in whatever way is idiomatic for that language:</p>
</blockquote>
<p>TypeScript implements some ES6 features (such as classes, which are how I want to represent React components) so (hopefully) this means that soon-to-hit versions of React are going to make ES6-classes-for-components much easier (and negate the need for a workaround such as is documented here).</p>
<p>The articles that I've linked to (I'm not quite sure how official that all is, btw!) <em>are</em> talking about a future version since they refer to the method &quot;React.createFactory&quot;, which isn't available in 0.11.2. I have cloned the in-progress master repo from <a href="https://github.com/facebook/react">github.com/facebook/react</a> and built the 0.12-alpha code* and that <em>does</em> have that method. However, I haven't yet managed to get it working as I was hoping. I only built it a couple of hours ago, though, and I want to get this post rounded out rather than let it drag on any longer! And, I'm sure, when this mechanism for creating React components is made available, I'm sure a lot of information will be released about it!</p>
<p>* <em>(npm</em> is <em>a great tool but it still can't make</em> everything <em>easy.. first I didn't realise that the version of node.js I was using was out of date and it prevented some dependencies from being installed. Then I had to install Python - but 2.7 was required, I found out, after I'd installed 3.4.</em> Then <em>I didn't have Git installed on the computer I was trying to build React from. Then I had to mess about with setting environment variables for the Python and Git locations. But it</em> did <em>work, and when I think about how difficult it would have been without a decent package manager I stop feeling the need to complain about it too much :)</em></p>
<p class="PostTime">Posted at 23:12</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/writing-a-brackets-extension-in-typescript-in-brackets">Writing a Brackets extension in TypeScript, in Brackets</a></li><li><a href="/typescript-es6-classes-for-react-components-without-the-hacks">TypeScript / ES6 classes for React components - without the hacks!</a></li><li><a href="/typescript-classes-for-react-flux-actions">TypeScript classes for (React) Flux actions</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/JavaScript" title="6 Posts">JavaScript</a></li><li><a href="/Archive/Tag/React" title="11 Posts">React</a></li><li><a href="/Archive/Tag/TypeScript" title="6 Posts">TypeScript</a></li></ul></div>
            <p class="Comments">
                <a href="/writing-react-components-in-typescript#disqus_thread" data-disqus-identifier="75">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByMonth">
        <h3 class="PostDate">17 September 2014</h3><h2><a id="implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp" href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired &quot;with&quot; updates for immutable classes in C#</a></h2>
<p>I've been prototyping a data service for a product at work that communicates with immutable types and one of the feedback comments was a question as to whether the classes supported a flexible F#-esque &quot;with&quot; method that would allow multiple properties to be changed without the garbage collection churn of creating intermediate references for each individual property (since, of course, the property values aren't actually changed on an instance, a <em>new</em> instance is generated that reflects the requested changes).</p>
<p>To pull an example straight from the excellent <a href="http://fsharpforfunandprofit.com/posts/records/">F# for fun and profit</a> site:</p>
<pre><code>let p1 = {first=&quot;Alice&quot;; last=&quot;Jones&quot;}
let p2 = {p1 with last=&quot;Smith&quot;}
</code></pre>
<p>This creates a new record p2 that takes p1 and changes one of the fields. Multiple fields may be altered in one use &quot;with&quot; statement</p>
<pre><code>let p2 = {p1 with first=&quot;John&quot;;last=&quot;Smith&quot;}
</code></pre>
<p>To start with a very simple example in C#, take the following class:</p>
<pre><code>public class RoleDetails
{
  public RoleDetails(string title, DateTime startDate, DateTime? endDateIfAny)
  {
    Title = title;
    StartDate = startDate;
    EndDateIfAny = endDateIfAny;
  }

  public string Title { get; private set; }
  public DateTime StartDate { get; private set; }
  public DateTime? EndDateIfAny { get; private set; }
}
</code></pre>
<p>This is a very close parallel to the F# record type since it just assigns read-only properties (they're not strictly read-only since they don't use the &quot;readonly&quot; keyword but they're not externally alterable and are only set once within the class so it's close enough).</p>
<p>If I was writing something like this for real use, I would probably try to make more guarantees.. or at least, document behaviour. Something like:</p>
<pre><code>public class RoleDetails
{
  public RoleDetails(string title, DateTime startDate, DateTime? endDateIfAny)
  {
    if (string.IsNullOrWhiteSpace(title))
      throw new ArgumentException(&quot;title&quot;);
    if ((endDateIfAny != null) &amp;&amp; (endDateIfAny &lt;= startDate))
      throw new ArgumentException(&quot;title&quot;);

    Title = title.Trim();
    StartDate = startDate;
    EndDateIfAny = endDateIfAny;
  }

  /// &lt;summary&gt;
  /// This will never be null or blank, it will not have any leading or trailing whitespace
  /// &lt;/summary&gt;
  public string Title { get; private set; }

  public DateTime StartDate { get; private set; }

  /// &lt;summary&gt;
  /// If non-null, this will greater than the StartDate
  /// &lt;/summary&gt;
  public DateTime? EndDateIfAny { get; private set; }
}
</code></pre>
<p>As I've said before, this validation and commenting is really a poor substitute for code contracts which would allow for compile time detection of invalid data rather than relying on runtime exceptions (speaking of which, I need to give the .net code contracts solution another go - last time I got stuck in I hit some problems which hopefully they've ironed out by now).</p>
<p>Another variation on the &quot;aggressive validation&quot; illustrated above would be a type that represents a non-blank string to prevent duplicating calls to <em>IsNullOrWhiteSpace</em> and <em>trim</em>. This concept could be taken even further to &quot;strongly type&quot; string values so that a &quot;Title&quot; can not be passed into a function that expects a &quot;Notes&quot; string value, for example. This is far from an original idea but it was something I was experimenting again with recently.</p>
<p>Incidentally, there is talk of a future version of C# getting a record type which would reduce boilerplate code when defining simple immutable types. For example (from the InfoQ article <a href="http://www.infoq.com/news/2014/08/Record-Class">Easier Immutable Objects in C# 6 and VB 12</a>) -</p>
<pre><code>public record class Cartesian(double x: X, double y: Y);
</code></pre>
<p>This will define an immutable class with two read-only properties that are set through a constructor call. This future C# specification is also apparently going to allow read-only auto properties - so in my RoleDetails class above instead of &quot;get; private set;&quot; properties, which are externally unalterable but could actually be changed within the instance, the properties could be truly readonly. This <em>is</em> possible currently but it requires a private readonly field and a property with a getter that returns that field's value, which is even <em>more</em> boring boilerplate.</p>
<h3>The obvious, verbose and potentially more GC-churny way</h3>
<p>To prevent callers from having to call the constructor every time a property needs to be altered, update methods for each &quot;mutable&quot; property may be added (they don't really mutate the values since a new instance is returned rather than the value changed on the current instance). This prevents the caller from having to repeat all of the constructor arguments that are <em>not</em> to be changed whenever one property needs altering. Forcing callers to call constructors in this way is particularly annoying if a constructor argument is added, removed or re-ordered at a later date; this can result in a lot of calling code that needs correcting.</p>
<pre><code>public class RoleDetails
{
  public RoleDetails(string title, DateTime startDate, DateTime? endDateIfAny)
  {
    Title = title;
    StartDate = startDate;
    EndDateIfAny = endDateIfAny;
  }

  public string Title { get; private set; }
  public DateTime StartDate { get; private set; }
  public DateTime? EndDateIfAny { get; private set; }

  public RoleDetails Update(string title)
  {
    return (title == Title)
      ? this
      : new RoleDetails(title, StartDate, EndDateIfAny);
  }
  public RoleDetails UpdateStartDate(DateTime startDate)
  {
    return (startDate == StartDate)
      ? this
      : new RoleDetails(Title, startDate, EndDateIfAny);
  }
  public RoleDetails UpdateEndDateIfAny(DateTime? endDateIfAny)
  {
    return (endDateIfAny == EndDateIfAny)
      ? this
      : new RoleDetails(Title, StartDate, endDateIfAny);
  }
}
</code></pre>
<p>To update two properties on a given instance, you would need to call</p>
<pre><code>var updatedRoleDetails = existingRoleDetails
  .UpdateStartDate(new DateTime(2014, 9, 21))
  .UpdateEndDateIfAny(new DateTime(2014, 11, 21));
</code></pre>
<p>If either of the new values is the same as the property value that it should be replacing, then no new instance is required for that property update - since the Update*{Whatever}* method will return back the same instance. But if both properties are changed then <em>two</em> new instances are required even though the first, intermediate value is immediately discarded and so is &quot;wasted&quot;.</p>
<p>There could be an Update method that takes multiple parameters for the different properties but then you're basically just mirroing the constructor. Or there could be various Update methods that took combinations of properties to try to cover either the most common cases or <em>all</em> combinations of cases, but neither of these are particularly elegant and they would all result in quite a lot of code duplication.</p>
<h3>A better way</h3>
<p>It struck me that it should be possible to do something with named and optional method arguments (support for which was added to C# when .net 4 came out, if I remember correctly). Something like</p>
<pre><code>public RoleDetails UpdateWith(
  string title = Title,
  DateTime startDate = StartDate,
  DateTime? endDateIfAny = EndDateIfAny)
{
  if ((title == Title) &amp;&amp; (startDate == StartDate) &amp;&amp; (endDateIfAny == EndDateIfAny))
    return this;
  return new RoleDetails(title, startDate, endDateIfAny);
}
</code></pre>
<p>would allow for only a subset of the arguments to be specified and for those that are left unspecified to default to the current property value of the instance. So the earlier update code becomes</p>
<pre><code>var updatedRoleDetails = existingRoleDetails
  .UpdateWith(startDate: new DateTime(2014, 9, 21), endDateIfAny: new DateTime(2014, 11, 21));
</code></pre>
<p>However, this won't fly. The compiler gives the errors</p>
<blockquote>
<p>Default parameter value for 'title' must be a compile-time constant</p>
</blockquote>
<blockquote>
<p>Default parameter value for 'startDate' must be a compile-time constant</p>
</blockquote>
<blockquote>
<p>Default parameter value for 'endDateIfAny' must be a compile-time constant</p>
</blockquote>
<p>That's a bummer.</p>
<p>Another thought that briefly crossed my mind was for the default argument values to all be null. This would work if the arguments were all reference types and would result in the method body looking something like</p>
<pre><code>if ((title == null) &amp;&amp; (startDate == null) &amp;&amp; (endDateIfAny == null))
  return this;
return new RoleDetails(title ?? Title, startDate ?? StartDate, endDateIfAny ?? EndDateIfAny);
</code></pre>
<p>But that is too restrictive a constraint since in this case we have a non-reference type argument (startDate) and we also have a reference type for which null is a valid value (endDateIfAny).</p>
<p>So what we really need is a wrapper type around the arguments that indicates when no value has been specified. Since we're being conscious of avoiding GC churn, this should be a struct since structs essentially avoid adding GC pressure since they are always copied when passed around - this means that no struct is referenced by multiple scopes and so they don't have to be traced in the same way as reference types; when the scope that has access to the struct is terminated, the struct can safely be forgotten as well. This is not a particularly precise description of what happens and more details can be found in the MSDN article <a href="http://msdn.microsoft.com/en-us/library/ms229017(v=vs.110).aspx">Choosing Between Class and Struct</a>. Particularly see the paragraph</p>
<blockquote>
<p>The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated. Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</p>
</blockquote>
<p>The other guidelines in that article around cases where structs may be appropriate (if the type &quot;logically represents a single value&quot;, &quot;has an instance size under 16 bytes&quot;, &quot;is immutable&quot; and &quot;will not have to be boxed frequently&quot;) are followed by this type:</p>
<pre><code>public struct Optional&lt;T&gt;
{
  private T _valueIfSet;
  private bool _valueHasBeenSet;

  public T GetValue(T valueIfNoneSet)
  {
    return _valueHasBeenSet ? _valueIfSet : valueIfNoneSet;
  }

  public bool IndicatesChangeFromValue(T value)
  {
    if (!_valueHasBeenSet)
      return false;

    if ((value == null) &amp;&amp; (_valueIfSet == null))
      return false;
    else if ((value == null) || (_valueIfSet == null))
      return true;

    return !value.Equals(_valueIfSet);
  }

  public static implicit operator Optional&lt;T&gt;(T value)
  {
    return new Optional&lt;T&gt;
    {
      _valueIfSet = value,
      _valueHasBeenSet = true
    };
  }
}
</code></pre>
<p>This type allows us to write an UpdateWith method</p>
<pre><code>public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  if (!title.IndicatesChangeFromValue(Title)
  &amp;&amp; !startDate.IndicatesChangeFromValue(StartDate)
  &amp;&amp; !endDateIfAny.IndicatesChangeFromValue(EndDateIfAny))
    return this;

  return new RoleDetails(
    title.GetValue(Title),
    startDate.GetValue(StartDate),
    endDateIfAny.GetValue(EndDateIfAny)
  );
}
</code></pre>
<p>The <strong>Optional</strong> type <em>could</em> have exposed properties for has-a-value-been-set and get-value-if-any but since each property comparison (to detemine whether a new instance is actually required) would have to follow the pattern if-value-has-been-set-and-if-value-that-has-been-set-does-not-equal-current-value, it made sense to me to hide the properties and to instead expose only the access methods &quot;IndicatesChangeFromValue&quot; and &quot;GetValue&quot;. The &quot;IndicatesChangeFromValue&quot; method returns true if the <strong>Optional</strong> describes a value that is different to that passed in and &quot;GetValue&quot; returns the wrapped value if there is one, and returns the input argument if not. This enables the relatively succinct &quot;UpdateWith&quot; method format shown above.</p>
<p>The other method on the struct is an implicit operator for the wrapped type which makes the &quot;UpdateWith&quot; calling code simpler. Instead of having to do something like</p>
<pre><code>var updatedRoleDetails = existingRoleDetails
  .UpdateWith(startDate = Optional&lt;DateTime&gt;(new DateTime(2014, 9, 21)));
</code></pre>
<p>the implicit conversion allows you to write</p>
<pre><code>var updatedRoleDetails = existingRoleDetails
  .UpdateWith(startDate = new DateTime(2014, 9, 21));
</code></pre>
<p>because the <strong>DateTime</strong> will be implicitly converted into an <strong>Optional&lt;DateTime&gt;</strong>. In fact, I went one step further and made it such that this is the <em>only</em> way to create an <strong>Optional</strong> that wraps a value. There is no constructor that may be used to initialise an <strong>Optional</strong> <em>with</em> a value, you <em>must</em> rely upon the implicit conversion. This means that it's very clear that there's only one way to use this type. It also happens to be very similar to the most common way that the <strong>Nullable</strong> type is used in C# - although that does have a public constructor that accepts the value to wrap, in practice I've only ever seen values cast to <strong>Nullable</strong> (as opposed to the <strong>Nullable</strong> constructor being passed the value).</p>
<h3>Turning it up to eleven</h3>
<p>Now this is all well and good and I think it would be a solid leap forward simply to leave things as they are shown above. Unnecessary GC pressue is avoided since there are no &quot;intermediary&quot; instances when changing properties, while the use of structs means that we're not generating a load of property-update-value references that need to be collected either.</p>
<p>But I just couldn't resist trying to push it a bit further since there's <em>still</em> quite a lot of boring code that needs to be written for every immutable type - the UpdateWith method needs to check all of the properties to ensure that they haven't changed and then it needs to pass values into a constructor. If a class has quite a lot of properties (which is not especially unusual if the types are representing complex data) then this UpdateWith method could grow quite large. Wouldn't it be nice if we could just write something like:</p>
<pre><code>public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return magicUpdater(title, startDate, endDateIfAny);
}
</code></pre>
<p>Wouldn't it?? Yes it would.</p>
<p>And we can.. if we dip into some of the .net framework's crazier parts - reflection and stack tracing. With some LINQ expressions thrown in to make it work efficiently when called more than once or twice.</p>
<p>What this &quot;magicUpdater&quot; needs to do is take the names and values of the arguments passed to it and then analyse the target type (<strong>RoleDetails</strong> in this example) to find the constructor to call that will allow all of these named values to be passed into a new instance, using existing property values on the source instance for any constructor arguments that are not provided by the update arguments. It also needs to do the same work to determine whether the update arguments actually require a new instance to be generated - if only the StartDate is being provided to change but the new value is the same as the current value then no new instance is required, the source instance can be returned directly by the &quot;magicUpdater&quot;.</p>
<p>This is handled by two steps. The first based around this line:</p>
<pre><code>var callingMethod = new StackFrame(1).GetMethod();
</code></pre>
<p>It returns a <strong>MethodBase</strong> with metadata about the method that called the &quot;magicUpdater&quot; (the &quot;1&quot; in the call above is how many steps back to go in the call stack). From this the names of the arguments can be extracted and a delegate returned which will take the argument values themselves. So the call would actually look more like (if this &quot;magicUpdater&quot; method return a delegate which then must itself be called):</p>
<pre><code>return magicUpdater()(title, startDate, endDateIfAny);
</code></pre>
<p>Before we move on to the second step, there are some important considerations in relation to the use of <strong>StackFrame</strong>. Firstly, there <em>is</em> some expense to performing analysis like this, as with using reflection - but we'll not worry about that here, some optimisations will be covered later which hopefully mean we can ignore it. What's more important is that analysing the call stack can seem somewhat.. unreliable, in a sense. In the real world, the code that gets executed is not always the code as it appears in the C# source. A release build will apply optimisations that won't be applied to debug builds <em>and</em> when code is manipulated by the JIT compiler more optimisations again may occur - one of the more well-known of which is &quot;method inlining&quot;. Method inlining is when the compiler sees a chain of Method1 -&gt; Method2 -&gt; Method3 -&gt; Method4 and observes that Method2 is so small that instead of being a distinct method call (which has a cost, as every method call does - the arguments have to be passed into a new scope and this must be considered by the garbage collector; as a very basic example of one of these costs) the code inside Method2 can be copied inside Method1. This would mean that if Method3 tried to access Method2's metadata through the <strong>StackFrame</strong> class, it would be unable to - it would be told it was called by Method1!</p>
<p>There's a short but informative article about this by Eric Gunnerson: <a href="http://blogs.msdn.com/b/ericgu/archive/2004/01/29/64717.aspx">More on inlining</a>. In a nutshell it says that -</p>
<ul>
<li>Methods that are greater than 32 bytes of IL will not be inlined.</li>
<li>Virtual functions are not inlined.</li>
<li>Methods that have complex flow control will not be in-lined. Complex flow control is any flow control other than if/then/else; in this case, switch or while.</li>
<li>Methods that contain exception-handling blocks are not inlined, though methods that throw exceptions are still candidates for inlining.</li>
<li>If any of the method's formal arguments are structs, the method will not be inlined.</li>
</ul>
<p>This means that we shouldn't have to worry about the UpdateWith method being inlined (since its arguments are all <strong>Optional</strong> which are structs), but the &quot;magicUpdater&quot; method <em>may</em> be a concern. The way that my library gets around that is that the method &quot;GetGenerator&quot; on the <strong>UpdateWithHelper</strong> class (it's not <em>really</em> called &quot;magicUpdater&quot; :) has the attribute</p>
<pre><code>[MethodImpl(MethodImplOptions.NoInlining)]
public UpdateWithSignature&lt;T&gt; GetGenerator&lt;T&gt;(int numberOfFramesFromCallSite = 1)
</code></pre>
<p>which tells the JIT compiler not to inline it and so, since the caller isn't inlined (because of the structs), we don't have to worry about stack &quot;compressing&quot;.</p>
<p>This &quot;GetGenerator&quot; method, then, has access to the argument names and argument types of the method that called it. The generic type param T is the immutable type that is being targeted by the &quot;UpdateWith&quot; method. <strong>UpdateWithSignature&lt;T&gt;</strong> is a delegate with the signature</p>
<pre><code>public delegate T UpdateWithSignature&lt;T&gt;(T source, params object[] updateValues);
</code></pre>
<p>This delegate is what takes the property update values and creates a new instance (or returns the source instance if no changes are required). It does this by considering every public constructor that T has and determining what constructor arguments it can satisfy with update arguments. It does this by matching the update argument names to the constructor argument names and ensuring that the types are compatible. If a constructor is encountered with arguments that don't match any update arguments but T has a property whose name and type matches the constructor argument, then <em>that</em> will be used. If a constructor argument is encountered that can't be matched to an update argument <em>or</em> a property on T but the constructor argument has a default value, then the default value may be used if the constructor.</p>
<p>If a constructor does not have at least one argument that can be matched to each update argument name, then that constructor is ignored (otherwise an update argument would be ignored, which would make the UpdateWith somewhat impotent!). If there are multiple constructors that meet all of these conditions, they are sorted by the number of arguments they have that are fulfilled by update arguments and then sorted by the number of arguments that are satisfed by other properties on T - the best match from this sorted set it used.</p>
<p>The return <strong>UpdateWithSignature&lt;T&gt;</strong> delegate itself is a compiled LINQ expression so, once the cost of generating it has been paid the first time that it's required, the calls to this delegate are very fast. The &quot;GetGenerator&quot; method caches these compiled expressions, so the method</p>
<pre><code>public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return DefaultUpdateWithHelper.GetGenerator&lt;RoleDetails&gt;()(this, title, startDate);
}
</code></pre>
<p>can be called repeatedly and cheaply.</p>
<p>Note that in the above example, the <strong>DefaultUpdateWithHelper</strong> is used. This is a static wrapper around the <strong>UpdateWithHelper</strong> which specifies a default configuration. The <strong>UpdateWithHelper</strong> takes arguments that describe how to match update argument names to constructor argument names, for example (amongst other configuration options). The implementation in the <strong>DefaultUpdateWithHelper</strong> matches by name in a case-insensitive manner, which should cover the most common cases. But the relevant <strong>UpdateWithHelper</strong> constructor argument is of type</p>
<pre><code>public delegate bool UpdateArgumentToConstructorArgumentComparison(
  ParameterInfo updateArgument,
  ConstructorInfo constructor,
  ParameterInfo constructorArgument);
</code></pre>
<p>so a custom implementation could implement any complex scheme based upon target type or constructor or update argument type.</p>
<p>The <strong>UpdateWithHelper</strong> also requires a cache implementation for maintaining the compiled expressions, as well as matchers for other comparisons (such as property name to constructor argument name, for constructor arguments that can't be matched by an update argument). If a custom <strong>UpdateWithHelper</strong> is desired that only needs to override <em>some</em> behaviour, the <strong>DefaultUpdateWithHelper</strong> class has a static nested class <strong>DefaultValues</strong> with properties that are the references that it uses for the <strong>UpdateWithHelper</strong> constructor arguments - some of these may be reused by the custom configuration, if appropriate.</p>
<p>I considered going into some detail about how the LINQ expressions are generated since I think it's hard to find a good &quot;how-to&quot; walkthrough on these. It's either information that seems too simple or fine-grained that it's hard to put it together into something useful or it's the other extreme; dense code that's hard to get to grips with if you don't know much about them. But I feel that it would balloon this post too much - so maybe another day!</p>
<p>Incidentally, the <strong>DefaultUpdateWithHelper</strong>'s static &quot;GetGenerator&quot; method inserts another layer into the call stack, which is why the <strong>UpdateWithHelper</strong>'s method requires an (optional) &quot;numberOfFramesFromCallSite&quot; argument - so that it can be set to 2 in this case, rather than the default 1 (since it will need to step back through the <strong>DefaultUpdateWithHelper</strong> method before getting to the real &quot;UpdateWith&quot; method). This also means that <strong>DefaultUpdateWithHelper</strong> has the &quot;MethodImplOptions.NoInlining&quot; attribute on its &quot;GetGenerator&quot; method.</p>
<p>It's also worthy of note that the &quot;GetGenerator&quot; methods support extension methods for &quot;UpdateWith&quot; implementations, as opposed to requiring that they be instance methods. So the following is also acceptable</p>
<pre><code>public static RoleDetails UpdateWith(
  this RoleDetails source,
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return DefaultUpdateWithHelper.GetGenerator&lt;RoleDetails&gt;()(source, title, startDate);
}
</code></pre>
<p>The analysis detects that the first argument is not an <strong>OptionalType&lt;T&gt;</strong> and asserts that its type is assignable to the type param T and then ignores it when generating the translation expression. The extension method will pass through the &quot;source&quot; reference where &quot;this&quot; was used in the instance method implementation shown earlier.</p>
<h3>Further performance optimisations</h3>
<p>Although the compiled &quot;generator&quot; expressions are cached, the cache key is based upon the &quot;UpdateWith&quot; method's metadata. This means that the cost of accessing the <strong>StackFrame</strong> is paid for every &quot;UpdateWith&quot; call, along with the reflection access to get the UpdateWith argument's metadata. If you feel that this might be an unbearable toll, a simple alternative is something like</p>
<pre><code>private static UpdateWithSignature&lt;RoleDetails&gt; updater
  = DefaultUpdateWithHelper.GetGenerator&lt;RoleDetails&gt;(typeof(RoleDetails).GetMethod(&quot;UpdateWith&quot;));
public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return updater(this, title, startDate);
}
</code></pre>
<p>The &quot;GetGenerator&quot; methods have alternate signatures that accept a <strong>MethodBase</strong> reference relating to the &quot;UpdateWith&quot; method, rather than relying upon <strong>StackFrame</strong> to retrieve it. And using a static &quot;updater&quot; reference means that &quot;GetGenerator&quot; is only ever called once, so subsequent calls that would require reflection in order to check for a cached expression are avoided entirely. The trade-off is that the method must be named in a string, which would break if the method was renamed. Not quite as convenient as relying upon stack-tracing magic.</p>
<p>If you really want to get crazy, you can go one step further. If part of the reason for this experiment was to reduce GC pressure, then surely the params array required by the <strong>UpdateWithSignature&lt;T&gt;</strong> is a step backwards from the less-automated method, where the number of update arguments is known at compile time? (Since that <em>didn't</em> require a params array for a variable number of arguments, there were no method calls where the precise number of update arguments was unknown). Well that params array can be avoided if we make some more trade-offs. Firstly, we may <em>only</em> use an approach like above, which doesn't rely on expression caching (ie. use a static property that requests a generator only once). Secondly, there may only be up to nine update arguments. The first reason is because the cache that the <strong>UpdateWithHelper</strong> uses records <strong>UpdateWithSignature&lt;T&gt;</strong> references, which are no good since they use the params array that we're trying to avoid. The second reason is because a distinct delegate is required for each number of arguments, as is a distinct method to construct the generator - so there had to be a limit somewhere and I chose nine. The methods are</p>
<pre><code>public UpdateWithSignature1&lt;T&gt; GetUncachedGenerator1&lt;T&gt;(MethodBase updateMethod)
public UpdateWithSignature2&lt;T&gt; GetUncachedGenerator2&lt;T&gt;(MethodBase updateMethod)
public UpdateWithSignature3&lt;T&gt; GetUncachedGenerator3&lt;T&gt;(MethodBase updateMethod)
// .. etc, up to 9
</code></pre>
<p>and the delegates are of the form</p>
<pre><code>public delegate T UpdateWithSignature1&lt;T&gt;(T source, object arg0);
public delegate T UpdateWithSignature2&lt;T&gt;(T source, object arg0, object arg1);
public delegate T UpdateWithSignature3&lt;T&gt;(T source, object arg0, object arg1, object arg2);
// .. etc, up to 9
</code></pre>
<p>They may be used in a similar manner to that already shown, but you must be careful to match the number of arguments required by the &quot;UpdateWith&quot; method. In a way, there is actually a compile-time advantage here - if you choose the wrong one, then the compiler will warn you that you have specified three update arguments when the delegate requires four (for example). With the generic form (the non-numbered &quot;GetGenerator&quot; method), the params array means that you can specify any number of update arguments and you won't find out until runtime that you specified the wrong amount.</p>
<p>So, to illustrate -</p>
<pre><code>private static UpdateWithSignature3&lt;RoleDetails&gt; updater
  = DefaultUpdateWithHelper.GetUncachedGenerator3&lt;RoleDetails&gt;(
    typeof(RoleDetails).GetMethod(&quot;UpdateWith&quot;));

public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return updater(this, title, startDate, endDateIfAny);
}
</code></pre>
<p>If I'm being honest, however, if you <em>really</em> think that this optimisation is beneficial (by which, I mean you've done performance analysis and found it to be a bottleneck worth addressing), you're probably better replacing this automated approach with the hand-written code that I showed earlier. It's not all that long and it removes all of this &quot;magic&quot; and also gives the compiler more opportunity to pick up on mistakes. But most importantly (in terms of performance) may be the fact that all update arguments are passed as &quot;object&quot; in these delegates. This means that any value types (ints, structs, etc..) will be boxed when they are passed around and then unboxed when used as constructor arguments. This is explained very clearly in the article <a href="http://www.techgalaxy.net/Docs/Dev/5ways.htm">5 Basic Ways to Improve Performance in C#</a> and more information about the use of the heap and stack can be found at <a href="http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types">Six important .NET concepts: Stack, heap, value types, reference types, boxing, and unboxing</a> - I'd not seen this article before today but I thought it explained things really clearly.</p>
<p>Chances are that you won't have to worry about such low level details as whether values are being boxed-unboxed 99% of the time and I think there's a lot of mileage to be had from how convenient this automated approach is. But it's worth bearing in mind the &quot;what ifs&quot; of performance for the times when they <em>do</em> make a difference.</p>
<h3>Any other downsides to the automagical way?</h3>
<p>I can't claim to have this code in production anywhere yet. But I'm comfortable enough with it at this stage that I intend to start introducing it into prototype projects that it will be applicable to - and then look to using it in real-world, scary, production projects before too long! My only concern, really, is about making silly mistakes with typos in update argument names. If I mistyped &quot;tittle&quot; in the <strong>RoleDetails</strong> &quot;UpdateWith&quot; example I've been using, I wouldn't find out until runtime that I'd made the mistaken - at which point, the &quot;GetGenerator&quot; call would throw an exception as it wouldn't be able to match &quot;tittle&quot; to any argument on any accessible constructor. I think the trade-off here would be that every &quot;UpdateWith&quot; method that used this library would need a unit test so that discovering the problem at &quot;runtime&quot; doesn't mean &quot;when I hit code in manual testing that triggers the exception&quot; but rather equates to &quot;whenever the test suite is run - whether locally or when pushed to the build server&quot;. I doubt that Update methods of this type would normally get a unit test since they're so basic (maybe you disagree!) but in this case the convenience of using the automated &quot;GetGenerator&quot; method still wins even with the (simple) unit test recommended for each one.</p>
<p>Now that I think about it, this is not a dissimilar situation to using a Dependency Injection framework or using AutoMapper in your code - there is a lot of convenience to be had, but at the risk that configuration errors are not exposed until the code is executed.</p>
<p>In summary, until I find a good reason <em>not</em> to use this library going forward, I intend to do so! To revisit my (F#) inspiration, how can it not be enticing to be able to write</p>
<pre><code>// F#
let p2 = {p1 with first=&quot;Jim&quot;;last=&quot;Smith&quot;}

// C#
var p2 = p1.UpdateWith(first:&quot;Jim&quot;,last:&quot;Smith&quot;);
</code></pre>
<p>with so little code having to be written to enable it?!</p>
<p>Go get the code at <a href="https://bitbucket.org/DanRoberts/updatewith">bitbucket.org/DanRoberts/updatewith</a>!</p>
<p>Or alternatively, pull the NuGet package straight down from <a href="https://www.nuget.org/packages/CSharpImmutableUpdateWith/">nuget.org/packages/CSharpImmutableUpdateWith</a>.</p>
<p><strong>Update (19th September 2014):</strong> There's been quite a lot of interest in this post and some good comments made here and at the discussion on <a href="http://www.reddit.com/r/programming/comments/2gqx9u/implementing_finspired_with_updates_for_immutable/">Reddit/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp</a>. I intend to write a follow-up post that talks about some of the observations and includes some performance stats. In summary, though, I may have to admit to considering a slight about-turn in the crazy magical approach and strike that up as a convenience for rattling out code quickly but probably something that won't make it into production code that I write. The idea of using an &quot;UpdateWith&quot; method with named, optional arguments (using the <strong>Optional</strong> struct) <em>will</em> make it into my &quot;real world&quot; code, though! It's also strikingly similar to some of the code in Roslyn, it was pointed out (I'll touch on this in the follow-up too). I still had a lot of fun with the &quot;Turning it up to eleven&quot; investigation and I think there's useful information in here and in the library code I wrote - even more so when I get round to documenting how I approach writing the LINQ expression-generating code. But maybe it didn't result in something that should always be everyone's immediate go-to method for writing this sort of code. Such is life! :)</p>
<p><strong>Update (2nd October 2014):</strong> See <a href="/a-followup-to-implementing-f-sharp-inspired-with-updates-in-c-sharp">A follow-up to &quot;Implementing F#-inspired 'with' updates in C#&quot;</a>.</p>
<p class="PostTime">Posted at 23:12</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/writing-f-sharp-to-implement-the-single-layer-perceptron">Writing F# to implement &#x27;The Single Layer Perceptron&#x27;</a></li><li><a href="/hasslefree-immutable-type-updates-in-c-sharp">Hassle-free immutable type updates in C#</a></li><li><a href="/a-followup-to-implementing-f-sharp-inspired-with-updates-in-c-sharp">A follow-up to &quot;Implementing F#-inspired &#x27;with&#x27; updates in C#&quot;</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li><li><a href="/Archive/Tag/LINQ" title="12 Posts">LINQ</a></li><li><a href="/Archive/Tag/Reflection" title="15 Posts">Reflection</a></li></ul></div>
            <p class="Comments">
                <a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp#disqus_thread" data-disqus-identifier="74">Comments</a>
            </p>
    </div>

        <script type="text/javascript">
            (function () {
                var s = document.createElement("script");
                s.type = "text/javascript";
                s.async = true;
                s.src = "https://" + disqus_shortname + ".disqus.com/count.js";
                (document.getElementsByTagName("HEAD")[0] || document.getElementsByTagName("BODY")[0]).appendChild(s);
            }());
        </script>

				<div class="Footer">
					© Productive Rage 2011 - 2021
				</div>
			</div>

			<div class="SideBar">
				<div class="About">
					<h2>About</h2>
					<p>Dan is a big geek who likes making stuff with computers! He can be quite outspoken so clearly needs a blog :)</p>
					<p>In the last few minutes he seems to have taken to referring to himself in the third person. He's quite enjoying it.</p>
					<p><a href="mailto:dangger36@gmail.com" class="Email">dangger36@gmail.com</a></p>
				</div>
				<div class="Search">
<form action="/Search" method="get">						<div>
							<input type="text" class="SiteSearch" name="term" value="" />
							<input type="submit" class="SiteSearchSubmit" value="Search" />
						</div>
</form>				</div>
				<div class="Recent"><h2>Recent Posts</h2><ul><li><a href="/parallelising-linq-work-in-c-sharp">Parallelising (LINQ) work in C#</a></li><li><a href="/automating-suggested-related-posts-links-for-my-blog-posts-part-2">Automating &quot;suggested / related posts&quot; links for my blog posts - Part 2</a></li><li><a href="/automating-suggested-related-posts-links-for-my-blog-posts">Automating &quot;suggested / related posts&quot; links for my blog posts</a></li><li><a href="/language-detection-and-wordsinsentence-classification-in-c-sharp">Language detection and words-in-sentence classification in C#</a></li><li><a href="/monitoring-my-gardens-limited-sunlight-time-period-with-an-arduino-and-some-tupperware">Monitoring my garden&#x27;s limited sunlight time period with an Arduino (and some tupperware)</a></li></ul><div class="RSSFeedLink"><a href="https://www.productiverage.com/feed">RSS Feed</a></div></div>
				<div class="Featured"><h2>Highlights</h2><ul><li><a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face (finding faces in photos using C# and Accord.NET)</a></li><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/translating-vbscript-into-c-sharp">Translating VBScript into C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div>
				<div class="History"><h2>Archives</h2><ul><li><a href="/Archive/8/2021">August 2021 (1)</a></li><li><a href="/Archive/4/2021">April 2021 (2)</a></li><li><a href="/Archive/3/2021">March 2021 (1)</a></li><li><a href="/Archive/8/2020">August 2020 (3)</a></li><li><a href="/Archive/7/2019">July 2019 (2)</a></li><li><a href="/Archive/9/2018">September 2018 (1)</a></li><li><a href="/Archive/4/2018">April 2018 (1)</a></li><li><a href="/Archive/3/2018">March 2018 (1)</a></li><li><a href="/Archive/7/2017">July 2017 (1)</a></li><li><a href="/Archive/6/2017">June 2017 (1)</a></li><li><a href="/Archive/2/2017">February 2017 (1)</a></li><li><a href="/Archive/11/2016">November 2016 (1)</a></li><li><a href="/Archive/9/2016">September 2016 (2)</a></li><li><a href="/Archive/8/2016">August 2016 (1)</a></li><li><a href="/Archive/7/2016">July 2016 (1)</a></li><li><a href="/Archive/6/2016">June 2016 (1)</a></li><li><a href="/Archive/5/2016">May 2016 (3)</a></li><li><a href="/Archive/3/2016">March 2016 (3)</a></li><li><a href="/Archive/2/2016">February 2016 (2)</a></li><li><a href="/Archive/12/2015">December 2015 (1)</a></li><li><a href="/Archive/11/2015">November 2015 (2)</a></li><li><a href="/Archive/8/2015">August 2015 (3)</a></li><li><a href="/Archive/7/2015">July 2015 (1)</a></li><li><a href="/Archive/6/2015">June 2015 (1)</a></li><li><a href="/Archive/5/2015">May 2015 (2)</a></li><li><a href="/Archive/4/2015">April 2015 (1)</a></li><li><a href="/Archive/3/2015">March 2015 (1)</a></li><li><a href="/Archive/1/2015">January 2015 (2)</a></li><li><a href="/Archive/12/2014">December 2014 (1)</a></li><li><a href="/Archive/11/2014">November 2014 (1)</a></li><li><a href="/Archive/10/2014">October 2014 (2)</a></li><li><a href="/Archive/9/2014">September 2014 (2)</a></li><li><a href="/Archive/8/2014">August 2014 (1)</a></li><li><a href="/Archive/7/2014">July 2014 (1)</a></li><li><a href="/Archive/6/2014">June 2014 (1)</a></li><li><a href="/Archive/5/2014">May 2014 (2)</a></li><li><a href="/Archive/2/2014">February 2014 (1)</a></li><li><a href="/Archive/1/2014">January 2014 (1)</a></li><li><a href="/Archive/12/2013">December 2013 (1)</a></li><li><a href="/Archive/11/2013">November 2013 (1)</a></li><li><a href="/Archive/10/2013">October 2013 (1)</a></li><li><a href="/Archive/8/2013">August 2013 (3)</a></li><li><a href="/Archive/7/2013">July 2013 (3)</a></li><li><a href="/Archive/6/2013">June 2013 (1)</a></li><li><a href="/Archive/5/2013">May 2013 (2)</a></li><li><a href="/Archive/4/2013">April 2013 (1)</a></li><li><a href="/Archive/3/2013">March 2013 (8)</a></li><li><a href="/Archive/2/2013">February 2013 (2)</a></li><li><a href="/Archive/1/2013">January 2013 (2)</a></li><li><a href="/Archive/12/2012">December 2012 (3)</a></li><li><a href="/Archive/11/2012">November 2012 (4)</a></li><li><a href="/Archive/9/2012">September 2012 (1)</a></li><li><a href="/Archive/8/2012">August 2012 (1)</a></li><li><a href="/Archive/7/2012">July 2012 (3)</a></li><li><a href="/Archive/6/2012">June 2012 (3)</a></li><li><a href="/Archive/5/2012">May 2012 (2)</a></li><li><a href="/Archive/2/2012">February 2012 (3)</a></li><li><a href="/Archive/1/2012">January 2012 (4)</a></li><li><a href="/Archive/12/2011">December 2011 (7)</a></li><li><a href="/Archive/8/2011">August 2011 (2)</a></li><li><a href="/Archive/7/2011">July 2011 (1)</a></li><li><a href="/Archive/5/2011">May 2011 (1)</a></li><li><a href="/Archive/4/2011">April 2011 (2)</a></li><li><a href="/Archive/3/2011">March 2011 (3)</a></li></ul><div class="EveryTitle"><a href="/Archive/All">Every Post Title</a></div></div>
			</div>

		</div>
	</div>

	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
	<script type="text/javascript" src="/Scripts/jquery.autocomplete.min.js"></script>
	<script type="text/javascript" src="/Scripts/prettify.js"></script>
	<script type="text/javascript" src="/Scripts/Site.js"></script>
	<script type="text/javascript" src="/Scripts/IndexSearchGenerator.js"></script>
	<script type="text/javascript" src="/Scripts/SearchTermHighlighter.js"></script>
	<script type="text/javascript" src="/Scripts/SearchPage.js"></script>
	<script type="text/javascript" src="/Scripts/LZString.js"></script>

</body>
</html>
