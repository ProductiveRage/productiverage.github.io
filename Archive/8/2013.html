
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Productive Rage - August 2013</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#393939" />
	<link rel="stylesheet" type="text/css" media="all" href="/Content/Styles.css" />
	<!--[if lt IE 9]>
	<link rel="stylesheet" type="text/css" href="/Content/IEBefore9.css" />
	<![endif]-->
	<link rel="stylesheet" type="text/css" media="print" href="/Content/PrintOverrides.css" />
	<meta name="robots" content="noindex, follow" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.productiverage.com/feed" />
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', "UA-32312857-1"]);
		_gaq.push(['_setSiteSpeedSampleRate', 100]);
		_gaq.push(['_trackPageview']);
		(function () {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>

<body>

	<div class="Header">
		<div class="HeaderContent">
			<h1>
				<a href="/">Productive Rage</a>
			</h1>
			<span class="Tagline">Dan's techie ramblings</span>
		</div>
	</div>

	<div class="WrapperOuter">
		<div class="Wrapper">

			<div class="Main HasSideBar">
				


				<script type="text/javascript">
					var disqus_shortname = "productiverage";
					function executeWhen(fncAction, fncConditional, intDelayBetweenRetries) {
						if (fncConditional()) { fncAction(); return; }
						setTimeout(function () { executeWhen(fncAction, fncConditional, intDelayBetweenRetries); }, intDelayBetweenRetries);
					}
					executeWhen(
						function () { $("div.Content p.Comments").show(); },
						function () { return (typeof ($) !== "undefined") },
						10
					);
				</script>

				<div class="Content ArchiveByMonth">
					<h3 class="PostDate">30 August 2013</h3><h2><a id="Post63"></a><a href="/why-do-you-hate-my-wcf-types-php">Why do you hate my (WCF) types, PHP??</a></h2>

<p>Last November, I was helping someone consume a WCF Web Service with PHP (in the imaginatively named <a href="/consuming-a-wcf-web-service-from-php">Consuming a WCF Web Service from PHP</a>). After jumping through some hoops (and reading a <em>lot</em> of unhelpful and/or misleading information on the web) it was working; requests that relied on type names being specified were being accepted, gzip support was being enabled, even some useful debug information was being made available for when problems were encountered. All was well. But there was something that was bugging me for a long time that I only quite recently was able to address -</p>

<p><em>Why does the PHP SoapClient so belligerently throw away the type names of response objects?</em></p>

<p>It has knowledge of the type name since it must process the response data to populate the associative arrays that represent this data. But the names of the response types are apparently then cast forever into the ether, never to exposed to me. After all, I'm using PHP - I don't want no stinkin' types!</p>

<h3>Is it just me?</h3>

<p>I feel I should probably explain why I care so much. To be fair, I imagine that in a large number of cases the type name of the returned data really isn't important. If, for example, I'm querying the Twitter API for a set of Statuses then I know the form of the returned data (and since it returns JSON, there <em>are</em> no type names in the responses!). And for a lot of services, I imagine the form of the returned data will be identical from one result to another and, in many of the cases where the forms vary, a form of "property sniffing" will deal with it; does this result have this particular property along with all of the common ones? If so, save it or use it or do whatever with it.</p>

<p>But there are cases where this isn't enough. In that <a href="/consuming-a-wcf-web-service-from-php">earlier post</a>, the example was a web method "GetHotels" which returned hotel data for results that matched a particular set of filters (in that case, the type names were important for the <em>request</em> since an array of filters was specified, each filter was a particular WCF class - without the type names, the service couldn't deserialise the request).</p>

<p>Each of the returned hotels has data such as Categories, Awards, and Facilities but only the keys of these Categories, Awards and Facilities are returned. There is a separate web method "GetMetaData" that maps these keys onto names. A language can be specified as part of the meta data request so that the names are provided in the correct language.</p>

<p>Some of the meta data types may have additional data, such as an optional ImageUrl for Awards. Categories can be grouped together, so Categories such "Budget Hotel", "Boutique Hotel" and "Garden Hotel" are all considered to be part of the Category Group "Hotel" whilst "Guest House", "Farmhouse" and "Inn" are all considered part of the "Bed &amp; Breakfast" Category Group.</p>

<p>The natural way to express this in a WCF Web Service (making use of wsdl-supported complex types) is something like the following -</p>

<pre><code>[ServiceContract]
public class HotelService
{
  [OperationContract]
  public MetaDataEntry[] GetMetaData(MetaDataRequest request)
  {
    ..
  }
}

[DataContact]
public class MetaDataRequest
{
  [DataMember]
  public string APIKey { get; set; }

  [DataMember]
  public string LanguageCode { get; set; }

  [DataMember]
  public MetaDataType[] MetaDataTypes { get; set; }
}

public enum MetaDataType
{
  Award,
  Category,
  CategoryGroup,
  Facility
}

[KnownType(AwardMetaDataEntry)]
[KnownType(CategoryMetaDataEntry)]
[KnownType(CategoryGroupMetaDataEntry)]
[KnownType(FacilityMetaDataEntry)]
[DataContract]
public abstract class MetaDataEntry
{
  [DataMember(IsRequired = true)]
  public int Key { get; set; }

  [DataMember]
  public string Name { get; set; }
}

[DataContract]
public class AwardMetaDataEntry : MetaDataEntry
{
  [DataMember]
  public string ImageUrl { get; set; }
}

[DataContract]
public class CategoryMetaDataEntry : MetaDataEntry
{
  [DataMember(IsRequired = true)]
  public int CategoryGroup { get; set; }
}

[DataContract]
public class CategoryGroupMetaDataEntry : MetaDataEntry { }

[DataContract]
public class FacilityMetaDataEntry : MetaDataEntry { }
</code></pre>

<p>The <strong>MetaDataRequest</strong> allows me to specify which types of meta data that I'm interested in.</p>

<p>So, feasibly, if I wanted to build up a set of Categories to map the keys from the Hotels onto, I could make a request for just the meta data for the Categories. If I then want to map those Categories onto Category Groups, I could make a request for the Category Group meta data.</p>

<p>But why shouldn't I be able to request <em>all</em> of the meta data types, loop through them and stash them all away for future reference <em>all in one go</em>? I could do this easily enough with a .net client. Or a Java client. But, by default, PHP refuses to allow a distinction to be made between a <strong>CategoryGroupMetaDataEntry</strong> and a <strong>FacilityMetaDataEntry</strong> since they have the same structure and PHP won't tell me type names.</p>

<p>Well.. that's not strictly true. PHP <em>does</em> have some means to interrogate type names; the methods "gettype" and "get_class". If you define a class in your PHP code and pass an instance of it to the "get_class" method, you will indeed get back the name of that class. "get_class" may only be given an argument that is an object, as reported by the "gettype" method (see the <a href="http://php.net/manual/en/function.get-class.php">get_class</a> and <a href="http://php.net/manual/en/function.gettype.php">gettype</a> PHP documentation).</p>

<p>But if we try this with the web service call -</p>

<pre><code>$client = new SoapClient(
  "http://webservice.example.com/hotelservice.svc?wsdl",
  array(
    "compression" =&gt; SOAP_COMPRESSION_ACCEPT | SOAP_COMPRESSION_GZIP,
    "trace" =&gt; 1
  )
);
$metaDataTypes = $client-&gt;GetMetaData(
  array(
    "request" =&gt; array(  
      "ApiKey" =&gt; "TestKey",
      "Language" =&gt; 1, 
      "MetaDataTypes" =&gt; array(
        "MetaDataTypeOptions" =&gt; array(
          "Award",
          "Category",
          "CategoryGroup",
          "Facility"
        )
      )
    )
  )
);
</code></pre>

<p>we can loop through the returned data and use get_class to find out that.. they are all apparently "<strong>StdObject</strong>".</p>

<p>This is what I meant by the type names being "thrown away".</p>

<h3>Duck-typing (doesn't work if everything quacks and waddles)</h3>

<p>In some cases we can work around this.</p>

<p>For example, to guess that a result is an <strong>AwardMetaDataEntry</strong> we could try</p>

<pre><code>if (property_exists($metaDataValue, "ImageUrl")) {
</code></pre>

<p>and work on the basis that if it exposes an "ImageUrl" property that it is <strong>AwardMetaDataEntry</strong>.</p>

<p>But this won't work for differentiating between a <strong>CategoryGroupMetaDataEntry</strong> and a <strong>FacilityGroupMetaDataEntry</strong> since those response types have no structural differences.</p>

<h3>Class Mappings</h3>

<p>It turns out that the SoapClient <em>does</em> offer a way to get what we want, so long as we don't mind declaring PHP classes for every response type that we're interested in.</p>

<pre><code>class MetaDataEntry
{
  public $Key;
  public $Name;
}

class AwardMetaDataEntry extends MetaDataEntry
{
  public $ImageUrl;
}

class CategoryMetaDataEntry extends MetaDataEntry
{
  public $CategoryGroup;
}

class CategoryGroupMetaDataEntry extends MetaDataEntry { }

class FacilityMetaDataEntry extends MetaDataEntry { }
</code></pre>

<p>As we can see in the <a href="http://php.net/manual/en/soapclient.soapclient.php">PHP SoapClient documentation</a>, one of the options that can be specified is a "classmap" -</p>

<blockquote>
  <p>This option must be an array with WSDL types as keys and names of PHP classes as values</p>
</blockquote>

<p>It's a way to say that particular response types should be mapped to particular PHP classes - eg.</p>

<pre><code>$client = new SoapClient(
  "http://webservice.example.com/hotelservice.svc?wsdl",
  array(
    "compression" =&gt; SOAP_COMPRESSION_ACCEPT | SOAP_COMPRESSION_GZIP,
    "trace" =&gt; 1,
    "classmap" =&gt; array(
      "AwardMetaDataEntry" =&gt; "AwardMetaDataEntry",
      "CategoryMetaDataEntry" =&gt; "CategoryMetaDataEntry",
      "CategoryGroupMetaDataEntry" =&gt; "CategoryGroupMetaDataEntry",
      "FacilityMetaDataEntry" =&gt; "FacilityMetaDataEntry"
    )
  )
);
</code></pre>

<p><em>Now</em> when we loop through the response values and call get_class we get the correct names. Success!</p>

<p>(In the above code I've named the PHP classes the same as the WSDL types but, since the mappings all have to be individually specified, the class names don't <em>have</em> to be the same. The properties, on the other hand, <em>do</em> have to match since there is no facility for custom-mapping them. Any classes that don't have a mapping will continue to be translated into objects of type <strong>StdObject</strong>).</p>

<p>It may well be that this is far from news for many seasoned PHP Developers but when I described the situation (before finding out about the "classmap" option) to someone I was told was experienced and competent they had no suggestion in this direction.</p>

<p>To be honest, I'm not sure how I came across this in the end. If you know that there exists an option to map classes with the SoapClient then it's easy to find; but with only a vague idea that I wanted it to stop throwing away type names, it took me <em>lots</em> of reading and clutching at straws with search terms. Interestingly, even <em>with</em> this knowledge, I'm still unable to find an article that describes the specific problem I've talked about here.. so maybe it really <em>is</em> just me that has encountered it or cares about it!</p>
<p class="PostTime">Posted at 00:03</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/PHP" title="2 Posts">PHP</a></li><li><a href="/Archive/Tag/WCF" title="6 Posts">WCF</a></li></ul></div>
						<p class="Comments">
							<a href="/why-do-you-hate-my-wcf-types-php#disqus_thread" data-disqus-identifier="63">Comments</a>
						</p>
				</div>
				<div class="Content ArchiveByMonth">
					<h3 class="PostDate">19 August 2013</h3><h2><a id="Post62"></a><a href="/typescript-state-machines">TypeScript State Machines</a></h2>

<p>Last time, in <a href="/c-sharp-state-machines">C# State Machines</a>, I used the example of traffic lights at a crossroads to illustrate how complexity could be handled easily with the state machine pattern. This was a follow-on to my <a href="/parsing-css">Parsing CSS</a> post and inspired by the excellent article <a href="http://gameprogrammingpatterns.com/state.html">Game Programming Patterns: State</a>.</p>

<p>Well this little excursion offered me the perfect opportunity to dive into something else I've been looking at: <a href="http://www.typescriptlang.org/">TypeScript</a>. I've long been a fan of JavaScript. It's got a lot of quirks and it's easy to write absolute rubbish with it. In fairness, it's possible to write crap with any language, it just feels like sometimes JavaScript makes it <em>very</em> easy. But if you embrace the patterns that work well with it and apply a little discipline, you can come up with elegant, maintainable solutions.</p>

<p>But I've often found it difficult to leave behind entirely the concept of static typing and that warm cozy feeling of knowing that the argument that you want is going to be an int and, as an int, you can apply any range checks you might need to and be content that everything has met your expectations (or demands, perhaps :) But if you don't even know what type it is, you can't as easily apply these sorts of restrictions. You can try to check the type of the argument and <em>then</em> apply range checking (or whatever) but that can start to get very messy, very quickly. I used to work with someone who claimed that static checking was unnecessary with sufficient unit testing. Meanwhile, I still think that there's a lot of potential for <a href="http://msdn.microsoft.com/en-us/library/dd264808.aspx">Code Contracts</a> which is tending towards the polar opposite, so we basically had to agree to disagree on that one. In fact I may choose to take his argument to mean that with static types that a whole category of unit tests become unnecessary, handled instead by compiler checks!</p>

<p>So it's probably fairly easy to see, if I like JavaScript <em>and</em> I like static typing, why TypeScript could seem apper attractive prospect. And here was a nice little project that was non-trivial but still pretty compact that I could try it out with.</p>

<p>The type annotations in TypeScript are optional, but since I'm writing the code from scratch it makes sense to use them throughout. Interfaces are defined but do not need to referenced by types that implement the interface - so long as they have all of the required properties and methods then they will implicitly be considered to implement the interface. This is like Google's <a href="http://golang.org/">Go</a> language and not like C#.</p>

<p>One thing that I don't like too much is that it isn't currently possible to specify an interface with readonly properties. It must be a property with a getter and setter or nothing. So I've resorted to specific Get methods on the interfaces instead, such as GetColour() and GetState().</p>

<p>(I'm going for a fairly direct port from the C# code. If you haven't read the <a href="/c-sharp-state-machines">last post</a> then it might be worth a quick look - there's nothing too complicated going on here, it's just that I'm going to be skimming over the general program structure and concentrating mostly on how it works with TypeScript).</p>

<pre><code>interface IAmATrafficLightState {
  GetColour(): ColourOptions;
  GetStatus(): StatusOptions;
  RegisterCarQueueing(): IAmAStateTransition;
  RegisterPassageOfTime(): IAmAStateTransition;
}

interface IAmAStateTransition {
  GetTransitionType(): TransitionTypeOptions;
  GetNewState(): IAmATrafficLightState; 
}

enum ColourOptions {
  GreenOnly,
  RedAndYellow,
  RedOnly,
  YellowOnly
}

enum StatusOptions {
  HandlingTraffic,
  NotHandlingTraffic
}

enum TransitionTypeOptions {
  NoChange,
  Pop,
  Push,
  Replace
}
</code></pre>

<p>In the C# code, I actually had a <strong>StateTransition</strong> class rather than an <strong>IAmAStateTransition</strong>. The class had a private constructor and multiple static public methods for constructing instances: NoChange, Pop, Push and Replace. This isn't a structure that TypeScript supports, so instead I've got an interface and separate implementations. Each of the below classes implicitly <strong>IAmAStateTransition</strong> as they have the methods GetTransitionType() and GetNewState().</p>

<p>The <strong>PushTransition</strong> and <strong>ReplaceTransition</strong> classes take a single constructor argument of type <strong>IAmATrafficLightState</strong> (as the transitions work against a "state stack", only the Push and Replace actions require a state to change to, Pop and NoChange don't). Since the constructor argument's type is specified, the only validation I have to perform to remain consistent with the C# code is to ensure that it has a non-null value. TypeScript would indicate a compile-time error if I tried to pass a string for this argument, as that clearly isn't an <strong>IAmATrafficLightState</strong> implementation. But it won't complain about <em>either</em> a null value or an undefined value. So the easiest thing to do seems to be just use the JavaScript pattern of testing for anything that evaluates to false - ie. "if (!state) { /* Error */ }"</p>

<pre><code>class NoChangeTransition {
  GetTransitionType(): TransitionTypeOptions {
    return TransitionTypeOptions.NoChange;
  }
  GetNewState(): IAmATrafficLightState {
    return null;
  }
}

class PopTransition {
  GetTransitionType(): TransitionTypeOptions {
    return TransitionTypeOptions.Pop;
  }
  GetNewState(): IAmATrafficLightState {
    return null;
  }
}

class PushTransition {
  constructor(private state: IAmATrafficLightState) {
    if (!state) {
      throw new Error("state may not be null for a Push Transition");
    }
  }
  GetTransitionType(): TransitionTypeOptions {
    return TransitionTypeOptions.Push;
  }
  GetNewState(): IAmATrafficLightState {
    return this.state;
  }
}

class ReplaceTransition {
  constructor(private state: IAmATrafficLightState) {
    if (!state) {
      throw new Error("state may not be null for a Replace Transition");
    }
  }
  GetTransitionType(): TransitionTypeOptions {
    return TransitionTypeOptions.Replace;
  }
  GetNewState(): IAmATrafficLightState {
    return this.state;
  }
}
</code></pre>

<p>I like the syntax here where constructor arguments can be marked as private, resulting in a private backing field being implicitly specified (see Steve Fenton's <a href="http://www.stevefenton.co.uk/Content/Blog/Date/201304/Blog/Stop-Manually-Assigning-TypeScript-Constructor-Parameters/">Stop Manually Assigning TypeScript Constructor Parameters</a>). What I don't like is that in the resulting JavaScript, these fields are <em>not</em> private. If you look at the JavaScript below, which is generated from the TypeScript <strong>PushTransition</strong> class..</p>

<pre><code>// This is the generated JavaScript for the TypeScript "PushTransition" class above
var PushTransition = (function () {
  function PushTransition(state) {
    this.state = state;
    if (!state) {
      throw new Error("state may not be null for a Push Transition");
    }
  }
  PushTransition.prototype.GetTransitionType = function () {
    return TransitionTypeOptions.Push;
  };
  PushTransition.prototype.GetNewState = function () {
    return this.state;
  };
  return PushTransition;
})();
</code></pre>

<p>.. you'll see that the state value is stored in "this.state". That's a public reference that JavaScript can manipulate. If all of the code that uses this class is TypeScript, then it won't be a problem as the compiler will enforce its private status. But if this is code to be called by non-TypeScript JavaScript then it's not ideal.</p>

<p>Although Douglas Crockford showed us years ago that genuinely private members were possible (see <a href="http://javascript.crockford.com/private.html">Private Members in JavaScript</a>), the sacrifice is that methods for an object instance with private members must be declared for each instance. The class structure used by TypeScript, on the other hand, uses the prototype approach to declare functions for each class. This means that each method is defined only once per class, rather than once per instance. So it's a conscious decision to gain a performance improvement in terms of the memory required. (Anders Hejlsberg - the daddy of both C# and TypeScript - addresses exactly this point in this forum post <a href="http://typescript.codeplex.com/discussions/397651">Private Variables</a>).</p>

<h3>Time-Transitioning States</h3>

<p>Some states in this model will transition based upon time alone. The initial state of <strong>RedLightWaitingForTraffic</strong> will only transition when cars arrive at the lights whereas states such as <strong>GreenLight</strong> transition based solely on time - it will stay green for a set period of time before cycling back round.</p>

<p>In the C# code last time, I had an abstract <strong>TimeBasedTransitiveState</strong> class with a nested class that would represent the states during which time was being counted down before the next transition. This nested class would have a "Source" property that pointed back to the traffic light state that started the countdown (eg. a <strong>GreenLight</strong> instance). TypeScript doesn't support abstract classes <em>or</em> nested classes so this structure wasn't going to work.</p>

<p>Instead I wrote it in a much more straight forward manner and then replaced the classes that have no internal state other than Colour, Status, Next Transition and Time-To-Next-Transition with what amount to static references. I liked this approach so much that I went back and changed the C# code such that <strong>TimeBasedTransitiveState</strong> class was written in pretty much the same way. (I've put the code up on Bitbucket for reference - see the <a href="https://bitbucket.org/DanRoberts/trafficlightstatemachine">TrafficLightStateMachine</a>). I haven't changed the C# code to use static references yet, but it's something I'm considering.</p>

<pre><code>class TimeBasedTransitiveState {
  constructor(
    private colour: ColourOptions,
    private status: StatusOptions,
    private timeSlicesToWaitFor: number,
    private nextTransition: IAmAStateTransition) {
    if (!nextTransition) {
      throw new Error("nextTransition may not be null for a Push Transition");
    }
    if (timeSlicesToWaitFor &lt;= 0) {
      throw new Error("timeSlicesToWaitFor must be a positive value");
    }
  }
  GetColour(): ColourOptions {
    return this.colour;
  }
  GetStatus(): StatusOptions {
    return this.status;
  }
  RegisterCarQueueing(): IAmAStateTransition {
    return new NoChangeTransition();
  }
  RegisterPassageOfTime(): IAmAStateTransition {
    if (this.timeSlicesToWaitFor === 1) {
      return this.nextTransition;
    }
    return new ReplaceTransition(
      new TimeBasedTransitiveState(
        this.colour,
        this.status,
        this.timeSlicesToWaitFor - 1,
        this.nextTransition
      )
    );
  }
}

var RedLightPausedBeforeWaitingForTraffic = (function () {
  var TIME_AFTER_RESETTING_TO_RED_BEFORE_CONSIDERING_TRAFFIC = 5;
  return new TimeBasedTransitiveState(
    ColourOptions.RedOnly,
    StatusOptions.HandlingTraffic,
    TIME_AFTER_RESETTING_TO_RED_BEFORE_CONSIDERING_TRAFFIC,
    new PopTransition()
  );
})();

var YellowLight = (function () {
  var TIME_TO_WAIT_ON_YELLOW = 5;
  return new TimeBasedTransitiveState(
    ColourOptions.YellowOnly,
    StatusOptions.HandlingTraffic,
    TIME_TO_WAIT_ON_YELLOW,
    new ReplaceTransition(RedLightPausedBeforeWaitingForTraffic)
  );
})();

var GreenLight = (function () {
  var TIME_TO_STAY_ON_GREEN = 100;
  return new TimeBasedTransitiveState(
    ColourOptions.GreenOnly,
    StatusOptions.HandlingTraffic,
    TIME_TO_STAY_ON_GREEN,
    new ReplaceTransition(YellowLight)
  );
})();

var RedAndYellowLight = (function () {
  var TIME_TO_WAIT_ON_RED_AND_YELLOW = 5;
  return new TimeBasedTransitiveState(
    ColourOptions.RedAndYellow,
    StatusOptions.HandlingTraffic,
    TIME_TO_WAIT_ON_RED_AND_YELLOW,
    new ReplaceTransition(GreenLight)
  );
})();

var RedLightAboutToChange = (function () {
  // We're committed to letting traffic pass at this point so declare HandlingTraffic
  var TIME_TO_STAY_RED_AFTER_CAR_ARRIVES = 10;
  return new TimeBasedTransitiveState(
    ColourOptions.RedOnly,
    StatusOptions.HandlingTraffic,
    TIME_TO_STAY_RED_AFTER_CAR_ARRIVES,
    new ReplaceTransition(RedAndYellowLight)
  );
})();
</code></pre>

<p>Note that the state objects have to follow the <strong>TimeBasedTransitiveState</strong> definition, in terms of the order in which they appear in the code. These objects are created by calling the constructor of the <strong>TimeBasedTransitiveState</strong> class. If these calls are made before the class is defined then an error such as "undefined is not a function" or "PushTransition is not a constructor" will be raised (depending upon browser or other runtime environment).</p>

<p>This has been observed by many people, sometimes resulting in bug reports such as <a href="https://typescript.codeplex.com/workitem/627">Inheritance only works if parent class is declared before child class</a>. These have so far been rejected. In that report, <a href="http://social.msdn.microsoft.com/profile/jonathan%20turner%20%5Bms%5D/">Jon Turner</a> writes</p>

<blockquote>
  <p>Unless we reorder the code for you, I think you still can come up with situations where a value hasn't been fully initialized. [..] At this time, we're explicitly not reordering code (or even adding code except in a couple of exceptions) that you've written.</p>
</blockquote>

<p>So I guess that we have to get used to the current situation.</p>

<p>For working with multiple files, there is support for CommonJs and AMD modules as talked about at <a href="http://blorkfish.wordpress.com/2012/10/23/typescript-organizing-your-code-with-amd-modules-and-require-js/">Organizing your code with AMD modules and require.js</a>. Note that I think the mention of comments "reference path" is out of date now, as Steve Fenton points out in <a href="http://www.stevefenton.co.uk/Content/Blog/Date/201308/Blog/Say-Goodbye-To-TypeScript-Reference-Comments/">Say Goodbye To TypeScript Reference Comments</a>!</p>

<p>One last point relating to this. I had a niggling thought that "isn't hoisting in JavaScript a way around this?" But hoisting is just about variable declarations, not their definitions. If you need a refresher on this (like I did) then this article is excellent: <a href="http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-javascript-hoisting-explained/">JavaScript Hoisting Explained</a> (it has a video at the top which I skipped, all of the information is written below it).</p>

<h3>Traffic-Transitioning States</h3>

<p>So back to the TypeScript state machine code..</p>

<p>The traffic-transitioning states are the ones that are a bit more interesting! Traffic lights start off as a <strong>RedLightWaitingForTraffic</strong>. Once traffic is registered as having arrived at the light, it will transition to either the <strong>RedLightAboutToChange</strong> state or the <strong>RedLightWaitingForAccess</strong>. The first option is only possible if the traffic lights on the intersecting road at the crossroads are not letting traffic through - it would be no good for traffic on both roads to be moving simultaneously! The <strong>RedLightAboutToChange</strong> is one of the time-transitioning states above, all that will happen is that the full state cycle (RedAndYellow to Green to Yellow and back to Red) will take place.</p>

<p>However, if the other road <em>is</em> letting through traffic then the <strong>RedLightWaitingForAccess</strong> state is used. This state will check whether it is free to pass traffic every time that its RegisterPassageOfTime method is called. If so (meaning that the other road is no longer letting traffic flow), then it can transition straight to the <strong>RedAndYellowLight</strong> state. Otherwise it has to stick to being a <strong>RedLightWaitingForAccess</strong>.</p>

<p>Something I particularly liked when writing the TypeScript version was how easy it was to specify a constructor argument that was a function. I shouldn't be surprised, really, since not only does JavaScript support first class functions but also C# has had lambdas all over the place (and the <strong>Func</strong> class) since .net 3.5. But it was just gratifying that it was so easy to declare! I want a single argument that is a parameter-less function that returns a bool. As such, I need only write -</p>

<pre><code>constructor(private isAllowedToLetTrafficThrough: () =&gt; boolean) {
</code></pre>

<p>Lovely! Succinct but easy to follow. So for the full implementations of the two traffic-based states we have -</p>

<pre><code>class RedLightWaitingForAccess {
  constructor(private isAllowedToLetTrafficThrough: () =&gt; boolean) {
    if (!isAllowedToLetTrafficThrough) {
      throw new Error("isAllowedToLetTrafficThrough must be specified");
    }
  }
  GetColour(): ColourOptions {
    return ColourOptions.RedOnly;
  }
  GetStatus(): StatusOptions {
    return StatusOptions.NotHandlingTraffic;
  }
  RegisterCarQueueing(): IAmAStateTransition {
    // We can't do anything here, we're already waiting
    return new NoChangeTransition();
  }
  RegisterPassageOfTime(): IAmAStateTransition {
    if (this.isAllowedToLetTrafficThrough()) {
      return new ReplaceTransition(RedAndYellowLight);
    }
    return new NoChangeTransition();
  }
}

class RedLightWaitingForTraffic {
  constructor(private isAllowedToLetTrafficThrough: () =&gt; boolean) {
    if (!isAllowedToLetTrafficThrough) {
      throw new Error("isAllowedToLetTrafficThrough must be specified");
    }
  }
  GetColour(): ColourOptions {
    return ColourOptions.RedOnly;
  }
  GetStatus(): StatusOptions {
    return StatusOptions.NotHandlingTraffic;
  }
  RegisterCarQueueing(): IAmAStateTransition {
    if (this.isAllowedToLetTrafficThrough()) {
      return new PushTransition(RedLightAboutToChange);
    }
    return new PushTransition(new RedLightWaitingForAccess(this.isAllowedToLetTrafficThrough));
  }
  RegisterPassageOfTime(): IAmAStateTransition {
    return new NoChangeTransition();
  }
}
</code></pre>

<p>Representing the state transitions as a stack and having each <strong>IAmATrafficLightState</strong> implementation return an <strong>IAmAStateTransition</strong> for the calls to RegisterCarQueueing and RegisterPassageOfTime makes following the changes in state very easy. The <strong>RedLightWaitingForTraffic</strong> is always at the bottom of the stack. When it changes state (to either a <strong>RedLightAboutToChange</strong> or a <strong>RedLightWaitingForAccess</strong>) that new state is pushed onto the stack. All of the following states replace that top entry until the final <strong>RedLightPausedBeforeWaitingForTraffic</strong> which will pop off, leaving the original <strong>RedLightWaitingForTraffic</strong>.</p>

<h3>Tying it all together</h3>

<p>Having recreated the states and the transitions, we need the <strong>TrafficLight</strong> class that keeps track of the state queue. The TypeScript version is reassuringly close to the C# code. There's no <strong>Stack</strong> class so I've used an array instead (which in JavaScript has "push" and "pop" methods and so isn't far removed from the .net <strong>Stack</strong> class). TypeScript's enums are implemented in such a way that if you want to display their name (rather than their numeric value) then you need to treat the enum as a hashtable which maps the value back onto the name. This varies from C#, where the ToString method of an enum value will return the name rather than the value. Also note that I'm using a method "Log" to write out messages. This will be defined below.</p>

<pre><code>class TrafficLight {
  private states: IAmATrafficLightState[];
  constructor(private trafficLightId: string, initialState: IAmATrafficLightState) {
    if (!trafficLightId) {
      throw new Error("A trafficLightId must be specified");
    }
    if (!initialState) {
      throw new Error("An initialstate must be specified");
    }
    this.states = [ initialState ];
  }

  GetTrafficLightId(): string {
    return this.trafficLightId;
  }

  GetColour(): ColourOptions {
    return this.GetCurrentState().GetColour();
  }

  GetStatus(): StatusOptions {
    return this.GetCurrentState().GetStatus();
  }

  RegisterPassageOfTime(): void {
    this.ApplyTransition(this.GetCurrentState().RegisterPassageOfTime());
  }

  RegisterCarQueueing(): void {
    this.ApplyTransition(this.GetCurrentState().RegisterCarQueueing());
  }

  private ApplyTransition(transition: IAmAStateTransition): void {
    var previousColour = this.GetCurrentState().GetColour();
    if (transition.GetTransitionType() === TransitionTypeOptions.NoChange) {
      // Do nothing
    }
    else if (transition.GetTransitionType() === TransitionTypeOptions.Pop) {
      if (this.states.length === 1) {
        throw new Error("Invalid transition - may not remove last state in the stack");
      }
      this.states.pop();
    }
    else if (transition.GetTransitionType() === TransitionTypeOptions.Push) {
      this.states.push(transition.GetNewState());
    }
    else if (transition.GetTransitionType() === TransitionTypeOptions.Replace) {
      this.states[this.states.length - 1] = transition.GetNewState();
    }
    else {
      throw new Error("Unsupported transition type: " + transition.GetTransitionType());
    }
    var newColour = this.GetCurrentState().GetColour();
    if (newColour !== previousColour) {
      Log(
        "* " + this.trafficLightId + " changed " + ColourOptions[previousColour] +
        " to " + ColourOptions[newColour]
      );
    }
  }

  private GetCurrentState() {
    return this.states[this.states.length - 1];
  }
}
</code></pre>

<p>The final piece of the puzzle is the equivalent of the <strong>Program</strong> class that drives the simulation in the C# code. This will create an object "tester" that wraps up references to both the North-South and East-West traffic lights in a closure, exposing a method "Advance" which will call "RegisterPassageOfTime" on the lights and, from time-to-time, based on the probabilityOfCarArrivingEachTimeSlice value, call "RegisterCarQueueing" too.</p>

<p>I originally intended to run the code from the command line (using CScript) but thought afterward that it might be worth doing in the browser as well, maybe using that to bolt on some sort of graphical representation of what's happening. Doing it in the browser allows it to be slowed down, too, since tester.Advance may be called through the setInterval method rather than firing full speed as it does at the command line (JavaScript has no Thread.Sleep method!). Note that any sort of "graphical representation" is yet to be implemented, it's text-only for now.</p>

<p>Whether or not it's being hosted in the browser also affects how it logs out its messages - with "console.log" or "WScript.Echo". I've gone for a simple approach in guessing how it's being hosted by presuming that if there is a "window" reference that it's in the browser and at the command line otherwise.</p>

<pre><code>var tester = (function () {
  var probabilityOfCarArrivingEachTimeSlice = 0.1;

  var eastWestTrafficLight: TrafficLight = null;
  var northSouthTrafficLight = new TrafficLight(
    "N-S",
    new RedLightWaitingForTraffic(
      function() {
        return eastWestTrafficLight.GetStatus() === StatusOptions.NotHandlingTraffic;
      }
    )
  );
  eastWestTrafficLight = new TrafficLight(
    "E-W",
    new RedLightWaitingForTraffic(
      function() {
        return northSouthTrafficLight.GetStatus() === StatusOptions.NotHandlingTraffic;
      }
    )
  );

  var allTrafficLights = [ northSouthTrafficLight, eastWestTrafficLight ];
  return {
    Advance: function () {
      for (var i = 0; i &lt; allTrafficLights.length; i++) {
        var trafficLight = allTrafficLights[i];
        if (Math.random() &lt; probabilityOfCarArrivingEachTimeSlice) {
          if (trafficLight.GetColour() === ColourOptions.GreenOnly) {
            Log(
              "Car didn't have to queue " + trafficLight.GetTrafficLightId() +
              ", went straight through"
            );
          }
          else if (trafficLight.GetColour() === ColourOptions.YellowOnly) {
            Log(
              "Car didn't have to queue " + trafficLight.GetTrafficLightId() +
              ", went straight through (naughty!)"
            );
          }
          else {
            Log("Register car queueing " + trafficLight.GetTrafficLightId() + "..");
          }
          trafficLight.RegisterCarQueueing();
        }
      }
      for (var i = 0; i &lt; allTrafficLights.length; i++) {
        allTrafficLights[i].RegisterPassageOfTime();
      }
    }
  };
})();

function IsBrowser(): boolean {
  return (typeof(window) !== "undefined");
}

function Log(message): void {
  if (IsBrowser()) {
    console.log(message);
  }
  else {
    WScript.Echo(message);
  }
}

if (IsBrowser()) {
  setInterval(tester.Advance, 100);
}
else {
  while (true) {
    tester.Advance();
  }
}
</code></pre>

<h2>So how did TypeScript treat me?</h2>

<p>All in all, I've enjoyed this. There were some potential gotchas like the ordering of classes. There's the concern over the public privates. There's no abstract classes or a "protected" keyword, nor are there nested classes, nor can you declare consts. Buut none of these are the end of the world.</p>

<p>When I first tried it out, for some reason I thought that the default behaviour of "==" and "!=" were going to be changed to act as "===" and "!==". This is not the case and I don't think it's the case for <a href="https://www.dartlang.org/">Dart</a> or <a href="http://coffeescript.org/">CoffeeScript</a> either. It <em>is</em> the case for <a href="http://ckknight.github.io/gorillascript/">GorillaScript</a>, which I read about last month. This also has support for optional typing (like TypeScript) but also throws in <em>a lot</em> of other features such as the equality changes I just mentioned (if you really want the JavaScript "==" and "!=" behaviour then you can use "~=" and "!~=" which I'm choosing to read as "wobbly equals" - which seems appropriate!), immutable-by-default (which I <em>love</em> the sound of), constants, generics, promises, all sorts! It even - hold onto your hats for controversy time - uses indentation-based code blocks, rather than curlies (now you know it's crazy! :) I don't know what uptake for this has been like or what sort of support is available but I may well be having a bit of a poke into this at some point.</p>

<p>Back to TypeScript.. I'm fairly sure that this is going to be just an early foray into its abilities for me. I've really liked what I've seen so far and hope to make time to try to use it in more scenarios. Something I really liked, that I found myself doing almost unconsciously to begin with, was not using hungarian notation in the code. Now I know that the idea that I used it <em>at all</em> will make some people a little sick in their mouth but I did feel that it acted as a crutch to document some of my intent when writing in a language without type annotations. I don't do it in C#. And I don't do it in TypeScript!</p>
<p class="PostTime">Posted at 21:03</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/TypeScript" title="6 Posts">TypeScript</a></li></ul></div>
						<p class="Comments">
							<a href="/typescript-state-machines#disqus_thread" data-disqus-identifier="62">Comments</a>
						</p>
				</div>
				<div class="Content ArchiveByMonth">
					<h3 class="PostDate">11 August 2013</h3><h2><a id="Post61"></a><a href="/c-sharp-state-machines">C# State Machines</a></h2>

<p>Not too long ago, I published <a href="/parsing-css">Parsing CSS</a> which talked about how I'd used a form of state machine to traverse the content and how doing so made changing the logic for "changing requirements" much easier -</p>

<blockquote>
  <p>When I started writing it, I somehow forgot all about attribute selectors [..] If this had been processed in some contorted single loop full of complicated interacting conditions [..] then adding that extra set of conditions would have filled me with dread. With this approach, it was no big deal.</p>
</blockquote>

<p>(In this case it wasn't really changing requirements, it was me jumping in head first to try something out, rather than doing as much preparation as I could have.. and then finding I'd forgotten a thing a two).</p>

<p>I didn't start out by deciding to use a state machine, I hadn't written one before and had only a passing familiarity with the term. It just seemed like the best approach and it was only afterwards that I thought it would make sense to see if it was a common pattern and see how close or far away from the standard manner I was with what I'd written.</p>

<p>To be honest, although there is a lot of information available about this pattern, it didn't entirely click with me until I read this: <a href="http://gameprogrammingpatterns.com/state.html">Game Programming Patterns: State</a>. It wasn't that I didn't see the point of them or that I could see much problem in implementing them, it was just.. they just didn't seem to slot very well into how I thought of things. In fact, I was having difficulty just trying to decide if my CSS Parser code could really be considered a state machine at all! But after reading that article, it all fell into place nicely. It's really well-written and the examples manage to demonstrate how quickly complexity escalates (and how this may be handled) while keeping things nice and concise.</p>

<p>Having linked to that article, hopefully what I'm going to write here won't seem redundant :)</p>

<p>Someone who I used to work with (hiya, Pricey!) got in touch with me about my parsing post and said that he'd also been getting to grips with the state machine pattern and we'd talked about using it to describe how a traffic light works. I presume that this is one of those examples that's been around <em>forever</em>. I have a <em>very</em> vague recollection of some interface between a BBC Micro and some sort of Lego-brick-mounted motors and lights and sensors when I was in my last year at primary school - one of the teaching projects was to try to model how a traffic light works. This was a loooooooong time before all those fancy Mindstorms Lego packages became available! And while researching this post, I've found numerous mention of traffic lights in relation to state machine tutorials or exercises.</p>

<p>Anyway... I thought this was a cool idea since a single traffic light is quite a simple prospect, but it could quickly be made increasingly complex by considering multiple sets of traffic lights controlling traffic at a crossroads, for example.</p>

<h3>How do UK Traffic Lights work?</h3>

<p>Traffic light strategies can be extremely complex when lights interact with each other so to begin with we'll just consider modelling a single set of lights controlling traffic flow. It seems like it would be odd to have traffic lights arbitrarily stopping cars if there is no traffic to flow perpendicular to it (whether that be pedestrians trying to cross or other cars at a junction or crossroads) but let's start simple.</p>

<ul>
<li>The default light state is red</li>
<li>If a car arrives at the red light then after a short delay that red light will change to red-and-yellow</li>
<li>After another short delay, it will change to a green light - at this point, cars may pass through</li>
<li>After staying green for some time, it will change to a yellow light - at this point cars shouldn't really go through, but it's not illegal to</li>
<li>The next state is the same as the first state; a red light that won't change until traffic arrives at the light</li>
</ul>

<p>The change from the first state occurs only if car(s) arrive at the light. The other transitions occur only according to the passing of time.</p>

<p>(If there were two sets of traffic lights at a crossroads - with two roads running perpendicular and controlling traffic in both directions on both roads - then the state of the traffic flow on the other road must be considered as well; just because both sets of lights have cars waiting to go doesn't mean they should both transition to green at the same time! But we'll talk about that later on..)</p>

<h3>Modelling</h3>

<p>Let's get straight in with some code. I'm going to declare an interface for a single traffic light state, the implementations of which will be immutable. Then I'll have a <strong>TrafficLight</strong> class which has a mutable state reference and that passes through possible transition triggers for car-has-arrived-at-lights and time-has-passed events. This class will also be used to log when the state visibly changes - eg. "red light to red-and-yellow light". So first the interface..</p>

<pre><code>public interface IAmATrafficLightState
{
  ColourOptions Colour { get; }

  IAmATrafficLightState RegisterCarQueueing();

  /// &lt;summary&gt;
  /// This will represent the passing of an arbitrary slice of time. The "real time" duration of it
  /// is not important, its duration could be decreased or increased to make the simulation proceed
  /// more quickly or more slowly.
  /// &lt;/summary&gt;
  IAmATrafficLightState RegisterPassageOfTime();
}

public enum ColourOptions
{
  GreenOnly,
  RedOnly,
  RedAndYellow,
  YellowOnly
}
</code></pre>

<p>.. and now the wrapper class...</p>

<pre><code>public class TrafficLight
{
  private IAmATrafficLightState _state;
  public TrafficLight(IAmATrafficLightState initialState)
  {
    if (initialState == null)
      throw new ArgumentNullException("initialState");

    _state = initialState;
  }

  public ColourOptions Colour
  {
    get { return _state.Colour; }
  }

  public void RegisterCarQueueing()
  {
    var previousColour = _state.Colour;
    _state = _state.RegisterCarQueueing();
    if (_state.Colour != previousColour)
      Console.WriteLine("* Colour changed from " + previousColour + " to " + _state.Colour);
  }

  /// &lt;summary&gt;
  /// This will represent the passing of an arbitrary slice of time. The "real time" duration of it
  /// is not important, its duration could be decreased or increased to make the simulation proceed
  /// more quickly or more slowly.
  /// &lt;/summary&gt;
  public void RegisterPassageOfTime()
  {
    var previousColour = _state.Colour;
    _state = _state.RegisterPassageOfTime();
    if (_state.Colour != previousColour)
      Console.WriteLine("* Colour changed from " + previousColour + " to " + _state.Colour);
  }
}
</code></pre>

<p>Before I get into how the states will be implemented, here's the app that will drive the simulation. All that happens is a loop periodically calls "trafficLight.RegisterPassageOfTime" and once every ten loops (on average, based on calls to Random.NextDouble) it calls trafficLight.RegisterCarQueueing. This logs when cars arrive at lights and have to stop, and it logs when they pass straight through. The thing only that determines whether they have to stop or whether they pass is the colour of the lights.</p>

<pre><code>class Program
{
  static void Main(string[] args)
  {
    // This controls how fast the simulation proceeds at
    var baseTimeSlice = TimeSpan.FromMilliseconds(100);

    // This is the chance that each time slice a car arrives
    var probabilityOfCarArrivingEachTimeSlice = 0.1;

    var trafficLight = new TrafficLight(new RedLightWaitingForTraffic());
    var rnd = new Random();
    while (true)
    {
      if (rnd.NextDouble() &lt; probabilityOfCarArrivingEachTimeSlice)
      {
        if (trafficLight.Colour == ColourOptions.GreenOnly)
          Console.WriteLine("Car didn't have to queue, went straight through");
        else if (trafficLight.Colour == ColourOptions.YellowOnly)
          Console.WriteLine("Car didn't have to queue, went straight through (naughty!)");
        else
        {
          Console.WriteLine("Register car queuing..");
          trafficLight.RegisterCarQueueing();
        }
      }

      Thread.Sleep(TimeSpan.FromMilliseconds(baseTimeSlice.TotalMilliseconds));

      trafficLight.RegisterPassageOfTime();
    }
  }
}
</code></pre>

<p>The first state is the only that is affected by traffic arriving at the light so we'll address that on its own -</p>

<pre><code>/// &lt;summary&gt;
/// This is a red light that currently has no reason to change. If cars starting queuing up at it
/// then it will transition into starting the colour-change cycle.
/// &lt;/summary&gt;
public class RedLightWaitingForTraffic : IAmATrafficLightState
{
  public ColourOptions Colour { get { return ColourOptions.RedOnly; } }

  public IAmATrafficLightState RegisterCarQueueing()
  {
    return new RedLightAboutToChangeLight();
  }

  public IAmATrafficLightState RegisterPassageOfTime()
  {
    // If all that's happening is that time is ticking along then there is nothing to action here
    return this;
  }
}
</code></pre>

<p>The other states will share a base class that deals with the boring work of wait-a-set-period-of-time-before-transitioning-to-another-state. This will make these states really easy to implement -</p>

<pre><code>public class RedLightAboutToChangeLight : TimeBasedTransitiveState
{
  public const int TIME_TO_STAY_RED_AFTER_CAR_ARRIVES = 10;

  public RedLightAboutToChangeLight() : base(
    TIME_TO_STAY_RED_AFTER_CAR_ARRIVES,
    new RedAndYellowLight()) { }

  public override ColourOptions Colour { get { return ColourOptions.RedOnly; } }
}

public class RedAndYellowLight : TimeBasedTransitiveState
{
  public const int TIME_TO_WAIT_ON_RED_AND_YELLOW = 5;

  public RedAndYellowLight() : base(
    TIME_TO_WAIT_ON_RED_AND_YELLOW,
    new GreenLight()) { }

  public override ColourOptions Colour { get { return ColourOptions.RedAndYellow; } }
}

public class GreenLight : TimeBasedTransitiveState
{
  public const int TIME_TO_STAY_ON_GREEN = 100;

  public GreenLight() : base(
    TIME_TO_STAY_ON_GREEN,
    new YellowLight()) { }

  public override ColourOptions Colour { get { return ColourOptions.GreenOnly; } }
}

public class YellowLight : TimeBasedTransitiveState
{
  private const int TIME_TO_WAIT_ON_YELLOW = 5;

  public YellowLight() : base(
    TIME_TO_WAIT_ON_YELLOW,
    new RedLightWaitingForTraffic()) { }

  public override ColourOptions Colour { get { return ColourOptions.YellowOnly; } }
}
</code></pre>

<p>The <strong>TimeBasedTransitiveState</strong> base class is not particularly taxing, it would just be loads of duplication if wasn't abstracted away. Each time the "RegisterPassageOfTime" method is called on a class that is derived from <strong>TimeBasedTransitiveState</strong>, either a <strong>TimeBasedTransitiveStateInstance</strong> is returned (that has a reference back to the derived class so that the "Colour" property can be reported) or - if the countdown has completed - it returns the "nextState" reference.</p>

<pre><code>/// &lt;summary&gt;
/// This represents a state that is predetermined to change and that may only be affected by the
/// passing of time. Any more cars queuing up at the light will have no effect. This may be a
/// green light that will stay green for a fixed period of time before cycling back through
/// red-and-yellow and then to red.
/// &lt;/summary&gt;
public abstract class TimeBasedTransitiveState : IAmATrafficLightState
{
  private readonly int _timeSlicesToWaitFor;
  private readonly IAmATrafficLightState _nextState;
  protected TimeBasedTransitiveState(int timeSlicesToWaitFor, IAmATrafficLightState nextState)
  {
    if (timeSlicesToWaitFor &lt;= 0)
      throw new ArgumentOutOfRangeException("timeSlicesToWaitFor");
    if (nextState == null)
      throw new ArgumentNullException("nextState");

    _timeSlicesToWaitFor = timeSlicesToWaitFor;
    _nextState = nextState;
  }

  public abstract ColourOptions Colour { get; }

  public IAmATrafficLightState RegisterCarQueueing()
  {
    return this;
  }

  public IAmATrafficLightState RegisterPassageOfTime()
  {
    if (_timeSlicesToWaitFor == 1)
      return _nextState;

    return new TimeBasedTransitiveStateInstance(this, _timeSlicesToWaitFor - 1, _nextState);
  }

  /// &lt;summary&gt;
  /// This is used to describe the states that are passed through while other classes derived from
  /// TimeBasedTransitiveState count down until they are allowed to reach their "nextState"
  /// &lt;/summary&gt;
  private class TimeBasedTransitiveStateInstance : TimeBasedTransitiveState
  {
    public TimeBasedTransitiveStateInstance(
      IAmATrafficLightState source,
      int timeSlicesToWaitFor,
      IAmATrafficLightState nextState) : base(timeSlicesToWaitFor, nextState)
    {
      if (source == null)
        throw new ArgumentNullException("source");

      Source = (source is TimeBasedTransitiveStateInstance)
        ? ((TimeBasedTransitiveStateInstance)source).Source
        : source;
    }

    /// &lt;summary&gt;
    /// This will never be null and will never be a TimeBasedTransitiveStateInstance, it will always
    /// be the state that inherited TimeBasedTransitiveState and that has transitioned into a
    /// TimeBasedTransitiveStateInstance until the timer ticks down
    /// &lt;/summary&gt;
    public IAmATrafficLightState Source { get; private set; }

    public override ColourOptions Colour { get { return Source.Colour; } }
  }
}
</code></pre>

<h2>First pass complete!</h2>

<p>That is actually all of the code required to run a simulation of the traffic light, according the behaviour I described earlier.</p>

<p>It's not all that exciting, though, is it? And it's not immediately obvious why writing this as a state machine would be particularly beneficial. (Although, there is an argument made that by the time you realise that a state machine might me most appropriate that it's too late: <a href="http://www.skorks.com/2011/09/why-developers-never-use-state-machines/">Why Developers Never Use State Machines</a>). So let's ramp up the complexity a bit!</p>

<h3>See you at the crossroads</h3>

<p>Let's paint a picture. There's a road that runs North-South and one that runs East-West. Where they cross, there are traffic lights for both roads. For this example, I'm going to say that both sets of traffic lights work in the same manner as outlined above with one caveat: only one light may be anything other than red at any time. So if one set of lights is anywhere in the red-and-yellow, green, yellow cycle then the other lights must be red. As soon as that first set of lights becomes red again, the other set are elligible to cycle round if traffic requires that they do so.</p>

<p>There are all sorts of variations that could be made instead at this point. If the North-South road is always busier than the East-West road then, to maximise overall throughput, the lights on the North-South road might be configured to default to green unless there is East-West traffic. In America, I believe that you can turn right at crossroads if you're in the right lane, even when they're on red in some (if not all?) circumstances. I don't know if that changes the behaviour of the lights depending upon which lane traffic is in? Traffic light patterns can be further complicated by having different patterns applied at different times of the day and further <em>again</em> if lights at multiple junctions interact with each other - so traffic at one junction can affect other junctions by giving them knowledge of what traffic may be coming towards them. It actually sounds like it could be a really interesting field to work in!</p>

<p>Having an insight into how complex things could get makes the state machine pattern look like a good fit here.</p>

<p>Before I get stuck into the code again, I want to mention one thing that I'm not too happy with in the above code. When the <strong>YellowLight</strong> cycles round it transitions to a new instance of the <strong>RedLightWaitingForTraffic</strong> state. It seems like it would be more efficient to be able to reuse the instance that first cycled round to let traffic through. The Game Programming article I linked talks about using a "pushdown automaton", which really just means a stack for the states. So when the <strong>RedLightWaitingForTraffic</strong> transitions to the <strong>RedLightAboutToChangeLight</strong>, that new state is pushed onto the stack. When that transitions through <strong>RedAndYellowLight</strong>, <strong>GreenLight</strong> and <strong>YellowLight</strong>, these each <em>replace</em> the current state at the top of the stack. When the <strong>YellowLight</strong> state has completed, it pops off the stack, leaving the <strong>RedLightWaitingForTraffic</strong>.</p>

<p>To implement a state stack, instead of returning an <strong>IAmATrafficLight</strong> instance for each "RegisterCarQueueing" and "RegisterPassingOfTime" call, a <strong>StateTransition</strong> will be returned -</p>

<pre><code>public class StateTransition
{
  public static StateTransition NoChange()
  {
    return new StateTransition(TransitionTypeOptions.NoChange, null);
  }
  public static StateTransition Pop()
  {
    return new StateTransition(TransitionTypeOptions.Pop, null);
  }
  public static StateTransition Push(IAmATrafficLightState state)
  {
    if (state == null)
      throw new ArgumentNullException("state");
    return new StateTransition(TransitionTypeOptions.Push, state);
  }
  public static StateTransition Replace(IAmATrafficLightState state)
  {
    if (state == null)
      throw new ArgumentNullException("state");
    return new StateTransition(TransitionTypeOptions.Replace, state);
  }

  private StateTransition(TransitionTypeOptions transitionType, IAmATrafficLightState newState)
  {
    if (!Enum.IsDefined(typeof(TransitionTypeOptions), transitionType))
      throw new ArgumentOutOfRangeException("transitionType");
    if ((transitionType == TransitionTypeOptions.NoChange)
    || (transitionType == TransitionTypeOptions.Pop))
    {
      if (newState != null)
        throw new ArgumentException("newState must be null if transitionType is NoChange or Pop");
    }
    else if (newState == null)
      throw new ArgumentException("newState must be non-null if transitionType is Push or Replace");

    TransitionType = transitionType;
    NewState = newState;
  }

  public enum TransitionTypeOptions
  {
    NoChange,
    Pop,
    Push,
    Replace
  }

  public TransitionTypeOptions TransitionType { get; private set; }

  /// &lt;summary&gt;
  /// This will be null if TransitionType is NoChange or Pop and non-null if TransitionType is
  /// Push or Replace
  /// &lt;/summary&gt;
  public IAmATrafficLightState NewState { get; private set; }
}
</code></pre>

<p>This is going to require a change to the "<strong>TrafficLight</strong> wrapper class but before that I'm going to introduce a change to the <strong>IAmATrafficLightState</strong> interface by adding the property "Status" -</p>

<pre><code>public interface IAmATrafficLightState
{
  ColourOptions Colour { get; }
  StatusOptions Status { get; }

  StateTransition RegisterCarQueueing();
  StateTransition RegisterPassageOfTime();
}

public enum StatusOptions
{
  HandlingTraffic,
  NotHandlingTraffic
}
</code></pre>

<p>If the North-South <strong>TrafficLight</strong> instance is currently in a state that reports that it is "HandlingTraffic" then the East-West <strong>TrafficLight</strong> may not be in any state that does not indicate a red light (and vice versa).</p>

<p>This "Status" will be easy to add to the states we've already defined. Anything other than the <strong>RedLightWaitingForTraffic</strong> will have the Status "HandlingTraffic" (including <strong>RedLightAboutToChangeLight</strong> since, by the point at which that state has been reached, the traffic light is committed to going through a full cycle). <strong>RedLightWaitingForTraffic</strong> will have the status "NotHandlingTraffic" since traffic is not actually passing through the lights (or about to pass through) so any dependent lights are free to change.</p>

<p>Two additional states need to be added to smoothly integrate this new status data, however. The first is the <strong>RedLightWaitingForAccess</strong> state. Previously, the pattern to change from red was as follows</p>

<ul>
<li>The state is <strong>RedLightWaitingForTraffic</strong></li>
<li>Car(s) arrive</li>
<li>State changes to <strong>RedLightAboutToChangeLight</strong></li>
<li>A short delay occurs</li>
<li>State changes to <strong>RedAndYellowLight</strong></li>
<li>A short delay occurs</li>
<li>etc..</li>
</ul>

<p>I'm not entirely sure <em>why</em> there is this short delay before changing to red-and-yellow with real-life traffic lights. I'm not sure if it's something to do with traffic calming, whether it improves traffic flow in a non-intuitive manner, whether it's about ensuring that drivers assume they will always have to come to a full stop when approaching a red light or if there's another explanation. What I <em>do</em> know, though, is that if traffic is already queued up at a crossroads' red light since the other road has traffic passing, then this delay should be removed. When the other road changes to red, the traffic lights for the road with backed-up cars should be able to transtion straight to red-and-yellow.</p>

<p>The <strong>RedLightWaitingForAccess</strong> covers this case. It is not affected by more cars arriving at the lights but each time slice it will check the status of the other road's lights and change state to <strong>RedAndYellowLight</strong> as soon as those other lights report "NotHandlingTraffic".</p>

<p>The other new state is the <strong>RedLightPausedBeforeWaitingForTraffic</strong>. A <strong>YellowLight</strong> will transition to this before returning to <strong>RedLightWaitingForTraffic</strong>. This imposes a short delay on a set of traffic lights which guarantees that it will stay in a state with status "NotHandlingTraffic" after allowing through traffic. This will ensure that traffic lights on the other road can transition if required, even if a car arrives at the set of traffic lights that just cycled round. Essentially, it makes sure that if traffic is trying to pass both North-South and East-West then the roads "take turns" in allowing traffic to pass.</p>

<h3>The new code</h3>

<p>To work with the new <strong>IAmATrafficLightState</strong> interface and to add support for a "state stack", the <strong>TrafficLight</strong> wrapper class will need to be updated -</p>

<pre><code>public class TrafficLight
{
  private readonly Stack&lt;IAmATrafficLightState&gt; _states;
  public TrafficLight(string trafficLightId, IAmATrafficLightState initialState)
  {
    if (string.IsNullOrWhiteSpace(trafficLightId))
      throw new ArgumentNullException("Null/blank trafficLightId specified");
    if (initialState == null)
      throw new ArgumentNullException("initialState");

    TrafficLightId = trafficLightId.Trim();
    _states = new Stack&lt;IAmATrafficLightState&gt;();
    _states.Push(initialState);
  }

  public string TrafficLightId { get; private set; }

  public ColourOptions Colour
  {
    get { return _states.Peek().Colour; }
  }

  public StatusOptions Status
  {
    get { return _states.Peek().Status; }
  }

  public void RegisterCarQueueing()
  {
    ApplyTransition(_states.Peek().RegisterCarQueueing());
  }

  public void RegisterPassageOfTime()
  {
    ApplyTransition(_states.Peek().RegisterPassageOfTime());
  }

  private void ApplyTransition(StateTransition transition)
  {
    if (transition == null)
      throw new ArgumentNullException("transition");

    var previousColour = _states.Peek().Colour;
    if (transition.TransitionType == StateTransition.TransitionTypeOptions.NoChange)
    {
      // Do nothing
    }
    else if (transition.TransitionType == StateTransition.TransitionTypeOptions.Pop)
    {
      if (_states.Count == 1)
        throw new ArgumentException("Invalid transition - may not remove last state in the stack");
      _states.Pop();
    }
    else if (transition.TransitionType == StateTransition.TransitionTypeOptions.Push)
      _states.Push(transition.NewState);
    else if (transition.TransitionType == StateTransition.TransitionTypeOptions.Replace)
    {
      _states.Pop();
      _states.Push(transition.NewState);
    }
    else
      throw new ArgumentException("Unsupported transition type: " + transition.TransitionType);
    var newColour = _states.Peek().Colour;
    if (newColour != previousColour)
      Console.WriteLine("* " + TrafficLightId + " changed " + previousColour + " to " + newColour);
  }
}
</code></pre>

<p>I've included a "TrafficLightId" property so that the console messages indicate <em>which</em> traffic light has changed colour. The code that is common for each state change event has been pulled out into its own method and the class also exposes the new "Status" property. It's not valid for the state stack to ever be empty (since that would indicate that it has no state, which makes no sense - this is guaranteed by the code in this class) and so the Colour and Status values can be taken by looking at the state at the top of the stack.</p>

<p>The <strong>RedLightWaitingForTraffic</strong> requires three changes. Firstly to return <strong>StateTransition</strong> instances from its "RegisterCarQueueing" and "RegisterPassageOfTime" methods instead of <strong>IAmATrafficLightState</strong> implementations. Secondly to expose the new <strong>IAmATrafficLightState</strong> Status property. And thirdly to accept a filter that may prevent it from allowing traffic through at any given time.</p>

<p>This filter is what prevents the North-South road traffic lights from changing from red if the East-West road is currently allowing through traffic. If cars are queuing at lights but the lights may not change colour at this time, then the state changes from <strong>RedLightWaitingForTraffic</strong> to the new <strong>RedLightWaitingForAccess</strong> state. If they <em>are</em> able to change then they proceed as before.</p>

<pre><code>public class RedLightWaitingForTraffic : IAmATrafficLightState
{
  private readonly Func&lt;bool&gt; _isAllowedToLetTrafficThrough;
  public RedLightWaitingForTraffic(Func&lt;bool&gt; isAllowedToLetTrafficThrough)
  {
    if (isAllowedToLetTrafficThrough == null)
      throw new ArgumentNullException("isAllowedToLetTrafficThrough");

    _isAllowedToLetTrafficThrough = isAllowedToLetTrafficThrough;
  }

  public ColourOptions Colour { get { return ColourOptions.RedOnly; } }
  public StatusOptions Status { get { return StatusOptions.NotHandlingTraffic; } }

  public StateTransition RegisterCarQueueing()
  {
    if (_isAllowedToLetTrafficThrough())
      return StateTransition.Push(new RedLightAboutToChange());

    return StateTransition.Push(new RedLightWaitingForAccess(_isAllowedToLetTrafficThrough));
  }

  public StateTransition RegisterPassageOfTime()
  {
    return StateTransition.NoChange();
  }
}
</code></pre>

<p>The new <strong>RedLightWaitingForAccess</strong> state will just try to proceed to the <strong>RedAndYellowLight</strong> state each time slice, if the filter allows it. Otherwise it has to stay as it is.</p>

<pre><code>public class RedLightWaitingForAccess : IAmATrafficLightState
{
  private readonly Func&lt;bool&gt; _isAllowedToLetTrafficThrough;
  public RedLightWaitingForAccess(Func&lt;bool&gt; isAllowedToLetTrafficThrough)
  {
    if (isAllowedToLetTrafficThrough == null)
      throw new ArgumentNullException("isAllowedToLetTrafficThrough");

    _isAllowedToLetTrafficThrough = isAllowedToLetTrafficThrough;
  }

  public ColourOptions Colour { get { return ColourOptions.RedOnly; } }
  public StatusOptions Status { get { return StatusOptions.NotHandlingTraffic; } }

  public StateTransition RegisterCarQueueing()
  {
    // We can't do anything here, we're already waiting
    return StateTransition.NoChange();
  }

  public StateTransition RegisterPassageOfTime()
  {
    if (_isAllowedToLetTrafficThrough())
      return StateTransition.Replace(new RedAndYellowLight());

    return StateTransition.NoChange();
  }
}
</code></pre>

<p>The other states require only minor changes to implement the new interface (note that I've snuck in the other new state here, the <strong>RedLightPausedBeforeWaitingForTraffic</strong>) -</p>

<pre><code>public class RedLightAboutToChange : TimeBasedTransitiveState
{
  public const int TIME_TO_STAY_RED_AFTER_CAR_ARRIVES = 10;

  public RedLightAboutToChange() : base(
    TIME_TO_STAY_RED_AFTER_CAR_ARRIVES,
    StateTransition.Replace(new RedAndYellowLight())) { }

  public override ColourOptions Colour { get { return ColourOptions.RedOnly; } }

  /// &lt;summary&gt;
  /// We're committed to letting traffic pass at this point so declare HandlingTraffic
  /// &lt;/summary&gt;
  public override StatusOptions Status { get { return StatusOptions.HandlingTraffic; } }
}

public class RedAndYellowLight : TimeBasedTransitiveState
{
  public const int TIME_TO_WAIT_ON_RED_AND_YELLOW = 5;

  public RedAndYellowLight() : base(
    TIME_TO_WAIT_ON_RED_AND_YELLOW,
    StateTransition.Replace(new GreenLight())) { }

  public override ColourOptions Colour { get { return ColourOptions.RedAndYellow; } }
  public override StatusOptions Status { get { return StatusOptions.HandlingTraffic; } }
}

public class GreenLight : TimeBasedTransitiveState
{
  public const int TIME_TO_STAY_ON_GREEN = 100;

  public GreenLight() : base(
    TIME_TO_STAY_ON_GREEN,
    StateTransition.Replace(new YellowLight())) { }

  public override ColourOptions Colour { get { return ColourOptions.GreenOnly; } }
  public override StatusOptions Status { get { return StatusOptions.HandlingTraffic; } }
}

public class YellowLight : TimeBasedTransitiveState
{
  private const int TIME_TO_WAIT_ON_YELLOW = 5;

  public YellowLight() : base(
    TIME_TO_WAIT_ON_YELLOW,
    StateTransition.Replace(new RedLightPausedBeforeWaitingForTraffic())) { }

  public override ColourOptions Colour { get { return ColourOptions.YellowOnly; } }
  public override StatusOptions Status { get { return StatusOptions.HandlingTraffic; } }
}

public class RedLightPausedBeforeWaitingForTraffic : TimeBasedTransitiveState
{
  private const int TIME_AFTER_RESETTING_TO_RED_BEFORE_CONSIDERING_TRAFFIC = 5;

  public RedLightPausedBeforeWaitingForTraffic() : base(
    TIME_AFTER_RESETTING_TO_RED_BEFORE_CONSIDERING_TRAFFIC,
    StateTransition.Pop()) { }

  public override ColourOptions Colour { get { return ColourOptions.RedOnly; } }
  public override StatusOptions Status { get { return StatusOptions.NotHandlingTraffic; } }
}
</code></pre>

<p>The <strong>TimeBasedTransitiveState</strong> code requires only minor tweaks (since I've gone for a code-heavy post, I thought I might as well include everything! :)</p>

<pre><code>public abstract class TimeBasedTransitiveState : IAmATrafficLightState
{
  private readonly int _timeSlicesToWaitFor;
  private readonly StateTransition _nextState;
  protected TimeBasedTransitiveState(int timeSlicesToWaitFor, StateTransition nextState)
  {
    if (timeSlicesToWaitFor &lt;= 0)
      throw new ArgumentOutOfRangeException("timeSlicesToWaitFor");
    if (nextState == null)
      throw new ArgumentNullException("nextState");

    _timeSlicesToWaitFor = timeSlicesToWaitFor;
    _nextState = nextState;
  }

  public abstract ColourOptions Colour { get; }
  public abstract StatusOptions Status { get; }

  public StateTransition RegisterCarQueueing()
  {
    return StateTransition.NoChange();
  }

  public StateTransition RegisterPassageOfTime()
  {
    if (_timeSlicesToWaitFor == 1)
      return _nextState;

    return StateTransition.Replace(
      new TimeBasedTransitiveStateInstance(this, _timeSlicesToWaitFor - 1, _nextState)
    );
  }

  private class TimeBasedTransitiveStateInstance : TimeBasedTransitiveState
  {
    public TimeBasedTransitiveStateInstance(
      IAmATrafficLightState source,
      int timeSlicesToWaitFor,
      StateTransition nextState) : base(timeSlicesToWaitFor, nextState)
    {
      if (source == null)
        throw new ArgumentNullException("source");

      Source = (source is TimeBasedTransitiveStateInstance)
        ? ((TimeBasedTransitiveStateInstance)source).Source
        : source;
    }

    public IAmATrafficLightState Source { get; private set; }

    public override ColourOptions Colour { get { return Source.Colour; } }
    public override StatusOptions Status { get { return Source.Status; } }
  }
}
</code></pre>

<p>The tester app now has to instantiate two <strong>TrafficLight</strong> instances and update them both. It has to be able to pass a filter to each of the initial <strong>RedLightWaitingForTraffic</strong> instances (one for the North-South route and one for East-West) but that's simple; it need only look at the Status of the other lights and allow traffic if the other Status reports "NotHandlingTraffic".</p>

<pre><code>class Program
{
  static void Main(string[] args)
  {
    // This controls how fast the simulation proceeds at
    var baseTimeSlice = TimeSpan.FromMilliseconds(100);

    // This is the chance that each time slice a car arrives
    var probabilityOfCarArrivingEachTimeSlice = 0.1;

    // The eastWestTrafficLight reference is required by the isAllowedToLetTrafficThrough filter
    // passed to the initial RedLightWaitingForTraffic state for the North-South traffic light so
    // it has to be set to something (otherwise we'll get a compiler error). At this point that
    // has to be null but it will be set to the real value immediately after. The filter won't be
    // used until the RegisterCarQueueing and RegisterPassageOfTime methods are called, so it
    // doesn't matter that the filter temporarily has a null reference.
    TrafficLight eastWestTrafficLight = null;
    var northSouthTrafficLight = new TrafficLight(
      "N-S",
      new RedLightWaitingForTraffic(
        () =&gt; (eastWestTrafficLight.Status == StatusOptions.NotHandlingTraffic)
      )
    );
    eastWestTrafficLight = new TrafficLight(
      "E-W",
      new RedLightWaitingForTraffic(
        () =&gt; (northSouthTrafficLight.Status == StatusOptions.NotHandlingTraffic)
      )
    );

    var allTrafficLights = new[] { northSouthTrafficLight, eastWestTrafficLight };
    var rnd = new Random();
    while (true)
    {
      foreach (var trafficLight in allTrafficLights)
      {
        if (rnd.NextDouble() &lt; probabilityOfCarArrivingEachTimeSlice)
        {
            if (trafficLight.Colour == ColourOptions.GreenOnly)
            {
              Console.WriteLine(
                "Car didn't have to queue {0}, went straight through",
                trafficLight.TrafficLightId
              );
            }
            else if (trafficLight.Colour == ColourOptions.YellowOnly)
            {
              Console.WriteLine(
                "Car didn't have to queue {0}, went straight through (naughty!)",
                trafficLight.TrafficLightId
              );
            }
            else
            {
              Console.WriteLine("Register car queuing {0}..", trafficLight.TrafficLightId);
              trafficLight.RegisterCarQueueing();
            }
        }
      }

      Thread.Sleep(TimeSpan.FromMilliseconds(baseTimeSlice.TotalMilliseconds));

      foreach (var trafficLight in allTrafficLights)
        trafficLight.RegisterPassageOfTime();
    }
  }
}
</code></pre>

<h3>Win?</h3>

<p>It might look like quite a lot of code since I've decided to include <em>all</em> of the code here. But there wasn't that much new code required to go from supporting the simple one-traffic-light example to the more complex configuration. And at each step, it's easy to see what exactly is going on and how the various interactions are being handled.</p>

<p>That's the real benefit of the state machine pattern, adding complexity is much cheaper than it is with more naive approaches. If we wanted to add <em>another</em> set of lights here (maybe there's a pedestrian crossing) then doing so wouldn't blow up the code complexity. Even if we bear in mind the fact that pedestrian crossing lights have different rules to traffic lights (there's only a red man and a green man - or "walk" and "don't walk", if you prefer - there's no yellow light).</p>

<p>Another interesting pattern would be to vary the length that the green light stays on for, depending upon the traffic pressure building up on the other road. This might require a way to pass a "pressure retriever" reference through to the <strong>GreenLight</strong> (similar to the is-access-allowed delegate that the <strong>RedLightWaitingForTraffic</strong> and <strong>RedLightWaitingForAccess</strong> states have, but with a sliding scale rather than a simple yes-or-no), but all of the complexity would be contained within that <strong>GreenLight</strong> state.</p>

<p>It's also worth noting that the mutability of the data is tightly restricted to the <strong>TrafficLight</strong> class and the "isAllowedToLetTrafficThrough" delegates. As always, this makes reasoning about the behaviour of the code much easier and can make the solution more robust. If a model was created where events would be raised on different threads then the number of places which would have to explicitly deal with access from different threads would be limited as it is only places where data is mutated that multi-threaded access tends to pose a problem. It makes me happy when I find even more reassurance that immutability is the way forward :)</p>

<p>So now all I have to do is try to look out for more times when this pattern will be appropriate (and try to avoid trying to crowbar it into places where it isn't)!</p>
<p class="PostTime">Posted at 23:45</p>
						<p class="Comments">
							<a href="/c-sharp-state-machines#disqus_thread" data-disqus-identifier="61">Comments</a>
						</p>
				</div>

				<script type="text/javascript">
					(function () {
						var s = document.createElement("script");
						s.type = "text/javascript";
						s.async = true;
						s.src = "https://" + disqus_shortname + ".disqus.com/count.js";
						(document.getElementsByTagName("HEAD")[0] || document.getElementsByTagName("BODY")[0]).appendChild(s);
					} ());
				</script>

				<div class="Footer">
					Productive Rage 2016
				</div>
			</div>

			<div class="SideBar">
				<div class="About">
					<h2>About</h2>
					<p>Dan is a big geek who likes making stuff with computers! He can be quite outspoken so clearly needs a blog :)</p>
					<p>In the last few minutes he seems to have taken to referring to himself in the third person. He's quite enjoying it.</p>
					<p><a href="mailto:dangger36@gmail.com" class="Email">dangger36@gmail.com</a></p>

				</div>
				<div class="Search">
<form action="/Search" method="get" />						<div>
							<input type="text" class="SiteSearch" name="term" value="" />
							<input type="submit" class="SiteSearchSubmit" value="Search" />
						</div>
</form>				</div>
				<div class="Recent"><h2>Recent Posts</h2><ul><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li><li><a href="/retrieving-performance-counter-from-a-remote-pc-using-c-sharp">Retrieving Performance Counter from a remote PC using C#</a></li><li><a href="/why-is-saving-performance-monitor-perfmon-settings-so-difficult-these-days">Why is saving Performance Monitor (PerfMon) settings so difficult these days?!</a></li><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li></ul><div class="RSSFeedLink"><a href="http://www.productiverage.com/feed">RSS Feed</a></div></div>
				<div class="Featured"><h2>Highlights</h2><ul><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/translating-vbscript-into-c-sharp">Translating VBScript into C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div>
				<div class="History"><h2>Archives</h2><ul><li><a href="/Archive/9/2016">September 2016 (2)</a></li><li><a href="/Archive/8/2016">August 2016 (1)</a></li><li><a href="/Archive/7/2016">July 2016 (1)</a></li><li><a href="/Archive/6/2016">June 2016 (1)</a></li><li><a href="/Archive/5/2016">May 2016 (3)</a></li><li><a href="/Archive/3/2016">March 2016 (3)</a></li><li><a href="/Archive/2/2016">February 2016 (2)</a></li><li><a href="/Archive/12/2015">December 2015 (1)</a></li><li><a href="/Archive/11/2015">November 2015 (2)</a></li><li><a href="/Archive/8/2015">August 2015 (3)</a></li><li><a href="/Archive/7/2015">July 2015 (1)</a></li><li><a href="/Archive/6/2015">June 2015 (1)</a></li><li><a href="/Archive/5/2015">May 2015 (2)</a></li><li><a href="/Archive/4/2015">April 2015 (1)</a></li><li><a href="/Archive/3/2015">March 2015 (1)</a></li><li><a href="/Archive/1/2015">January 2015 (2)</a></li><li><a href="/Archive/12/2014">December 2014 (1)</a></li><li><a href="/Archive/11/2014">November 2014 (1)</a></li><li><a href="/Archive/10/2014">October 2014 (2)</a></li><li><a href="/Archive/9/2014">September 2014 (2)</a></li><li><a href="/Archive/8/2014">August 2014 (1)</a></li><li><a href="/Archive/7/2014">July 2014 (1)</a></li><li><a href="/Archive/6/2014">June 2014 (1)</a></li><li><a href="/Archive/5/2014">May 2014 (2)</a></li><li><a href="/Archive/2/2014">February 2014 (1)</a></li><li><a href="/Archive/1/2014">January 2014 (1)</a></li><li><a href="/Archive/12/2013">December 2013 (1)</a></li><li><a href="/Archive/11/2013">November 2013 (1)</a></li><li><a href="/Archive/10/2013">October 2013 (1)</a></li><li><a href="/Archive/8/2013">August 2013 (3)</a></li><li><a href="/Archive/7/2013">July 2013 (3)</a></li><li><a href="/Archive/6/2013">June 2013 (1)</a></li><li><a href="/Archive/5/2013">May 2013 (2)</a></li><li><a href="/Archive/4/2013">April 2013 (1)</a></li><li><a href="/Archive/3/2013">March 2013 (8)</a></li><li><a href="/Archive/2/2013">February 2013 (2)</a></li><li><a href="/Archive/1/2013">January 2013 (2)</a></li><li><a href="/Archive/12/2012">December 2012 (3)</a></li><li><a href="/Archive/11/2012">November 2012 (4)</a></li><li><a href="/Archive/9/2012">September 2012 (1)</a></li><li><a href="/Archive/8/2012">August 2012 (1)</a></li><li><a href="/Archive/7/2012">July 2012 (3)</a></li><li><a href="/Archive/6/2012">June 2012 (3)</a></li><li><a href="/Archive/5/2012">May 2012 (2)</a></li><li><a href="/Archive/2/2012">February 2012 (3)</a></li><li><a href="/Archive/1/2012">January 2012 (4)</a></li><li><a href="/Archive/12/2011">December 2011 (7)</a></li><li><a href="/Archive/8/2011">August 2011 (2)</a></li><li><a href="/Archive/7/2011">July 2011 (1)</a></li><li><a href="/Archive/5/2011">May 2011 (1)</a></li><li><a href="/Archive/4/2011">April 2011 (2)</a></li><li><a href="/Archive/3/2011">March 2011 (3)</a></li></ul><div class="EveryTitle"><a href="/Archive/All">Every Post Title</a></div></div>
			</div>

		</div>
	</div>

	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
	<script type="text/javascript" src="/Scripts/jquery.autocomplete.min.js"></script>
	<script type="text/javascript" src="/Scripts/prettify.js"></script>
	<script type="text/javascript" src="/Scripts/Site.js"></script>
	<script type="text/javascript" src="/Scripts/IndexSearchGenerator.js"></script>
	<script type="text/javascript" src="/Scripts/SearchTermHighlighter.js"></script>
	<script type="text/javascript" src="/Scripts/SearchPage.js"></script>
	<script type="text/javascript" src="/Scripts/LZString.js"></script>

</body>
</html>
