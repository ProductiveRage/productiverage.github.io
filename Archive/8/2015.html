<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Productive Rage - August 2015</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta name="theme-color" content="#393939" />
	<link rel="stylesheet" type="text/css" media="all" href="/Content/Styles.css" />
	<link rel="stylesheet" type="text/css" media="print" href="/Content/PrintOverrides.css" />
	<meta name="robots" content="noindex, follow" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.productiverage.com/feed" />
	<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-WRKSEZTFBP"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag("js", new Date());
		gtag("config", "G-WRKSEZTFBP");
	</script>
	<script type="text/javascript">
		var darkModeEnabledLocalStorageKey = "DarkMode";
		var darkModeHtmlWrapperClassName = "DarkMode";
		function IsDarkModeEnabled() {
			return localStorage.getItem(darkModeEnabledLocalStorageKey) !== null;
		}
		if (IsDarkModeEnabled()) {
			document.querySelector("html").classList.add(darkModeHtmlWrapperClassName);
		}
	</script>

    <meta name="description" content="Archive for August 2015" />
</head>

<body>

	<div class="Header">
		<div class="HeaderContent">
			<h1>
				<a href="/">Productive Rage</a>
			</h1>
			<span class="Tagline">Dan's techie ramblings</span>
		</div>
	</div>

	<div class="WrapperOuter">
		<div class="Wrapper">
			<div class="Main HasSideBar">
				

        <script type="text/javascript">
            var disqus_shortname = "productiverage";
            document.addEventListener(
                "DOMContentLoaded",
                function () {
                    var commentsLinks = document.querySelectorAll("div.Content p.Comments");
                    for (var i = 0; i < commentsLinks.length; i++) {
                        commentsLinks[i].style.display = "block";
                    }
                }
            );
        </script>

    <div class="Content ArchiveByMonth">
        <span class="PostDate">19 August 2015</span><h2 id="strongly-typed-react-with-bridge.net"><a href="/stronglytyped-react-with-bridgenet">Strongly-typed React (with Bridge.net)</a></h2>
<p>A few weeks ago, I wrote about using <a href="/react-and-flux-with-bridgenet">React with Bridge.net</a>. I described that I'd only written the bare minimum of bindings required to get my samples working - so, while I had a function for React.DOM.div -</p>
<pre><code>[Name(&quot;div&quot;)]
public extern static ReactElement Div(
  HTMLAttributes properties,
  params ReactElementOrText[] children
);
</code></pre>
<p>The <strong>HTMLAttributes</strong> class I had written really was the <em>bare</em> minimum:</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class HTMLAttributes
{
  public string className;
}
</code></pre>
<p>It's time to revisit this and build up my bindings library!</p>
<h3 id="a-starting-point"><a href="/stronglytyped-react-with-bridgenet#a-starting-point">A starting point</a></h3>
<p>An obvious resource to work from initially is the &quot;<a href="https://github.com/borisyankov/DefinitelyTyped/blob/master/react/react.d.ts">DefinitelyTyped</a>&quot; bindings that allow you to use React from TypeScript. But I'd identified a pattern that I didn't like with them in my earlier post - the type system isn't being used to as full effect as it could be. For example, in the declaration of &quot;input&quot; elements. Let me explain (and please bear with me, I need to go through a few steps to get to the point)..</p>
<p>The TypeScript bindings describe a function for creating input elements:</p>
<pre><code>React.DOM.input(props: HTMLAttributes, ...children: ReactNode[]): DOMElement
</code></pre>
<p>For any non-TypeScripters, this is a function that takes an argument named &quot;props&quot; that is of type <strong>HTMLAttributes</strong>, and then 0, 1, .. n arguments of type <strong>ReactNode</strong> that are wrapped up into an array (the same principle as &quot;params&quot; arguments in C#). It returns a <strong>DOMElement</strong> instance.</p>
<p><strong>HTMLAttributes</strong> has 115 of its own properties (such as &quot;className&quot;, &quot;disabled&quot; and &quot;itemScope&quot; - to take three at random) and extends <strong>DOMAttributes</strong>, which has 34 more properties (such as &quot;onChange&quot; and &quot;onDragStart&quot;).</p>
<p>The &quot;onChange&quot; property is a <strong>FormEventHandler</strong>, which is derived from <strong>EventHandler&lt;FormEvent&gt;</strong>, where <strong>EventHandler&lt;E&gt;</strong> is a delegate which has a single &quot;event&quot; argument of type &quot;E&quot; which returns no value. It's a callback, in other words.</p>
<p>This looks promising and is, on the whole, a good use of TypeScript's generics system.</p>
<p>However, I don't think it uses this system <em>enough</em>. The <strong>FormEvent</strong> (that the &quot;onChange&quot; property passes in the callback) is a specialisation of a <strong>SyntheticEvent</strong> type:</p>
<pre><code>interface FormEvent extends SyntheticEvent { }

interface SyntheticEvent {
  bubbles: boolean;
  cancelable: boolean;
  currentTarget: EventTarget;
  defaultPrevented: boolean;
  eventPhase: number;
  isTrusted: boolean;
  nativeEvent: Event;
  preventDefault(): void;
  stopPropagation(): void;
  target: EventTarget;
  timeStamp: Date;
  type: string;
}
</code></pre>
<p><em>(The <strong>EventTarget</strong>, which is what the &quot;target&quot; property is an instance of, is a DOM concept and is not a type defined by the React bindings, it just means that it is one of the DOM elements that are able to raise events).</em></p>
<p>The problem I have is that if we write code such as</p>
<pre><code>React.DOM.input({
  value: &quot;hi&quot;
  onChange: e =&gt; { alert(e.target.value); }
})
</code></pre>
<p>Then we'll get a TypeScript compile error because &quot;e.target&quot; is only known to be of type <strong>EventTarget</strong>, it is <em>not</em> known to be an input element and so it is <em>not</em> known to have a &quot;value&quot; property. But we're specifying this &quot;onChange&quot; property <em>while declaring an input element</em>.. the type system <em>should</em> know that the &quot;e.target&quot; reference will be an input!</p>
<p>In fact, in TypeScript, we actually have to skirt around the type system to make it work:</p>
<pre><code>// &quot;&lt;any&gt;&quot; means cast the &quot;e.target&quot; reference to the magic type &quot;any&quot;, which
// is like &quot;dynamic&quot; in C# - you can specify any property or method and the
// compiler will assume you know what you're doing and allow it (resulting
// in a runtime exception if you get it wrong)
React.DOM.input({
  value: &quot;hi&quot;
  onChange: e =&gt; { alert((&lt;any&gt;e.target).value); }
})
</code></pre>
<p>In my React bindings for <a href="http://bridge.net/">Bridge</a> I improved this by defining an <strong>InputAttributes</strong> type:</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class InputAttributes : HTMLAttributes
{
  public Action&lt;FormEvent&lt;InputEventTarget&gt;&gt; onChange;
  public string value;
}
</code></pre>
<p>And having a generic <strong>FormEvent&lt;T&gt;</strong> which inherits from <strong>FormEvent</strong> -</p>
<pre><code>[Ignore]
public class FormEvent&lt;T&gt; : FormEvent where T : EventTarget
{
  public new T target;
}
</code></pre>
<p>This means that the &quot;target&quot; property can be typed more specifically. And so, when you're writing this sort of code in C# with Bridge.net, you <em>can</em> write things like:</p>
<pre><code>// No nasty casts required! The type system knows that &quot;e.target&quot; is an
// &quot;InputEventTarget&quot; and therefore knows that it has a &quot;value&quot; property
// that is a string.
DOM.Input(new InputAttributes
{
  value = &quot;hi&quot;,
  onChange = e =&gt; Global.Alert(e.target.value)
})
</code></pre>
<p>This is great stuff! And I'm not changing how React works in any way, I'm just changing how we interpret the data that React is communicating; the event reference in the input's &quot;onChange&quot; callback has always had a &quot;target&quot; which had a &quot;value&quot; property, it's just that the TypeScript bindings don't tell us this through the type system.</p>
<p>So that's all good.. but it did require me to write more code for the bindings. The <strong>InputEventTarget</strong> class, for example, is one I had to define:</p>
<pre><code>[Ignore]
public class InputEventTarget : EventTarget
{
  public string value;
}
</code></pre>
<p>And I've already mentioned having to define the <strong>FormEvent&lt;T&gt;</strong> and <strong>InputAttributes</strong> classes..</p>
<p>What I'm saying is that these improvements do not come for free, they required some analysis and some further effort putting into the bindings (which is not to take anything away from DefinitelyTyped, by the way - I'm a big fan of the work in that repository and I'm very glad that it's available, both for TypeScript / React work I've done in the past <em>and</em> to use as a starting point for Bridge bindings).</p>
<p>Seeing how these more focussed / specific classes can improve things, I come to my second problem with the TypeScript bindings..</p>
<h3 id="why-must-the-htmlattributes-have-almost-150-properties"><a href="/stronglytyped-react-with-bridgenet#why-must-the-htmlattributes-have-almost-150-properties">Why must the HTMLAttributes have almost 150 properties??</a></h3>
<p>The place that I wanted to start in extending my (very minimal) bindings was in fleshing out the <strong>HTMLAttributes</strong> class. Considering that it had only a single property (&quot;className&quot;) so far, and that it would be used by so many element types, that seemed like a reasonable plan. But looking at the TypeScript binding, I felt like I was drowning in properties.. I realised that I wasn't familiar with <em>everything</em> that appeared in html5, but I was astonished by how many options there were - and convinced that they couldn't <em>all</em> be applicable to <em>all</em> elements types. So I picked one at random, of those that stood out as being completely unfamiliar to me: &quot;download&quot;.</p>
<p>w3schools has this to say about the <a href="http://www.w3schools.com/tags/att_a_download.asp">HTML &lt;a&gt; download Attribute</a>:</p>
<blockquote>
<p>The download attribute is new for the &lt;a&gt; tag in HTML5.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>The download attribute specifies that the target will be downloaded when a user clicks on the hyperlink.<br />
This attribute is only used if the href attribute is set.<br />
The value of the attribute will be the name of the downloaded file. There are no restrictions on allowed values, and the browser will automatically detect the correct file extension and add it to the file (.img, .pdf, .txt, .html, etc.).</p>
</blockquote>
<p>So it appears that this attribute is only applicable to anchor tags. Therefore, it would make more sense to <em>not</em> have a &quot;React.DOM.a&quot; function such as:</p>
<pre><code>[Name(&quot;a&quot;)]
public extern static ReactElement A(
  HTMLAttributes properties,
  params ReactElementOrText[] children
);
</code></pre>
<p>and, like the &quot;input&quot; function, to be more specific and create a new &quot;attributes&quot; type. So the function would be better as:</p>
<pre><code>[Name(&quot;a&quot;)]
public extern static ReactElement A(
  AnchorAttributes properties,
  params ReactElementOrText[] children
);
</code></pre>
<p>and the new type would be something like:</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class AnchorAttributes : HTMLAttributes
{
  public string download;
}
</code></pre>
<p>This would allow the &quot;download&quot; property to be pulled out of <strong>HTMLAttributes</strong> (so that it couldn't be a applied to a &quot;div&quot;, for example, where it has no meaning).</p>
<p>So one down! Many, many more to go..</p>
<p>Some properties are applicable to multiple element types, but these elements may not have anything else in common. As such, I think it would be more sensible to duplicate some properties in multiple attributes classes, rather than trying to come up with a complicated inheritance tree that tries to avoid any repeating of properties, at the cost of the complexities that inheritance can bring. For example, &quot;href&quot; is a valid attribute for both &quot;a&quot; and &quot;link&quot; tags, but these elements do not otherwise have much in common - so it might be better to have completely distinct classes</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class AnchorAttributes : HTMLAttributes
{
  public string href;
  public string download;
  // .. and other attributes specified to anchor tags
}

[Ignore]
[ObjectLiteral]
public class LinkAttributes : HTMLAttributes
{
  public string href;
  // .. and other attributes specified to link tags
}
</code></pre>
<p>than to try to create a base class</p>
<pre><code>[Ignore]
[ObjectLiteral]
public abstract class HasHrefAttribute : HTMLAttributes
{
  public string href;
}
</code></pre>
<p>which <strong>AnchorAttributes</strong> and <strong>LinkAttributes</strong> could be derived from. While it might <em>appear</em> initially to make sense, I imagine that it will all come unstuck quite quickly and you'll end up finding yourself wanting to inherit from multiple base classes and all sorts of things that C# doesn't like. I think this is a KISS over DRY scenario (I'd rather repeat &quot;public string href;&quot; in a few distinct places than try to tie the classes together in some convoluted manner).</p>
<h3 id="more-type-shenanigans"><a href="/stronglytyped-react-with-bridgenet#more-type-shenanigans">More type shenanigans</a></h3>
<p>So, with more thought and planning, I think a reduced <strong>HTMLAttributes</strong> class could be written <em>and</em> a range of attribute classes produced that make the type system work for us. I should probably admit that I haven't actually <em>done</em> any of that further thought or planning yet! I feel like I've spent this month coming up with grandiose schemes and then writing about doing them rather than actually getting them done! :D</p>
<p>Anyway, enough about my shortcomings, there's <em>another</em> issue I found while looking into this &quot;download&quot; attribute. Thankfully, it's a minor problem that can easily be solved with the way that bindings may be written for Bridge..</p>
<p>There was an issue on React's GitHub repo: &quot;<a href="https://github.com/facebook/react/issues/1337">Improve handling of download attribute</a>&quot; which says the following:</p>
<blockquote>
<p>Currently, the &quot;download&quot; attribute is handled as a normal attribute. It would be nice if it could be treated as a boolean value attribute when its value is a boolean. ... For example,</p>
<p>a({href: 'thing', download: true}, 'clickme'); // =&gt; &lt;a href=&quot;thing&quot; download&gt;clickme&lt;/a&gt;</p>
<p>a({href: 'thing', download: 'File.pdf'}, 'clickme'); // =&gt; &lt;a href=&quot;thing&quot; download=&quot;File.pdf&quot;&gt;</p>
</blockquote>
<p>This indicates that</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class AnchorAttributes : HTMLAttributes
{
  public string href;
  public string download;
  // .. and other attributes specified to anchor tags
}
</code></pre>
<p>is not good enough and that &quot;download&quot; needs to be allowed to be a string <em>or</em> a boolean.</p>
<p>This can be worked around by introducing a new class</p>
<pre><code>[Ignore]
public sealed class StringOrBoolean
{
  private StringOrBoolean() { }

  public static implicit operator StringOrBoolean(bool value)
    =&gt; new StringOrBoolean();

  public static implicit operator StringOrBoolean(string value)
    =&gt; new StringOrBoolean();
}
</code></pre>
<p>This looks a bit strange at first glance. But it is <em>only</em> be used to describe a way to pass information in a binding, that's why it's got the &quot;Ignore&quot; attribute on it - that means that this class will <em>not</em> be translated into any JavaScript by Bridge, it exists <em>solely</em> to tell the type system how one thing talks to another (my <a href="/react-and-flux-with-bridgenet">React with Bridge.net</a> post talked a little bit about this attribute, and others similar to it, that are used in creating Bridge bindings - so if you want to know more, that's a good place to start).</p>
<p>This explains why the &quot;value&quot; argument used in either of the implicit operators is thrown away - it's because it's never used by the binding code! It is <em>only</em> so that we can use this type in the attribute class:</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class AnchorAttributes : HTMLAttributes
{
  public string href;
  public StringOrBoolean download;
  // .. and other attributes specified to anchor tags
}
</code></pre>
<p>And this allows to then write code like</p>
<pre><code>DOM.a(new AnchorAttributes
{
  href: &quot;/instructions.pdf&quot;,
  download: &quot;My Site's Instructions.pdf&quot;
})
</code></pre>
<p><em>or</em></p>
<pre><code>DOM.a(new AnchorAttributes
{
  href: &quot;/instructions.pdf&quot;,
  download: true
})
</code></pre>
<p>We <em>only</em> require this class to exist so that we can tell the type system that React is cool with us giving a string value for &quot;download&quot; or a boolean value.</p>
<p>The &quot;ObjectLiteral&quot; attribute on these classes means that the code</p>
<pre><code>DOM.a(new AnchorAttributes
{
  href: &quot;/instructions.pdf&quot;,
  download: true
})
</code></pre>
<p>is not even translated into an instantiation of a class called &quot;<strong>AnchorAttributes</strong>&quot;, it is instead translated into a simple object literal -</p>
<pre><code>// It is NOT translated into this
React.DOM.a(
  Bridge.merge(
    new Bridge.React.AnchorAttributes(),
    { name: &quot;/instructions.pdf&quot;, download: true }
  )
)

// It IS just translated into this
React.DOM.a({ name: &quot;/instructions.pdf&quot;, download: true })
</code></pre>
<p>Again, this illustrates why the &quot;value&quot; argument was thrown away in the <strong>StringOrBoolean</strong> implicit operator calls - because those calls do not exist in the translated JavaScript.</p>
<h3 id="a-nice-bonus"><a href="/stronglytyped-react-with-bridgenet#a-nice-bonus">A nice bonus</a></h3>
<p>Another thing that I like about the &quot;ObjectLiteral&quot; attribute that I've used on these <strong>{Whatever}Attributes</strong> classes is that the translated code only includes the properties that have been explicitly set.</p>
<p>This means that, unlike in the TypeScript definitions, we don't have to declare all value types as nullable. If, for example, we have an attributes class for table cells - like:</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class TableCellAttributes : HTMLAttributes
{
  public int colSpan;
  public int rowSpan;
}
</code></pre>
<p>and we have C# code like this:</p>
<pre><code>DOM.td(new TableCellAttributes { colSpan = 2 }, &quot;Hello!&quot;)
</code></pre>
<p>Then the resulting JavaScript is simply:</p>
<pre><code>React.DOM.td({ colSpan = 2 }, &quot;Hello!&quot;)
</code></pre>
<p>Note that the unspecified &quot;rowSpan&quot; property does <em>not</em> appear in the JavaScript.</p>
<p>If we <em>want</em> it to appear, then we can specify a value in the C# code -</p>
<pre><code>DOM.td(new TableCellAttributes { colSpan = 2, rowSpan = 1 }, &quot;Hello!&quot;)
</code></pre>
<p>That will be translated as you would expect:</p>
<pre><code>React.DOM.td({ colSpan = 2, rowSpan = 1 }, &quot;Hello!&quot;)
</code></pre>
<p>This has <em>two</em> benefits, actually, because not only do we not have to mark all of the properties as nullable (while that wouldn't be the end of the world, it's nicer - I think - to have the attribute classes have properties that match the html values as closely as possible and using simple value types does so) but it also keeps the generated JavaScript succint. Imagine the alternative, where <em>every</em> property was included in the JavaScript.. every time a div element was declared it would have 150 properties listed along with it. The JavaScript code would get huge, very quickly!*</p>
<p class="footnote">* <em>(Ok, ok, it shouldn't be 150 properties for every div since half the point of this post is that it will be much better to create attribute classes that are as specific as possible - but there would still be a lot of properties that appear in element initialisations in the JavaScript which were not present in the C# code, it's much better only having the explicitly-specified values wind up in the translated output).</em></p>
<h4 id="a-change-in-bridge-1.8"><a href="/stronglytyped-react-with-bridgenet#a-change-in-bridge-1.8">A change in Bridge 1.8</a></h4>
<p>I was part way through writing about how pleased I was that unspecified properties in an [ObjectLiteral]-decorated class do not appear in the generated JavaScript when I decided to upgrade to Bridge 1.8 (which was just released two days ago).. and things stopped doing what I wanted.</p>
<p>With version 1.8, it seems like if you have an [ObjectLiteral] class then all of the properties <em>will</em> be included in the JavaScript - with default values if you did not specify them explicitly. So the example above:</p>
<pre><code>DOM.td(new TableCellAttributes { colSpan = 2 }, &quot;Hello!&quot;)
</code></pre>
<p>would result in something like:</p>
<pre><code>React.DOM.td({
    colSpan = 2,
    rowSpan = 0,
    id = null,
    className = null,
    // .. every other HTMLAttribute value here with a default value
  },
  &quot;Hello!&quot;
)
</code></pre>
<p>Which is a real pity.</p>
<p>The good news is that it appears to be as easy as <em>also</em> including an [Ignore] attribute on the type - doing so re-enables the behaviour that only includes explicitly-specified properties in the JavaScript. However, I have been unable to find authoritative information on how [ObjectLiteral] <em>should</em> behave and how it should behave with or without [Ignore]. I had a quick flick through the 1.8 release notes and couldn't see any mention of this being an explicit change from 1.7 to 1.8 (but, I will admit, I wasn't <em>super</em> thorough in that investigation).</p>
<p>I only came across the idea of combining [Ignore] with [ObjectLiteral] when I was looking through their source code on <a href="https://github.com/bridgedotnet/">GitHub</a> (open source software, ftw!) and found a few places where there are checks for one of those attributes or <em>both</em> of them in some places.</p>
<p><em>(I've updated the code samples in this post to illustrate what I mean - now anywhere that has [ObjectLiteral] also has [Ignore]).</em></p>
<p>I'm a little bit concerned that this may change again in the future or that I'm not using these options correctly, but I've raised a bug in their forums and they've been very good at responding to these in the past - <a href="http://forums.bridge.net/forum/bridge-net-pro/bugs/495-objectliteral-classes-generate-values-for-all-properties-in-1-8-changed-from-1-7">ObjectLiteral classes generate values for all properties in 1.8 (changed from 1.7)</a>.</p>
<h3 id="whats-next"><a href="/stronglytyped-react-with-bridgenet#whats-next">What's next</a></h3>
<p>So.. how am I intending to progress this? Or am I going to just leave it as an interesting initial investigation, something that I've looked briefly into and then blogged about??</p>
<p>Well, no. Because I <em>am</em> actually planning to do some useful work on this! :) I'm a big fan of both React and Bridge and hope to be doing work with both of them, so moving this along is going to be a necessity as much as a nice idea to play around with. It's just a case of <em>how</em> to proceed - as the I-have-never-heard-of-this-new-download-attribute story goes to show, I'm not intimately familiar with every single tag and every single attribute, particular in regards to some of the less well-known html5 combinations.</p>
<p>Having done some research while writing this post, I think the best resource that I've found has been <a href="https://developer.mozilla.org/en-US/">MDN</a> (the Mozilla Developer Network). It seems like you can look up any tag - eg.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a</a></p>
<p>And then find details of every attribute that it has, along with compatibility information. For example, the <code>td</code> table cell documentation..</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td</a></p>
<p>.. mentions &quot;colSpan&quot; and &quot;rowSpan&quot;, with no particular mentions of compatibility (these have existed from day one, surely, and I don't think they're going to disappear any time soon) but also mentions attributes such as &quot;align&quot; and &quot;valign&quot; and highlights them as deprecated in html 4.01 and obsolete in html 5.</p>
<p>I'm strongly considering scraping these MDN pages and trying to parse out the attribute names and compatibility information (probably only supporting html5, since what's the point in supporting anything older when Bridge and React are new and and so I will be using them for writing new code and taking advantage of current standards). It doesn't provide type information (like &quot;colSpan&quot; is numeric or &quot;download&quot; may be a string or a boolean), but the <a href="https://github.com/borisyankov/DefinitelyTyped/blob/master/react/react.d.ts">DefinitelyTyped</a> definitions will go some way in helping out with that. And MDN says that its <a href="https://developer.mozilla.org/en-US/docs/MDN/About#Copyrights_and_licenses">wiki documents are available under the creative commons license</a>, so I believe that this would acceptable use of the data, so long as they are given the appropriate credit in the bindings code that I will eventually generate (which only seems fair!).</p>
<p>So I think that that is what will come next - trying to glean all of the information I need about the attributes specific to particular tags and then using this to produce bindings that take as much advantage of the C# type system as possible!</p>
<p>Unless I'm missing something and someone else can think of a better way? Anyone??</p>
<p><strong>Update (8th October 2015):</strong> I've had some suggestions from a member of the Bridge.net Team on how to reuse some of their work on html5 element definitions to make this a <em>lot</em> easier - so hopefully I'll have an update before too long based upon this. Before I can do so, the Bridge Team are looking into some improvements, such as allowing the &quot;CurrentTarget&quot; property of elements to be more strongly-typed (see <a href="http://forums.bridge.net/forum/general/feature-requests/630-open-461-generic-html5-element-and-event-classes">http://forums.bridge.net/forum/general/feature-requests/630-open-461-generic-html5-element-and-event-classes</a>), but hopefully we'll all have an update before too long!</p>
<p class="PostTime">Posted at 23:07</p><div class="Related"><h3>You may also be interested in:</h3><ul><li><a href="/react-and-flux-with-bridgenet">React (and Flux) with Bridge.net</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/React" title="11 Posts">React</a></li></ul></div>
            <p class="Comments">
                <a href="/stronglytyped-react-with-bridgenet#disqus_thread" data-disqus-identifier="90">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByMonth">
        <span class="PostDate">14 August 2015</span><h2 id="hassle-free-immutable-type-updates-in-c"><a href="/hasslefree-immutable-type-updates-in-c-sharp">Hassle-free immutable type updates in C#</a></h2>
<p>Earlier this week, I was talking about parsing TypeScript definitions in an inspired-by-function-programming manner. Like this:</p>
<pre><code>public static Optional&lt;MatchResult&lt;PropertyDetails&gt;&gt; Property(IReadStringContent reader)
{
  IdentifierDetails name = null;
  ITypeDetails type = null;
  var readerAfterProperty = Optional.For(reader)
    .Then(Identifier, value =&gt; name = value)
    .ThenOptionally(Whitespace)
    .Then(Match(':'))
    .ThenOptionally(Whitespace)
    .Then(TypeScriptType, value =&gt; type = value)
    .ThenOptionally(Whitespace)
    .Then(Match(';'));

  if (!readerAfterProperty.IsDefined)
    return null;

  return MatchResult.New(
    new PropertyDetails(name, type),
    readerAfterProperty.Value
  );
}
</code></pre>
<p>&quot;Identifier&quot;, &quot;Whitespace&quot; and &quot;TypeScriptType&quot; are functions that match the following delegate:</p>
<pre><code>public delegate Optional&lt;MatchResult&lt;T&gt;&gt; Parser&lt;T&gt;(
  IReadStringContent reader
);
</code></pre>
<p>.. while &quot;Match&quot; is a function that returns a <strong>Parser&lt;char&gt;</strong>.</p>
<p>The <strong>MatchResult</strong> class looks like this:</p>
<pre><code>public sealed class MatchResult&lt;T&gt;
{
  public MatchResult(T result, IReadStringContent reader)
  {
    Result = result;
    Reader = reader;
  }
  public T Result { get; }
  public IReadStringContent Reader { get; }
}

/// &lt;summary&gt;
/// This non-generic static class is just to expose a helper method that takes advantage
/// of C#'s type inference to allow you to say &quot;MatchResult.New(value, reader)&quot; rather than
/// having to write out the type of the value in &quot;new MatchResult&lt;string&gt;(value, reader)&quot;
/// &lt;/summary&gt;
public static class MatchResult
{
  /// &lt;summary&gt;
  /// Convenience method to utilise C# type inherence
  /// &lt;/summary&gt;
  public static MatchResult&lt;T&gt; New&lt;T&gt;(T value, IReadStringContent reader)
  {
    if (value == null)
      throw new ArgumentNullException(nameof(value));
    if (reader == null)
      throw new ArgumentNullException(nameof(reader));

    return new MatchResult&lt;T&gt;(value, reader);
  }
}
</code></pre>
<p>.. and <strong>Optional</strong> is basically a way to identify a type as being maybe-null (the convention then being that any non-<strong>Optional</strong> type should never be null).</p>
<p>Feel free to fresh your memory at <a href="/parsing-typescript-definitions-functionally-ish">Parsing TypeScript definitions</a>!</p>
<p>One thing that I thought was very un-functional-like (a very precise term! :) was the way that the &quot;name&quot; and &quot;type&quot; values were updated via callbacks from the &quot;Then&quot; methods. This mechanism felt wrong for two reasons; the repeat assignment to the references (setting them to null and then setting them again to something else) and the fact that the assignments were effectively done as side effects of the work of the &quot;Then&quot; function.</p>
<p>So I thought I'd have a look into some alternatives and see if I could whip up something better.</p>
<h3 id="the-verbose-approach"><a href="/hasslefree-immutable-type-updates-in-c-sharp#the-verbose-approach">The verbose approach</a></h3>
<p>The current approach chains together functions that take and return <strong>Optional&lt;IReadStringContent&gt;</strong> instances. If content is encountered that does not match the specified <strong>Parser</strong> then a &quot;Missing&quot; value will be returned from the &quot;Then&quot; call. If a &quot;Then&quot; call receives a &quot;Missing&quot; value then it passes that straight out. So, any time that a match is missed, all subsequent calls pass the &quot;Missing&quot; value straight through.</p>
<p>This is why the side effect callbacks are required to pass out the values, because each &quot;Then&quot; call only returns the next position for the reader (or &quot;Missing&quot; if content did not meet requirements).</p>
<p>To change this, the &quot;Then&quot; function will need to return additional information. Conveniently, there is already a structure to do this - the <strong>MatchResult&lt;T&gt;</strong>. As long as we had one result type that we wanted to thread through the &quot;Then&quot; calls then we could write an alternate version of &quot;Then&quot; -</p>
<pre><code>public static Optional&lt;MatchResult&lt;TResult&gt;&gt; Then&lt;TResult, TValue&gt;(
  this Optional&lt;MatchResult&lt;TResult&gt;&gt; resultSoFar,
  Parser&lt;TValue&gt; parser,
  Func&lt;TResult, TValue, TResult&gt; updater)
{
  if (!resultSoFar.IsDefined)
    return null;

  var result = parser(resultSoFar.Value.Reader);
  if (!result.IsDefined)
    return null;

  return MatchResult.New(
    updater(resultSoFar.Value.Result, result.Value.Result),
    result.Value.Reader
  );
}
</code></pre>
<p>This takes an <strong>Optional&lt;MatchResult&lt;T&gt;&gt;</strong> and tries to match content in the reader inside that <strong>MatchResult</strong> using a <strong>Parser</strong> (just like before) - if it successfully matches the content then it uses an &quot;updater&quot; which takes the previous values from the <strong>MatchResult</strong> and the matched value from the reader, and returns a new result that combines the two. It then returns a <strong>MatchResult</strong> that combines this new value with the reader in a position after the matched content. (Assuming the content met the <strong>Parser</strong> requirements.. otherwise it would return null).</p>
<p>This all sounds very abstract, so let's make it concrete. Continuing with the parsing-a-TypeScript-property (such as &quot;name: string;&quot;) example, let's declare an interim type -</p>
<pre><code>public sealed class PartialPropertyDetails
{
  public PartialPropertyDetails(
    Optional&lt;IdentifierDetails&gt; name,
    Optional&lt;ITypeDetails&gt; type)
  {
    Name = name;
    Type = type;
  }
  public Optional&lt;IdentifierDetails&gt; Name { get; }
  public Optional&lt;ITypeDetails&gt; Type { get; }
}
</code></pre>
<p>This has <strong>Optional</strong> values because we are going to start with them being null (since we don't have any real values until we've done the parsing). This is the reason that I've introduced this interim type, rather than using the final <strong>PropertyDetails</strong> type - that type is very similar but it has non-<strong>Optional</strong> properties because it doesn't make sense for a correctly-parsed TypeScript property to be absent either a name or a type.</p>
<p>Now, the parsing method could be rewritten into this:</p>
<pre><code>public static Optional&lt;MatchResult&lt;PropertyDetails&gt;&gt; Property(IReadStringContent reader)
{
  var result = Optional.For(MatchResult.New(
      new PartialPropertyDetails(null, null),
      reader
    ))
    .Then(Identifier, (value, name) =&gt; new PartialPropertyDetails(name, value.Type))
    .ThenOptionally(Whitespace)
    .Then(Match(':'))
    .ThenOptionally(Whitespace)
    .Then(TypeScriptType, (value, type) =&gt; new PartialPropertyDetails(value.Name, type))
    .ThenOptionally(Whitespace)
    .Then(Match(';'));

  if (!result.IsDefined)
    return null;

  return MatchResult.New(
    new PropertyDetails(result.Value.Result.Name, result.Value.Result.Type),
    result.Value.Reader
  );
}
</code></pre>
<p>Ta-da! No reassignments or reliance upon side effects!</p>
<p>And we could make this a bit cleaner by tweaking <strong>PartialPropertyDetails</strong> -</p>
<pre><code>public sealed class PartialPropertyDetails
{
  public static PartialPropertyDetails Empty { get; }
    = new PartialPropertyDetails(null, null);

  private PartialPropertyDetails(
    Optional&lt;IdentifierDetails&gt; name,
    Optional&lt;ITypeDetails&gt; type)
  {
    Name = name;
    Type = type;
  }

  public Optional&lt;IdentifierDetails&gt; Name { get; }
  public Optional&lt;ITypeDetails&gt; Type { get; }

  public PartialPropertyDetails WithName(IdentifierDetails value)
    =&gt; new PartialPropertyDetails(value, Type);
  public PartialPropertyDetails WithType(ITypeDetails value)
    =&gt; new PartialPropertyDetails(Name, value);
}
</code></pre>
<p>and then changing the parsing code into this:</p>
<pre><code>public static Optional&lt;MatchResult&lt;PropertyDetails&gt;&gt; Property(IReadStringContent reader)
{
  var result = Optional.For(MatchResult.New(
      PartialPropertyDetails.Empty,
      reader
    ))
    .Then(Identifier, (value, name) =&gt; value.WithName(name))
    .ThenOptionally(Whitespace)
    .Then(Match(':'))
    .ThenOptionally(Whitespace)
    .Then(TypeScriptType, (value, type) =&gt; value.WithType(name))
    .ThenOptionally(Whitespace)
    .Then(Match(';'));

  if (!result.IsDefined)
    return null;

  return MatchResult.New(
    new PropertyDetails(result.Value.Result.Name, result.Value.Result.Type),
    result.Value.Reader
  );
}
</code></pre>
<p>This makes the parsing code look nicer, at the cost of having to write more boilerplate code for the interim type.</p>
<p>What if we could use anonymous types and some sort of magic for performing the copy-and-update actions..</p>
<h3 id="one-way-to-write-less-code"><a href="/hasslefree-immutable-type-updates-in-c-sharp#one-way-to-write-less-code">One way to write less code</a></h3>
<p>The problem with the <strong>PartialPropertyDetails</strong> is not only that it's quite a lot of code to write out (and that was only for two properties, it will quickly get bigger for more complicated structures) but also the fact that it's only useful in the context of the &quot;Property&quot; function. So this non-negligible chunk of code is not reusable and it clutters up the scope of whatever class or namespace has to contain it.</p>
<p>Anonymous types sound ideal, because they would just let us start writing objects to populate - eg.</p>
<pre><code>var result = Optional.For(MatchResult.New(
    new
    {
      Name = (IdentifierDetails)null,
      Type = (ITypeDetails)null,
    },
    reader
  ))
  .Then(Identifier, (value, name) =&gt; new { Name = name, Type = value.Type })
  .ThenOptionally(Whitespace)
  .Then(Match(':'))
  .ThenOptionally(Whitespace)
  .Then(TypeScriptType, (value, type) =&gt; new { Name = value.Name, Type = Type })
  .ThenOptionally(Whitespace)
  .Then(Match(';'));
</code></pre>
<p>They're immutable types (so nothing is edited in-place, which is just as bad as editing via side effects) and, despite looking like they're being defined dynamically, the C# compiler defines real classes for them behind the scenes, so the &quot;Name&quot; property will always be of type <strong>IdentifierDetails</strong> and &quot;Type&quot; will always be an <strong>ITypeDetails</strong>.</p>
<p>The compiler creates new classes for every distinct combination of properties (considering both property name and property type). This means that if you declare two anonymous objects that have the same properties then they will be represented by the same class. This is what allows the above code to declare &quot;updater&quot; implementations such as</p>
<pre><code>(value, name) =&gt; new { Name = name, Type = value.Type }
</code></pre>
<p>The &quot;value&quot; in the lambda will be an instance of an anonymous type and the returned value will be an instance of that same anonymous class because it specifies the exact same property names and types. This is key, because the &quot;updater&quot; is a delegate with the signature</p>
<pre><code>Func&lt;TResult, TValue, TResult&gt; updater
</code></pre>
<p>(and so the returned value must be of the same type as the first value that it was passed).</p>
<p>This is not actually a bad solution, I don't think. There was no need to create a <strong>PartialPropertyDetails</strong> class and we have full type safety through those anonymous types. The only (admittedly minor) thing is that if the data becomes more complex then there will be more and more properties and so every instantiation of the anonymous types will get longer and longer. It's a pity that there's no way to create &quot;With{Whatever}&quot; functions for the anonymous types.</p>
<h3 id="a-minor-side-track"><a href="/hasslefree-immutable-type-updates-in-c-sharp#a-minor-side-track">A minor side-track</a></h3>
<p>Before I go any further, there's another extension method I want to introduce. I just think that the way that these parser chains are initiated feels a bit clumsy -</p>
<pre><code>var result = Optional.For(MatchResult.New(
    new
    {
      Name = (IdentifierDetails)null,
      Type = (ITypeDetails)null,
    },
    reader
  ))
  .Then(Identifier, (value, name) =&gt; new { Name = name, Type = value.Type })
  // .. the rest of the parsing code continues here..
</code></pre>
<p>This could be neatened right up with an extension method such as this:</p>
<pre><code>public static Optional&lt;MatchResult&lt;T&gt;&gt; StartMatching&lt;T&gt;(
  this IReadStringContent reader,
  T value)
{
  return MatchResult.New(value, reader);
}
</code></pre>
<p>This uses C#'s type inference to ensure that you don't have to declare the type of <strong>T</strong> (which is handy if we're using an anonymous type because we have no idea what its type name might be!) and it relies on the fact that the <strong>Optional</strong> struct has an implicit operator that allows a value <strong>T</strong> to be returned as an <strong>Optional&lt;T&gt;</strong>; it will wrap the value up automatically. (For more details on the <strong>Optional</strong> type, read what I wrote <a href="/parsing-typescript-definitions-functionally-ish">last time</a>).</p>
<p>Now, the parsing code that we have look like this:</p>
<pre><code>var resultWithAnonymousType = reader
  .StartMatching(new
  {
    Name = (IdentifierDetails)null,
    Type = (ITypeDetails)null
  })
  .Then(Identifier, (value, name) =&gt; new { Name = name, Type = value.Type })
  .ThenOptionally(Whitespace)
  .Then(Match(':'))
  .ThenOptionally(Whitespace)
  .Then(TypeScriptType, (value, type) =&gt; new { Name = value.Name, Type = Type })
  .ThenOptionally(Whitespace)
  .Then(Match(';'));
</code></pre>
<p>Only a minor improvement but another step towards making the code match the intent (which was one of the themes in my last post).</p>
<h3 id="a-cleverer-but-less-safe-alternative"><a href="/hasslefree-immutable-type-updates-in-c-sharp#a-cleverer-but-less-safe-alternative">A cleverer (but less safe) alternative</a></h3>
<p>Let's try turning the volume up to &quot;silly&quot; for a bit. (Fair warning: &quot;clever&quot; here refers more to &quot;clever for the sake of it&quot; than &quot;intelligent).</p>
<p>A convenient property of the anonymous type classes is that they each have a constructor whose arguments directly match the properties on it - this is an artifact of the way that they're translated into regular classes by the compiler. You don't see this in code anywhere since the names of these mysterious classes is kept secret and you can't directly call a constructor without knowing the name of the class to call. But they are there, nonetheless. And there is one way to call them.. REFLECTION!</p>
<p>We could use reflection to create something like the &quot;With{Whatever}&quot; methods - that way, we could go back to only having to specify a single property-to-update in each &quot;Then&quot; call. The most obvious way that this could be achieved would be by specifying the name of the property-to-update as a string. But this is particularly dirty and prone to breaking if any refactoring is done (such as a change to a property name in the anonymous type). There is one way to mitigate this, though.. MORE REFLECTION!</p>
<p>Let me code-first, explain-later:</p>
<pre><code>public static Optional&lt;MatchResult&lt;TResult&gt;&gt; Then&lt;TResult, TValue&gt;(
  this Optional&lt;MatchResult&lt;TResult&gt;&gt; resultSoFar,
  Parser&lt;TValue&gt; parser,
  Expression&lt;Func&lt;TResult, TValue&gt;&gt; propertyRetriever)
{
  if (!resultSoFar.IsDefined)
    return null;

  var result = parser(resultSoFar.Value.Reader);
  if (!result.IsDefined)
    return null;

  var memberAccessExpression = propertyRetriever.Body as MemberExpression;
  if (memberAccessExpression == null)
  {
    throw new ArgumentException(
      &quot;must be a MemberAccess&quot;,
      nameof(propertyRetriever)
    );
  }

  var property = memberAccessExpression.Member as PropertyInfo;
  if ((property == null)
  || !property.CanRead
  || property.GetIndexParameters().Any())
  {
    throw new ArgumentException(
      &quot;must be a MemberAccess that targets a readable, non-indexed property&quot;,
      nameof(propertyRetriever)
    );
  }

  foreach (var constructor in typeof(TResult).GetConstructors())
  {
    var valuesForConstructor = new List&lt;object&gt;();
    var encounteredProblemWithConstructor = false;
    foreach (var argument in constructor.GetParameters())
    {
      if (argument.Name == property.Name)
      {
        if (!argument.ParameterType.IsAssignableFrom(property.PropertyType))
        {
          encounteredProblemWithConstructor = false;
          break;
        }
        valuesForConstructor.Add(result.Value.Result);
        continue;
      }
      var propertyForConstructorArgument = typeof(TResult)
        .GetProperties()
        .FirstOrDefault(p =&gt;
          (p.Name == argument.Name) &amp;&amp;
          p.CanRead &amp;&amp; !property.GetIndexParameters().Any()
        );
      if (propertyForConstructorArgument == null)
      {
        encounteredProblemWithConstructor = false;
        break;
      }
      var propertyGetter = propertyForConstructorArgument.GetGetMethod();
      valuesForConstructor.Add(
        propertyGetter.Invoke(
          propertyGetter.IsStatic ? default(TResult) : resultSoFar.Value.Result,
          new object[0]
        )
      );
    }
    if (encounteredProblemWithConstructor)
      continue;

    return MatchResult.New(
      (TResult)constructor.Invoke(valuesForConstructor.ToArray()),
      result.Value.Reader
    );
  }
  throw new ArgumentException(
    $&quot;Unable to locate a constructor that can be used to update {property.Name}&quot;
  );
}
</code></pre>
<p>This allows the parsing code to be rewritten (again!) into:</p>
<pre><code>var result = reader
  .StartMatching(new
  {
    Name = (IdentifierDetails)null,
    Type = (ITypeDetails)null
  })
  .Then(Identifier, x =&gt; x.Name)
  .ThenOptionally(Whitespace)
  .Then(Match(':'))
  .ThenOptionally(Whitespace)
  .Then(TypeScriptType, x =&gt; x.Type)
  .ThenOptionally(Whitespace)
  .Then(Match(';'));
</code></pre>
<p>Well now. Isn't that easy on the eye! Ok.. maybe beauty is in the eye of the beholder, so let me hedge my bets and say: Well now. Isn't that succint!</p>
<p>Those lambdas (&quot;x =&gt; x.Name&quot; and &quot;x =&gt; x.Type&quot;) satisfy the form:</p>
<pre><code>Expression&lt;Func&lt;TResult, TValue&gt;&gt;
</code></pre>
<p>This means that they are expressions which must take a <strong>TResult</strong> and return a <strong>TValue</strong>. So in the call</p>
<pre><code>.Then(Identifier, x =&gt; x.Name)
</code></pre>
<p>.. the Expression describes how to take the anonymous type that we're threading through the &quot;Then&quot; calls and extract an <strong>IdentifierDetails</strong> instance from it (the type of this is dictated by the <strong>TValue</strong> type parameter on the &quot;Then&quot; method, which is inferred from the &quot;Identifier&quot; call - which returns an <strong>Optional&lt;IdentifierDetails&gt;</strong>).</p>
<p>This is the difference between an <strong>Expression</strong> and a <strong>Func</strong> - the <strong>Func</strong> is executable and tells us how to do something (such as &quot;take the 'Name' property from the 'x' reference&quot;) while the <strong>Expression</strong> tells us how the <strong>Func</strong> is constructed.</p>
<p>This information allows the new version of &quot;Then&quot; to not only retrieve the specified property <em>but also to be aware of the name of that property</em>. And this is what allows the code to say &quot;I've got a new value for one property now, I'm going to try to find a constructor that I can call which has an argument matching this property name (so I can satisfy that argument with this new value) and which has other arguments that can all be satisfied by other properties on the type&quot;.</p>
<p>Anonymous types boil down to simple classes, a little bit like this:</p>
<pre><code>private sealed CRAZY_AUTO_GEN_NAME&lt;T1, T2&gt;
{
  public CRAZY_AUTO_GEN_NAME(T1 Name, T2 Type)
  {
    this.Name = Name;
    this.Type = Type;
  }
  public T1 Name { get; }
  public T2 Type { get; }
}
</code></pre>
<p>Note: I said earlier that the compiler generates distinct classes for anonymous types that have unique combinations of property names and types. That's a bit of a lie, it only has to vary them based upon the property names since it can use generic type parameters for the types of those properties. I confirmed this by using <a href="https://msdn.microsoft.com/en-us/library/aa309387(v=vs.71).aspx">ildasm</a> on my binaries, which also showed that the name of the auto-generated class was <strong>&lt;&gt;f_AnonymousType1</strong>.. it's not <em>really</em> called &quot;CRAZY_AUTO_GEN_NAME&quot; :)</p>
<p>So we can take the Expression &quot;x =&gt; x.Name&quot; and extract the fact the &quot;Name&quot; property is being targeted. This allows us to match the constructor that takes a &quot;Name&quot; argument and a &quot;Type&quot; argument and to call that constructor - passing the new value into the &quot;Name&quot; argument and passing the existing &quot;Type&quot; property value into the &quot;Type&quot; argument.</p>
<p>This has the benefit that everything would still work if one of the properties was renamed in a refactor (since if the &quot;Name&quot; property was renamed to &quot;SomethingElse&quot; then Visual Studio would update the lambda &quot;x =&gt; x.Name&quot; to &quot;x =&gt; x.SomethingElse&quot;, just as it would for any other reference to that &quot;Name&quot; property).</p>
<p>The major downside is that the &quot;Then&quot; function requires that the Expression relate to a simple property retrieval, failing at runtime if this is not the case.* Since an Expression could be almost anything then this could be a problem. For example, the following is valid code and would compile -</p>
<pre><code>.Then(Identifier, x =&gt; null)
</code></pre>
<p>.. but it would fail at runtime. This is what I mean by it not being safe.</p>
<p>But I've got to admit, this approach has a certain charm about it! Maybe it's not an appropriate mechanism for critical life-or-death production code, but for building a little parser for a personal project.. maybe I could convince myself it's worth it!</p>
<p>(Credit where it's due, I think I first saw this specify-a-property-with-an-Expression technique some years ago in <a href="http://automapper.org/">AutoMapper</a>, which is an example of code that <em>is</em> often used in production despite not offering compile-time guarantees about mappings - but has such convenience that the need to write tests around the mappings is outweighed by the benefits).</p>
<p>* <em>(Other people might also point out that reflection is expensive and that</em> that <em>is a major downside - however, the code that is used here is fairly easy to wrap up in LINQ Expressions that are dynamically compiled so that repeated executions of hot paths are as fast as hand-written code.. and if the paths aren't hot and executed many times, what's the problem with the reflection being slower??)</em></p>
<p class="PostTime">Posted at 00:10</p><div class="Related"><h3>You may also be interested in:</h3><ul><li><a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired &quot;with&quot; updates for immutable classes in C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div>
            <p class="Comments">
                <a href="/hasslefree-immutable-type-updates-in-c-sharp#disqus_thread" data-disqus-identifier="89">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByMonth">
        <span class="PostDate">10 August 2015</span><h2 id="parsing-typescript-definitions-functional-ly.ish"><a href="/parsing-typescript-definitions-functionally-ish">Parsing TypeScript definitions (functional-ly.. ish)</a></h2>
<p>A couple of things have happened recently, I've started using Visual Studio 2015 and C# 6 (<a href="http://csharp.2000things.com/2014/10/31/1216-c-6-0-initializing-read-only-auto-properties-within-constructors/">read-only auto-properties</a>, where have you been all my life???) and I've been playing around with using <a href="/react-and-flux-with-bridgenet">Bridge.net to write React applications in C#</a>. So far, I've only written the bare minimum of bindings that I required to use React in Bridge so I was wondering if there was a shortcut to extending these - like taking the <a href="https://github.com/borisyankov/DefinitelyTyped/blob/master/react/react.d.ts">DefinitelyTyped TypeScript/React bindings</a> and converting them somehow.</p>
<p>Looking at those TypeScript bindings, there really isn't <em>that</em> much content and it's not particularly complicated. Translating the majority of it into C# Bridge.net bindings by hand would probably not be a huge deal. But I don't really want to have to spend much time trying to update bindings when new versions of React come out (in fairness, React is fairly stable now and I suspect that any changes in the future will be very minor for most of the surface area of these bindings).</p>
<p>.. if I'm being really honest, though, I didn't just start out trying to manually translate the TypeScript bindings because I wanted to play around with writing some code! In the professional world, if there's a chance that a one-off(ish) operation like this will be much quicker (and not much less accurate) to perform by hand than by code then it's not an easy sell to say that you should code up an awesome general solution (that <em>probably</em>.. or.. <em>hopefully</em> will work) instead.-But this is all for my own enjoyment, so I'm going to do it however I damn well please! :D</p>
<p>Back in 2013, I wrote a post about <a href="/parsing-css">parsing CSS</a>. It pulled the style sheet input through an interface:</p>
<pre><code>public interface IReadStringContent
{
  char? Current { get; }
  uint Index { get; }
  IReadStringContent GetNext();
}
</code></pre>
<p>This allowed the source to be abstracted away (is it a fixed string, is it a huge file being streamed in chunks; who cares!) and it allowed the logic around where-is-the-current-position-in-the-content to be hidden somewhat (which is where a lot of the complications and the off-by-one errors creep into things like this).</p>
<p>So I figured this seemed like a resonable place to start. But I also wanted to throw a few more ideas into the mix - I'm all for describing structures with immutable classes (if you've read <em>any</em> other post on this site, you probably already know that!) but I wanted to play around with using an F#-esque <strong>Optional</strong> class to allow the type system to indicate where nulls are and aren't acceptable. In the past, I've relied on comments - eg.</p>
<pre><code>public interface IReadStringContent
{
  /// &lt;summary&gt;
  /// This will be null if all of the content has been consumed
  /// &lt;/summary&gt;
  char? Current { get; }

  /// &lt;summary&gt;
  /// This will be an index within the string or the position immediately
  /// after it (if all content has been read)
  /// &lt;/summary&gt;
  uint Index { get; }

  /// &lt;summary&gt;
  /// This will never return null. If all of the content has been read
  /// then the returned reference will have a null Current character
  /// &lt;/summary&gt;
  IReadStringContent GetNext();
}
</code></pre>
<p>I think that, <em>really</em>, I want to give <a href="https://msdn.microsoft.com/en-us/library/dd264808%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396">Code Contracts</a> another try (so that I could describe in source code where nulls are not acceptable and then have the compiler verify that every call to such functions matches those constraints). But every time I try contracts again I find it daunting. And for this little project, I wanted to have fun with coding and not get bogged down again with something that I've struggled with in the past*.</p>
<p class="footnote">* <em>(Even typing that, it sounds like a poor excuse.. which it is; one day I'll give them a proper go!)</em></p>
<p>Anyway.. my point is, I'm getting bored of writing &quot;This will never return null&quot; or &quot;This is optional and may return null&quot; in. Over.. and over.. and over again. What I'd like is to know that a <strong>string</strong> property will never be null in my own code because if it <em>was</em> allowed to be null then the return type would be <strong>Optional&lt;string&gt;</strong> and not just <strong>string</strong>.</p>
<p>Well, there just happens to be such a construct that someone else has written that I'm going to borrow (steal). There's a GitHub project <a href="https://github.com/AArnott/ImmutableObjectGraph">ImmutableObjectGraph</a> that is about using T4 templates to take a minimal representation of a class and transforming it into a fully-populated immutable type, saving you from having to write the repetitive boiler plate code yourself. (There's actually less of this type of boiler pate required if you use C# 6 and the project is in the process of changing to use <a href="https://github.com/dotnet/roslyn">Roslyn</a> instead of dirty T4 templates). I digress.. the point is that there is an optional type out there that does the job pretty well.</p>
<pre><code>// Borrowed from https://github.com/AArnott/ImmutableObjectGraph but tweaked slightly
[DebuggerDisplay(&quot;{IsDefined ? Value.ToString() : \&quot;&lt;missing&gt;\&quot;,nq}&quot;)]
public struct Optional&lt;T&gt;
{
  private readonly T value;
  private readonly bool isDefined;

  [DebuggerStepThrough]
  public Optional(T value)
  {
    // Tweak - if this is initialised with a null value then treat that the same
    // as this being a &quot;Missing&quot; value. I think you should either have a value or
    // not have a value (which is what null should be). I don't think you should
    // be able to choose between having a &quot;real&quot; value, having a value that is
    // null and having a Missing value. Not having a value (ie. null) and
    // Missing should be the same thing.
    this.isDefined = (value != null);
    this.value = value;
  }

  public static Optional&lt;T&gt; Missing
  {
    [DebuggerStepThrough]
    get { return new Optional&lt;T&gt;(); }
  }

  public bool IsDefined
  {
    [DebuggerStepThrough]
    get { return this.isDefined; }
  }

  public T Value
  {
    [DebuggerStepThrough]
    get { return this.value; }
  }

  [DebuggerStepThrough]
  public static implicit operator Optional&lt;T&gt;(T value)
    =&gt; new Optional&lt;T&gt;(value);

  public T GetValueOrDefault(T defaultValue)
    =&gt; this.IsDefined ? this.value : defaultValue;
}

public static class Optional
{
  public static Optional&lt;T&gt; For&lt;T&gt;(T value) =&gt; value;
}
</code></pre>
<p>I'm also thinking of trying to make all classes either abstract or sealed - inheritance always makes me a bit nervous when I'm trying to write &quot;value-like&quot; classes (I might want to write a nice custom Equals implementation, but then I start worrying that if someone derives from the type then there's no way to require that they also write their own Equals function that ensures that any new data they add to the type is considered in the comparison). Interestingly, someone posted a question Stack Overflow about this a few years ago, so rather than talk any more about it I'll just link to that: <a href="http://stackoverflow.com/questions/2016608/why-are-concrete-types-rarely-useful-as-bases-for-further-derivation/2016927#2016927">why are concrete types rarely useful as bases for further derivation</a>.</p>
<p>On a less significant note, I've been meaning to create functions as static by default for a while now. I'm going to make a concerted effort this time. If a function in a class does not need to access any instance state, then marking it as static is a good way to highlight this fact to the reader - it's a sort-of indicator that the function is pure (nitpickers might highlight the fact that a static function could still interact with any static state that the containing class has, but - even in these cases - marking it as static still reduces the possible references that it could affect). Little touches like this can make code more readable, I find. The only problem comes when you could pass just that one piece of state into it, keeping the function static and pure.. but then you find you need to make a change and pass it <em>another</em> piece of state - at which point should you say that the number of arguments required offsets the benefits of purity? (I don't have an easy answer to that, in case you were wondering!).</p>
<p>By applying these principles, I've found that the style of code that I wrote changed a bit. And I think that the patterns that came out are quite interesting - maybe some of this is due to the changing nature of C#, or maybe it's because I've read so many blog posts over the last couple of years about functional programming that some of it was bound to stick!</p>
<h3 id="getting-on-with-it"><a href="/parsing-typescript-definitions-functionally-ish#getting-on-with-it">Getting on with it</a></h3>
<p>Imagine that, during parsing a TypeScript definition, we find ourselves within an interface and need to parse a property that it has -</p>
<pre><code>name: string;
</code></pre>
<p><em>(I've picked this as a simple starting point - I realise that it seems an arbitrary place to begin at, but I had to start somewhere!)</em></p>
<p>I want to pick out the property name (&quot;name&quot;) and its type (&quot;string&quot;). I could go through each character in a loop and keep track of when I hit token delimiters (such as the &quot;:&quot; between the name and the type), but it seems like this is going to be code that will need writing over and over again for different structures. As such, it seems like somewhere that a helper function would be very useful in cutting down on code duplication and &quot;noise&quot; in the code - eg.</p>
<pre><code>public static Optional&lt;MatchResult&lt;string&gt;&gt; MatchAnythingUntil(
  IReadStringContent reader,
  ImmutableList&lt;char&gt; acceptableTerminators)
{
  var content = new StringBuilder();
  while (reader.Current != null)
  {
    if (acceptableTerminators.Contains(reader.Current.Value))
    {
      if (content.Length &gt; 0)
        return MatchResult.New(content.ToString(), reader);
      break;
    }
    content.Append(reader.Current);
    reader = reader.GetNext();
  }
  return null;
}
</code></pre>
<p><em>(Note: I'm using the <a href="https://www.nuget.org/packages/System.Collections.Immutable.Net40/">Microsoft Immutable Collections</a> NuGet package, which is where the &quot;ImmutableList&quot; type comes from).</em></p>
<p>This relies upon the <strong>Optional</strong> type that I mentioned before, but also a <strong>MatchResult</strong> class -</p>
<pre><code>public sealed class MatchResult&lt;T&gt;
{
  public MatchResult(T result, IReadStringContent reader)
  {
    Result = result;
    Reader = reader;
  }
  public T Result { get; }
  public IReadStringContent Reader { get; }
}

/// &lt;summary&gt;
/// This non-generic static class is just to expose a helper method that takes advantage
/// of C#'s type inference to allow you to say &quot;MatchResult.New(value, reader)&quot; rather than
/// having to write out the type of the value in &quot;new MatchResult&lt;string&gt;(value, reader)&quot;
/// &lt;/summary&gt;
public static class MatchResult
{
  public static MatchResult&lt;T&gt; New&lt;T&gt;(T value, IReadStringContent reader)
    =&gt; return new MatchResult&lt;T&gt;(value, reader);
}
</code></pre>
<p>This result type is just used to say &quot;here is the value that you asked for and here is a reader that picks up after that content&quot;. Neither the &quot;Result&quot; nor &quot;Reader&quot; properties have comments saying &quot;This will never be null&quot; because their properties are not wrapped in <strong>Optional</strong> types and so it is assumed that they never will be null.</p>
<p>The &quot;MatchAnythingUntil&quot; function returns a value of type <strong>Optional&lt;MatchResult&lt;string&gt;&gt;</strong>. This means that it is expected that this function <em>may</em> return a null value. Previously, I might have named this function &quot;TryToMatchAnythingUntil&quot; - to try to suggest through a naming convention that it may return null if it is unable to perform a match. I think that having this expressed through the type system is a big improvement.</p>
<p>Right.. now, let's try and make some more direct steps towards actually parsing something! I want to read that &quot;name&quot; value into a class called <strong>IdentifierDetails</strong>:</p>
<pre><code>public sealed class IdentifierDetails
{
  public static ImmutableList&lt;char&gt; DisallowedCharacters { get; }
    = Enumerable.Range(0, char.MaxValue)
      .Select(c =&gt; (char)c)
      .Where(c =&gt; !char.IsLetterOrDigit(c) &amp;&amp; (c != '$') &amp;&amp; (c != '_'))
      .ToImmutableList();

  public IdentifierDetails(string value, SourceRangeDetails sourceRange)
  {
    if (value == &quot;&quot;)
      throw new ArgumentException(&quot;may not be blank&quot;, nameof(value));

    var firstInvalidCharacter = value
      .Select((c, i) =&gt; new { Index = i, Character = c })
      .FirstOrDefault(c =&gt; DisallowedCharacters.Contains(c.Character));
    if (firstInvalidCharacter != null)
    {
      throw new ArgumentException(
        string.Format(
          &quot;Contains invalid character at index {0}: '{1}'&quot;,
          firstInvalidCharacter.Index,
          firstInvalidCharacter.Character
        ),
        nameof(value)
      );
    }

    Value = value;
    SourceRange = sourceRange;
  }

  public string Value { get; }
  public SourceRangeDetails SourceRange { get; }

  public override string ToString() =&gt; $&quot;{Value}&quot;;
}

public sealed class SourceRangeDetails
{
  public SourceRangeDetails(uint startIndex, uint length)
  {
    if (length == 0)
      throw new ArgumentOutOfRangeException(nameof(length), &quot;must not be zero&quot;);

    StartIndex = startIndex;
    Length = length;
  }

  public uint StartIndex { get; }

  /// &lt;summary&gt;This will always be greater than zero&lt;/summary&gt;
  public uint Length { get; }

  public override string ToString() =&gt; $&quot;{StartIndex}, {Length}&quot;;
}
</code></pre>
<p><em>These classes illustrates more of the new C# 6 features - property initialisers, expression-bodied members and string interpolation. I think these are all fairly small tweaks that add up to large improvements overall. If you're not already familiar with these and want to know more then I highly recommend this Visual Studio extension: <a href="https://visualstudiogallery.msdn.microsoft.com/a4445ad0-f97c-41f9-a148-eae225dcc8a5">C# Essentials</a>. It makes nice suggestions about how you could use the new features and has the facility to automatically apply the changes to your code; awesome! :)</em></p>
<p>Ok.. so now we can start tying this all together. Say we have an <strong>IReadStringContent</strong> implementation which is pointing at the &quot;name: string;&quot; content. We could write another function that tries to parse the property's details, starting with something like -</p>
<pre><code>public static Optional&lt;MatchResult&lt;PropertyDetails&gt;&gt; GetProperty(IReadStringContent reader)
{
  var identifierMatch = MatchAnythingUntil(reader, IdentifierDetails.DisallowedCharacters);
  if (!identifierMatch.IsDefined)
    return null;

  var readerAfterIdentifier = identifierMatch.Value.Reader;
  var identifier = new IdentifierDetails(
    identifierMatch.Value.Result,
    new SourceRangeDetails(reader.Index, readerAfterIdentifier.Index - reader.Index)
  );

  // .. more code (to check for the &quot;:&quot; separator and to get the type of the property)..
</code></pre>
<p>This function will either return the details of the property or it will return null, meaning that it failed to do so (it is immediately obvious from the method signature that a null return value is possible since its return type is an <strong>Optional</strong>).</p>
<p>Before I go into details on the &quot;.. more code..&quot; section above, we could do with some more helper functions to parse the content after the &quot;name&quot; value - eg.</p>
<pre><code>public static Optional&lt;MatchResult&lt;char&gt;&gt; MatchCharacter(
  IReadStringContent reader,
  char character)
{
  return (reader.Current == character)
    ? MatchResult.New(character, reader.GetNext())
    : null;
}

public static Optional&lt;MatchResult&lt;string&gt;&gt; MatchWhitespace(IReadStringContent reader)
{
  var content = new StringBuilder();
  while ((reader.Current != null) &amp;&amp; char.IsWhiteSpace(reader.Current.Value))
  {
    content.Append(reader.Current.Value);
    reader = reader.GetNext();
  }
  return (content.Length &gt; 0) ? MatchResult.New(content.ToString(), reader) : null;
}
</code></pre>
<p>While we're doing this, let's put the try-to-match-Identifier logic into its own function. It's going to be used in other places (the <strong>IdentifierDetails</strong> will be used for type names, variable names, interface names, class names, property names, etc..) so having it in a reusable method makes sense:</p>
<pre><code>public static Optional&lt;MatchResult&lt;IdentifierDetails&gt;&gt; GetIdentifier(
  IReadStringContent reader)
{
  var identifierMatch = MatchAnythingUntil(reader, IdentifierDetails.DisallowedCharacters);
  if (!identifierMatch.IsDefined)
    return null;

  var readerAfterIdentifier = identifierMatch.Value.Reader;
  return MatchResult.New(
    new IdentifierDetails(
      identifierMatch.Value.Result,
      new SourceRangeDetails(reader.Index, readerAfterIdentifier.Index - reader.Index)
    ),
    readerAfterIdentifier
  );
}
</code></pre>
<p>Now, the work-in-progress GetProperty function looks like this:</p>
<pre><code>public static Optional&lt;MatchResult&lt;PropertyDetails&gt;&gt; GetProperty(IReadStringContent reader)
{
  IdentifierDetails identifier;
  var identifierMatch = GetIdentifier(reader);
  if (identifierMatch.IsDefined)
  {
    identifier = identifierMatch.Value.Result;
    reader = identifierMatch.Value.Reader;
  }
  else
    return null;

  var colonMatch = MatchCharacter(reader, ':');
  if (colonMatch.IsDefined)
    reader = colonMatch.Value.Reader;
  else
    return null;

  var whitespaceMatch = MatchWhitespace(reader);
  if (colonMatch.IsDefined)
    reader = whitespaceMatch.Value.Reader;

  // .. more code..
</code></pre>
<p>Hmm.. that's actually quite a lot of code. And there are already three patterns emerging which are only apparent if you look closely and pay attention to what's going on -</p>
<ol>
<li>The &quot;identifier&quot; reference is required and the retrieved value is stored (then the &quot;reader&quot; reference is updated to point at the content immediately after the identifier)</li>
<li>The colon separator is required, but the &quot;Value&quot; of the <strong>MatchResult</strong> is not important - we just want to know that the character is present (and to move the &quot;reader&quot; reference along to the content after it)</li>
<li>The white space matching is optional - there doesn't <em>need</em> to be whitespace after the colon and before the type name (and if there is such whitespace then we don't store its value, it's of no interest to us, we just want to be able to get a &quot;reader&quot; reference that skips over any whitespace)</li>
</ol>
<p>This feels like it's going to get repetitive very quickly and that silly mistakes could easily slip in. I don't like the continued re-assignment of the &quot;reader&quot; reference, I can see myself making a stupid mistake in code like that quite easily.</p>
<p>On top of this, the code above misses a valid case - where there is whitespace <em>before</em> the colon as well as after it (eg. &quot;name : string;&quot;).</p>
<p>We can do better.</p>
<h3 id="lets-get-functional"><a href="/parsing-typescript-definitions-functionally-ish#lets-get-functional">Let's get functional</a></h3>
<p>What I'd like to do is chain the content-matching methods together. My first thought was how jQuery chains functions one after another, but LINQ might have been just as appropriate an inspiration.</p>
<p>The way that both of these libraries work is that they have standard input / output types. In LINQ, you can get a lot of processing done based just on <strong>IEnumerable&lt;T&gt;</strong> references. With jQuery, you're commonly working with sets of DOM elements (it has methods like &quot;<a href="http://api.jquery.com/jquery.map/">map</a>&quot;, though, so nothing forces you to operate <em>only</em> on sets of elements).</p>
<p>So what I need to do is to encourage my parsing functions into a standard form. Well.. that's not quite true. I like my parsing functions as they are! They're clear and succinct and their type signatures are informative (&quot;GetIdentifier&quot; takes a non-null reader reference and returns either a result-plus-reader-after-the-result or a no-match response; similarly MatchCharacter has a very simple but descriptive signature).</p>
<p>What I <em>really</em> want to do is to create something generic that will wrap these parser functions and let me chain them together.</p>
<p>Before I do this, I'm going to try to create a definition for the parser signatures that I want to wrap. (I know, I know - I've <em>just</em> said that I'm happy with my little matching functions just the way they are! But this will only be a way to guide them all together into a happy family). So this is what I've come up with:</p>
<pre><code>public delegate Optional&lt;MatchResult&lt;T&gt;&gt; Parser&lt;T&gt;(
  IReadStringContent reader
);
</code></pre>
<p>The &quot;GetIdentifier&quot; method already matches this delegate perfectly. As does &quot;MatchWhitespace&quot;. The &quot;MatchCharacter&quot; function doesn't, however, due to its argument that specifies <em>what</em> character it is to look for.</p>
<p>What I'm going to do, then, is change &quot;MatchCharacter&quot; into a function that <em>creates</em> a <strong>Parser</strong> delegate. We go from:</p>
<pre><code>public static Optional&lt;MatchResult&lt;char&gt;&gt; MatchCharacter(
  IReadStringContent reader,
  char character)
{
  return (reader.Current == character)
    ? MatchResult.New(character, reader.GetNext())
    : null;
}
</code></pre>
<p>to</p>
<pre><code>public static Parser&lt;char&gt; MatchCharacter(char character)
{
  return reader =&gt;
  {
    return (reader.Current == character)
      ? MatchResult.New(character, reader.GetNext())
      : null;
  };
}
</code></pre>
<p>That was pretty painless, yes?</p>
<p>But now that our parser functions take a consistent form, we can wrap them up in some sort of structure that allows them to be chained together. I'm going to create an extension method -</p>
<pre><code>public static Optional&lt;IReadStringContent&gt; Then&lt;T&gt;(
  this Optional&lt;IReadStringContent&gt; reader,
  Parser&lt;T&gt; parser,
  Action&lt;T&gt; report)
{
  if (!reader.IsDefined)
    return null;

  var result = parser(reader.Value);
  if (!result.IsDefined)
    return null;

  report(result.Value.Result);
  return Optional.For(result.Value.Reader);
}
</code></pre>
<p>This is an extension for <strong>Optional&lt;IReadStringContent&gt;</strong> that also <em>returns</em> an <strong>Optional&lt;IReadStringContent&gt;</strong>. So multiple calls to this extension method could be chained together. It takes a <strong>Parser&lt;T&gt;</strong> which dictates what sort of parsing it's going to attempt. If it succeeds then it passes the matched value out through an <strong>Action&lt;T&gt;</strong> and then returns a reader for the position in the content immediately after that match. If the parser fails to match the content then it returns a &quot;Missing&quot; optional reader.</p>
<p>Any time that &quot;Then&quot; is called, if it is given a &quot;Missing&quot; reader then it returns a &quot;Missing&quot; response immediately. That means that we could string these together and when one of them fails to match, any subsequent &quot;Then&quot; calls will effectively be skipped over and the &quot;Missing&quot; value will pop out the bottom.</p>
<p>Before I show some demonstration code, I want to introduce two variations. For values such as the property name (going back to the &quot;name: string;&quot; example), the name of that property is vitally important - it's a key part of the content. However, with the colon separator, we only want to know that it's present, we don't really care about it's value. So the first variation of &quot;Then&quot; doesn't bother with the I've-matched-this-content callback:</p>
<pre><code>public static Optional&lt;IReadStringContent&gt; Then&lt;T&gt;(
  this Optional&lt;IReadStringContent&gt; reader,
  Parser&lt;T&gt; parser)
{
  return Then(reader, parser, value =&gt; { });
}
</code></pre>
<p>The second variation relates to whitespace-matching. The thing with whitespace around symbols is that, not only do we not care about the &quot;value&quot; of that whitespace, we don't care whether it's there or not! The space in &quot;name: string;&quot; is not significant. Enter &quot;ThenOptionally&quot;:</p>
<pre><code>public static Optional&lt;IReadStringContent&gt; ThenOptionally&lt;T&gt;(
  this Optional&lt;IReadStringContent&gt; reader,
  Parser&lt;T&gt; parser)
{
  if (!reader.IsDefined)
    return null;

  return Optional.For(
    Then(reader, parser).GetValueOrDefault(reader.Value)
  );
}
</code></pre>
<p>This will try to apply a parser to the current content (if there is any). If the parser matches content, that's great! We'll return a reader that points to the content immediately after the match. However, if the parser <em>doesn't</em> match any content, then we'll just return the same reader that we were given in the first place.</p>
<p>This becomes less abstract if we refactor the &quot;GetProperty&quot; function to take advantage of these new functions -</p>
<pre><code>public static Optional&lt;MatchResult&lt;PropertyDetails&gt;&gt; GetProperty(IReadStringContent reader)
{
  IdentifierDetails name = null;
  ITypeDetails type = null;
  var readerAfterProperty = Optional.For(reader)
    .Then(GetIdentifier, value =&gt; name = value)
    .ThenOptionally(MatchWhitespace)
    .Then(MatchCharacter(':'))
    .ThenOptionally(MatchWhitespace)
    .Then(GetTypeScriptType, value =&gt; type = value)
    .ThenOptionally(MatchWhitespace)
    .Then(MatchCharacter(';'));

  if (!readerAfterProperty.IsDefined)
    return null;

  return MatchResult.New(
    new PropertyDetails(name, type),
    readerAfterProperty.Value
  );
}
</code></pre>
<p>Well, isn't that much nicer!</p>
<p>Before, it looked like this method was going to run away with itself. And I said that I didn't like the fact that there seemed be a lot of &quot;noise&quot; required to describe the patterns &quot;if this is matched then record the value and move on&quot; / &quot;if this is matched, I don't care about its value, just move the reader on&quot; / &quot;I don't care if this is matched or not, but if it <em>is</em> then move the reader past it&quot;.</p>
<p>This is a lovely example of C#'s type inference - each call to &quot;Then&quot; or &quot;ThenOptionally&quot; has a generic type, but those types did not need to be explicitly specified in the code above. When &quot;Then&quot; is provided &quot;GetIdentifier&quot; as an argument, it knows that the &quot;T&quot; in &quot;Then&lt;T&gt;&quot; is an <strong>IdentifierDetails</strong> because the return type of &quot;GetIdentifier&quot; is an <strong>Optional&lt;MatchResult&lt;IdentifierDetails&gt;&gt;</strong>.</p>
<p>It's also an example of.. if I've got this right.. the Monad Pattern. That concept that seems impossibly theoretical in 99% of articles you read (or maybe that's just me). Even this highly-upvoted answer on Stack Overflow by the ever-readable Eric Lippert starts off sounding very dense and full of abstract terms: <a href="http://stackoverflow.com/a/2704795">Monad in plain English</a>.</p>
<p>I don't want to get too hung up on all that, though, I just thought it was interesting to highlight the concept in use in some practical code. Plus, if I try to make myself out as some functional programming guru then someone might pick on me for writing &quot;Then&quot; in such a way that it requires a side effect to report the value it matches - side effects are so commonly (and fairly, imho) seen as an evil that must be minimised that it seems strange to write a function that will be used in many places that <em>relies</em> upon them. However, with C#, I think it would be complicated to come up with a structure that is passed through the &quot;Then&quot; calls, along with the <strong>Optional&lt;IReadStringContent&gt;</strong>, and since the side effects are so localised here, it's not something I'm going to lose sleep over. Maybe it will be easier if &quot;<a href="https://github.com/dotnet/roslyn/issues/206">record types</a>&quot; get implemented in C# 7, or maybe it's just an exercise for the reader to come up with an elegant solution and let me know! :)</p>
<p>Speaking of exercises for the reader, you might have noticed that I haven't included the source code for the <strong>ITypeDetails</strong> interface or the &quot;GetTypeScriptType&quot; function. That's because I haven't finished writing them yet! To be honest, I've been having a bit of an attention span problem so I thought I'd switch from writing code to writing a blog post for a little while. Hopefully, at some point, I'll release the source in case it's of any use to anyone else - but for now it's such work-in-progress that it's not even much use to <em>me</em> yet!</p>
<h3 id="refinements"><a href="/parsing-typescript-definitions-functionally-ish#refinements">Refinements</a></h3>
<p>After wrapping the &quot;GetIdentifier&quot;, &quot;MatchCharacter&quot;, etc.. functions in &quot;Then&quot; calls, I felt like renaming them. In general, I prefer to have variables and properties named as nouns and functions named as verbs. However, when functions are being passed around as arguments for other functions, it blurs the borders! So, since &quot;GetIdentifier&quot; and &quot;MatchWhitespace&quot; are only ever passed into &quot;Then&quot; as arguments, I've switched them from being verbs into being nouns (simply &quot;Identifer&quot; and &quot;Whitespace&quot;).</p>
<p>I've also shortened the &quot;MatchCharacter&quot; function to just &quot;Match&quot;. It's still a verb, but that's because it will be passed a character to match - and the <strong>Parser</strong> that the &quot;Match&quot; function returns is passed to &quot;Then&quot;. (To make things worse, &quot;Match&quot; can be either a verb <em>or</em> a noun, but in this case I'm taking it to be a verb!).</p>
<p>Now &quot;GetPropertyDetails&quot; looks like this:</p>
<pre><code>public static Optional&lt;MatchResult&lt;PropertyDetails&gt;&gt; GetProperty(IReadStringContent reader)
{
  IdentifierDetails name = null;
  ITypeDetails type = null;
  var readerAfterProperty = Optional.For(reader)
    .Then(Identifier, value =&gt; name = value)
    .ThenOptionally(Whitespace)
    .Then(Match(':'))
    .ThenOptionally(Whitespace)
    .Then(TypeScriptType, value =&gt; type = value)
    .ThenOptionally(Whitespace)
    .Then(Match(';'));

  if (!readerAfterProperty.IsDefined)
    return null;

  return MatchResult.New(
    new PropertyDetails(name, type),
    readerAfterProperty.Value
  );
}
</code></pre>
<p>They're only little changes, but now the code is closer to directly expressing the intent (&quot;match an Identifier then optionally match whitespace then match the colon separator then optionally whitespace then the type, etc..&quot;).</p>
<p>To take another example from the work I've started - this is how I parse a TypeScript interface header:</p>
<pre><code>IdentifierDetails interfaceName = null;
ImmutableList&lt;GenericTypeParameterDetails&gt; genericTypeParameters = null;
ImmutableList&lt;NamedTypeDetails&gt; baseTypes = null;
var readerAfterInterfaceHeader = Optional.For(reader)
  .Then(Match(&quot;interface&quot;))
  .Then(Whitespace)
  .Then(Identifier, value =&gt; interfaceName = value)
  .ThenOptionally(Whitespace)
  .If(Match('&lt;')).Then(GenericTypeParameters, value =&gt; genericTypeParameters = value)
  .ThenOptionally(Whitespace)
  .ThenOptionally(InheritanceChain, value =&gt; baseTypes = value)
  .ThenOptionally(Whitespace)
  .Then(Match('{'));
</code></pre>
<p>There are a couple of functions I haven't included the source for here (&quot;GenericTypeParameters&quot; and &quot;InheritanceChain&quot;) because I really wanted this example to be used to show how easy it is to extend functionality like &quot;Then&quot; and &quot;Match&quot; for different cases. I introduced a &quot;Match&quot; method signature that takes a string instead of a single character -</p>
<pre><code>public static Parser&lt;string&gt; Match(string value)
{
  if (value == &quot;&quot;)
    throw new ArgumentException(&quot;may not be blank&quot;, nameof(value));

  return reader =&gt;
  {
    // Enumerate the characters in the &quot;value&quot; string and ensure that the reader
    // has characters that match, moving the reader along one character each
    // time until either every character in the string is tested or until
    // a non-matching character is encountered from the reader
    var numberOfMatchedCharacters = value
      .TakeWhile(c =&gt;
      {
        if (reader.Current != c)
          return false;
        reader = reader.GetNext();
        return true;
      })
      .Count();
    if (numberOfMatchedCharacters &lt; value.Length)
      return null;

    return MatchResult.New(value, reader);
  };
}
</code></pre>
<p>And I introduced an &quot;If&quot; function, which basically says &quot;if this Parser is found to be a match, then move past it and use this other Parser on the subsequent content - but if that first Parser did <em>not</em> match, then ignore the second one&quot;. This makes it easy to parse either of the following interface headers:</p>
<pre><code>// This interface has no generic type parameters..
interface ISomething {

// .. but this one does
interface ISomethingElse&lt;TKey, TValue&gt; {
</code></pre>
<p>The &quot;If&quot; function allows us to say &quot;if this interface has a pointy bracket that indicates some generic type params then parse them, otherwise don't bother trying&quot;. And it <em>could</em> be implemented thusly:</p>
<pre><code>public static Optional&lt;IReadStringContent&gt; If&lt;TCondition, TResult&gt;(
  this Optional&lt;IReadStringContent&gt; reader,
  Parser&lt;TCondition&gt; condition,
  Parser&lt;TResult&gt; parser,
  Action&lt;TResult&gt; report)
{
  if (!reader.IsDefined)
    return null;

  var readerAfterCondition = condition(reader.Value);
  if (!readerAfterCondition.IsDefined)
    return reader;

  return Then(Optional.For(readerAfterCondition.Value.Reader), parser, report);
}
</code></pre>
<p>However, that function takes three arguments in one continuous list: 1. the condition, 2. the parser-if-condition-is-met, 3. callback-if-condition-is-met-and-then-subsequent-parser-matches-content. So it would be called like:</p>
<pre><code>.If(Match('&lt;'), GenericTypeParameters, value =&gt; genericTypeParameters = value)
</code></pre>
<p>which isn't terrible.. but I think it's even better to have &quot;If&quot; return an interim type (a &quot;<strong>ConditionalParser&lt;T&gt;</strong>&quot;) that has its own &quot;Then&quot; function that is only called if the condition parser matches content - ie.</p>
<pre><code>// Using C# 6 &quot;expression-bodied member&quot; syntax..
public static ConditionalParser&lt;T&gt; If&lt;T&gt;(
  this Optional&lt;IReadStringContent&gt; reader,
  Parser&lt;T&gt; parser) =&gt; new ConditionalParser&lt;T&gt;(reader, parser);

public sealed class ConditionalParser&lt;TCondition&gt;
{
  private readonly Optional&lt;IReadStringContent&gt; _reader;
  private readonly Parser&lt;TCondition&gt; _condition;
  public ConditionalParser(
    Optional&lt;IReadStringContent&gt; reader,
    Parser&lt;TCondition&gt; condition)
  {
    _reader = reader;
    _condition = condition;
  }

  public Optional&lt;IReadStringContent&gt; Then&lt;T&gt;(Parser&lt;T&gt; parser, Action&lt;T&gt; report)
  {
    if (!_reader.IsDefined || !_reader.Then(_condition).IsDefined)
      return _reader;

    return _reader.Then(parser, report);
  }
}
</code></pre>
<p>That way, the resulting code is just a little closer to the original intent. Instead of</p>
<pre><code>.If(Match('&lt;'), GenericTypeParameters, value =&gt; genericTypeParameters = value)
</code></pre>
<p>we can use</p>
<pre><code>.If(Match('&lt;')).Then(GenericTypeParameters, value =&gt; genericTypeParameters = value)
</code></pre>
<p>And because the <strong>ConditionalParser</strong>'s &quot;Then&quot; function returns an <strong>Optional&lt;IReadStringContent&gt;</strong> we can go back to chaining more &quot;Then&quot; calls right on to it (as I do in the &quot;InterfaceHeader&quot; example above).</p>
<h3 id="in-conclusion"><a href="/parsing-typescript-definitions-functionally-ish#in-conclusion">In conclusion..</a></h3>
<p>I really like how the techniques I've talked about work together and how combining these small functions enables complex forms to be described while still keeping things manageable. Having the complexity grow at a nice linear rate, rather than multiplying out every time something new needs to be considered, is very gratifying. Not to mention that having these small and simple functions also makes automated testing a lot easier.</p>
<p>All of the functions shown are pure (although some technically have side effects, these effects are only<br />
actioned through lambdas that are passed to the functions as arguments) and nothing shares state, which makes the code very easy to reason about.</p>
<p>And it's nice to be able to see my own coding style evolving over time. It's an often-heard clich that you'll hate your own code from six months ago, but lately I feel like I'm looking back to code from a couple of years ago and being largely content with it.. there's always things I find that I'd do slightly differently now, but rarely anything too egregious (I had to fix up some code I wrote more than five years ago recently, now <em>that</em> was an unpleasant surprise!) so it's gratifying to observe myself changing (in positive ways, I hope!).</p>
<p>Maybe now's a good time to give F# another proper go..</p>
<p class="PostTime">Posted at 22:06</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/simple-typescript-type-definitions-for-amd-modules">Simple TypeScript type definitions for AMD modules</a></li><li><a href="/typescript-state-machines">TypeScript State Machines</a></li><li><a href="/typescript-es6-classes-for-react-components-without-the-hacks">TypeScript / ES6 classes for React components - without the hacks!</a></li></ul></div>
            <p class="Comments">
                <a href="/parsing-typescript-definitions-functionally-ish#disqus_thread" data-disqus-identifier="88">Comments</a>
            </p>
    </div>

        <script type="text/javascript">
            (function () {
                var s = document.createElement("script");
                s.type = "text/javascript";
                s.async = true;
                s.src = "https://" + disqus_shortname + ".disqus.com/count.js";
                (document.getElementsByTagName("HEAD")[0] || document.getElementsByTagName("BODY")[0]).appendChild(s);
            }());
        </script>

				<div class="Footer">
					 Productive Rage 2011 - 2025
				</div>
			</div>

			<div class="SideBar">
				<div class="About">
					<h2>About</h2>
					<p>Dan is a big geek who likes making stuff with computers! He can be quite outspoken so clearly needs a blog :)</p>
					<p>In the last few minutes he seems to have taken to referring to himself in the third person. He's quite enjoying it.</p>
					<p><a href="mailto:dangger36@gmail.com" class="Email">dangger36@gmail.com</a></p>
				</div>
				<div class="Search">
<form action="/Search" autocomplete="off" class="Search" method="get">						<div>
							<label class="SearchField">
								<span class="text">Site Search</span>
								<input type="text" class="SiteSearch" name="term" value="" />
							</label>
							<input type="submit" class="SiteSearchSubmit" value="Search" />
						</div>
</form>				</div>
				<div class="Recent"><h2>Recent Posts</h2><ul><li><a href="/hosting-a-digitalocean-app-platform-app-on-a-custom-subdomain-with-cors">Hosting a DigitalOcean App Platform app on a custom subdomain (with CORS)</a></li><li><a href="/approximately-correcting-perspective-with-c-sharp-fixing-a-blurry-presentation-video-part-two">(Approximately) correcting perspective with C# (fixing a blurry presentation video - part two)</a></li><li><a href="/finding-the-brightest-area-in-an-image-with-c-sharp-fixing-a-blurry-presentation-video-part-one">Finding the brightest area in an image with C# (fixing a blurry presentation video - part one)</a></li><li><a href="/so-what-is-machine-learning-nocodeintro">So.. what is machine learning? (#NoCodeIntro)</a></li><li><a href="/parallelising-linq-work-in-c-sharp">Parallelising (LINQ) work in C#</a></li></ul><div class="RSSFeedLink"><a href="https://www.productiverage.com/feed">RSS Feed</a></div></div>
				<div class="Featured"><h2>Highlights</h2><ul><li><a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face (finding faces in photos using C# and Accord.NET)</a></li><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/translating-vbscript-into-c-sharp">Translating VBScript into C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div>
				<div class="History"><h2>Archives</h2><ul><li><a href="/Archive/4/2025">April 2025 (1)</a></li><li><a href="/Archive/3/2022">March 2022 (2)</a></li><li><a href="/Archive/2/2022">February 2022 (1)</a></li><li><a href="/Archive/8/2021">August 2021 (1)</a></li><li><a href="/Archive/4/2021">April 2021 (2)</a></li><li><a href="/Archive/3/2021">March 2021 (1)</a></li><li><a href="/Archive/8/2020">August 2020 (3)</a></li><li><a href="/Archive/7/2019">July 2019 (2)</a></li><li><a href="/Archive/9/2018">September 2018 (1)</a></li><li><a href="/Archive/4/2018">April 2018 (1)</a></li><li><a href="/Archive/3/2018">March 2018 (1)</a></li><li><a href="/Archive/7/2017">July 2017 (1)</a></li><li><a href="/Archive/6/2017">June 2017 (1)</a></li><li><a href="/Archive/2/2017">February 2017 (1)</a></li><li><a href="/Archive/11/2016">November 2016 (1)</a></li><li><a href="/Archive/9/2016">September 2016 (2)</a></li><li><a href="/Archive/8/2016">August 2016 (1)</a></li><li><a href="/Archive/7/2016">July 2016 (1)</a></li><li><a href="/Archive/6/2016">June 2016 (1)</a></li><li><a href="/Archive/5/2016">May 2016 (3)</a></li><li><a href="/Archive/3/2016">March 2016 (3)</a></li><li><a href="/Archive/2/2016">February 2016 (2)</a></li><li><a href="/Archive/12/2015">December 2015 (1)</a></li><li><a href="/Archive/11/2015">November 2015 (2)</a></li><li><a href="/Archive/8/2015">August 2015 (3)</a></li><li><a href="/Archive/7/2015">July 2015 (1)</a></li><li><a href="/Archive/6/2015">June 2015 (1)</a></li><li><a href="/Archive/5/2015">May 2015 (2)</a></li><li><a href="/Archive/4/2015">April 2015 (1)</a></li><li><a href="/Archive/3/2015">March 2015 (1)</a></li><li><a href="/Archive/1/2015">January 2015 (2)</a></li><li><a href="/Archive/12/2014">December 2014 (1)</a></li><li><a href="/Archive/11/2014">November 2014 (1)</a></li><li><a href="/Archive/10/2014">October 2014 (2)</a></li><li><a href="/Archive/9/2014">September 2014 (2)</a></li><li><a href="/Archive/8/2014">August 2014 (1)</a></li><li><a href="/Archive/7/2014">July 2014 (1)</a></li><li><a href="/Archive/6/2014">June 2014 (1)</a></li><li><a href="/Archive/5/2014">May 2014 (2)</a></li><li><a href="/Archive/2/2014">February 2014 (1)</a></li><li><a href="/Archive/1/2014">January 2014 (1)</a></li><li><a href="/Archive/12/2013">December 2013 (1)</a></li><li><a href="/Archive/11/2013">November 2013 (1)</a></li><li><a href="/Archive/10/2013">October 2013 (1)</a></li><li><a href="/Archive/8/2013">August 2013 (3)</a></li><li><a href="/Archive/7/2013">July 2013 (3)</a></li><li><a href="/Archive/6/2013">June 2013 (1)</a></li><li><a href="/Archive/5/2013">May 2013 (2)</a></li><li><a href="/Archive/4/2013">April 2013 (1)</a></li><li><a href="/Archive/3/2013">March 2013 (8)</a></li><li><a href="/Archive/2/2013">February 2013 (2)</a></li><li><a href="/Archive/1/2013">January 2013 (2)</a></li><li><a href="/Archive/12/2012">December 2012 (3)</a></li><li><a href="/Archive/11/2012">November 2012 (4)</a></li><li><a href="/Archive/9/2012">September 2012 (1)</a></li><li><a href="/Archive/8/2012">August 2012 (1)</a></li><li><a href="/Archive/7/2012">July 2012 (3)</a></li><li><a href="/Archive/6/2012">June 2012 (3)</a></li><li><a href="/Archive/5/2012">May 2012 (2)</a></li><li><a href="/Archive/2/2012">February 2012 (3)</a></li><li><a href="/Archive/1/2012">January 2012 (4)</a></li><li><a href="/Archive/12/2011">December 2011 (7)</a></li><li><a href="/Archive/8/2011">August 2011 (2)</a></li><li><a href="/Archive/7/2011">July 2011 (1)</a></li><li><a href="/Archive/5/2011">May 2011 (1)</a></li><li><a href="/Archive/4/2011">April 2011 (2)</a></li><li><a href="/Archive/3/2011">March 2011 (3)</a></li></ul><div class="EveryTitle"><a href="/Archive/All">Every Post Title</a></div></div>
			</div>

		</div>
	</div>

	<script type="text/javascript" src="/Scripts/autocomplete.js"></script>
	<script type="text/javascript" src="/Scripts/prettify.js"></script>
	<script type="text/javascript" src="/Scripts/Site.js"></script>
	<script type="text/javascript" src="/Scripts/IndexSearchGenerator.js"></script>
	<script type="text/javascript" src="/Scripts/SearchTermHighlighter.js"></script>
	<script type="text/javascript" src="/Scripts/SearchPage.js"></script>
	<script type="text/javascript" src="/Scripts/LZString.js"></script>

</body>
</html>
