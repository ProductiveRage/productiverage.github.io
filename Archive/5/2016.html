<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Productive Rage - May 2016</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta name="theme-color" content="#393939" />
	<link rel="stylesheet" type="text/css" media="all" href="/Content/Styles.css" />
	<!--[if lt IE 9]>
	<link rel="stylesheet" type="text/css" href="/Content/IEBefore9.css" />
	<![endif]-->
	<link rel="stylesheet" type="text/css" media="print" href="/Content/PrintOverrides.css" />
	<meta name="robots" content="noindex, follow" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.productiverage.com/feed" />
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', "UA-32312857-1"]);
		_gaq.push(['_setSiteSpeedSampleRate', 100]);
		_gaq.push(['_trackPageview']);
		(function () {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>

<body>

	<div class="Header">
		<div class="HeaderContent">
			<h1>
				<a href="/">Productive Rage</a>
			</h1>
			<span class="Tagline">Dan's techie ramblings</span>
		</div>
	</div>

	<div class="WrapperOuter">
		<div class="Wrapper">
			<div class="Main HasSideBar">
				

        <script type="text/javascript">
			var disqus_shortname = "productiverage";
			function executeWhen(fncAction, fncConditional, intDelayBetweenRetries) {
				if (fncConditional()) { fncAction(); return; }
				setTimeout(function () { executeWhen(fncAction, fncConditional, intDelayBetweenRetries); }, intDelayBetweenRetries);
			}
			function whenjQueryIsAvailable(fncAction) {
				executeWhen(
					fncAction,
					function () { return (typeof ($) !== "undefined") },
					10
				);
			}
			(function () {
				whenjQueryIsAvailable(
					function () { $("div.Content p.Comments").show(); }
				);
			}());
        </script>

    <div class="Content ArchiveByMonth">
        <h3 class="PostDate">31 May 2016</h3><h2><a id="a-static-type-system-is-a-wonderful-message-to-the-present-and-future-supplementary" href="/a-static-type-system-is-a-wonderful-message-to-the-present-and-future-supplementary">A static type system is a wonderful message to the present and future - Supplementary</a></h2>
<p>This is an extension of my post &quot;<a href="/a-static-type-system-is-a-wonderful-message-to-the-present-and-future">A static type system is a wonderful message to the present and future</a>. I initially rolled this all together into a single article but then decided to break it into two to make the first part easier to consume.</p>
<p>So, what else did I want to say? Rather than just saying &quot;static typing is better&quot;, I want to express some more detailed &quot;for&quot; and &quot;against&quot; arguments. Spoiler alert: despite the negatives, I still believe that static typing is worth the effort.</p>
<h3>FTW</h3>
<p>I find that the more that I take advantage of the type system, the more reliable that my code becomes - not only in terms of how well it lasts over the years, but how likely that it is to work the first time that it compiles. Going back to some code that I wrote a few years ago, there are various parts of a particular project that deal with internationalisation - some parts want to know what language that particular content is in while some parts of more specific and want to know what language <em>culture</em> it's in; the difference between &quot;English&quot; (the language) and &quot;English UK&quot; / &quot;en-GB&quot; (the language culture). I wish now that, for that project, I'd created a type (in C#, a struct would have been the natural choice) to represent a <strong>LanguageKey</strong> and another for a <strong>LanguageCultureKey</strong> as I encountered several places where it was confusing which was required - some parts of the code had method arguments named &quot;language&quot; that wanted a language key while others had arguments named &quot;language&quot; that wanted a language culture key. The two parts of the project were written by different people at different times and, in both cases, it seemed natural to them to presume that &quot;language&quot; could mean a language key (since nothing more specific was required) or could mean a language culture (since they presumed that nothing <em>less</em> specific would ever be required). This is an example of a place where better argument naming would have helped because it would have been easier to spot if a language culture key was being passed where a language key was required. However, it would have been better again if the compiler would spot the wrong key type being passed - a human might miss it if a naming convention is relied upon, but the compiler will never miss an invalid type.</p>
<p>Another example that I've used in the past is that of React &quot;props&quot; validation - when creating React components (which are used to render DOM elements.. or OS components, if you're using <a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">React Native](http://www.reactnative.com)), you must provide specific information for the component; if it's a Label, for example, then you must provide a text string and maybe a class name string. If you're using JavaScript with React then you will probably be providing the props reference using simple object notation, so you will have to be careful that you remember that the text string is named &quot;text&quot; and not &quot;labelText&quot;. The React library includes support for a &quot;propTypes&quot; object to be defined for a component - this performs validation at runtime, ensuring that required properties have values and that they are of the correct type. If a [strongly-typed language (such as C#)</a> was used to create and consume React components, then this additional runtime validation would not be required as the component's &quot;props&quot; class would be declared as a class and all properties would have the appropriate types specified there. These would be validated at compile time, rather than having to wait until runtime. Returning to the &quot;<a href="https://m.signalvnoise.com/provide-sharp-knives-cc0a22bf7934#.yv2771vf7">Sharp Knives</a>&quot; quote, this may be construed as being validation written for &quot;other programmers&quot; - as in, &quot;I don't want other programmers to try to use my component incorrectly&quot; - but, again, I'm very happy to be the one of the &quot;other programmers&quot; in this case, it allows the type system to work as very-welcome documentation.</p>
<p>While we're talking about React and component props, the React library always treats the props reference for a component as being immutable. If the props data needs to change then the component needs to be re-rendered with a new props reference. If you are writing your application in JavaScript then you need to respect this convention. However, if you choose to write your React application in a strongly-typed language then you may have your props classes represented by immutable types. This enforces this convention through the type system - <em>you</em> (and anyone reviewing your code) don't have to keep a constant vigil against accidental mutations, the compiler will tell you if this is attempted (by refusing to build and pointing out where the mistake made).</p>
<p>The common thread, for me, in all of the reasons why static typing is a good thing is that it enforces things that I want (or that I require) to be enforced, while providing invaluable information and documentation through the types. This makes code easier to reason about and code that is easier to reason about is easier to maintain and extend.</p>
<h3>What static typing can't solve</h3>
<p>It's not a silver bullet. But, then, nothing is. Static typing is a valuable tool that should be used <em>with</em> automated test in order to create a reliable product.</p>
<p>To take a simple example that will illustrate a variety of principles, the following is a LINQ call made in C# to take a set of <strong>EmployeeDetails</strong> instances and determine the average age (we'll assume that <strong>EmployeeDetails</strong> is a class with an integer Age property) -</p>
<pre><code>var averageAge = employees.Average(employee =&gt; employee.Age);
</code></pre>
<p>If we were implementing the &quot;Average&quot; function ourselves, then we would need to populate the following -</p>
<pre><code>public static int Average&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; selector)
{
}
</code></pre>
<p>Static typing gives us a lot of clues here. It ensures that anyone calling &quot;Average&quot; has to provide a set of values that may be enumerated and they have to provide a lambda that extracts an integer from each of those values. If the caller tried to provide a lambda that extracted a string (eg. the employee's name) from the values then it wouldn't compile. The type signature documents many of the the requirements of the method.</p>
<p>However, the type system does not ensure that the implementation of &quot;Average&quot; is correct. It would be entirely possible to write an &quot;Average&quot; function that returned the <em>highest</em> value, rather than the <a href="https://en.wikipedia.org/wiki/Arithmetic_mean">mean</a> value.</p>
<p><em>This is what unit tests are for.</em> Unit tests will ensure that the logic within a method is correct. It will ensure that 30 is returned from &quot;Average&quot; if a set of employees with ages 20, 30 and 40 are provided.</p>
<p>The type system ensures that the code is not called with inappropriate data. If you didn't have a static type system then it would still be possible to write more unit tests around the code that called &quot;Average&quot; to ensure that it was always dealing with appropriate data - but this is an entire class of tests that are not required if you leverage static analysis*.</p>
<p>Unfortunately, there <em>are</em> limitations to what may be expressed in the type system. In the &quot;Average&quot; example above, there is no way (in C#) to express the fact that it's invalid for a null &quot;source&quot; or &quot;selector&quot; reference to be passed or a &quot;source&quot; reference that has zero elements (since there is no such thing as an average value if there are zero values) or a set of items where one of more of the values is null. Any of these cases of bad data will result in a runtime error. However, I believe that the solution to this is not to run away screaming from static typing because it's not perfect - in fact, I think that the answer is <em>more</em> static analysis. <a href="https://github.com/Microsoft/CodeContracts">Code Contracts</a> is a way to include these additional requirements in the type system; to say that &quot;source and selector may not be null&quot; and &quot;source may not be empty&quot; and &quot;source may not contain any null references&quot;. Again, this will be a way for someone consuming the code to have greater visibility of its requirements <em>and</em> for the compiler to enforce them. I will be able to write stricter code to stop other people from making mistakes with it, and other people will be able to write stricter code to make it clearer to me how it should be used and prevent me from making mistakes or trying to use it in ways that is not supported. <em>I don't want the power to try to use code incorrectly</em>.</p>
<p>I think that there are two other obvious ways that static typing can't help and protect you..</p>
<p>Firstly, when dealing with an external system there may be additional rules that you can not (and would not want to, for the sake of preventing duplication) describe in your code. Perhaps you have a data store that you pass updates to in order to persist changes made by a user - say the user wants to change the name of an employee in the application, so an <strong>UpdateEmployeeName</strong> action must be sent to the data service. This action will have an integer &quot;Key&quot; property and a string &quot;Name&quot; property. This class structure ensures that data of the appropriate form is provided but it can <em>not</em> ensure that the Key itself is valid - only the data store will know that. The type system is not an all-seeing-all-knowing magician, so it <em>will</em> allow some invalid states to be represented (such as an update action for an entity key that doesn't exist). But the more invalid states that may <em>not</em> be represented (such as not letting the key, which the data service requires to be an integer, be the string &quot;abc&quot; - for example) means that there are less possible errors states to test against and the code is more reliable (making it harder to write incorrect code will make the code more correct overall and hence more reliable).</p>
<p>Secondly, if the type system is not taken advantage to the fullest extent then it can't help you to the fullest extent. I have worked on code in the past where a single class was used in many places to represent variations on the same data. Sometimes a &quot;Hotel&quot; instance would describe the entity key, the name, the description. Sometimes the &quot;Hotel&quot; instance would contain detailed information about the rooms in the hotel, sometimes the &quot;Rooms&quot; property would be null. Sometimes it would have its &quot;Address&quot; value populated, other times it would be null. It would depend upon the type of request that the &quot;Hotel&quot; instance was returned for.  This is a poor use of the type system - different response types should have been used, it should have been clear from the returned type what data would be present. The more often we're in a &quot;sometimes this, sometimes that&quot; situation, the less reliable that the code will be as it becomes easier to forget one of &quot;sometimes&quot; cases (again, I'm talking from personal experience and not just worrying about how this may or may not affect &quot;other programmers&quot;). Unfortunately, not even the potential for a strong type system can make shitty code good.</p>
<p>* <em>(It's probably worth stating that a static type system is one way that tooling can automatically identify mistakes for you but it's not the only way - <a href="https://github.com/Microsoft/CodeContracts">code contracts</a> are a way to go beyond what C# can support &quot;out of the box&quot; but there are other approaches, such as what <a href="http://www.gamasutra.com/view/news/128836/InDepth_Static_Code_Analysis.php">John Carmark has written about static analysis of C++</a> or how <a href="http://flowtype.org/">Facebook is analysing JavaScript without even requiring types to be explicitly declared</a></em>)</p>
<h3>Code Reviews</h3>
<p>Another quote that stuck out for me in the &quot;<a href="https://m.signalvnoise.com/provide-sharp-knives-cc0a22bf7934#.yv2771vf7">Sharp Knives</a>&quot; post was that</p>
<blockquote>
<p>We enforce such good senses by convention, by nudges, and through education</p>
</blockquote>
<p>This is very sensible advice. I think that one of the best ways for code quality to remain high is through developers working together - learning from each other and supporting each other. This is something that I've found code reviews to be very effective for. If all code is reviewed, then all code is guaranteed to have been read by at least two people; the author and the reviewer. If the code is perfect, then that's where the review ends - on a high note. If the code needs work then any mistakes or improvements can be highlighted and addressed. As the recipient of a review that identifies a mistake that I've made, I'm happy! Well.. I'm generally a bit annoyed with myself for making the mistake but I'm glad that a colleague has identified it rather than it getting to an end user.</p>
<p>As a code reviewer, I will be happy with code that I think requires no changes or if code needs to be rejected only once. I've found that code that is rejected and then fixed up is much harder to re-review and that bugs more often slip through the re-review process. It's similar to the way in which you can more easily become blind to bugs in code that you've just written than you are to someone else's code - you have a familarity with the code that you are reviewing for a second time <em>and</em> someone has just told you that they have fixed it; I've found that there is something psychological about that that makes it just that little bit harder to pick up on any subsequent mistakes. Thusly, I would prefer to limit the number of times that reviews bounce back and forth.</p>
<p>I have found that a static type system encourages a stricter structure on the code and that conventions are clearer, not to mention the fact that the compiler can identify more issues - meaning that there should be fewer types of mistake that can get through to a review. There is, of course, a limit to what the type system can contribute on this front but <em>any</em> mechanical checks that a computer could perform leave the reviewer more time (and mental capacity) to provide deeper insight; to offer guidance to a more junior developer or to suggest implementation tweaks to a peer.</p>
<h3>A &quot;wonderful message&quot;</h3>
<p>It's a theme that has picked up more and more weight for me over the years, that the computer should be able to help me tell it what to do - I should be able to leverage its strengths in order to multiply mine. As a developer, there is a lot of creativity required but also a huge quantity of seemingly banal details. The strength of a good abstraction comes from being able to &quot;hide away&quot; details that don't matter, leaving you with larger and more useful shapes to deal with, allowing you to think closer to the big picture. The more details that may be automatically verified, the less that you need to worry about them; freeing up more valuable mental space. Leaning on static analysis aids this, it allows the computer to do what it's good at and concentrate on the simple-and-boring rules, allowing you to become more effective. It's an incredibly powerful tool, the ability to actually limit certain things from being done allows you to do <em>more</em> of what you should be doing.</p>
<p>It can also be an invaluable form of documentation for people using your code (including you, in six months, when you've forgotten the finer details). Good use of the type system allows for the requirements and the intent of code to be clearer. It's not just a way of communicating with the compiler, it's also a very helpful way to communicate with human consumers of your code.</p>
<p>On a personal note, this marks my 100th post on this blog. The first (<a href="/i-love-immutable-data">I love Immutable Data</a>) was written about five years ago and was <em>also</em> (basically) about leveraging the type system - by defining immutable types and the benefits that they could have. I find it reassuring that, with all that I've seen since then (and thinking back over the time since I first started writing code.. over 25 years ago) that this still feels like a good thing. In a time where it seems like everyone's crying about JavaScript fatigue (and the frequent off-the-cuff comments about React being &quot;<a href="https://camo.githubusercontent.com/a85f7c2c03b36655323ec7a3250057233e82ef55/68747470733a2f2f692e696d6775722e636f6d2f695549497571622e6a7067">so hot right now</a>&quot;*), I'm glad that there are still plenty of principles that stand the test of time.</p>
<p>* <em>(Since I'm feeling so brave and self-assured, I'm going to say that I think that React *will* still be important five years from now - maybe I'll look back in 2021 and see how this statement has fared!)</em></p>
<p class="PostTime">Posted at 21:34</p>
            <p class="Comments">
                <a href="/a-static-type-system-is-a-wonderful-message-to-the-present-and-future-supplementary#disqus_thread" data-disqus-identifier="101">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByMonth">
        <h3 class="PostDate">31 May 2016</h3><h2><a id="a-static-type-system-is-a-wonderful-message-to-the-present-and-future" href="/a-static-type-system-is-a-wonderful-message-to-the-present-and-future">A static type system is a wonderful message to the present and future</a></h2>
<p>Last week, I read the article &quot;<a href="http://solnic.eu/2016/05/22/my-time-with-rails-is-up.html">My time with Rails is up</a>&quot; (by <a href="https://twitter.com/_solnic_">Piotr Solnica</a>) which resulted in me reading some of <a href="https://medium.com/@dhh">DHH</a>'s latest posts and re-reading some of his older ones.</p>
<p>Some people write articles that I enjoy reading because they have similar ideas and feelings about development that I do, that they manage to express in a new or particularly articulate way that helps me clarify it in my own head or that helps me think about whether I really do still agree with the principle. Some people write articles that come from a completely different point of view and experience to me and these also can have a lot of benefit, in that they make me reconsider where I stand on things or inspire me to try something different to see how it feels. DHH is, almost without fail, interesting to read and I like his passion and conviction.. but he's definitely not in that first category of author. There was one thing in particular, though, that really stuck out for me in his post &quot;<a href="https://m.signalvnoise.com/provide-sharp-knives-cc0a22bf7934#.yv2771vf7">Provide sharp knives</a>&quot; -</p>
<blockquote>
<p>Ruby includes a lot of sharp knives in its drawer of features.. The most famous is monkey patching: The power to change existing classes and methods. .. it offered a different and radical perspective on the role of the programmer: That they could be trusted with sharp knives. .. That’s an incredibly aspirational idea, and one that runs counter to a lot of programmer’s intuition about other programmers.</p>
<p>Because it’s always about other programmers when the value of sharp knives is contested. <strong>I’ve yet to hear a single programmer put up their hand and say &quot;I can’t trust myself with this power, please take it away from me!&quot;. It’s always &quot;I think other programmers would abuse this&quot;</strong></p>
</blockquote>
<p>The highlighted section of the quote is what I disagree with most - because I absolutely <em>do</em> want to be able to write code in a way that limits how I (as well as others) may use it.</p>
<h3>And I strongly disagree with it because..</h3>
<p>The harsh reality is that all code is created according to a particular set of limitations and compromises that are present at the time of writing. The more complex the task that the code must perform, the more likely that there will be important assumptions that are &quot;baked into&quot; the code and that it would be beneficial for someone using the code to be aware of. A good type system can be an excellent way to communicate some of these assumptions. And, unlike documentation, convention or code review, a good type system can allow these assumptions to be <em>enforced</em> by the computer - rather than a principle that <em>should be treated as unbreakable</em> being allowed to be ignored. Computers are excellent at verifying simple sets of rules, which allow them to help identify common mistakes (or miscomprehensions).</p>
<p>At the very simplest level, specifying types for a method's arguments makes it much less likely that I'll refactor my code by swapping two of the arguments and then miss one of the call sites and not find out that something now fails until runtime (the example sounds contrived but, unfortunately, it <em>is</em> something that I've done from time to time). Another simple example is that having descriptive classes reminds me precisely what the minimum requirements are for a method without having to poke around <em>inside</em> the method - if there is an argument named &quot;employeeSummaries&quot; in a language without type annotations, I can presume that it's some sort of collection type.. but should each value in the collection include just the key and name of each employee or should it be key, name and some other information that the method requires such as, say, a list of reporting employees that the employee is responsible for managing? With a type system, if the argument is <strong>IEnumerable&lt;EmployeeSummary&gt;</strong> then I can see what information I have to provide by looking at the <strong>EmployeeSummary</strong> class.</p>
<p>A more complex example might involve data that is shared across multiple threads, whether for parallel processing or just for caching. The simplest way to write this sort of code reliably is to prevent mutation of the data from occurring on multiple threads and one way to achieve that is for the data to be represented by immutable data types. If the multi-threaded code requires that the data passed in be immutable then it's hugely beneficial for the type system to be able to specify that immutable types be used, so that the internal code may be written in the simplest way - based on the requirement that the data not be mutable.</p>
<p>I want to reinforce here that this is not just about me trying to stop other people from messing up when they use my code, <em>this is just as much about me</em>. Being able to represent these sorts of key decisions in the type system means that I can actually be a little bit less obsessive with how much I worry about them, easing the mental burden. This, in turn, leaves me more mental space to concentrate on solving the real problem at hand. I won't be able to forget to pass data in an immutable form to methods that require it in an immutable form, because the compiler won't let me do so.</p>
<h3>Isn't this what automated tests are for?</h3>
<p>An obvious rebuttal is that these sorts of errors (particular the mixing-up-the-method-arguments example) can (and should) be caught by unit tests.</p>
<p>In my opinion: no.</p>
<p>I believe that unit tests <em>are</em> required to test logic in an application and it <em>is</em> possible to write unit tests that show how methods work when given the correct data and that show how they will fail when given invalid data but it's difficult (and arduous) to prove, using automated tests, that the same guarantees that a type system could enforce are not being broken anywhere in your code. The only-allow-immutable-data-types-to-be-passed-into-this-thread-safe-method example is a good one here since multi-threaded code will often appear to work fine when only executed within a single thread, meaning that errors will only surface when multiple threads are working with it simultaneously. Writing unit tests to try to detect race conditions is not fun. You could have 100% code coverage and not always pick up on all of the horrible things that can happen when multiple threads deal with mutable data. If the data passed around within those code paths is <em>immutable</em>, though (which may be enforced through the types passed around), then these potential races are prevented.</p>
<p>Good use of static typing means that an entire class of unit tests are not required.</p>
<p>The fact that static typing is not enough to confirm that your code is correct, and that unit tests should be written as well, does not mean that <em>only</em> units tests should be used.</p>
<p>I've kept this post deliberately short because I would love for it to have some impact and experience has taught me that it's much more difficult for that to be the case with a long format post. I've expanded on this further at &quot;<a href="/a-static-type-system-is-a-wonderful-message-to-the-present-and-future-supplementary">A static type system is a wonderful message to the present and future - Supplementary</a>&quot;. There's more about the benefits, more about the limitations, more examples of me saying &quot;I don't want the power to do try to do something that this code has been explicitly written not to have to deal with&quot; and <em>no more</em> mentions of multi-threading because static typing's benefits are not restricted to especially complicated problem domains, applications may benefit regardless of their complexity.</p>
<p class="PostTime">Posted at 21:33</p>
            <p class="Comments">
                <a href="/a-static-type-system-is-a-wonderful-message-to-the-present-and-future#disqus_thread" data-disqus-identifier="100">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByMonth">
        <h3 class="PostDate">4 May 2016</h3><h2><a id="using-roslyn-code-fixes-to-make-the-frictionless-immutable-objects-in-bridge-even-easier" href="/using-roslyn-code-fixes-to-make-the-frictionless-immutable-objects-in-bridge-even-easier">Using Roslyn code fixes to make the &quot;Friction-less immutable objects in Bridge&quot; even easier</a></h2>
<p>This is going to be a short post about a Roslyn (or &quot;The .NET Compiler Platform&quot;, if you're from Microsoft) analyser and code fix that I've added to a library. I'm not going to try to take you through the steps required to create an analyser nor how the Roslyn object model describes the code that you've written in the IDE* but I want to talk about the analyser itself because it's going to be very useful if you're one of the few people using my <a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a> library. Also, I feel like the inclusion of analysers with libraries is something that's going to become increasingly common (and I want to be able to have something to refer back to if I get the chance to say &quot;told you!&quot; in the future).</p>
<p>* <em>(This is largely because I'm still struggling with it a bit myself; my current process is to start with <a href="https://msdn.microsoft.com/en-gb/magazine/dn879356.aspx">Use Roslyn to Write a Live Code Analyzer for Your API</a> and the &quot;Analyzer with Code Fix (NuGet + VSIX)&quot; Visual Studio template. I then tinker around a bit and try running what I've got so far, so that I can use the &quot;Syntax Visualizer&quot; in the Visual Studio instance that is being debugged. Then I tend to do a lot of Google searches when I feel like I'm getting close to something useful.. how do I tell if a <strong>FieldDeclarationSyntax</strong> is for a readonly field or not? Oh, good, someone else has already written some code doing something like what  I want to do - I look at the &quot;Modifiers&quot; property on the <strong>FieldDeclarationSyntax</strong> instance).</em></p>
<p>As new .net libraries get written, some of them will have guidelines and rules that can't easily be described through the type system. In the past, the only option for such rules would be to try to ensure that the documentation (whether this be the project README and / or more in-depth online docs and / or the xml summary comment documentation for the types, methods, properties and fields that intellisense can bring to your attention in the IDE). The support that Visual Studio 2015 introduced for customs analysers* allows these rules to be communicated in a different manner.</p>
<p>* <em>(I'm being English and stubborn, hence my use of &quot;analysers&quot; rather than &quot;analyzers&quot;)</em></p>
<p>In short, they allow these library-specific guidelines and rules to be higlighted in the Visual Studio Error List, just like any error or warning raised by Visual Studio itself (even refusing to allow the project to be built, if an error-level message is recorded).</p>
<p>An excellent example that I've seen recently was encountered when I was writing some of my own analyser code. To do this, you can start with the &quot;Analyzer with Code Fix (NuGet + VSIX)&quot; template, which pulls in a range of NuGet packages and includes some template code of its own. You then need to write a class that is derived from <strong>DiagnosticAnalyzer</strong>. Your class will declare one of more <strong>DiagnosticDescriptor</strong> instances - each will be a particular rule that is checked. You then override an &quot;Initialize&quot; method, which allows your code to register for syntax changes and to raise any rules that have been broken. You must also override a &quot;SupportedDiagnostics&quot; property and return the set of <strong>DiagnosticDescriptor</strong> instances (ie. rules) that your analyser will cover. If the code that the &quot;Initialize&quot; method hooks up tries to raise a rule that &quot;SupportedDiagnostics&quot; did not declare, the rule will be ignored by the analysis engine. This would be a kind of (silent) runtime failure and it's something that is documented - but it's still a very easy mistake to make; you might create a new <strong>DiagnosticDescriptor</strong> instance and raise it from your &quot;Initialize&quot; method but forget to add it to the &quot;SupportedDiagnostics&quot; set.. whoops. In the past, you may not realise until runtime that you'd made a mistake and, as a silent failure, you might end up getting very frustrated and be stuck wondering what had gone wrong. But, mercifully (and I say this as I made this very mistake), there is an analyser in the &quot;Microsoft.CodeAnalysis.CSharp&quot; NuGet package that brings this error immediately to your attention with the message:</p>
<blockquote>
<p>RS1005 ReportDiagnostic invoked with an unsupported DiagnosticDescriptor</p>
</blockquote>
<p>The entry in the Error List links straight to the code that called &quot;context.ReportDiagnostic&quot; with the unexpected rule. This is fantastic - instead of suffering a runtime failure, you are informed at compile time precisely what the problem is. Compile time is <em>always</em> better than run time (for many reasons - it's more immediate, so you don't have to <em>wait</em> until runtime, and it's more thorough; a runtime failure may only happen if a particular code path is followed, but static analysis such as this is like having <em>every possible</em> code path tested).</p>
<h3>The analysers already in ProductiveRage.Immutable</h3>
<p>The ProductiveRage uber-fans (who, surely exist.. yes? ..no? :D) may be thinking &quot;doesn't the ProductiveRage.Immutable library already have some analysers built into it?&quot;</p>
<p>And they would be correct, for some time now it has included a few analysers that try to prevent some simple mistakes. As a quick reminder, the premise of the library is that it will make creating immutable types in <a href="http://www.bridge.net">Bridge.NET</a> easier.</p>
<p>Instead of writing something like this:</p>
<pre><code>public sealed class EmployeeDetails
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
    if (id == null)
      throw new ArgumentNullException(&quot;id&quot;);
    if (name == null)
      throw new ArgumentNullException(&quot;name&quot;);

    Id = id;
    Name = name;
  }

  /// &lt;summary&gt;
  /// This will never be null
  /// &lt;/summary&gt;
  public PersonId Id { get; }

  /// &lt;summary&gt;
  /// This will never be null
  /// &lt;/summary&gt;
  public NameDetails Name { get; }

  public EmployeeDetails WithId(PersonId id)
  {
    return Id.Equals(id) ? this : return new EmployeeDetails(id, Name);
  }
  public EmployeeDetails WithName(NameDetails name)
  {
    return Name.Equals(name) ? this : return new EmployeeDetails(Id, name);
  }
}
</code></pre>
<p>.. you can express it just as:</p>
<pre><code>public sealed class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
    this.CtorSet(_ =&gt; _.Id, id);
    this.CtorSet(_ =&gt; _.Name, name);
  }
  public PersonId Id { get; }
  public NameDetails Name { get; }
}
</code></pre>
<p>The if-null-then-throw validation is encapsulated in the CtorSet call (since the library takes the view that no value should ever be null - it introduces an <strong>Optional</strong> struct so that you can identify properties that may be without a value). And it saves you from having to write &quot;With&quot; methods for the updates as <strong>IAmImmutable</strong> implementations may use the &quot;With&quot; extension method whenever you want to create a new instance with an altered property - eg.</p>
<pre><code>var updatedEmployee = employee.With(_ =&gt; _.Name, newName);
</code></pre>
<p>The library can only work if certain conditions are met. For example, every property must have a getter and a setter - otherwise, the &quot;CtorSet&quot; extension method won't know how to actually set the value &quot;under the hood&quot; when populating the initial instance (nor would the &quot;With&quot; method know how to set the value on the new instance that it would create).</p>
<p>If you forgot this and wrote the following (note the &quot;DisplayNameLength&quot; property that is now effectively a computed value and there would be no way for us to directly set it via a &quot;With&quot; call) -</p>
<pre><code>public sealed class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
    this.CtorSet(_ =&gt; _.Id, id);
    this.CtorSet(_ =&gt; _.Name, name);
  }
  public PersonId Id { get; }
  public NameDetails Name { get; }
  public int DisplayNameLength { get { return Name.DisplayName.Length; } }
}
</code></pre>
<p>.. then you would see the following errors reported by Visual Studio (presuming you are using 2015 or later) -</p>
<p><img src="/Content/Images/Posts/ProductiveRageImmutableAnalyserError1.png" alt="Example analyser errors raised by the ProductiveRage.Immutable library" /></p>
<p>.. which is one of the &quot;common IAmImmutable mistakes&quot; analysers identifying the problem for you.</p>
<h3>Getting Visual Studio to write code for you, using code fixes</h3>
<p>I've been writing more code with this library and I'm still, largely, happy with it. Making the move to assuming never-allow-null (which is baked into the &quot;CtorSet&quot; and &quot;With&quot; calls) means that the classes that I'm writing are a lot shorter and that type signatures are more descriptive. (I wrote about all this in my post at the end of last year &quot;<a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a>&quot; if you're curious for more details).</p>
<p>However.. I <em>still</em> don't really like typing out as much code for each class as I have to. Each class has to repeat the property names four times - once in the constructor, twice in the &quot;CtorSet&quot; call and a fourth time in the public property. Similarly, the type name has to be repeated twice - once in the constructor and once in the property.</p>
<p>This is better than the obvious alternative, which is to not bother with immutable types. I will gladly take the extra lines of code (and the effort required to write them) to get the additional confidence that a &quot;stronger&quot; type system offers - I wrote about this recently in my &quot;<a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">Writing React with Bridge.NET - The Dan Way</a>&quot; posts; I think that it's really worthwhile to bake assumptions into the type system where possible. For example, the Props types of React components are assumed, by the React library, to be immutable - so having them defined as immutable types represents this requirement in the type system. If the Props types are <em>mutable</em> then it would be possible to write code that tries to change that data and then bad things could happen (you're doing something that library expects not to happen). If the Props types are <em>immutable</em> then it's not even possible to write this particular kind of bad-things-might-happen code, which is a positive thing.</p>
<p>But <em>still</em> I get a niggling feeling that things could be better. And now they are! With Roslyn, you can not only identify particular patterns but you can also offer automatic fixes for them. So, if you were to start writing the <strong>EmployeeDetails</strong> class from scratch and got this far:</p>
<pre><code>public sealed class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
  }
}
</code></pre>
<p>.. then an analyser could identify that you were writing an <strong>IAmImmutable</strong> implementation and that you have an empty constructor - it could then offer to fix that for you by filling in the rest of the class.</p>
<p>The latest version of the ProductiveRage.Immutable library (1.7.0) does just that. The empty constructor will not only be identified with a warning but a light bulb will also appear alongside the code. Clicking this (or pressing [Ctrl]-[.] while within the empty constructor, for fellow keyboard junkies) will present an option to &quot;Populate class from constructor&quot; -</p>
<p><img src="/Content/Images/Posts/ProductiveRageImmutableAnalyserCodeFix1.png" alt="Screenshot showing the analyser identifying an empty constructor on an IAmImmutable implementation" /></p>
<p>Selecting the &quot;Populate class from constructor&quot; option -</p>
<p><img src="/Content/Images/Posts/ProductiveRageImmutableAnalyserCodeFix2.png" alt="Screenshot showing the code fix that may auto-populate the incomplete IAmImmutable implementation" /></p>
<p>.. will take the constructor arguments and generate the &quot;CtorSet&quot; calls and the public properties automatically. Now you can have all of the safety of the immutable type with no more typing effort than the mutable version!</p>
<pre><code>// This is what you have to type of the immutable version,
// then the code fix will expand it for you
public sealed class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
  }
}

// This is what you would have typed if you were feeling
// lazy and creating mutable types because you couldn't
// be bothered with the typing overhead of immutability
public sealed class EmployeeDetails
{
  public PersonId Id;
  public NameDetails name;
}
</code></pre>
<h3>To summarise</h3>
<p>If you're already using the library, then all you need to do to start taking advantage of this code fix is update your NuGet reference* (presuming that you're using VS 2015 - analysers weren't supported in previous versions of Visual Studio).</p>
<p>* <em>(Sometimes you have to restart Visual Studio after updating, you will know that this is the case if you get a warning in the Error List about Visual Studio not being able to load the Productive.Immutable analyser)</em></p>
<p>If you're writing your own library that has any guidelines or common gotchas that you have to describe in documentation somewhere (that the users of your library may well not read unless they have a problem - at which point they may even abandon the library, if they're only having an investigative play around with it) then I highly recommend that you consider using analysers to surface some of these assumptions and best practices. While I'm aware that I've not offered much concrete advice on <em>how</em> to write these analysers, the reason is that I'm still very much a beginner at it - but that puts me in a good position to be able to say that it really is fairly easy if you read a few articles about it (such as <a href="https://msdn.microsoft.com/en-gb/magazine/dn879356.aspx">Use Roslyn to Write a Live Code Analyzer for Your API</a>) and then just get stuck in. With some judicious Google'ing, you'll be making progress in no time!</p>
<p>I guess that only time will tell whether library-specific analysers become as prevelant as I imagine. It's very possible that I'm biased because I'm such a believer in static analysis. Let's wait and see*!</p>
<p>* <em>Unless YOU are a library writer that this might apply to - in which case, make it happen rather than just sitting back to see what MIGHT happen! :)</em></p>
<p class="PostTime">Posted at 22:33</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/using-roslyn-code-fixes-to-make-the-frictionless-immutable-objects-in-bridge-even-easier#disqus_thread" data-disqus-identifier="99">Comments</a>
            </p>
    </div>

        <script type="text/javascript">
            (function () {
                var s = document.createElement("script");
                s.type = "text/javascript";
                s.async = true;
                s.src = "https://" + disqus_shortname + ".disqus.com/count.js";
                (document.getElementsByTagName("HEAD")[0] || document.getElementsByTagName("BODY")[0]).appendChild(s);
            }());
        </script>

				<div class="Footer">
					© Productive Rage 2011 - 2021
				</div>
			</div>

			<div class="SideBar">
				<div class="About">
					<h2>About</h2>
					<p>Dan is a big geek who likes making stuff with computers! He can be quite outspoken so clearly needs a blog :)</p>
					<p>In the last few minutes he seems to have taken to referring to himself in the third person. He's quite enjoying it.</p>
					<p><a href="mailto:dangger36@gmail.com" class="Email">dangger36@gmail.com</a></p>
				</div>
				<div class="Search">
<form action="/Search" method="get">						<div>
							<input type="text" class="SiteSearch" name="term" value="" />
							<input type="submit" class="SiteSearchSubmit" value="Search" />
						</div>
</form>				</div>
				<div class="Recent"><h2>Recent Posts</h2><ul><li><a href="/language-detection-and-wordsinsentence-classification-in-c-sharp">Language detection and words-in-sentence classification in C#</a></li><li><a href="/monitoring-my-gardens-limited-sunlight-time-period-with-an-arduino-and-some-tupperware">Monitoring my garden&#x27;s limited sunlight time period with an Arduino (and some tupperware)</a></li><li><a href="/how-are-barcodes-read-libraryless-image-processing-in-c-sharp">How are barcodes read?? (Library-less image processing in C#)</a></li><li><a href="/removing-all-assembly-names-in-jsonnet-typenamehandling-output">Removing ALL assembly names in Json.NET TypeNameHandling output</a></li><li><a href="/private-local-c-sharp-analysers-without-nuget">Private / local C# analysers (without NuGet)</a></li></ul><div class="RSSFeedLink"><a href="http://www.productiverage.com/feed">RSS Feed</a></div></div>
				<div class="Featured"><h2>Highlights</h2><ul><li><a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face (finding faces in photos using C# and Accord.NET)</a></li><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/translating-vbscript-into-c-sharp">Translating VBScript into C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div>
				<div class="History"><h2>Archives</h2><ul><li><a href="/Archive/3/2021">March 2021 (1)</a></li><li><a href="/Archive/8/2020">August 2020 (3)</a></li><li><a href="/Archive/7/2019">July 2019 (2)</a></li><li><a href="/Archive/9/2018">September 2018 (1)</a></li><li><a href="/Archive/4/2018">April 2018 (1)</a></li><li><a href="/Archive/3/2018">March 2018 (1)</a></li><li><a href="/Archive/7/2017">July 2017 (1)</a></li><li><a href="/Archive/6/2017">June 2017 (1)</a></li><li><a href="/Archive/2/2017">February 2017 (1)</a></li><li><a href="/Archive/11/2016">November 2016 (1)</a></li><li><a href="/Archive/9/2016">September 2016 (2)</a></li><li><a href="/Archive/8/2016">August 2016 (1)</a></li><li><a href="/Archive/7/2016">July 2016 (1)</a></li><li><a href="/Archive/6/2016">June 2016 (1)</a></li><li><a href="/Archive/5/2016">May 2016 (3)</a></li><li><a href="/Archive/3/2016">March 2016 (3)</a></li><li><a href="/Archive/2/2016">February 2016 (2)</a></li><li><a href="/Archive/12/2015">December 2015 (1)</a></li><li><a href="/Archive/11/2015">November 2015 (2)</a></li><li><a href="/Archive/8/2015">August 2015 (3)</a></li><li><a href="/Archive/7/2015">July 2015 (1)</a></li><li><a href="/Archive/6/2015">June 2015 (1)</a></li><li><a href="/Archive/5/2015">May 2015 (2)</a></li><li><a href="/Archive/4/2015">April 2015 (1)</a></li><li><a href="/Archive/3/2015">March 2015 (1)</a></li><li><a href="/Archive/1/2015">January 2015 (2)</a></li><li><a href="/Archive/12/2014">December 2014 (1)</a></li><li><a href="/Archive/11/2014">November 2014 (1)</a></li><li><a href="/Archive/10/2014">October 2014 (2)</a></li><li><a href="/Archive/9/2014">September 2014 (2)</a></li><li><a href="/Archive/8/2014">August 2014 (1)</a></li><li><a href="/Archive/7/2014">July 2014 (1)</a></li><li><a href="/Archive/6/2014">June 2014 (1)</a></li><li><a href="/Archive/5/2014">May 2014 (2)</a></li><li><a href="/Archive/2/2014">February 2014 (1)</a></li><li><a href="/Archive/1/2014">January 2014 (1)</a></li><li><a href="/Archive/12/2013">December 2013 (1)</a></li><li><a href="/Archive/11/2013">November 2013 (1)</a></li><li><a href="/Archive/10/2013">October 2013 (1)</a></li><li><a href="/Archive/8/2013">August 2013 (3)</a></li><li><a href="/Archive/7/2013">July 2013 (3)</a></li><li><a href="/Archive/6/2013">June 2013 (1)</a></li><li><a href="/Archive/5/2013">May 2013 (2)</a></li><li><a href="/Archive/4/2013">April 2013 (1)</a></li><li><a href="/Archive/3/2013">March 2013 (8)</a></li><li><a href="/Archive/2/2013">February 2013 (2)</a></li><li><a href="/Archive/1/2013">January 2013 (2)</a></li><li><a href="/Archive/12/2012">December 2012 (3)</a></li><li><a href="/Archive/11/2012">November 2012 (4)</a></li><li><a href="/Archive/9/2012">September 2012 (1)</a></li><li><a href="/Archive/8/2012">August 2012 (1)</a></li><li><a href="/Archive/7/2012">July 2012 (3)</a></li><li><a href="/Archive/6/2012">June 2012 (3)</a></li><li><a href="/Archive/5/2012">May 2012 (2)</a></li><li><a href="/Archive/2/2012">February 2012 (3)</a></li><li><a href="/Archive/1/2012">January 2012 (4)</a></li><li><a href="/Archive/12/2011">December 2011 (7)</a></li><li><a href="/Archive/8/2011">August 2011 (2)</a></li><li><a href="/Archive/7/2011">July 2011 (1)</a></li><li><a href="/Archive/5/2011">May 2011 (1)</a></li><li><a href="/Archive/4/2011">April 2011 (2)</a></li><li><a href="/Archive/3/2011">March 2011 (3)</a></li></ul><div class="EveryTitle"><a href="/Archive/All">Every Post Title</a></div></div>
			</div>

		</div>
	</div>

	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
	<script type="text/javascript" src="/Scripts/jquery.autocomplete.min.js"></script>
	<script type="text/javascript" src="/Scripts/prettify.js"></script>
	<script type="text/javascript" src="/Scripts/Site.js"></script>
	<script type="text/javascript" src="/Scripts/IndexSearchGenerator.js"></script>
	<script type="text/javascript" src="/Scripts/SearchTermHighlighter.js"></script>
	<script type="text/javascript" src="/Scripts/SearchPage.js"></script>
	<script type="text/javascript" src="/Scripts/LZString.js"></script>

</body>
</html>
