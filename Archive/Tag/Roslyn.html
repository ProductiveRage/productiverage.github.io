<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Productive Rage - Roslyn</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta name="theme-color" content="#393939" />
	<link rel="stylesheet" type="text/css" media="all" href="/Content/Styles.css" />
	<!--[if lt IE 9]>
	<link rel="stylesheet" type="text/css" href="/Content/IEBefore9.css" />
	<![endif]-->
	<link rel="stylesheet" type="text/css" media="print" href="/Content/PrintOverrides.css" />
	<meta name="robots" content="noindex, follow" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.productiverage.com/feed" />
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', "UA-32312857-1"]);
		_gaq.push(['_setSiteSpeedSampleRate', 100]);
		_gaq.push(['_trackPageview']);
		(function () {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>

<body>

	<div class="Header">
		<div class="HeaderContent">
			<h1>
				<a href="/">Productive Rage</a>
			</h1>
			<span class="Tagline">Dan's techie ramblings</span>
		</div>
	</div>

	<div class="WrapperOuter">
		<div class="Wrapper">
			<div class="Main HasSideBar">
				

        <script type="text/javascript">
			var disqus_shortname = "productiverage";
			function executeWhen(fncAction, fncConditional, intDelayBetweenRetries) {
				if (fncConditional()) { fncAction(); return; }
				setTimeout(function () { executeWhen(fncAction, fncConditional, intDelayBetweenRetries); }, intDelayBetweenRetries);
			}
			function whenjQueryIsAvailable(fncAction) {
				executeWhen(
					fncAction,
					function () { return (typeof ($) !== "undefined") },
					10
				);
			}
			(function () {
				whenjQueryIsAvailable(
					function () { $("div.Content p.Comments").show(); }
				);
			}());
        </script>

    <div class="Content ArchiveByTag">
        <h3 class="PostDate">10 July 2019</h3><h2><a id="private-local-c-sharp-analysers-without-nuget" href="/private-local-c-sharp-analysers-without-nuget">Private / local C# analysers (without NuGet)</a></h2>
<p>(<strong>Note:</strong> The information here depends upon the &quot;new&quot; .csproj format being used.. but it's not that new any more, so hopefully that's not a limitation for too many people)</p>
<p>I'm a big fan of writing analysers to catch common mistakes at compile time rather than run time. For example, the <a href="https://github.com/ProductiveRage/DanSerialiser">DanSerialiser</a>, <a href="https://github.com/ProductiveRage/Bridge.Immutable">Bridge.Immutable</a> and <a href="https://github.com/ProductiveRage/ProductiveRage.SealedClassVerification">ProductiveRage.SealedClassVerification</a> libraries that I've published all include some. The way that they're traditionally distributed is as a NuGet package that installs the analyser into the desired project, which is great if you're publishing a public package that you expect to be installed via nuget.org. But what if you wanted to create a non-public analyser for something that you were working on, can you do so <em>without</em> creating a NuGet package? Yes.. but with some caveats.</p>
<p>If you're still interested then read on for the details!</p>
<p>(For anyone who finds themselves in the <strong>&quot;too lazy; didn't read&quot;</strong> category, hopefully this gives you enough information as to whether to continue or not)</p>
<h3>What I wish existed</h3>
<p>Actually, before I talk about what I wish already existed (but which, unfortunately, does <em>not</em> exist), I'll get one option out of the way first; nuget.org is not the only place that NuGet packages can be published to. If you decided that you wanted to write an analyser for some conventions internal to your company then you could create a NuGet package and publish it on an <em>internal</em> NuGet feed. It's pretty easy and you have a range of options such as a private NuGet feed service within your network, a private hosted service (possible with MyGet, I believe) or you can even chuck all of your private NuGet .nupkg files into a folder (on your local computer or, I presume, on a network - though I've not tested that option) and then add that as a NuGet feed in Visual Studio. This <em>is</em> straight forward but, still, occasionally I wish that it was possible to include an analyser project as part of a solution and have that analyser added to one of the other projects. Which brings me to..</p>
<p>What I've really wanted, from time to time, is to be able to have one project (say, &quot;MyLibrary&quot;) in a solution and another project (say, &quot;MyAnalyser&quot;) where the second project is added an analyser reference to the first project.</p>
<p>I'd like it to be as simple as clicking on References on the &quot;MyLibrary&quot; project, then &quot;Add an Analyzer&quot; and then choosing the &quot;MyAnalyser&quot; project. This, however, is not currently possible.</p>
<p>It seems that I'm not the only one that thinks that this would be nice, there is an issue on the <a href="https://github.com/dotnet/roslyn/">.NET Compiler Platform (&quot;Roslyn&quot;)</a> repo relating to this: <a href="https://github.com/dotnet/roslyn/issues/18093">Adding Analyzers Via a Project Reference</a>. The first reply is from a Senior Software Engineer at Microsoft who says:</p>
<blockquote>
<p>This would be one of the coolest features ever</p>
</blockquote>
<p>.. which sounds like a great and promising start!</p>
<p>However, the issue was raised in March 2017 and I don't think that any progress has been made on it, so I don't know when / if it will be tackled*.</p>
<p><em>(Having said that, just last month it was recategorised from &quot;Backlog&quot; to &quot;IDE: InternalPriority&quot; and even assigned Priority 1 - so maybe this <strong>will</strong> change in the near future! We'll have to wait and see)</em></p>
<h3>What <em>does</em> exist</h3>
<p>So the bad news is that there is no way in the UI to do what I want. But the good news is that there <em>is</em> a way to move towards it with some manual .csproj editing.</p>
<p>If I opened the MyLibrary.csproj from the example earlier then I could add the following section:</p>
<pre><code>&lt;ItemGroup&gt;
  &lt;ProjectReference Include=&quot;..\MyAnalyser\MyAnalyser.csproj&quot;&gt;
    &lt;ReferenceOutputAssembly&gt;false&lt;/ReferenceOutputAssembly&gt;
    &lt;OutputItemType&gt;Analyzer&lt;/OutputItemType&gt;
  &lt;/ProjectReference&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>.. and the MyAnalyser would now be added to MyLibrary and it would check over the code that I'd written in MyLibrary project - reporting any resulting messages, warnings or error in the VS Error List. Hurrah!</p>
<p>It seems like a pity that something seemingly so simple needs to be done by hand-editing the .csproj file instead of there being something in the VS GUI to do this but there are other features where you have to do the same. For example, if you want a project to target multiple frameworks when it's built then you have to manually edit the .csproj file and rename the &quot;targetframework&quot; node to &quot;targetframeworks&quot; and then type in a semi-colon-delimited list of IDs of frameworks that you're interested in - eg. from this:</p>
<pre><code>&lt;TargetFramework&gt;netcoreapp2.1&lt;/TargetFramework&gt;
</code></pre>
<p>.. to this:</p>
<pre><code>&lt;TargetFrameworks&gt;netcoreapp2.1;net461&lt;/TargetFrameworks&gt;
</code></pre>
<p>(It's quite common to do this in <a href="https://benchmarkdotnet.org/">BenchmarkDotNet</a> projects so that you can see how the results vary when your library is imported into different frameworks)</p>
<p>The good news is that hand-editing the .csproj file is much easier with the file format that we have now than the old one! So having to do this is not the end of the world.</p>
<p>It's not <em>all</em> rainbows and unicorns, though..</p>
<h3>What are the downsides?</h3>
<p>The biggest (and only, so far as I can tell) downside is that it seem like Visual Studio will somehow cache the analyser assembly after it loads it. This means that when you first open the solution, the analyser(s) in the MyAnalyser project will be run against the MyLibrary code and any messages, warnings and errors displayed.. <em>but</em>, if you then change the MyAnalyser code and rebuild then those changes won't affect the checks performed against MyLibrary.</p>
<p>Even if you rebuild the entire solution (rebuilding MyAnalyser first and <em>then</em> rebuilding MyLibrary, to try to force the new analyser assembly to be loaded).</p>
<p>Even if you rebuild it and then unload the solution and then reload the solution and build <em>again</em>.</p>
<p>It seems like the only way to get it to reliably load the new analyser assembly is to close the Visual Studio instance entirely and start it again.</p>
<p>A cryptic note in the <a href="https://github.com/dotnet/roslyn/issues/18093">GitHub issue</a> that I referenced earlier made me wonder if changing the assembly version of the analyser project would help.. but it didn't.</p>
<p>Now, <em>hopefully,</em> in real world usage this isn't as bad as it sounds. The process of writing analysers lends itself very nicely to a test driven development style because you can set up a test suite where every test is of the format &quot;for code snippet, will I get the analyser messages that I expect?&quot; and you can build up a nice suite of tests for middle-of-the-road cases and edge cases and have them all run quickly. I actually find this to be the easiest way for me to debug things when I get myself into a situation where I don't understand why the analyser code isn't doing what I expect; I write a test with a snippet of code and then debug the test to step through the code. So you should be to get your analyser working nicely without having to test it against your &quot;MyLibrary&quot; code over and over.</p>
<p>Of course, sometimes you'll want to run it against your entire code base (otherwise, what was the point of writing it!) and then you <em>will</em> have to close VS and restart it. And this is inconvenient and I wish that it wasn't the case.</p>
<p>I think, though, that you would be in the same situation if you decided to go down the NuGet distribution route (whether from a private or public feed) - in the past, I've found that if a new version of a NuGet package includes a new version of an analyser then Visual Studio won't load the new version of the analyser without me restarting VS. Which is just as frustrating. Maybe this is part of what's delaying the work on Microsoft's side; they know that if they make adding analysers easier then they'll have to fix the cached-analyser-doesn't-get-updated problem at the same time.</p>
<h3>To conclude</h3>
<p>I'm going to keep my eye on that GitHub issue. It would be great to see some movement on it but I have no idea how much weight &quot;IDE: InternalPriority&quot; cases have, even if they are listed as Priority 1 within that category.. to be honest, I'm presuming that Priority 1 means <strong>top priority</strong> but it's just as feasible that it means <em>lowest</em> priority. There's a nice view of the <a href="https://github.com/dotnet/roslyn/projects/35#card-16650341">&quot;IDE: Internal Priority&quot; category in GitHub here</a> in case you want to join in on the guessing game!</p>
<p>At the end of the day, though, I still think that this is a powerful technology to have access to and I'd still rather have it with these caveats than not have it at all. I really believe that analysers provide a way to improve code quality and I encourage everyone to have a play around with them!</p>
<p class="PostTime">Posted at 21:42</p><div class="Related"><h3>You may also be interested in:</h3><ul><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Roslyn" title="4 Posts">Roslyn</a></li></ul></div>
            <p class="Comments">
                <a href="/private-local-c-sharp-analysers-without-nuget#disqus_thread" data-disqus-identifier="115">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <h3 class="PostDate">28 June 2016</h3><h2><a id="creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner" href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></h2>
<p>I've been meaning to try writing a post about creating analysers for a little while now - they're a technology that I think has huge promise for improving code quality and they're something that I've successfully played around with recently.. but I'm still very much in the early phases of being proficient and they're not something that I can just sit down and bang out easily (ie. not without a lot of googling).</p>
<p>So this won't be the post of an expert - but I'm hoping to use that to my advantage since I hopefully remember the pain points all too well and can go through the sort of things that I try when I'm hashing these out.</p>
<p>Most of the analysers I've been writing have been for libraries that work with <a href="http://bridge.net/">Bridge.NET</a>, which introduces some of its own complications. I'm hoping to talk about those problems and how to overcome them in a later post - this one will be a more general introduction.</p>
<h3>Creating a fresh Analyser project</h3>
<p>The easiest way to get started is to use a Microsoft template. To do this, first you need to install the Visual Studio 2016 SDK and to do <em>this</em> you go to File / New / Project and then choose C# in the left navigation pane, click on Extensibility and then select &quot;Install the Visual Studio Extensibility Tools&quot; (you may already have it installed, it's an optional component of VS2015 - if you see no link to &quot;Install the Visual Studio Extensibility Tools&quot; then hopefully that's why). Next, from the same Extensibility section, you need to select &quot;Download the .NET Compiler Platform SDK&quot;. This will ensure that you have the project template installed that we're going to use and it installs some other helpful tools, such as the Syntax Visualizer (which we'll see in a moment).</p>
<p>Now that you have the template and since you're already in File / New / Project / C# / Extensibility, select &quot;Analyzer with Code Fix (NuGet + VSIX)&quot; to create an example analyser solution. This will be a fully operational analyser, split into three projects - the analyser itself, a unit test library and a &quot;Vsix&quot; project. This last one would be used if you wanted to create an analyser that would be installed and applied to <em>all</em> projects that you would ever open and <em>not</em> apply to any specific library. What I'll be talking about here will be creating an analyser to work with a particular library (that would be distributed <em>with</em> the library) - so that everyone consuming the library can benefit from it. As such, to keep things simple, delete the &quot;Vsix&quot; project now,</p>
<p>The example analyser that this template installs does something very simple - it looks for class names that are not upper case and it warns about them. In terms of functionality, this is not particularly useful.. but in terms of education and illustrating how to get started it's a good jumping off point. In fact, the project includes not just an analyser but also a &quot;code fix&quot; - once a non-all-upper-case class name is identified and warned about, a quick fix will be offered in the IDE to change the name to match the upper case regime that it's pushing. Code fixes can be really helpful but I'll talk about them another day, I think that there already will be plenty to deal with in this post.</p>
<p>The analyser class looks basically like this (I've removed comments and replaced localisable strings with hard-coded strings, just to make it a little less to absorb all at once) -</p>
<pre><code>using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;

namespace ExampleAnalyser
{
    [DiagnosticAnalyzer(LanguageNames.CSharp)]
    public class ExampleAnalyserAnalyzer : DiagnosticAnalyzer
    {
        public const string DiagnosticId = &quot;ExampleAnalyser&quot;;
        private const string Category = &quot;Naming&quot;;
        private static readonly LocalizableString Title
            = &quot;Type name contains lowercase letters&quot;;
        private static readonly LocalizableString MessageFormat
            = &quot;Type name '{0}' contains lowercase letters&quot;;
        private static readonly LocalizableString Description
            = &quot;Type names should be all uppercase.&quot;;

        private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(
            DiagnosticId,
            Title,
            MessageFormat,
            Category,
            DiagnosticSeverity.Warning,
            isEnabledByDefault: true,
            description: Description
        );

        public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics
        {
            get { return ImmutableArray.Create(Rule); }
        }

        public override void Initialize(AnalysisContext context)
        {
            context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);
        }

        private static void AnalyzeSymbol(SymbolAnalysisContext context)
        {
            var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;
            if (namedTypeSymbol.Name.ToCharArray().Any(char.IsLower))
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    Rule,
                    namedTypeSymbol.Locations[0],
                    namedTypeSymbol.Name
                ));
            }
        }
    }
}
</code></pre>
<p>To summarise what's in the above code:</p>
<ol>
<li><strong>Every analyser needs at least one rule that it will declare</strong>, where a rule has various properties such as a Diagnostic Id, Category, Title, MessageFormat, Description and Severity. The two that are most immediately interesting are Severity (make it a Warning to point out a potential mistake or make it an Error to indicate a critical problem that will prevent a build from being completed) and MessageFormat, since MessageFormat is responsible for the text that will be displayed to the user in their Error List. MessageFormat supports string replacement; in the above example, you can see that there is a &quot;{0}&quot; placeholder in the MessageFormat - when &quot;Diagnostic.Create&quot; is called, the argument &quot;namedTypeSymbol.Name&quot; is injected into that &quot;{0}&quot; placeholder.</li>
<li><strong>Every analyser needs to declare a &quot;SupportedDiagnostics&quot; value that lists all of the types of rule</strong> that it is possible for the analyser to raise. This is vital in order for the analyser to work correctly at runtime. (If you create an analyser that has three different types of rule that it can report but you forget to declare one of the types in the &quot;SupportedDiagnostics&quot; property, there is actually an analyser that is installed with the template that points out the mistake to you - which is a great example of how analysers can protect you at compile time from potential runtime problems!)</li>
<li><strong>Every analyser needs an &quot;Initialize&quot; method that registers what type of symbol (more on what this actually means in a moment) it's interested in</strong> and provides a reference to a method that will perform the actual analysis</li>
</ol>
<p>The simple task of the class above is to look at any &quot;named type&quot; (ie. classes and structs) and inspect their name to ensure that they consist entirely of capital letters (remember, this example included in the &quot;Analyzer with Code Fix (NuGet + VSIX)&quot; template is simply for educational purposes and <em>not</em> because it's believed that all class names should be SHOUTING_FORMAT! :) Any class that doesn't have an all-caps name will result in a warning in the Error List.</p>
<p>To illustrate how this should work, the test project includes the following test method -</p>
<pre><code>[TestMethod]
public void TestMethod2()
{
    var test = @&quot;
        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Text;
        using System.Threading.Tasks;
        using System.Diagnostics;

        namespace ConsoleApplication1
        {
            class TypeName
            {
            }
        }&quot;;
    var expected = new DiagnosticResult
    {
        Id = &quot;ExampleAnalyser&quot;,
        Message = String.Format(&quot;Type name '{0}' contains lowercase letters&quot;, &quot;TypeName&quot;),
        Severity = DiagnosticSeverity.Warning,
        Locations = new[] {
            new DiagnosticResultLocation(&quot;Test0.cs&quot;, 11, 15)
        }
    };

    VerifyCSharpDiagnostic(test, expected);
}
</code></pre>
<p>This makes it clear to see precisely what sort of thing the analyser is looking for but it also gives us another immediate benefit - we can actually execute the analyser and step through it in the debugger if we want to have a poke around with exactly what is in the <strong>SymbolAnalysisContext</strong> reference or if we want to look at the properties of a particular <strong>INamedTypeSymbol</strong> instance. This is as easy as putting a breakpoint into the &quot;AnalyzeSymbol&quot; method in the example analyser and then going back into the test class, right-clicking within &quot;TestMethod2&quot; and selecting &quot;Debug Tests&quot;.</p>
<p>I want to introduce one other useful technique before moving on - the use of the &quot;Syntax Visualizer&quot;. An analyser works on an in-memory tree of nodes that represent the source code of the file that you're looking at*. In the unit test above, the named symbol &quot;TypeName&quot; is a child node of the &quot;TypeName&quot; class declaration, which is a child node of the &quot;ConsoleApplication1&quot; namespace, which is a child of a top-level construct called the &quot;CompilationUnit&quot;. Understanding the various types of node will be key to writing analysers and the Syntax Visualizer makes this a little bit easier.</p>
<p>* <em>(Although an analyser starts by examining source code in a particular file, it's also possible to look up types and values that are referenced in that code that live elsewhere - to find out what namespace a class that is referenced exists in, for example, or to determine what arguments a method that is called that exists in a different library. These lookups are more expensive than looking solely at the content in the current file, however, and so should only be done if strictly necessary. We will see how to do this shortly. When looking only at content parsed from the current file, we are looking at the &quot;syntax tree&quot;. When looking up references elsewhere in the solution we accessing the &quot;semantic model&quot;).</em></p>
<p>Having installed the &quot;.NET Compiler Platform SDK&quot; earlier, you will now have access to this tool - go to View / Other Windows / Syntax Visualizer. This shows the syntax tree for any code within your project. So, if you click on the name &quot;TestMethod2&quot; then you will see that it is an <strong>IdentifierToken</strong> (which is the name &quot;TestMethod2&quot;) that is a child node of a <strong>MethodDeclaration</strong> which is a child node of a <strong>ClassDeclaration</strong> which is a child node of a <strong>NamespaceDeclaration</strong>, which is a child node of a <strong>CompilationUnit</strong>. You can click on any of these nodes in the Syntax Visualiser to inspect some of the properties of the node and you can open further branches to inspect more - for example, there is a &quot;Block&quot; node that will appear shortly after the <strong>IdentifierToken</strong> that you may click to reveal the nodes that represent the statements within the method.</p>
<p><img src="/Content/Images/Posts/SyntaxVisualizer.png" alt="The Syntax Visualizer" /></p>
<h3>Writing a real analyser</h3>
<p>I'm going to walk through an analyser that I created recently - starting from scratch and, hopefully, encountering the same problems that I did last time so that I can illustrate how to find out how to solve them.</p>
<p>The analyser is part of my <a href="https://www.nuget.org/packages/Bridge.React">Bridge.React</a> library but you won't need to know anything about React or Bridge to follow along.</p>
<p>The root of the problem relates to the rendering of html &quot;select&quot; elements. There are three related properties to consider when rendering a &quot;select&quot; element; &quot;Multiple&quot;, &quot;Value&quot; and &quot;Values&quot;. Multiple is a boolean that indicates whether the elements supports only single selections (false) or zero, one or more selections (true). If rendering an element with pre-selected items then the &quot;Value&quot; or &quot;Values&quot; properties must be used. &quot;Value&quot; is a string while &quot;Values&quot; is a string array. If &quot;Multiple&quot; is false and &quot;Values&quot; is set then React will display a warning at runtime and ignore the value, similarly if &quot;Multiple&quot; is true and &quot;Value&quot; is set.</p>
<p>I wanted an analyser that handled these simple cases -</p>
<pre><code>// This is fine
return DOM.Select(new SelectAttributes { Multiple = false, Value = &quot;x&quot; };

// This is fine
return DOM.Select(new SelectAttributes { Multiple = true, Values = new [] { &quot;x&quot;, &quot;y&quot; } };

// Wrong (shouldn't use &quot;Value&quot; when &quot;Multiple&quot; is true)
return DOM.Select(new SelectAttributes { Multiple = true, Value = &quot;x&quot; };

// Wrong (shouldn't use &quot;Values&quot; when &quot;Multiple&quot; is false)
return DOM.Select(new SelectAttributes { Multiple = false, Values = new [] { &quot;x&quot;, &quot;y&quot; } };

// Wrong (shouldn't use &quot;Values&quot; when &quot;Multiple&quot; defaults to false)
return DOM.Select(new SelectAttributes { Values = new [] { &quot;x&quot;, &quot;y&quot; } };
</code></pre>
<p>It's worth mentioning that I'm <em>only</em> considering these simple cases so this analyser won't be &quot;perfect&quot;. If &quot;Multiple&quot; is set according to a variable then I'm not going to try to follow all possible code paths to ensure that it is never true/false if Values/Value is set. I'm also not going to cater for the technically-valid case where someone instantiates a <strong>SelectAttributes</strong> and sets &quot;Values&quot; on it initially (but leaves &quot;Multiple&quot; as false) and then sets &quot;Multiple&quot; to true on a later line of code. While this would be valid (there would be no runtime warning), I think that it would be clearer to set &quot;Multiple&quot; <em>and</em> &quot;Values&quot; together. In this case, I'm imposing what I believe to be a best practice on the consumer of my library - some analysers do this, some don't.</p>
<p>To keep things as simple as possible for now, instead of trying to pull in the real Bridge.React library, we'll just create another class library project in the solution to work against - call it &quot;Bridge.React&quot; and rename the &quot;Class1.cs&quot; file that is automatically created as part of a class library project to &quot;SelectAttributes.cs&quot;. Change its contents to the following:</p>
<pre><code>namespace Bridge.React
{
    public sealed class SelectAttributes
    {
        public bool Multiple { private get; set; }
        public string Value { private get; set; }
        public string[] Values { private get; set; }
    }
}
</code></pre>
<p>This will be enough to start writing the analyser.</p>
<p>What I want to do is to take the example analyser from the &quot;Analyzer with Code Fix (NuGet + VSIX)&quot; and change it to ensure that <strong>SelectAttributes</strong> properties are always configured according to the rule outlined above. Before getting started on that, though, it seems like a good time to formalise the rules by decribing them with unit tests. We get many bonuses here - writing individual tests may help guide us through fixing them up one at a time and so help us focus on individual problems that the analyser has to solve. It will also provide us with a way to exercise the analyser and step through it with the debugger (which I find invaluable when I'm not very familiar with a library or object model - when I <em>do</em> have a good grasp on code then stepping through a debugger can feel very time-consuming but it can be helpful in cases like this, as I'll demonstrate shortly). Finally, the tests will help avoid regressions creeping in if I decide to refactor the analyser or extend its functionality in the future.</p>
<p>So, replace the contents of &quot;UnitTest.cs&quot; with the following:</p>
<pre><code>using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using TestHelper;

namespace ExampleAnalyser.Test
{
    [TestClass]
    public class UnitTest : DiagnosticVerifier
    {
        [TestMethod]
        public void DoNotUseValueWhenMultipleIsTrue()
        {
            var testContent = @&quot;
                using Bridge.React;

                namespace TestCase
                {
                    public class Example
                    {
                        public void Go()
                        {
                            new SelectAttributes { Multiple = true, Value = &quot;&quot;1&quot;&quot; };
                        }
                    }
                }&quot;;

            var expected = new DiagnosticResult
            {
                Id = ExampleAnalyserAnalyzer.DiagnosticId,
                Message = &quot;If 'Multiple' is true then the 'Values' property should be used instead of 'Value'&quot;,
                Severity = DiagnosticSeverity.Warning,
                Locations = new[]
                {
                    new DiagnosticResultLocation(&quot;Test0.cs&quot;, 10, 29)
                }
            };

            VerifyCSharpDiagnostic(testContent, expected);
        }

        [TestMethod]
        public void DoNotUseValuesWhenMultipleIsFalse()
        {
            var testContent = @&quot;
                using Bridge.React;

                namespace TestCase
                {
                    public class Example
                    {
                        public void Go()
                        {
                            new SelectAttributes { Multiple = false, Values = new[] { &quot;&quot;1&quot;&quot; } };
                        }
                    }
                }&quot;;

            var expected = new DiagnosticResult
            {
                Id = ExampleAnalyserAnalyzer.DiagnosticId,
                Message = &quot;If 'Multiple' is false then the 'Value' property should be used instead of 'Values'&quot;,
                Severity = DiagnosticSeverity.Warning,
                Locations = new[]
                {
                    new DiagnosticResultLocation(&quot;Test0.cs&quot;, 10, 29)
                }
            };

            VerifyCSharpDiagnostic(testContent, expected);
        }

        [TestMethod]
        public void DoNotUseValueWhenMultipleDefaultsToFalse()
        {
            var testContent = @&quot;
                using Bridge.React;

                namespace TestCase
                {
                    public class Example
                    {
                        public void Go()
                        {
                            var x = new SelectAttributes { Values = new[] { &quot;&quot;1&quot;&quot; } };
                            x.Multiple = True;
                        }
                    }
                }&quot;;

            var expected = new DiagnosticResult
            {
                Id = ExampleAnalyserAnalyzer.DiagnosticId,
                Message = &quot;If 'Multiple' is false then the 'Value' property should be used instead of 'Values'&quot;,
                Severity = DiagnosticSeverity.Warning,
                Locations = new[]
                {
                    new DiagnosticResultLocation(&quot;Test0.cs&quot;, 10, 37)
                }
            };

            VerifyCSharpDiagnostic(testContent, expected);
        }

        protected override DiagnosticAnalyzer GetCSharpDiagnosticAnalyzer()
        {
            return new ExampleAnalyserAnalyzer();
        }
    }
}
</code></pre>
<p>Now there's one more important thing to do before actually writing the analyser. When those unit tests run, the &quot;.NET Compiler Platform&quot; (referred to as &quot;Roslyn&quot;) will parse and compile those code snippets in memory. This means that the code snippets need to actually be able to compile! Currently they won't because Roslyn won't know how to resolve the &quot;Bridge.React&quot; namespace that is referenced.</p>
<p>This is quite easily fixed - the <strong>DiagnosticVerifier</strong> class (which is part of the template that we started with) configures some environment options. That's why each test checks a file called &quot;Test0.cs&quot; - because Roslyn wants a filename to work with and that's what the <strong>DiagnosticVerifier</strong> tells it to use. It also specifies what assemblies to include when building the project. So, if the code snippets referenced &quot;System&quot; or &quot;Sytem.Collections.Generic&quot; then those references will work fine. However, it doesn't initially know about the &quot;Bridge.React&quot; project, so we need to tell it to support it.</p>
<ol>
<li><p>Add a reference to the &quot;Bridge.React&quot; project to the &quot;ExampleAnalayser.Test&quot; project</p>
</li>
<li><p>Edit the file &quot;Helpers/DiagnosticVerifier.Helper.cs&quot; in the &quot;ExampleAnalayser.Test&quot; project and add the following near the top, where other <strong>MetadataReference</strong> instances are created:</p>
<pre><code> private static readonly MetadataReference CSharpBridgeReactReference
     = MetadataReference.CreateFromFile(typeof(Bridge.React.SelectAttributes).Assembly.Location);
</code></pre>
</li>
<li><p>Open all of the code regions in that file and add pass &quot;CSharpBridgeReactReference&quot; into the solution by adding an additional &quot;AddMetadataReference&quot; call. The &quot;CreateProject&quot; method should now look like this:</p>
<pre><code> private static Project CreateProject(string[] sources, string language = LanguageNames.CSharp)
 {
     string fileNamePrefix = DefaultFilePathPrefix;
     string fileExt = language == LanguageNames.CSharp
         ? CSharpDefaultFileExt
         : VisualBasicDefaultExt;
     var projectId = ProjectId.CreateNewId(debugName: TestProjectName);
     var solution = new AdhocWorkspace()
     .CurrentSolution
         .AddProject(projectId, TestProjectName, TestProjectName, language)
         .AddMetadataReference(projectId, CorlibReference)
         .AddMetadataReference(projectId, SystemCoreReference)
         .AddMetadataReference(projectId, CSharpSymbolsReference)
         .AddMetadataReference(projectId, CodeAnalysisReference)
         .AddMetadataReference(projectId, CSharpBridgeReactReference);
     int count = 0;
     foreach (var source in sources)
     {
         var newFileName = fileNamePrefix + count + &quot;.&quot; + fileExt;
         var documentId = DocumentId.CreateNewId(projectId, debugName: newFileName);
         solution = solution.AddDocument(documentId, newFileName, SourceText.From(source));
         count++;
     }
     return solution.GetProject(projectId);
 }
</code></pre>
</li>
</ol>
<h3><em>Really</em> writing the analyser</h3>
<p>Now that the groundwork is done and we've decided what precisely needs doing (and documented it with tests), we need to write the actual code.</p>
<p>Although I can use the debugger to inspect the syntax tree for the code snippets in the unit tests, at this point I think even that would be information overload. To begin with, just add the following line to one of the unit test methods - it doesn't matter which one because it will be deleted very shortly, it's just to have a bit of a poke around with the Syntax Visualizer:</p>
<pre><code>var x = new Bridge.React.SelectAttributes { Multiple = true, Value = &quot;x&quot; };
</code></pre>
<p>Ensuring that the Syntax Visualizer is visible (View / Other Windows / Syntax Visualizer), clicking on &quot;Multiple&quot; shows the following:</p>
<p><img src="/Content/Images/Posts/ObjectInitializerExpression.png" alt="ObjectInitializerExpression" /></p>
<p>The <strong>IdentifierToken</strong> is the &quot;Multiple&quot; property, which is part of a <strong>SimpleAssignment</strong> (ie. &quot;Multiple = 1&quot;) which is a child of an <strong>ObjectInitializerExpression</strong> (which is the curly brackets around the two properties being set) which is a child of an <strong>ObjectCreationExpression</strong> (which is the entire statement that includes &quot;new Bridge.React.SelectAttributes&quot; <em>and</em> the setting of the two properties) and that itself is part of a <strong>VariableDeclaration</strong> (which sets &quot;x&quot; to be the result of the object creation). With the Syntax Visualizer, we could go all the way up to the top of the method and then to the class and then to the namespace and then to the top-level CompilationUnit. However, what we're most interested in is the <strong>ObjectInitializerExpression</strong>, since that contains the properties that we want to verify.</p>
<p>So, how do we alter the analyser class that we currently have in order to identify object initialisers such as this?</p>
<p>Currently the example analyser class has an &quot;Initialize&quot; method that looks like this:</p>
<pre><code>public override void Initialize(AnalysisContext context)
{
    context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);
}
</code></pre>
<p>The first thing to try would be to see what other options are in the &quot;SymbolKind&quot; enum. However, this contains things like &quot;Alias&quot;, &quot;Event&quot;, &quot;Method&quot;, &quot;NamedType&quot;, &quot;Property&quot; which don't bear much resemblance to <strong>ObjectInitializerExpression</strong>. Without any better plan, I recommend turning to Google. If &quot;SymbolKind&quot; doesn't seem to have what we want, maybe there's something else that we can extract from the <strong>AnalysisContext</strong> instance that the &quot;Initialize&quot; method has.</p>
<p>Googling for <a href="https://www.google.co.uk/search?q=AnalysisContext+ObjectInitializerExpression">&quot;AnalysisContext ObjectInitializerExpression&quot;</a> doesn't actually return that many results. However, the second one <a href="https://github.com/mjsabby/RoslynClrHeapAllocationAnalyzer/blob/master/ClrHeapAllocationsAnalyzer/ExplicitAllocationAnalyzer.cs">RoslynClrHeapAllocationAnalyzer/ExplicitAllocationAnalyzer.cs</a> has some code that looks promising:</p>
<pre><code>public override void Initialize(AnalysisContext context)
{
    var kinds = new[]
    {
        SyntaxKind.ObjectCreationExpression,
        SyntaxKind.AnonymousObjectCreationExpression,
        SyntaxKind.ArrayInitializerExpression,
        SyntaxKind.CollectionInitializerExpression,
        SyntaxKind.ComplexElementInitializerExpression,
        SyntaxKind.ObjectInitializerExpression,
        SyntaxKind.ArrayCreationExpression,
        SyntaxKind.ImplicitArrayCreationExpression,
        SyntaxKind.LetClause
    };
    context.RegisterSyntaxNodeAction(AnalyzeNode, kinds);
}
</code></pre>
<p>Instead of calling &quot;RegisterSymbolAction&quot; and passing a &quot;SymbolKind&quot; value, we can call &quot;RegisterSyntaxNodeAction&quot; and pass it an array of &quot;SyntaxKind&quot; values - where &quot;SyntaxKind&quot; is an enum that has an &quot;ObjectInitializerExpression&quot; value.</p>
<p>Actually, by starting to change the &quot;Initialize&quot; method to</p>
<pre><code>public override void Initialize(AnalysisContext context)
{
    context.RegisterSyntaxNodeAction(AnalyzeSymbol,
</code></pre>
<p>.. it becomes clear that the method actually takes a params array and so it will be perfectly happy for us to specify only a single &quot;SyntaxKind&quot; value. &quot;Initialize&quot; now becomes:</p>
<pre><code>public override void Initialize(AnalysisContext context)
{
    context.RegisterSyntaxNodeAction(
        AnalyzeSymbol,
        SyntaxKind.ObjectInitializerExpression
    );
}
</code></pre>
<p>But the analyser project doesn't compile now - it complains about the type of one of the arguments of the call to &quot;SymbolAnalysisContext&quot;. It definitely takes a &quot;SyntaxKind&quot; enum as its second argument so it must be the first that is wrong. Intellisense indicates that it wants the first argument to be of type <strong>Action&lt;SymbolAnalysisContext&gt;</strong> but the &quot;AnalyzeSymbol&quot; method currently takes a <strong>SyntaxNodeAnalysisContext</strong> (and so is an <strong>Action&lt;SymbolAnalysisContext&gt;</strong>, rather than an <strong>Action&lt;SyntaxNodeAnalysisContext&gt;</strong>).</p>
<p>This is easily fixed by changing the argument of the &quot;AnalyzeSymbol&quot; method. Doing so, however, will mean that <em>it</em> causes a compile error because the example code was expecting a <strong>SymbolAnalysisContext</strong> and we want to give it a <strong>SyntaxNodeAnalysisContext</strong>. No matter, that code doesn't do what we want anyway! So change the method argument, delete its body and - while we're making changes - rename it to something better than &quot;AnalyzeSymbol&quot;, such as &quot;LookForInvalidSelectAttributeProperties&quot; -</p>
<pre><code>public override void Initialize(AnalysisContext context)
{
    context.RegisterSyntaxNodeAction(
        LookForInvalidSelectAttributeProperties,
        SyntaxKind.ObjectInitializerExpression
    );
}

private static void LookForInvalidSelectAttributeProperties(SyntaxNodeAnalysisContext context)
{
}
</code></pre>
<p>Now that the basic structure is there, we can start work on the new &quot;LookForInvalidSelectAttributeProperties&quot; implementation. The &quot;context&quot; reference that is passed in has a &quot;Node&quot; property and this will match the SyntaxKind value that we passed to &quot;RegisterSyntaxNodeAction&quot;. So &quot;context.Node&quot; will be a reference to a node that represents an &quot;object initialisation&quot;.</p>
<p><em>Sanity check: The <strong>SyntaxNode</strong> class (which is the base node class) has a &quot;Kind()&quot; method that will return the &quot;SyntaxKind&quot; enum value that applies to the current node - so calling &quot;Kind()&quot; on &quot;context.Node&quot; here will return the &quot;ObjectInitializerExpression&quot; option from the &quot;SyntaxKind&quot; enum.</em></p>
<p>Now that we have a reference to an object initialisation node, we can go one of two ways. We want to ensure that the type being initialised is the <strong>SelectAttributes</strong> class from the &quot;Bridge.React&quot; assembly and we want to check whether any invalid property combinations are being specified. The first task will involve getting the type name and then doing a lookup in the rest of the solution to work out where that type name comes from (to ensure that it is actually the &quot;Bridge.React&quot; <strong>SelectAttributes</strong> class and not another class that exists somewhere with the same name). The second task only requires us to look at what properties are set by code in the syntax tree that we already have. This means that the first task is more expensive to perform than the second task and so we should try to deal with &quot;step two&quot; first since we will be able to avoid &quot;step one&quot; altogether if no invalid property combinations appear.</p>
<p>So, to look for invalid property combinations first.. The Syntax Visualizer (as seen in the last image) shows that each individual property-setting is represented by a &quot;SimpleAssignmentExpression&quot; and that each of these is a direct child of the object initialisation. The <strong>SyntaxNode</strong> class has a ChildNodes() method that will return all of the children, which seems like a good place to start. So, we might be able to do something like this:</p>
<pre><code>// This doesn't work,SimpleAssignmentExpressionSyntax isn't a real class :(
var propertyInitialisers = context.Node.ChildNodes()
    .OfType&lt;SimpleAssignmentExpressionSyntax&gt;();
</code></pre>
<p>.. however, &quot;SimpleAssignmentExpressionSyntax&quot; is not a real type. I tried starting to type  out &quot;Simple&quot; to see if intellisense would pick up what the correct name was - but that didn't get me anywhere.</p>
<p>Next, I resorted to deleting those last few lines (since they don't compile) and to just putting a breakpoint at the top of &quot;LookForInvalidSelectAttributeProperties&quot;. I then used Debug Tests on &quot;DoNotUseValueWhenMultipleIsTrue&quot;. The breakpoint is hit.. but I can't see the child nodes with QuickWatch because &quot;ChildNodes()&quot; is a method, not a property, and QuickWatch only shows you property values (it doesn't offter to execute methods and show you what is returned). So I go to the Immediate Window (Debug / Windows / Immediate), type the following and hit [Enter] -</p>
<pre><code>context.Node.ChildNodes().First().GetType().Name
</code></pre>
<p>This displays &quot;AssignmentExpressionSyntax&quot;.</p>
<p>This clue is enough to stop the debugger and go back to trying to populate the &quot;LookForInvalidSelectAttributeProperties&quot;. It may now start with:</p>
<pre><code>var propertyInitialisers = context.Node.ChildNodes()
    .OfType&lt;AssignmentExpressionSyntax&gt;();
</code></pre>
<p>Using Go To Definition on <strong>AssignmentExpressionSyntax</strong> shows that it has a &quot;Left&quot; and a &quot;Right&quot; property. These are the expressions that come either side of the operator, which is always an Equals sign when considering object property initialisations.</p>
<p>The Syntax Visualizer shows that each &quot;SimpleAssignmentExpression&quot; has an &quot;IdentifierName&quot; on the left, so we should be able to get the property name from that.</p>
<p>To try to work out what type &quot;IdentifierName&quot; relates to, I start typing &quot;Identifier&quot; and intellisense suggests <strong>IdentifierNameSyntax</strong> (if it hadn't suggested anything helpful then I would have resorted to using Debug Tests again and inspecting types in the debugger). Having a poke around the <strong>IdentifierNameSyntax</strong> class, I see that it has a property &quot;Identifier&quot; and that has a string property &quot;ValueText&quot;. This looks like the name of the property being set. Things are coming together. The start of the &quot;LookForInvalidSelectAttributeProperties&quot; can now look like this:</p>
<pre><code>var propertyInitialisers = context.Node.ChildNodes()
    .OfType&lt;AssignmentExpressionSyntax&gt;()
    .Select(propertyInitialiser =&gt; new
    {
        PropertyName = ((IdentifierNameSyntax)propertyInitialiser.Left).Identifier.ValueText,
        ValueExpression = propertyInitialiser.Right
    });
</code></pre>
<p>It's worth noting that we don't have to worry about the &quot;Left&quot; property ever being anything other than a simple identifier because assignments in object initialisers are only ever allow to be simple assignments. For example, the following would not compile:</p>
<pre><code>var x = new MyClass { Name.Value = &quot;Ted };
</code></pre>
<p>.. because attempting to set nested properties in object initialisers does not compile in C#. Because it's not valid C#, we don't have to worry about it being passed through the analyser.</p>
<p>Maybe it's worth adding another unit test around this - to ensure that invalid C# can't result in a load of edge cases that we need to be concerned about:</p>
<pre><code>[TestMethod]
public void IgnoreInvalidPropertySetting()
{
    var testContent = @&quot;
        using Bridge.React;

        namespace TestCase
        {
            public class Example
            {
                public void Go()
                {
                    new SelectAttributes { Nested.Multiple = true };
                }
            }
        }&quot;;

    VerifyCSharpDiagnostic(testContent);
}
</code></pre>
<p><em>Note: Calling the &quot;VerifyCSharpDiagnostic&quot; with no &quot;expected&quot; value means that the test expects that the analyser will not report any violated rules.</em></p>
<p>Now we can really move things along. We're interested in property initialisers where &quot;Multiple&quot; is clearly true or false (meaning it is set specifically to true or false <em>or</em> it's not specified at all, leaving it with its default value of false). So, again using the Syntax Visualizer to work out how to tell whether an expression means a &quot;true&quot; constant or a &quot;false&quot; constant, I've come up with this:</p>
<pre><code>var propertyInitialisers = context.Node.ChildNodes()
    .OfType&lt;AssignmentExpressionSyntax&gt;()
    .Select(propertyInitialiser =&gt; new
    {
        PropertyName = ((IdentifierNameSyntax)propertyInitialiser.Left).Identifier.ValueText,
        ValueExpression = propertyInitialiser.Right
    });

var multiplePropertyInitialiser = propertyInitialisers.FirstOrDefault(
    propertyInitialiser =&gt; propertyInitialiser.PropertyName == &quot;Multiple&quot;
);
bool multiplePropertyValue;
if (multiplePropertyInitialiser == null)
    multiplePropertyValue = false; // Defaults to false if not explicitlt set
else
{
    var multiplePropertyValueKind = multiplePropertyInitialiser.ValueExpression.Kind();
    if (multiplePropertyValueKind == SyntaxKind.TrueLiteralExpression)
        multiplePropertyValue = true;
    else if (multiplePropertyValueKind == SyntaxKind.FalseLiteralExpression)
        multiplePropertyValue = false;
    else
    {
        // Only looking for very simple cases - where explicitly set to true or to false or not set at
        // all (defaulting to false). If it's set according to a method return value or a variable then
        // give up (this is just intended to catch obvious mistakes, not to perform deep and complex
        // analysis)
        return;
    }
}
</code></pre>
<p>The next thing to do is to look for a &quot;Value&quot; or &quot;Values&quot; property being specified that is not appropriate for the &quot;Multiple&quot; value that we've found.</p>
<p>From the above code, it should be fairly clear that the way to do this is the following:</p>
<pre><code>var valuePropertyIsSpecified = propertyInitialisers.Any(
    propertyInitialiser =&gt; propertyInitialiser.PropertyName == &quot;Value&quot;
);
var valuesPropertyIsSpecified = propertyInitialisers.Any(
    propertyInitialiser =&gt; propertyInitialiser.PropertyName == &quot;Values&quot;
);
if (!valuePropertyIsSpecified &amp;&amp; !valuesPropertyIsSpecified)
    return;
</code></pre>
<p>The final step is to ensure that the object initialisation that we're looking at is indeed for a <strong>SelectAttributes</strong> instance. This is the bit that requires a lookup into the &quot;SemanticModel&quot; and which is more expensive than just looking at the current syntax tree because it needs the project to compile and to then work out what references to external code there may be.</p>
<p>Knowing that I'm going to be dealing with the full semantic model, I'll start by looking through the methods available on &quot;context.SemanticModel&quot; to see what might help me. Using the intellisense / documentation, it doesn't take long to find a &quot;GetTypeInfo&quot; method that takes an <strong>ObjectCreationExpression</strong> instance - this is ideal because we have an <strong>ObjectInitializerExpressionSyntax</strong> and we know that an <strong>ObjectInitializerExpressionSyntax</strong> is a child of an <strong>ObjectCreationExpressionSyntax</strong>, so it's easy for us to get an <strong>ObjectCreationExpression</strong> (it's just the parent of <strong>ObjectInitializerExpressionSyntax</strong> that we have).</p>
<p>&quot;GetTypeInfo&quot; returns a <strong>TypeInfo</strong> instance which has two properties; &quot;Type&quot; and &quot;ConvertedType&quot;. &quot;ConvertedType&quot; is (taken from the xml summary documentation):</p>
<blockquote>
<p>The type of the expression after it has undergone an implicit conversion</p>
</blockquote>
<p>which shouldn't apply here, so we'll just look at &quot;Type&quot;. Note, though, that the documentation for &quot;Type&quot; says that:</p>
<blockquote>
<p>For expressions that do not have a type, null is returned. If the type could not be determined due to an error, than an IErrorTypeSymbol is returned.</p>
</blockquote>
<p>Since this is an object creation expression, there should <em>always</em> be a type returned (the type of the object being instantiated) but we do need to be careful about the error response. Here, it's fine to stop processing if there's an error - it might mean that there is a &quot;new SelectAttributes&quot; statements in the code being analysed but no &quot;Using Bridge.React;&quot; at the top of the file. We'll ignore these error cases and plan to only analyse valid code.</p>
<p>This is the code that needs adding to ensure that the properties that we're looking at are for a Bridge.React.SelectAttributes -</p>
<pre><code>var objectCreation = (ObjectCreationExpressionSyntax)context.Node.Parent;
var objectCreationTypeInfo = context.SemanticModel.GetTypeInfo(objectCreation);
if ((objectCreationTypeInfo.Type is IErrorTypeSymbol)
|| (objectCreationTypeInfo.Type.ContainingAssembly.Identity.Name != &quot;Bridge.React&quot;)
|| (objectCreationTypeInfo.Type.Name != &quot;SelectAttributes&quot;))
    return;
</code></pre>
<p>Having written this code, it strikes me as a good idea to add another test - one that ensures that we don't raise false positives about &quot;Multiple&quot; and &quot;Value&quot; / &quot;Values&quot; in cases where it's a different <strong>SelectAttributes</strong> class, that is declared somewhere other than in &quot;Bridge.React&quot;.</p>
<pre><code>/// &lt;summary&gt;
/// Don't analyse a SelectAttributes initialisation that is for a different SelectAttributes class
/// (only target the SelectAttributes class that is part of the Bridge.React library)
/// &lt;/summary&gt;
[TestMethod]
public void OnlyTargetBridgeReactSelectAttributes()
{
    var testContent = @&quot;
        namespace TestCase
        {
            public class Example
            {
                public void Go()
                {
                    new SelectAttributes { Multiple = true, Value = &quot;&quot;x&quot;&quot; };
                }
            }

            public class SelectAttributes
            {
                public bool Multiple { get; set; }
                public string Value { get; set; }
            }
        }&quot;;

    VerifyCSharpDiagnostic(testContent);
}
</code></pre>
<p>Now we have all of the required information to display a warning for invalid &quot;Multiple&quot; / &quot;Value&quot; / &quot;Values&quot; combinations. What we <em>don't</em> have is appropriate message content to display - we've only got the warning content from the example analyser in the project template.</p>
<p>So delete all of the code at the top of the analyser - the const and static strings, the &quot;Rule&quot; reference and the &quot;SupportedDiagnostics&quot; property and replace them with this:</p>
<pre><code>public const string DiagnosticId = &quot;Bridge.React&quot;;
private static readonly LocalizableString Title
    = &quot;Be careful to use the appropriate 'Value' or 'Values' property for the 'Multiple' setting&quot;;
private static readonly LocalizableString MultipleWithValueMessage
    = &quot;If 'Multiple' is true then the 'Values' property should be used instead of 'Value'&quot;;
private static readonly LocalizableString NoMultipleWithValuesMessage
    = &quot;If 'Multiple' is false then the 'Value' property should be used instead of 'Values'&quot;;
private const string Category = &quot;Configuration&quot;;

private static DiagnosticDescriptor MultipleWithValueRule = new DiagnosticDescriptor(
    DiagnosticId,
    Title,
    MultipleWithValueMessage,
    Category,
    DiagnosticSeverity.Warning,
    isEnabledByDefault: true
);
private static DiagnosticDescriptor NoMultipleWithValuesRule = new DiagnosticDescriptor(
    DiagnosticId,
    Title,
    NoMultipleWithValuesMessage,
    Category,
    DiagnosticSeverity.Warning,
    isEnabledByDefault: true
);

public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics
{
    get { return ImmutableArray.Create(MultipleWithValueRule, NoMultipleWithValuesRule); }
}
</code></pre>
<p>The final step, then, is to report rules when they are broken. The following needs adding to the end of the &quot;LookForInvalidSelectAttributeProperties&quot; method in order to complete it:</p>
<pre><code>if ((multiplePropertyValue == true) &amp;&amp; valuePropertyIsSpecified)
{
    context.ReportDiagnostic(Diagnostic.Create(
        MultipleWithValueRule,
        context.Node.GetLocation()
    ));
}
else if ((multiplePropertyValue == false) &amp;&amp; valuesPropertyIsSpecified)
{
    context.ReportDiagnostic(Diagnostic.Create(
        NoMultipleWithValuesRule,
        context.Node.GetLocation()
    ));
}
</code></pre>
<h3>Localisation support</h3>
<p>There's just one final thing to do now, which is more of a good practice than an essential - that is to replace the hard-coded strings in the analyser class with resources (that may potentially be translated into different languages one day). The project template includes a &quot;Resources.resx&quot; file, which is where we should move these strings to. Edit that file in Visual Studio and delete the existing entries and then add the following Name and Value pairs:</p>
<blockquote>
<p><strong>Name:</strong> SelectAttributesAnalyserTitle</p>
</blockquote>
<blockquote>
<p><strong>Value:</strong> Be careful to use the appropriate 'Value' or 'Values' property for the 'Multiple' setting</p>
</blockquote>
<blockquote>
<p><strong>Name:</strong> SelectAttributesAnalyserMultipleWithValueMessage</p>
</blockquote>
<blockquote>
<p><strong>Value:</strong> If 'Multiple' is true then the 'Values' property should be used instead of 'Value'</p>
</blockquote>
<blockquote>
<p><strong>Name:</strong> SelectAttributesAnalyserNoMultipleWithValuesTitle</p>
</blockquote>
<blockquote>
<p><strong>Value:</strong> If 'Multiple' is false then the 'Value' property should be used instead of 'Values'</p>
</blockquote>
<p>To make accessing these resources a little easier, add the following method to the bottom of the analyser class:</p>
<pre><code>private static LocalizableString GetLocalizableString(string nameOfLocalizableResource)
{
    return new LocalizableResourceString(
        nameOfLocalizableResource,
        Resources.ResourceManager,
        typeof(Resources)
    );
}
</code></pre>
<p>Finally, replace the three hard-coded string property initialisers with the following:</p>
<pre><code>    private static readonly LocalizableString Title = GetLocalizableString(
        nameof(Resources.SelectAttributesAnalyserTitle)
    );
    private static readonly LocalizableString MultipleWithValueTitle = GetLocalizableString(
        nameof(Resources.SelectAttributesAnalyserMultipleWithValueMessage)
    );
    private static readonly LocalizableString NoMultipleWithValuesTitle = GetLocalizableString(
        nameof(Resources.SelectAttributesAnalyserNoMultipleWithValuesTitle)
    );
</code></pre>
<h3>Summary</h3>
<p>That completes the analyser. I've included the complete source code for the final implementation below - now that it's written it doesn't look like much, which hopefully illustrates how powerful and complete the Roslyn library is. And, hopefully, it's shown that this powerful library doesn't need to be daunting because there's many resources out there for helping you understand how to use it; people have written a lot about it and so Googling for terms relating to what you want to do often yields helpful results, people have answered a lot of questions about it on Stack Overflow and so you will often find example and sample code there.</p>
<p>If you're not sure what terms to use to try to search for help then using the Syntax Visualizer to explore your code can set you on the right path, as can writing a test or two and then examining the &quot;context.Node&quot; reference in the debugger (if you do this then ensure that you are building your project in Debug mode since Release builds may prevent your breakpoints from being hit and may optimise some of the variable references away, which will mean that you won't be able to use QuickWatch on them). Finally, don't forget that there is a lot of helpful information in the xml summary documentation that's available in Visual Studio when you examine the Roslyn classes and their methods - often the names of methods are descriptive enough to help you choose the appropriate one or, at least, give you a clue as to what direction to go in.</p>
<p>This has really only scraped the surface of what analysers are capable of, it's a technology with huge capability and potential. I might talk about other uses for analysers (or talk about how particular analysers may be implemented) another day but two topics that I definitely <em>will</em> talk about soon are &quot;code fixes&quot; and how to get analysers to work with <a href="http://bridge.net/">Bridge.NET</a> libraries.</p>
<p>Code fixes are interesting because they allow you to go beyond just saying &quot;this is wrong&quot; to saying &quot;this is how it may be fixed (automatically, by the IDE)&quot;. For example, if someone changed a <strong>SelectAttributes</strong> instantiation to enable multiple selections - eg. started with:</p>
<pre><code>DOM.Select(
    new SelectAttributes { Value = selectedId },
    options
)
</code></pre>
<p>.. and changed it to:</p>
<pre><code>DOM.Select(
    new SelectAttributes { Multiple = true, Value = selectedId },
    options
)
</code></pre>
<p>.. then the analyser could point out that the &quot;Value&quot; property should not be used now that &quot;Multiple&quot; is true but it could also offer to fix it up to the following <em>automatically</em>:</p>
<pre><code>DOM.Select(
    new SelectAttributes { Multiple = true, Values = new[] { selectedId } },
    options
)
</code></pre>
<p>There will be times that the warning from an analyser will require manual intervention to correct but there will also be times where the computer could easily correct it, so it's great having the ability to explain to the computer <em>how</em> to do so and thus make life that bit easier for the person consuming your library.</p>
<p>The reason that I also want to spend a little bit of time talking about making analysers work with Bridge.NET libraries soon is that it's something of a special case since Bridge projects don't have references to the standard .net System, System.Collections, etc.. assemblies because they are replaced by special versions of those libraries that have JavaScript translations. This means that you can't reference a Bridge library from a project that relies on the standard .net assemblies, which is a bit of a problem when you want to write a Roslyn analyser for types in a Bridge library (since the analyser project will rely on standard .net assemblies and the analyser will want to reference the Bridge library whose rules are to be applied by the analyser). But there are ways to get around it and I'll go through that another time.</p>
<h3>The complete analyser</h3>
<pre><code>using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace ExampleAnalyser
{
    [DiagnosticAnalyzer(LanguageNames.CSharp)]
    public sealed class ExampleAnalyserAnalyzer : DiagnosticAnalyzer
    {
        public const string DiagnosticId = &quot;Bridge.React&quot;;
        private static readonly LocalizableString Title = GetLocalizableString(
            nameof(Resources.SelectAttributesAnalyserTitle)
        );
        private static readonly LocalizableString MultipleWithValueTitle = GetLocalizableString(
            nameof(Resources.SelectAttributesAnalyserMultipleWithValueMessage)
        );
        private static readonly LocalizableString NoMultipleWithValuesTitle = GetLocalizableString(
            nameof(Resources.SelectAttributesAnalyserNoMultipleWithValuesTitle)
        );
        private const string Category = &quot;Configuration&quot;;

        private static DiagnosticDescriptor MultipleWithValueRule = new DiagnosticDescriptor(
            DiagnosticId,
            Title,
            MultipleWithValueTitle,
            Category,
            DiagnosticSeverity.Warning,
            isEnabledByDefault: true
        );
        private static DiagnosticDescriptor NoMultipleWithValuesRule = new DiagnosticDescriptor(
            DiagnosticId,
            Title,
            NoMultipleWithValuesTitle,
            Category,
            DiagnosticSeverity.Warning,
            isEnabledByDefault: true
        );

        public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics
        {
            get { return ImmutableArray.Create(MultipleWithValueRule, NoMultipleWithValuesRule); }
        }

        public override void Initialize(AnalysisContext context)
        {
            context.RegisterSyntaxNodeAction(
                LookForInvalidSelectAttributeProperties,
                SyntaxKind.ObjectInitializerExpression
            );
        }

        private static void LookForInvalidSelectAttributeProperties(SyntaxNodeAnalysisContext context)
        {
            var propertyInitialisers = context.Node.ChildNodes()
                .OfType&lt;AssignmentExpressionSyntax&gt;()
                .Select(propertyInitialiser =&gt; new
                {
                    PropertyName = ((IdentifierNameSyntax)propertyInitialiser.Left).Identifier.ValueText,
                    ValueExpression = propertyInitialiser.Right
                });

            var multiplePropertyInitialiser = propertyInitialisers.FirstOrDefault(
                propertyInitialiser =&gt; propertyInitialiser.PropertyName == &quot;Multiple&quot;
            );
            bool multiplePropertyValue;
            if (multiplePropertyInitialiser == null)
                multiplePropertyValue = false; // Defaults to false if not explicitlt set
            else
            {
                var multiplePropertyValueKind = multiplePropertyInitialiser.ValueExpression.Kind();
                if (multiplePropertyValueKind == SyntaxKind.TrueLiteralExpression)
                    multiplePropertyValue = true;
                else if (multiplePropertyValueKind == SyntaxKind.FalseLiteralExpression)
                    multiplePropertyValue = false;
                else
                {
                    // Only looking for very simple cases - where explicitly set to true or to false or
                    // not set at all (defaulting to false). If it's set according to a method return
                    // value or a variable then give up (this is just intended to catch obvious
                    // mistakes, not to perform deep and complex analysis)
                    return;
                }
            }

            var valuePropertyIsSpecified = propertyInitialisers.Any(
                propertyInitialiser =&gt; propertyInitialiser.PropertyName == &quot;Value&quot;
            );
            var valuesPropertyIsSpecified = propertyInitialisers.Any(
                propertyInitialiser =&gt; propertyInitialiser.PropertyName == &quot;Values&quot;
            );
            if (!valuePropertyIsSpecified &amp;&amp; !valuesPropertyIsSpecified)
                return;

            var objectCreation = (ObjectCreationExpressionSyntax)context.Node.Parent;
            var objectCreationTypeInfo = context.SemanticModel.GetTypeInfo(objectCreation);
            if ((objectCreationTypeInfo.Type is IErrorTypeSymbol)
            || (objectCreationTypeInfo.Type.ContainingAssembly.Identity.Name != &quot;Bridge.React&quot;)
            || (objectCreationTypeInfo.Type.Name != &quot;SelectAttributes&quot;))
                return;

            if ((multiplePropertyValue == true) &amp;&amp; valuePropertyIsSpecified)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    MultipleWithValueRule,
                    context.Node.GetLocation()
                ));
            }
            else if ((multiplePropertyValue == false) &amp;&amp; valuesPropertyIsSpecified)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    NoMultipleWithValuesRule,
                    context.Node.GetLocation()
                ));
            }
        }

        private static LocalizableString GetLocalizableString(string nameOfLocalizableResource)
        {
            return new LocalizableResourceString(
                nameOfLocalizableResource,
                Resources.ResourceManager,
                typeof(Resources)
            );
        }
    }
}
</code></pre>
<p class="PostTime">Posted at 07:49</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Roslyn" title="4 Posts">Roslyn</a></li></ul></div>
            <p class="Comments">
                <a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner#disqus_thread" data-disqus-identifier="102">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <h3 class="PostDate">3 February 2016</h3><h2><a id="using-roslyn-to-identify-unused-and-undeclared-variables-in-vbscript-wsc-components" href="/using-roslyn-to-identify-unused-and-undeclared-variables-in-vbscript-wsc-components">Using Roslyn to identify unused and undeclared variables in VBScript WSC components</a></h2>
<p><em>(<strong>Note:</strong> I had intended to keep this aside for April Fools since it's intended to be a bit tongue-in-cheek and really just an excuse to play with technology for technology's sake.. but I haven't got many other posts that I'm working on at the moment so I'm going to just unleash this now, rather than waiting!)</em></p>
<p>Imagine that you maintain a project which was migrated over time from an old and fragile platform to a new and improved (C#) code base. But there are various complicated external components that have been left untouched since they were (mostly) working and the new code could continue to use them - allowing the valuable rewriting time to be spent elsewhere, on less compartmentalised areas of code.</p>
<p>For some projects, these could be C++ COM components - I'm no expert on C++, but since people are still writing a lot of code in it and there are powerful IDEs to support this (such as Visual Studio), I presume that maintaining these sorts of components is possibly a little annoying (because COM) but not the worst thing in the world. For other projects, though, these could be &quot;<a href="https://msdn.microsoft.com/en-us/library/ms524594(v=vs.90).aspx">Windows Scripting Components</a>&quot; - these are basically COM components that are written in scripting languages, such as VBScript. They look something like the following:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;?component error=&quot;false&quot; debug=&quot;false&quot; ?&gt;
&lt;package&gt;
  &lt;component id=&quot;ExampleComponent&quot;&gt;
    &lt;registration progid=&quot;ExampleComponent&quot; description=&quot;Example Component&quot; version=&quot;1&quot; /&gt;
    &lt;public&gt;
      &lt;method name=&quot;DoSomething&quot; /&gt;
    &lt;/public&gt;
    &lt;script language=&quot;VBScript&quot;&gt;
    &lt;![CDATA[

      Function DoSomething(ByVal objOutput)
        Dim intIndex: For intIndex = 1 To 5
          objOutput.WriteLine &quot;Entry &quot; &amp; iIndex
        Next
      End Function

    ]]&gt;
    &lt;/script&gt;
  &lt;/component&gt;
&lt;/package&gt;
</code></pre>
<p>Creating &quot;Classic ASP&quot; web projects using these components had the advantage that interfaces between components could be limited and documented, enabling a semblance of organisation to be brought to bear on large solutions.. but &quot;Classic ASP&quot; and VBScript are technologies that, by this point, should have long since been put to bed. They do <em>not</em> have good IDE support or debugging tools (nor do they perform well, nor is it easy to hire good people to work on your solutions that contain code in this language).</p>
<p>If you have components that work and that will never be needed to change, then maybe that's no big deal. Or maybe there is something in the migration plan that says that legacy components that work (and do not require adapting or extending) will be left as-is and any components that need work will be rewritten.</p>
<p>If this is the case, then it's easy enough to use these working components from C# -</p>
<pre><code>var filename = &quot;ExampleComponent.wsc&quot;;
dynamic component = Microsoft.VisualBasic.Interaction.GetObject(
  &quot;script:&quot; + new FileInfo(filename).FullName,
  null
);
component.DoSomething(new ConsoleWriter());
</code></pre>
<p><em>Note: In order for the above code to run with the WSC presented further up, the C# code needs to provide a ComVisible &quot;objOutput&quot; reference which has a &quot;WriteLine&quot; method that takes a single (string) argument. The snippet above uses a <strong>ConsoleWriter</strong> class, which could be implemented as follows:</em></p>
<pre><code>[ComVisible(true)]
public class ConsoleWriter
{
  public void WriteLine(string value)
  {
    Console.WriteLine(value);
  }
}
</code></pre>
<p>But what if there <em>isn't</em> an agreement to rewrite any WSCs that need work and what if there are some that need bug-fixing or new functionality? Well, good luck! Error messages from these components tend to be vague and - just to really add a little extra joy to your life - they don't include line numbers. Oh, &quot;Object expected&quot;? Great.. will you tell me where? No. Oh, good.</p>
<p>If you were so intrigued by what I've written here so far that you've actually been playing along and have saved the WSC content from the top of this post into a file and executed it using the C# above, you might have noticed another problem when you ran it. Below is what is output to the console:</p>
<blockquote>
<p>Entry</p>
</blockquote>
<blockquote>
<p>Entry</p>
</blockquote>
<blockquote>
<p>Entry</p>
</blockquote>
<blockquote>
<p>Entry</p>
</blockquote>
<blockquote>
<p>Entry</p>
</blockquote>
<p>But, since the VBScript is performing a simple loop and writing a message that includes that loop variable in it, shouldn't it be this instead??</p>
<blockquote>
<p>Entry 1</p>
</blockquote>
<blockquote>
<p>Entry 2</p>
</blockquote>
<blockquote>
<p>Entry 3</p>
</blockquote>
<blockquote>
<p>Entry 4</p>
</blockquote>
<blockquote>
<p>Entry 5</p>
</blockquote>
<h3>Identifying unused and undeclared variables with the VBScriptTranslator and Roslyn</h3>
<p>Well, I do have a glimmer of hope for the problem above and, potentially, for other VBScript-writing pitfalls.</p>
<p>What we could do is process WSC files to -</p>
<ol>
<li>Extract VBScript section(s) from them</li>
<li>Run the VBScript content through the <a href="/translating-vbscript-into-c-sharp">VBScriptTranslator</a> to generate C#</li>
<li>Parse and build the resulting C# using <a href="https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview">Roslyn</a></li>
<li>Use information gleaned from steps 2 and 3 to identify errors that might otherwise not be apparent before runtime</li>
</ol>
<p>The packages we want are available through NuGet -</p>
<ul>
<li><a href="https://www.nuget.org/packages/VBScriptTranslator">https://www.nuget.org/packages/VBScriptTranslator</a></li>
<li><a href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.CSharp">https://www.nuget.org/packages/Microsoft.CodeAnalysis.CSharp</a></li>
</ul>
<p>Before I go through these steps, let me just explain briefly what the problem was in the VBScript sample code shown further up - just in case you're not familiar with VBScript or didn't spot it.</p>
<p>The loop variable in the code</p>
<pre><code>Dim intIndex: For intIndex = 1 To 5
  objOutput.WriteLine &quot;Entry &quot; &amp; iIndex
Next
</code></pre>
<p>is named &quot;intIndex&quot; but the line that writes out the text refers to &quot;iIndex&quot;, which is an undeclared variable.</p>
<p>In C#, if we tried to do something similar then the compiler would bring it immediately to our attention - eg.</p>
<pre><code>for (var i = 1; i &lt;= 5; i++)
  Console.WriteLine(&quot;Entry &quot; + j);
</code></pre>
<p>Presuming that &quot;j&quot; was not defined elsewhere within the scope of the above code, we would be informed that</p>
<blockquote>
<p>The name 'j' does not exist in the current context</p>
</blockquote>
<p>But VBScript doesn't care about this, declaring variables (such as with the use of &quot;Dim intIndex&quot;) is generally optional. The &quot;iIndex&quot; value in the code above is never defined, which means it gets the special VBScript &quot;Empty&quot; value, which is treated as an empty string when introduced into a string concatenation operation.</p>
<p>VBScript does support a mode that requires that variables be declared before they are referenced; &quot;Option Explicit&quot;. If we changed the code to the following:</p>
<pre><code>Option Explicit

Dim intIndex: For intIndex = 1 To 5
  objOutput.WriteLine &quot;Entry &quot; &amp; iIndex
Next
</code></pre>
<p>then we would get an error at runtime:</p>
<blockquote>
<p>Variable is undefined: 'iIndex'</p>
</blockquote>
<p>Which seems much better, but there's one big gotcha to &quot;Option Explicit&quot; - it is <em>not</em> enforced when the VBScript code is parsed, it is only enforced as the code is executed. This means that enabling Option Explicit and having a script run successfully does <em>not</em> mean that it contains no undeclared variables, it only means that the code path that just ran contained no undeclared variables.</p>
<p>To illustrate, the following script will run successfully <em>except on Saturdays</em> -</p>
<pre><code>Option Explicit

Dim intIndex: For intIndex = 1 To 5
  If IsSaturday() Then
    objOutput.WriteLine &quot;Entry &quot; &amp; iIndex
  Else
    objOutput.WriteLine &quot;Entry &quot; &amp; intIndex
  End If
Next

Function IsSaturday()
  IsSaturday = WeekDay(Now()) = 7
End Function
</code></pre>
<p>This is a pity. I think that it would have been much better for Option Explicit to have been enforced when the script was loaded. But that ship has <em>loooooong</em> since sailed.</p>
<p>So, instead of crying about spilt milk, let's look at something positive. We've got a four step plan to crack on with!</p>
<h4>1. Extracting VBScript content from a WSC</h4>
<p>This is the most boring step and so I'll try not to get bogged down too much here. A WSC file is xml content and we want to identify CDATA content sections within &quot;script&quot; tags that have a &quot;language&quot; attribute with the value &quot;VBScript&quot;.</p>
<p>The below is some rough-and-ready code, taken from a project that I wrote years ago, dusted off to reuse here -</p>
<pre><code>private static IEnumerable&lt;Tuple&lt;string, int&gt;&gt; GetVBScriptSections(string wscContent)
{
  var document = new XPathDocument(new StringReader(wscContent));
  var nav = document.CreateNavigator();
  if (nav.HasChildren &amp;&amp; nav.MoveToFirstChild())
  {
    while (true)
    {
      foreach (var scriptSection in TryToGetVBScriptContentFromNode(nav))
        yield return scriptSection;
      if (!nav.MoveToNext())
        break;
    }
  }
}

private static IEnumerable&lt;Tuple&lt;string, int&gt;&gt; TryToGetVBScriptContentFromNode(XPathNavigator nav)
{
  if (nav.NodeType == XPathNodeType.Text)
  {
    var navParent = nav.Clone();
    navParent.MoveToParent();
    if (navParent.Name.Equals(&quot;script&quot;, StringComparison.OrdinalIgnoreCase)
    &amp;&amp; DoesNodeHaveVBScriptLanguageAttribute(navParent))
      yield return Tuple.Create(nav.Value, ((IXmlLineInfo)nav).LineNumber - 1);
  }
  if (nav.HasChildren)
  {
    var navChildren = nav.Clone();
    if (navChildren.MoveToFirstChild())
    {
      while (true)
      {
        foreach (var scriptSection in TryToGetVBScriptContentFromNode(navChildren))
          yield return scriptSection;
        if (!navChildren.MoveToNext())
          break;
      }
    }
  }
}

private static bool DoesNodeHaveVBScriptLanguageAttribute(XPathNavigator node)
{
  node = node.Clone();
  if (!node.HasAttributes || !node.MoveToFirstAttribute())
    return false;

  while (true)
  {
    if (node.Name.Equals(&quot;language&quot;, StringComparison.OrdinalIgnoreCase)
    &amp;&amp; node.Value.Equals(&quot;VBScript&quot;, StringComparison.OrdinalIgnoreCase))
      return true;
    if (!node.MoveToNextAttribute())
      return false;
  }
}
</code></pre>
<p>The &quot;GetVBScriptSections&quot; function will return a set of Tuples - pairs of values where the first value is the VBScript content and the second value is the line index that the content starts at in the WSC. It returns a set, rather than a single Tuple, since it is valid for WSC files to contain multiple script tags.</p>
<p>The source line index will be important for identifying where in the WSC that any warnings we generate later originate.</p>
<h4>2. Translate the VBScript sections</h4>
<p>Now that we've got VBScript content, let's translate it into C#!</p>
<p>After the <a href="https://www.nuget.org/packages/VBScriptTranslator/">VBScriptTranslator</a> NuGet package is installed, the following code may be written -</p>
<pre><code>foreach (var vbscriptCodeSection in GetVBScriptSections(wscContent))
{
  // When translating the VBScript, add in new lines before the content so
  // that the lines indexes in the only-VBScript content match the line
  // indexes in the WSC
  var lineIndexInSourceFile = vbscriptCodeSection.Item2;
  var blankLinesToInject = string.Join(
    &quot;&quot;,
    Enumerable.Repeat(Environment.NewLine, lineIndexInSourceFile)
  );

  var vbscriptContent = vbscriptCodeSection.Item1;
  var translatedStatements = DefaultTranslator.Translate(
    blankLinesToInject + vbscriptContent,
    externalDependencies: new string[0],
    warningLogger: message =&gt;
    {
      if (message.StartsWith(&quot;Undeclared variable:&quot;))
        Console.WriteLine(message);
    }
  );
</code></pre>
<p>This actually goes a long way to identifying my original problem - in order for the <a href="https://bitbucket.org/DanRoberts/vbscripttranslator">VBScriptTranslator</a> to do its thing, it needs to identify any undeclared variables (because it will have to create explicitly declared variables in the resulting C# code). When it encounters an undeclared variable, it will log a warning message - the code above writes to the console any warnings about undeclared variables.</p>
<p>Running the above against the content at the top of this post results in the following being written out:</p>
<blockquote>
<p>Undeclared variable: &quot;iIndex&quot; (line 14)</p>
</blockquote>
<p>Success! Line 14 is, indeed, the line where an undeclared variable &quot;iIndex&quot; was accessed.</p>
<p>Now that we have a C# interpretation of the source code, though, it seems like we should be able to do more by bringing the impressive array of C# analysis tools that are now available to bear (ie. Roslyn aka &quot;Microsoft.CodeAnalysis&quot;).</p>
<p>Imagine if the original VBScript content was something more like this -</p>
<pre><code>Function DoSomething(ByVal objOutput)
  Dim intIndex, strName

  ' .. loads of code

  For intIndex = 1 To 5
    objOutput.Write &quot;Entry &quot; &amp; iIndex
  Next

  ' .. loads more code

End Function
</code></pre>
<p>Those legacy VBScript writers sure did love their huge functions with 100s of lines of code! So the &quot;loads of code&quot; sections above really could be <em>loads</em> of code.</p>
<p>One day, someone has to change this long, long function a little bit and thinks that they've removed the only use of the &quot;strName&quot; variable from the function. But it's hard to be sure since the function is so long and it's got conditions nested so deeply that it's headache-inducing. The <a href="http://programmer.97things.oreilly.com/wiki/index.php/The_Boy_Scout_Rule">Boy Scout Rule</a> makes it seem attractive to remove the &quot;strName&quot; declaration if it's no longer used.. the problem is that this someone is not utterly, 100% confident that it's safe to remove. And it's not like they could just remove the variable declaration then re-run and rely on Option Explicit to inform them if the variable <em>is</em> still used somewhere (for the reason outlined earlier).</p>
<p>One way to obtain confidence as to whether a variable is used or not is to continue to the next step..</p>
<h4>3. Build the generated C# using Roslyn</h4>
<p>Adding the <a href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.CSharp">Microsoft.CodeAnalysis.CSharp</a> NuGet package allows us to write:</p>
<pre><code>private static IEnumerable&lt;Tuple&lt;string, int&gt;&gt; GetUnusedVariables(string translatedContent)
{
  // Inspired by code from www.tugberkugurlu.com (see http://goo.gl/HYT8eo)
  var syntaxTree = CSharpSyntaxTree.ParseText(translatedContent);
  var compilation = CSharpCompilation.Create(
    assemblyName: &quot;VBScriptTranslatedContent&quot;,
    syntaxTrees: new[] { syntaxTree },
    references:
      new[]
      {
        // VBScriptTranslator content requires System, System.Collections, System.Runtime
        // and one of its own libraries to run. To identify these assemblies, one type
        // from each is identified, then its Assembly location is used to create the
        // MetadataReferences that we need here
        typeof(object),
        typeof(List&lt;string&gt;),
        typeof(ComVisibleAttribute),
        typeof(DefaultRuntimeSupportClassFactory),
      }
      .Select(type =&gt; MetadataReference.CreateFromFile(type.Assembly.Location)),
    options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
  );
  EmitResult result;
  using (var ms = new MemoryStream())
  {
    result = compilation.Emit(ms);
  }
  if (!result.Success)
  {
    var errorMessages = result.Diagnostics
      .Where(diagnostic =&gt;
        diagnostic.IsWarningAsError || (diagnostic.Severity == DiagnosticSeverity.Error)
      )
      .Select(diagnostic =&gt; $&quot;{diagnostic.Id}: {diagnostic.GetMessage()}&quot;);
    throw new Exception(
      &quot;Compilation of generated C# code failed: &quot; + string.Join(&quot;, &quot;, errorMessages)
    );
  }
  return result.Diagnostics
    .Where(diagnostic =&gt; diagnostic.Id == &quot;CS0219&quot;)
    .Select(diagnostic =&gt; Tuple.Create(
      diagnostic.GetMessage(),
      diagnostic.Location.GetLineSpan().StartLinePosition.Line
    ));
}
</code></pre>
<p>This will take the VBScriptTranslator-generated C# code and return information about any unused variables; a set of Tuples where each pair of values is a message about an unused variable and the line index of this variable's declaration.</p>
<p>We'll use this information in the final step..</p>
<h4>4. Use information gleaned from steps 2 and 3 to identify errors that might otherwise not be apparent before runtime</h4>
<p>In the VBScriptTranslator-calling code from step 2, we got a list of translated statements. Each of these represents a single line of C# code and has the properties &quot;Content&quot;, &quot;IndentationDepth&quot; and &quot;LineIndexOfStatementStartInSource&quot;. If we so desired, we could use the &quot;Content&quot; and &quot;IndentationDepth&quot; properties to print to the console the generated C# in a nicely-indented format.</p>
<p>But that's not important right now, what we really want are two things; a single string for the entirety of the generated C# content (to compile with Roslyn) and we want mappings for line index values in the C# back to line index values in the source VBScript. The C# code may have more or less lines than the VBScript (the translation process is not a simple line-to-line process), which is why these line index mappings will be important.</p>
<pre><code>// Each &quot;translatedStatements&quot; item has a Content string and a
// LineIndexOfStatementStartInSource value (these are used to
// create a single string of C# code and to map each line in
// the C# back to a line in the VBScript)
var translatedContent = string.Join(
  Environment.NewLine,
  translatedStatements.Select(c =&gt; c.Content)
);
var lineIndexMappings = translatedStatements
  .Select((line, index) =&gt; new { Line = line, Index = index })
  .ToDictionary(
    entry =&gt; entry.Index,
    entry =&gt; entry.Line.LineIndexOfStatementStartInSource
  );
</code></pre>
<p>Now it's a simple case of bringing things together -</p>
<pre><code>foreach (var unusedVariableWarning in GetUnusedVariables(translatedContent))
{
  var unusedVariableWarningMessage = unusedVariableWarning.Item1;
  var lineIndexInTranslatedContent = unusedVariableWarning.Item2;
  var lineIndexInSourceContent = lineIndexMappings[lineIndexInTranslatedContent];

  // Line index values are zero-based but warnings messages that refer to
  // a line generally refer to a line NUMBER, which is one-based (hence
  // the +1 operation)
  Console.WriteLine(
    $&quot;{unusedVariableWarningMessage} (line {lineIndexInSourceContent + 1})&quot;
  );
}
</code></pre>
<p>If this was run against our second WSC sample, then we would get a new warning reported:</p>
<blockquote>
<p>The variable 'strname' is assigned but its value is never used (line 13)</p>
</blockquote>
<p>Which is precisely what we wanted to find out - the &quot;strName&quot; variable is declared but never used, so it's safe for our Boy Scout Developer to remove it!</p>
<h3>Ooooooo, I'm excited! What else could I do??</h3>
<p>I must admit, I haven't thought too much about what other possibilities are available when some static analysis is available for VBScript code, I was just intending to mess about with Roslyn a bit. But, thinking about it, a few ideas come to mind.</p>
<p>As an example of the frankly terrible errors that you get when working with VBScript WSCs, if you took the WSC example from earlier and decided to refactor the FUNCTION into a SUB (in VBScript, a SUB is basically a FUNCTION that can not return a value) and you made the silly mistake of changing the function &quot;header&quot; but not its &quot;terminator&quot; - eg.</p>
<pre><code>Sub DoSomething(ByVal objOutput)
  Dim intIndex: For intIndex = 1 To 5
    objOutput.Write &quot;Entry &quot; &amp; iIndex
  Next
End Function
</code></pre>
<p>Then you would get a particularly unhelpful error when trying to load the WSC into the .net runtime -</p>
<blockquote>
<p>Cannot create ActiveX component.</p>
</blockquote>
<p>The problem is that the &quot;END FUNCTION&quot; should have been changed &quot;END SUB&quot;, since the first VBScript line has had the keyword &quot;FUNCTION&quot; changed to &quot;SUB&quot;. It would seem that the VBScript interpreter would have plenty of information available to it that would allow it to raise a more descriptive error. However, it chooses not to.</p>
<p>If this WSC content was run through the VBScriptTranslator, though, then an exception with the following error message would be raised:</p>
<blockquote>
<p>Encountered must-handle keyword in statement content, this should have been handled by a previous AbstractBlockHandler: &quot;End&quot;, line 16 (this often indicates a mismatched block terminator, such as an END SUB when an END FUNCTION was expected)</p>
</blockquote>
<p>Ok.. I'll admit that this is not the friendliest error message ever formed. What exactly is a &quot;must-handle keyword&quot;? What is an &quot;AbstractBlockHandler&quot;?? But the good thing is that a line number is included along with a reference to an &quot;END&quot; token - and this hopefully is enough to point you at where the problem is.</p>
<p>Another idea that springs to mind is to try to identify functions that have inconsistent return types, in terms of whether they are value types or object references. In VBScript, you must be aware of this distinction at all times - if calling a function that you expect to return an object, then you need to write the function call using the &quot;SET&quot; keyword - eg.</p>
<pre><code>Set objPrice = GetPriceDetails(order)
</code></pre>
<p>But if you expect it to return a value type, then you would write it as</p>
<pre><code>sngPrice = GetPriceDetails(order)
</code></pre>
<p>VBScript has a special kind of null that represents an object with no value; &quot;Nothing&quot;. This allows you to write functions that will always return an object reference, but that may return a reference that means &quot;no result&quot; - eg.</p>
<pre><code>Function GetPriceDetails(ByVal x)
  If IsObject(x) Then
    Set GetPriceDetails = x.PriceDetails
    Exit Function
  End If
  Set GetPriceDetails = Nothing
End Function
</code></pre>
<p>However, I've seen code that forgets this and returns a value type &quot;Null&quot; instead - eg.</p>
<pre><code>Function GetPriceDetails(ByVal x)
  If IsObject(x) Then
    Set GetPriceDetails = x.PriceDetails
    Exit Function
  End If
  GetPriceDetails = Null
End Function
</code></pre>
<p>Now, when calling GetPriceDetails, you will get an object reference sometimes and a value type other times. How do you know whether to use &quot;SET&quot; when calling it if you don't know whether you are expecting an object reference or a value type back? Answer: You don't. Most likely whoever wrote the code used &quot;SET&quot; because they tested the &quot;happy case&quot; (which returns an object reference) and forgot to test the less-happy case, which returned a &quot;Null&quot; value type (and that would fail at runtime if called with use of &quot;SET&quot;).</p>
<p>Well, this is something else that the VBScriptTranslator can help with. Instead of using the <strong>DefaultTranslator</strong>'s &quot;Translate&quot; method, we can use its &quot;Parse&quot; method. This will return a syntax tree describing the source code. By examining this data, we can identify cases, like the one above, which are almost certainly mistakes.</p>
<p>Below is a complete example. I won't go too deeply into the details, since that would send me even further off track than I am now!</p>
<pre><code>static void Main(string[] args)
{
  var scriptContent = @&quot;
    Function GetPriceDetails(ByVal x)
      If IsObject(x) Then
        Set GetPriceDetails = x.Price
        Exit Function
      End If
      GetPriceDetails = Null
    End Function&quot;;

  // Note: An &quot;AbstractFunctionBlock&quot; is a Function, a Sub, or a Property - they are
  // all variations on a theme
  var codeBlocks = DefaultTranslator.Parse(scriptContent);
  foreach (var function in GetAllCodeBlocks(codeBlocks).OfType&lt;AbstractFunctionBlock&gt;())
  {
    var returnValueSetters = GetAllCodeBlocks(function.Statements)
      .OfType&lt;ValueSettingStatement&gt;()
      .Where(ValueSetterTargetIs(function.Name));
    var valueTypeReturnValueSetterLineNumbers = returnValueSetters
      .Where(v =&gt; v.ValueSetType == ValueSettingStatement.ValueSetTypeOptions.Let)
      .Select(v =&gt; v.ValueToSet.Tokens.First().LineIndex + 1)
      .Distinct();
    var objectReturnValueSetterLineNumbers = returnValueSetters
      .Where(v =&gt; v.ValueSetType == ValueSettingStatement.ValueSetTypeOptions.Set)
      .Select(v =&gt; v.ValueToSet.Tokens.First().LineIndex + 1)
      .Distinct();
    if (valueTypeReturnValueSetterLineNumbers.Any()
    &amp;&amp; objectReturnValueSetterLineNumbers.Any())
    {
      Console.WriteLine(
        &quot;{0} \&quot;{1}\&quot; has both LET (lines {2}) and SET (lines {3}) return values&quot;,
        function.GetType().Name,
        function.Name.Content,
        string.Join(&quot;, &quot;, valueTypeReturnValueSetterLineNumbers),
        string.Join(&quot;, &quot;, objectReturnValueSetterLineNumbers)
      );
    }
  }
  Console.ReadLine();
}

private static IEnumerable&lt;ICodeBlock&gt; GetAllCodeBlocks(IEnumerable&lt;ICodeBlock&gt; blocks)
{
  foreach (var block in blocks)
  {
    yield return block;

    var parentBlock = codeBlock as IHaveNestedContent;
    if (parentBlock != null)
    {
      foreach (var nestedBlock in GetAllCodeBlocks(parentBlock.AllExecutableBlocks))
        yield return nestedBlock;
    }
  }
}

private static Func&lt;ValueSettingStatement, bool&gt; ValueSetterTargetIs(NameToken target)
{
  return valueSetter =&gt;
  {
    if (valueSetter.ValueToSet.Tokens.Count() &gt; 1)
      return false;
    var valueSetterTarget = valueSetter.ValueToSet.Tokens.Single();
    return
      (valueSetterTarget is NameToken) &amp;&amp;
      valueSetterTarget.Content.Equals(target.Content, StringComparison.OrdinalIgnoreCase);
  };
}
</code></pre>
<p>This will write out the warning</p>
<blockquote>
<p>FunctionBlock &quot;GetPriceDetails&quot; has both LET (lines 7) and SET (lines 4) return value setters</p>
</blockquote>
<p>Hurrah! Very helpful! No more waiting for run time execution to find out that some code paths return object references and some return value types!</p>
<p>Static analysis is very valuable. It's one of the reasons why I like C# so much because there is a lot of power in static analysis - and I'm always looking out for ways to leverage it further, such as more strongly-typed classes (should a phone number really be a string or should it be a &quot;PhoneNumber&quot; class?) and technologies such as code contracts (which I've been meaning to look back into for about a year now.. must stop making excuses).</p>
<p>But there's one other thing that could be done with VBScript WSCs and the VBScriptTranslator - instead of just translating the code to analyse it, it could be translated into C# and then <em>executed</em> as C#! This way the (very expensive) COM boundary would be removed between the .net hosting environment and the old legacy component. <em>And</em> the translated code will execute more quickly than VBScript. Double-win!</p>
<p>The output from a &quot;DefaultTranslator.Translate&quot; call is content that may be saved into a file that will then define a class called &quot;TranslatedProgram&quot; (this string content is what we were earlier pushing through Roslyn for further analysis). This may be executed using a runtime library included in the <a href="https://www.nuget.org/packages/VBScriptTranslator">VBScriptTranslator</a> NuGet package (or that is available on its own, in the <a href="https://www.nuget.org/packages/VBScriptTranslator.RuntimeSupport">VBScriptTranslator.RuntimeSupport</a> NuGet package) with the following code -</p>
<pre><code>// The &quot;compatLayer&quot; provides implementations of VBScript functions (like &quot;CInt&quot;)
// to the translated code, along with functions such as &quot;CALL&quot;, which enable late-
// bound method calls to be executed (which are then compiled into LINQ expressions
// and cached so that subsequent calls are close in performance to hand-written C#)
using (var compatLayer = DefaultRuntimeSupportClassFactory.Get())
{
  // The Runner's &quot;Go&quot; function returns a new instance of the translated
  // component. The &quot;DoSomething&quot; method from the component may then be
  // called. Translated names are all lower-cased, it makes the mismatch
  // between VBScript's case insensitivity and C#'s case SENSITIVITY
  // less important.
  var component = new TranslatedProgram.Runner(compatLayer).Go();
  component.dosomething(new ConsoleWriter());
}
</code></pre>
<h3>So.. not actually <em>that</em> much Roslyn then?</h3>
<p>Sticklers for accuracy may note, at this point, that there hasn't actually been <em>that</em> much use of Roslyn in a post that features that word in its title. Well.. yes, that is fair enough.</p>
<p>But, then, this entire post was only intended to be a slightly silly foray into &quot;just because I can..&quot; that included a detour through Roslyn. Let's not take things too seriously, though - I mean, <em>really</em>, who is still even using <a href="https://www.youtube.com/watch?v=T55ArHjeR1c">VBScript in any serious production applications these days</a>??</p>
<p class="PostTime">Posted at 23:41</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Roslyn" title="4 Posts">Roslyn</a></li><li><a href="/Archive/Tag/VBScript" title="8 Posts">VBScript</a></li></ul></div>
            <p class="Comments">
                <a href="/using-roslyn-to-identify-unused-and-undeclared-variables-in-vbscript-wsc-components#disqus_thread" data-disqus-identifier="94">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <h3 class="PostDate">2 November 2014</h3><h2><a id="locating-todo-comments-with-roslyn" href="/locating-todo-comments-with-roslyn">Locating TODO comments with Roslyn</a></h2>
<p>I picked up an old project recently that I knew I'd made good progress on and that the bits that were finished were looking good.. but also I knew that it had TODO comments littered throughout it to remind me what I <em>hadn't</em> finished.</p>
<p>To get an idea just how many of these there were, I did a solution-wide search for &quot;TODO&quot; in Visual Studio. There were just over two hundred of them. The search results gave me a fair idea of where they were but I got it into my head that I wanted to export this into a list and then map them onto projects and - ideally - classes and methods. The first part is easy, the search results output contains the path to the file, which indicates the project name. The classes, also, could often be extracted from the filename - so long as there was only one class (or interface or enum or whatever) per file, though no nested types would be awkward.</p>
<p>And this, really, would have been enough information to start tracking my progress and have a checklist that I could take satisfaction in crossing items off from. But of course I wanted more! Isn't this new* Roslyn thing supposed to be about parsing code, shouldn't I be able to use it to find out what properties or methods the TODO comments I've found are associated with? And don't I sometimes need a break from genuinely productive work to play with something new and shiny under the pretense of doing something useful with it?? :)</p>
<p>* <em>(Not that new, actually, seeing as it was announced for preview back in 2011)</em>.</p>
<h3>The two sides of Roslyn</h3>
<p>Roslyn is often talked about as enabling a &quot;compiler as a service&quot; - where code can be compiled and executed on-the-fly. So some sort of scripting engine could be created to dynamically change behaviour on already-executing code. Essentially, Roslyn can take source code (C# or VB) and generate IL, which can then be executed and interacted with by the application that fed that source code through it.</p>
<p>However, the other side of it is that it provides &quot;rich code analysis APIs&quot; (according to its <a href="http://msdn.microsoft.com/en-gb/vstudio/roslyn.aspx">page on MSDN</a>) - meaning that it will help you examine the source code, even if you have no intention of executing that code. Which sounds exactly like what I want to try to locate my TODO comments within a containing method / property / type / namespace.</p>
<p>If I had more ambitious aims in mind then it could also be used for all manner of IDE extensions for code investigation, refactoring or &quot;best practices analysis&quot;. A bit like many of the features that <a href="https://www.jetbrains.com/resharper">ReSharper</a> provides (though ReSharper predates it, and woe betide anyone who asks if they are thinking of integrating with Roslyn so that they don't have to maintain as much parsing code of their own - <a href="http://blog.jetbrains.com/dotnet/2014/04/10/resharper-and-roslyn-qa">Ask me again if ReSharper will use Roslyn.. I dare you</a>).</p>
<p>To getting started with Roslyn, you install it through NuGet - though, currently, it's marked as pre-release so mightn't show up when you search for it. The best thing to do is follow the instruction on the <a href="https://www.nuget.org/packages/Microsoft.CodeAnalysis">NuGet package</a> page and run</p>
<blockquote>
<p>Install-Package Microsoft.CodeAnalysis -Pre</p>
</blockquote>
<p>at the Package Manager Console.</p>
<p>With this done, parsing code is as easy as</p>
<pre><code>var parsedContent = CSharpSyntaxTree.ParseText(content);
</code></pre>
<p>where &quot;content&quot; is a string. This string may be an entire file as you would expect to encounter it in a project - with a namespace containing class / interface / enum and fields / properties / methods / values - or it may be a &quot;fragment&quot;, such as a single method or method call (as often illustrated when people talk about using Roslyn for scripting).</p>
<p>The &quot;ParseText&quot; method returns a <strong>SyntaxTree</strong> instance. This is an immutable structure that describes the parsed content. I'm a huge fan of immutable structures since I think it makes code much easier to reason about (my love of immutability has been a theme through many of the posts I've written). In Roslyn's design it has been stated that</p>
<blockquote>
<p>The short answer to why syntax trees are immutable in Roslyn is that it makes parallel work much easier.  You can take a syntax tree and pass it to any thread and not worry that someone else will mutate it while you are in the middle of doing analysis.  This is useful in the command line compiler so that multiple trees can have their methods bound in parallel (which may need to occasionally access information from a different tree), but it's EXTREMELY important for VS scenarios where we want to have an extensibility model that allows many extensions to analyze and transform the same tree in parallel, and it doesn't really work to have a model that forces all those separate extensions to co-ordinate locking a single tree.  Similarly, providing each extension its own copy of the tree would be prohibitive from a memory overhead point of view.</p>
</blockquote>
<p>(I took this from a Google Groups thread <a href="http://groups.google.com/d/msg/altnetisrael/0yUJJdg2D5g/CBk2Kn-mK9sJ">Why are Roslyn Syntax Trees Immutable?</a> and the answer is attributed to &quot;the Roslyn PM&quot;).</p>
<p>Eric Lippert has also written about the design, saying that they wanted the data structures to be immutable and persistent and that</p>
<blockquote>
<p>By persistence I mean the ability to reuse most of the existing nodes in the tree when an edit is made to the text buffer. Since the nodes are immutable, there's no barrier to reusing them, as I've discussed many times on this blog. We need this for performance; we cannot be re-parsing huge wodges of text every time you hit a key. We need to re-lex and re-parse only the portions of the tree that were affected by the edit, because we are potentially re-doing this analysis between every keystroke.</p>
</blockquote>
<p>This is in the context of using Roslyn to analyse code being written within Visual Studio - the full post is titled <a href="http://blogs.msdn.com/b/ericlippert/archive/2012/06/08/persistence-facades-and-roslyn-s-red-green-trees.aspx">Persistence, Facades and Roslyn's Red-Green Trees</a>.</p>
<h3>Get to the point already!</h3>
<p>So. Enough history. Back to my TODO-search.</p>
<p>The <strong>SyntaxTree</strong> returned from &quot;ParseText&quot; looks quite complex at first glance when you starting poking around it with Visual Studio's &quot;QuickWatch&quot; facility, at least (which is the first thing I did).</p>
<p>However, Roslyn helpfully provides a <strong>SyntaxWalker</strong> class, which may be used to easily examine every node within the tree. It uses the vistor pattern to do this. Design patterns are said to be a benefit when their form is appropriate to your problem such that they extend your vocabulary to describe the solution. There seem like there are times, unfortunately, that people layer on design patterns and abstractions only because they think they should - which is why it's nice in cases like this where it makes perfect sense and succeeds in makings things simple if you know the pattern being used. Last year, I was writing a plugin for <a href="http://www.dotlesscss.org">dotLess</a> which used the visitor pattern to traverse the nodes in a stylesheet (see <a href="/cross-browser-pseudo-source-mapping-with-less">Cross Browser (Pseudo) Source Mapping with LESS</a>) and it was nice to see the exact same concept in use here.</p>
<p>The simplest implementation is</p>
<pre><code>public class TriviaVisitor : SyntaxWalker
{
  public TriviaVisitor() : base(SyntaxWalkerDepth.StructuredTrivia) { }
  protected override void VisitTrivia(SyntaxTrivia trivia)
  {
    // Examine Trivia here..
  }
}
</code></pre>
<p>When the &quot;Visit&quot; method is called (which is defined by the <strong>SyntaxWalker</strong> class) and given a parsed tree, the &quot;VisitTrivia&quot; method is called for every <strong>SyntaxTrivia</strong> instance that is encountered within that tree - eg.</p>
<pre><code>(new TriviaVisitor()).Visit(
  CSharpSyntaxTree.ParseText(content).GetRoot()
);
</code></pre>
<p>Comments and whitespace are <strong>SyntaxTrivia</strong>. Everything else will be represented by the <strong>SyntaxNode</strong> and <strong>SyntaxToken</strong> types. A <strong>SyntaxNode</strong> is made up on <strong>SyntaxToken</strong>s. For example, a &quot;<strong>UsingDirectiveSyntax</strong>&quot; represents a &quot;using&quot; statement such as</p>
<pre><code>using System;
</code></pre>
<p>and will contain <strong>SyntaxTokens</strong> for the &quot;using&quot;, &quot;System&quot; and &quot;;&quot; components of the statement.</p>
<p>These <strong>SyntaxNode</strong>s and <strong>SyntaxToken</strong>s are part of the tree that describes that parsed content. Trivia, however, are not directly part of the hierarchical data - rather, they are related to tokens  and accessible through the token's &quot;LeadingTrivia&quot; and &quot;TrailingTrivia&quot; properties. Conversely, <strong>SyntaxTrivia</strong> instances have a &quot;Token&quot; property which allows you to map from the trivia back to the associated token.</p>
<p>So, within a &quot;VisitTrivia&quot; method, we can identify trivia we're interested in (comments, in this case, rather than whitespace) and determine what token they're associated with. The token will have a &quot;Parent&quot; property, which is the <strong>SyntaxNode</strong> that it's part of. The node is part of a hierarchy, which can be traversed up through via the &quot;Parent&quot; property values - each node may be something we're interested in identifying; such as the method containing the comment, the type containing that method or the namespace containing that type (must remember, though, that not all comments will be within methods - some may be TODO comments annotating a class, or even just sitting out on their own in an otherwise-empty file).</p>
<pre><code>public class CommentLocatingVisitor : SyntaxWalker
{
  private readonly Action&lt;ToDoComment&gt; _commentLocated;
  public CommentLocatingVisitor(Action&lt;ToDoComment&gt; commentLocated)
    : base(SyntaxWalkerDepth.StructuredTrivia)
  {
    if (commentLocated == null)
      throw new ArgumentNullException(&quot;commentLocated&quot;);

    _commentLocated = commentLocated;
  }

  protected override void VisitTrivia(SyntaxTrivia trivia)
  {
    if (_commentTypes.Contains(trivia.CSharpKind()))
    {
      string triviaContent;
      using (var writer = new StringWriter())
      {
        trivia.WriteTo(writer);
        triviaContent = writer.ToString();
      }

      // Note: When looking for the containingMethodOrPropertyIfAny, we want MemberDeclarationSyntax
      // types such as ConstructorDeclarationSyntax, MethodDeclarationSyntax, IndexerDeclarationSyntax,
      // PropertyDeclarationSyntax but NamespaceDeclarationSyntax and TypeDeclarationSyntax also
      // inherit from MemberDeclarationSyntax and we don't want those
      var containingNode = trivia.Token.Parent;
      var containingMethodOrPropertyIfAny = TryToGetContainingNode&lt;MemberDeclarationSyntax&gt;(
        containingNode,
        n =&gt; !(n is NamespaceDeclarationSyntax) &amp;&amp; !(n is TypeDeclarationSyntax)
      );
      var containingTypeIfAny = TryToGetContainingNode&lt;TypeDeclarationSyntax&gt;(containingNode);
      var containingNameSpaceIfAny = TryToGetContainingNode&lt;NamespaceDeclarationSyntax&gt;(containingNode);
      _commentLocated(new ToDoComment(
        triviaContent,
        trivia.SyntaxTree.GetLineSpan(trivia.Span).StartLinePosition.Line,
        containingMethodOrPropertyIfAny,
        containingTypeIfAny,
        containingNameSpaceIfAny
      ));
    }
    base.VisitTrivia(trivia);
  }

  private static HashSet&lt;SyntaxKind&gt; _commentTypes = new HashSet&lt;SyntaxKind&gt;(new[] {
    SyntaxKind.SingleLineCommentTrivia,
    SyntaxKind.MultiLineCommentTrivia,
    SyntaxKind.DocumentationCommentExteriorTrivia,
    SyntaxKind.SingleLineDocumentationCommentTrivia,
    SyntaxKind.MultiLineDocumentationCommentTrivia
  });

  private T TryToGetContainingNode&lt;T&gt;(SyntaxNode node, Predicate&lt;T&gt; optionalFilter = null)
    where T : SyntaxNode
  {
    if (node == null)
      throw new ArgumentNullException(&quot;node&quot;);

    var currentNode = node;
    while (true)
    {
      var nodeOfType = currentNode as T;
      if (nodeOfType != null)
      {
        if ((optionalFilter == null) || optionalFilter(nodeOfType))
          return nodeOfType;
      }
      if (currentNode.Parent == null)
        break;
      currentNode = currentNode.Parent;
    }
    return null;
  }
}
</code></pre>
<p>This <strong>CommentLocatingVisitor</strong> class is instantiated with a callback that is executed for every comment that is encountered when its &quot;ParseText&quot; method is called and the provided root traversed.</p>
<p>To keep things organised, this callback passes a <strong>Comment</strong> instance, as follows:</p>
<pre><code>public class Comment
{
  public Comment(
    string content,
    int lineNumber,
    MemberDeclarationSyntax methodOrPropertyIfAny,
    TypeDeclarationSyntax typeIfAny,
    NamespaceDeclarationSyntax namespaceIfAny)
  {
    if (string.IsNullOrEmpty(content))
      throw new ArgumentException(&quot;Null/blank content specified&quot;);
    if (lineNumber &lt; 1)
      throw new ArgumentOutOfRangeException(&quot;lineNumber&quot;);

    Content = content;
    LineNumber = lineNumber;
    MethodOrPropertyIfAny = methodOrPropertyIfAny;
    TypeIfAny = typeIfAny;
    NamespaceIfAny = namespaceIfAny;
  }

  /// &lt;summary&gt;
  /// This will never be null or blank
  /// &lt;/summary&gt;
  public string Content { get; private set; }

  /// &lt;summary&gt;
  /// This will always be a positive integer
  /// &lt;/summary&gt;
  public int LineNumber { get; private set; }

  /// &lt;summary&gt;
  /// This may be null since the comment may not exist within a method or property
  /// &lt;/summary&gt;
  public MemberDeclarationSyntax MethodOrPropertyIfAny { get; private set; }

  /// &lt;summary&gt;
  /// This may be null since the comment may not exist within an class, interface or struct
  /// &lt;/summary&gt;
  public TypeDeclarationSyntax TypeIfAny { get; private set; }

  /// &lt;summary&gt;
  /// This may be null since the comment may not exist within a method or property
  /// &lt;/summary&gt;
  public NamespaceDeclarationSyntax NamespaceIfAny { get; private set; }
}
</code></pre>
<p>So now, given the contents of any C# file, the comments can be identified and traced to the constructs that they're associated with. Now they just need to be filtered to those containing the text &quot;TODO&quot;, since those are the particular comments of interest.</p>
<p>For the first stab I took at this, I did a search-all-solution for &quot;TODO&quot; and copy-pasted the results into a file. I then read in this file, extracted the filenames and ran the above against the contents of each file.</p>
<p>But surely there's a better way..</p>
<h3>Parsing the solution</h3>
<p>What would be ideal would be the ability to point some code at a solution file, for it to determine what projects are in the solution, what C# code files are in the projects and then to extract all of the locations of TODO comments within those. None of this search-all / copy-paste / parse-the-results-and-read-the-files-from-there nonsense.</p>
<p>There are two parts to this - reading the solution file to get the projects and reading the individual project files. I'll start with the latter since it turned out to be easier.</p>
<p>If you add a reference to &quot;Microsoft.Build&quot; then you can can use the <strong>ProjectCollection</strong> type in a method such as</p>
<pre><code>private static IEnumerable&lt;FileInfo&gt; GetCSharpCompileItemFilesForProject(FileInfo projectFile)
{
  if (projectFile == null)
    throw new ArgumentNullException(&quot;projectFile&quot;);

  return (new ProjectCollection()).LoadProject(projectFile.FullName).AllEvaluatedItems
    .Where(item =&gt; item.ItemType == &quot;Compile&quot;)
    .Select(item =&gt; item.EvaluatedInclude)
    .Where(include =&gt; include.EndsWith(&quot;.cs&quot;, StringComparison.OrdinalIgnoreCase))
    .Select(include =&gt; new FileInfo(Path.Combine(projectFile.Directory.FullName, include)));
}
</code></pre>
<p>Nice when the framework provides you just what you need! This is basically just looking for &quot;.cs&quot; items in a given project file and returning <strong>FileInfo</strong> instances such that the full path is made available (the filenames in the project will be paths relative to the location of the project file and so need to be combined with the project file location to get the full path of the file).</p>
<p>The solution file parsing is not quite so elegant.</p>
<p>There is a Stack Overflow question &quot;<a href="http://stackoverflow.com/questions/13280008/how-do-i-compile-a-c-sharp-solution-with-roslyn">How do I compile a C# solution with Roslyn?</a>&quot; which talks about parsing a solution file. But it's very out of date and the code doesn't compile. But it leads to another question &quot;<a href="http://stackoverflow.com/questions/23160685/roslyn-find-references-cant-properly-load-workspace">Roslyn / Find References - Can't properly load Workspace</a>&quot; which looks like it's going to help but I encountered the same problem as this question: &quot;<a href="http://stackoverflow.com/questions/25504951/msbuildworkspace-create-throws-exception">MSBuildWorkspace.Create() throws exception</a>&quot;. The gist is that to use this you need to Microsoft.Build version 14, whereas the version available (for VS 2013, at least) is version 4. It seems like the solution is to download the VS 2014 CTP or get the ISO file and root around for the version 14 assembly.</p>
<p>At this point, I got bored with it and fell back to parsing the solution field with a regular expression, looking for &quot;.csproj&quot; files in what look like project declarations.</p>
<pre><code>private static IEnumerable&lt;FileInfo&gt; GetProjectFilesForSolution(FileInfo solutionFile)
{
  if (solutionFile == null)
    throw new ArgumentNullException(&quot;solutionFile&quot;);

  var projectFileMatcher = new Regex(
    @&quot;Project\(&quot;&quot;\{\w{8}-\w{4}-\w{4}-\w{4}-\w{12}\}&quot;&quot;\) = &quot;&quot;(.*?)&quot;&quot;, &quot;&quot;(?&lt;projectFile&gt;(.*?\.csproj))&quot;&quot;, &quot;&quot;\{\w{8}-\w{4}-\w{4}-\w{4}-\w{12}\}&quot;&quot;&quot;
  );
  foreach (Match match in projectFileMatcher.Matches(solutionFile.OpenText().ReadToEnd()))
  {
    yield return new FileInfo(
      Path.Combine(solutionFile.Directory.FullName, match.Groups[&quot;projectFile&quot;].Value)
    );
  }
}
</code></pre>
<p>It feels a bit dirty but it seems to do the job! And this is hardly production code so I can live with it.</p>
<h3>Cryptic warnings</h3>
<p>There is another small niggle with all this code. It works but there's a compile warning</p>
<blockquote>
<p>Found conflicts between different versions of the same dependent assembly that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</p>
</blockquote>
<p>I don't like compile warnings, if something's wrong then I want to make it right. Plenty of people have eloquently made the case for always resolving compile warnings so I won't go over old ground here - just suffice to say that I agree!</p>
<p>The log verbosity can be altered by going to Tools / Option / Projects and Solutions / Build and Run, from there &quot;MSBuild project build output verbosity&quot; can be changed. So I set it to &quot;Detailed&quot; as instructed in the warning message and found.. nothing useful.</p>
<p>It turns out that this warning is telling a bit of a fib and you actually need to bump the verbosity up another step to &quot;Diagnostic&quot;. <em>Then</em> the log includes the following</p>
<blockquote>
<p>There was a conflict between &quot;Microsoft.Build, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&quot; and &quot;Microsoft.Build, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&quot;.</p>
</blockquote>
<p>It also includes lots of other useful information like what references have what dependencies, so I can see that Microsoft Build v4 is required by project item &quot;Microsoft.Build&quot; (meaning that is the version that I explicitly added as a reference to parse the project files). And I can see that Microsoft Build v14 is required by the project items &quot;Microsoft.CodeAnalysis.Workspaces&quot;, &quot;Microsoft.CodeAnalysis.VisualBasic.Workspaces&quot; and &quot;Microsoft.CodeAnalysis.CSharp.Workspaces&quot;, which are references pulled in by the Roslyn NuGet package.</p>
<p>Unfortunately, I've already explained that I gave up trying to install Microsoft.Build v14! If this was &quot;real&quot; code then I would do it properly and investigate installing that package properly to get rid of this warning.. but for this sort of one-off task (pulling the TODO comments out of a solution, once) I decided I can live with the warning. At least I have an idea how to sort it out if I ever do want to use this code in a more demanding environment.</p>
<h3>Parting words</h3>
<p>This first foray into Roslyn's capabilities has been interesting. I've clearly scratched only the very outer surface of it but it seems like a really well considered product, I think it could be useful in many scenarios and fully intend to have a poke around with its compiling capabilities at some point (since I do love a bit of dynamic compilation, as I was writing about last time!).</p>
<p>If anything that I've written about today could be useful to you, I've put a complete solution up on Bitbucket - find it at <a href="https://bitbucket.org/DanRoberts/todocommentretriever">The TODOCommentRetriever</a>.</p>
<p class="PostTime">Posted at 19:38</p><div class="Related"><h3>You may also be interested in:</h3><ul><li><a href="/cross-browser-pseudo-source-mapping-with-less">Cross Browser (Pseudo) Source Mapping with LESS</a></li><li><a href="/c-sharp-state-machines">C# State Machines</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li><li><a href="/Archive/Tag/Roslyn" title="4 Posts">Roslyn</a></li></ul></div>
            <p class="Comments">
                <a href="/locating-todo-comments-with-roslyn#disqus_thread" data-disqus-identifier="78">Comments</a>
            </p>
    </div>

        <script type="text/javascript">
            (function () {
                var s = document.createElement("script");
                s.type = "text/javascript";
                s.async = true;
                s.src = "https://" + disqus_shortname + ".disqus.com/count.js";
                (document.getElementsByTagName("HEAD")[0] || document.getElementsByTagName("BODY")[0]).appendChild(s);
            }());
        </script>

				<div class="Footer">
					© Productive Rage 2011 - 2021
				</div>
			</div>

			<div class="SideBar">
				<div class="About">
					<h2>About</h2>
					<p>Dan is a big geek who likes making stuff with computers! He can be quite outspoken so clearly needs a blog :)</p>
					<p>In the last few minutes he seems to have taken to referring to himself in the third person. He's quite enjoying it.</p>
					<p><a href="mailto:dangger36@gmail.com" class="Email">dangger36@gmail.com</a></p>
				</div>
				<div class="Search">
<form action="/Search" method="get">						<div>
							<input type="text" class="SiteSearch" name="term" value="" />
							<input type="submit" class="SiteSearchSubmit" value="Search" />
						</div>
</form>				</div>
				<div class="Recent"><h2>Recent Posts</h2><ul><li><a href="/automating-suggested-related-posts-links-for-my-blog-posts">Automating &quot;suggested / related posts&quot; links for my blog posts</a></li><li><a href="/language-detection-and-wordsinsentence-classification-in-c-sharp">Language detection and words-in-sentence classification in C#</a></li><li><a href="/monitoring-my-gardens-limited-sunlight-time-period-with-an-arduino-and-some-tupperware">Monitoring my garden&#x27;s limited sunlight time period with an Arduino (and some tupperware)</a></li><li><a href="/how-are-barcodes-read-libraryless-image-processing-in-c-sharp">How are barcodes read?? (Library-less image processing in C#)</a></li><li><a href="/removing-all-assembly-names-in-jsonnet-typenamehandling-output">Removing ALL assembly names in Json.NET TypeNameHandling output</a></li></ul><div class="RSSFeedLink"><a href="https://www.productiverage.com/feed">RSS Feed</a></div></div>
				<div class="Featured"><h2>Highlights</h2><ul><li><a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face (finding faces in photos using C# and Accord.NET)</a></li><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/translating-vbscript-into-c-sharp">Translating VBScript into C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div>
				<div class="History"><h2>Archives</h2><ul><li><a href="/Archive/4/2021">April 2021 (1)</a></li><li><a href="/Archive/3/2021">March 2021 (1)</a></li><li><a href="/Archive/8/2020">August 2020 (3)</a></li><li><a href="/Archive/7/2019">July 2019 (2)</a></li><li><a href="/Archive/9/2018">September 2018 (1)</a></li><li><a href="/Archive/4/2018">April 2018 (1)</a></li><li><a href="/Archive/3/2018">March 2018 (1)</a></li><li><a href="/Archive/7/2017">July 2017 (1)</a></li><li><a href="/Archive/6/2017">June 2017 (1)</a></li><li><a href="/Archive/2/2017">February 2017 (1)</a></li><li><a href="/Archive/11/2016">November 2016 (1)</a></li><li><a href="/Archive/9/2016">September 2016 (2)</a></li><li><a href="/Archive/8/2016">August 2016 (1)</a></li><li><a href="/Archive/7/2016">July 2016 (1)</a></li><li><a href="/Archive/6/2016">June 2016 (1)</a></li><li><a href="/Archive/5/2016">May 2016 (3)</a></li><li><a href="/Archive/3/2016">March 2016 (3)</a></li><li><a href="/Archive/2/2016">February 2016 (2)</a></li><li><a href="/Archive/12/2015">December 2015 (1)</a></li><li><a href="/Archive/11/2015">November 2015 (2)</a></li><li><a href="/Archive/8/2015">August 2015 (3)</a></li><li><a href="/Archive/7/2015">July 2015 (1)</a></li><li><a href="/Archive/6/2015">June 2015 (1)</a></li><li><a href="/Archive/5/2015">May 2015 (2)</a></li><li><a href="/Archive/4/2015">April 2015 (1)</a></li><li><a href="/Archive/3/2015">March 2015 (1)</a></li><li><a href="/Archive/1/2015">January 2015 (2)</a></li><li><a href="/Archive/12/2014">December 2014 (1)</a></li><li><a href="/Archive/11/2014">November 2014 (1)</a></li><li><a href="/Archive/10/2014">October 2014 (2)</a></li><li><a href="/Archive/9/2014">September 2014 (2)</a></li><li><a href="/Archive/8/2014">August 2014 (1)</a></li><li><a href="/Archive/7/2014">July 2014 (1)</a></li><li><a href="/Archive/6/2014">June 2014 (1)</a></li><li><a href="/Archive/5/2014">May 2014 (2)</a></li><li><a href="/Archive/2/2014">February 2014 (1)</a></li><li><a href="/Archive/1/2014">January 2014 (1)</a></li><li><a href="/Archive/12/2013">December 2013 (1)</a></li><li><a href="/Archive/11/2013">November 2013 (1)</a></li><li><a href="/Archive/10/2013">October 2013 (1)</a></li><li><a href="/Archive/8/2013">August 2013 (3)</a></li><li><a href="/Archive/7/2013">July 2013 (3)</a></li><li><a href="/Archive/6/2013">June 2013 (1)</a></li><li><a href="/Archive/5/2013">May 2013 (2)</a></li><li><a href="/Archive/4/2013">April 2013 (1)</a></li><li><a href="/Archive/3/2013">March 2013 (8)</a></li><li><a href="/Archive/2/2013">February 2013 (2)</a></li><li><a href="/Archive/1/2013">January 2013 (2)</a></li><li><a href="/Archive/12/2012">December 2012 (3)</a></li><li><a href="/Archive/11/2012">November 2012 (4)</a></li><li><a href="/Archive/9/2012">September 2012 (1)</a></li><li><a href="/Archive/8/2012">August 2012 (1)</a></li><li><a href="/Archive/7/2012">July 2012 (3)</a></li><li><a href="/Archive/6/2012">June 2012 (3)</a></li><li><a href="/Archive/5/2012">May 2012 (2)</a></li><li><a href="/Archive/2/2012">February 2012 (3)</a></li><li><a href="/Archive/1/2012">January 2012 (4)</a></li><li><a href="/Archive/12/2011">December 2011 (7)</a></li><li><a href="/Archive/8/2011">August 2011 (2)</a></li><li><a href="/Archive/7/2011">July 2011 (1)</a></li><li><a href="/Archive/5/2011">May 2011 (1)</a></li><li><a href="/Archive/4/2011">April 2011 (2)</a></li><li><a href="/Archive/3/2011">March 2011 (3)</a></li></ul><div class="EveryTitle"><a href="/Archive/All">Every Post Title</a></div></div>
			</div>

		</div>
	</div>

	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
	<script type="text/javascript" src="/Scripts/jquery.autocomplete.min.js"></script>
	<script type="text/javascript" src="/Scripts/prettify.js"></script>
	<script type="text/javascript" src="/Scripts/Site.js"></script>
	<script type="text/javascript" src="/Scripts/IndexSearchGenerator.js"></script>
	<script type="text/javascript" src="/Scripts/SearchTermHighlighter.js"></script>
	<script type="text/javascript" src="/Scripts/SearchPage.js"></script>
	<script type="text/javascript" src="/Scripts/LZString.js"></script>

</body>
</html>
