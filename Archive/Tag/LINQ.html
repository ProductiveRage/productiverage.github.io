
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Productive Rage - LINQ</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#393939" />
	<link rel="stylesheet" type="text/css" media="all" href="/Content/Styles.css" />
	<!--[if lt IE 9]>
	<link rel="stylesheet" type="text/css" href="/Content/IEBefore9.css" />
	<![endif]-->
	<link rel="stylesheet" type="text/css" media="print" href="/Content/PrintOverrides.css" />
	<meta name="robots" content="noindex, follow" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.productiverage.com/feed" />
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', "UA-32312857-1"]);
		_gaq.push(['_setSiteSpeedSampleRate', 100]);
		_gaq.push(['_trackPageview']);
		(function () {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>

<body>

	<div class="Header">
		<div class="HeaderContent">
			<h1>
				<a href="/">Productive Rage</a>
			</h1>
			<span class="Tagline">Dan's techie ramblings</span>
		</div>
	</div>

	<div class="WrapperOuter">
		<div class="Wrapper">

			<div class="Main HasSideBar">
				


		<script type="text/javascript">
					var disqus_shortname = "productiverage";
					function executeWhen(fncAction, fncConditional, intDelayBetweenRetries) {
						if (fncConditional()) { fncAction(); return; }
						setTimeout(function () { executeWhen(fncAction, fncConditional, intDelayBetweenRetries); }, intDelayBetweenRetries);
					}
					function whenjQueryIsAvailable(fncAction) {
					    executeWhen(
							fncAction,
							function () { return (typeof ($) !== "undefined") },
							10
						);
					}
					(function () {
					    whenjQueryIsAvailable(
							function () { $("div.Content p.Comments").show(); }
						);
					}());
		</script>

	<div class="Content ArchiveByTag">
		<h3 class="PostDate">14 October 2014</h3><h2><a id="Post77"></a><a href="/writing-runtime-compiled-linq-expressions">Writing run-time compiled LINQ Expressions</a></h2>

<p>In September, I was talking about <a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired "with" updates for immutable classes in C#</a> - in which I mentioned that</p>

<blockquote>
  <p>The <strong>UpdateWithSignature<t></t></strong> delegate itself is a compiled LINQ expression so, once the cost of generating it has been paid the first time that it's required, the calls to this delegate are very fast</p>
</blockquote>

<p>In the past, I've made use of LINQ expressions for writing code that is generated at runtime that will be executed many times and would benefit from being as fast as code written at compile time. I'm by no means an expert, but I've put it to use a few times and feel like I'm slowly getting the hang of it. What struck me, the first few times that I tried to find out <em>how</em> to do things, was how sparse the information seems to be out there. There's reference material from Microsoft - which is helpful if you basically have a good grasp on what you're doing and need to look up some minutiae of the implementation. You can find quite advanced articles, but these also tend to assume deep knowledge and jump right into the deep end. Then there's beginner-oriented overview articles - these can be excellent at giving an introduction into what LINQ expressions can mean and what they can be used for, but they don't tend to go beyond fairly simple examples and don't (I found) help you get into the frame of mind that you need to build up complex expressions.</p>

<p>I thought it might be helpful for an "intermediary level" article to exist that takes the basic concepts and walks through creating something useful with it.</p>

<p>Now, I should maybe preface this with an admission that in a subsequent post to the one I quoted above (see "<a href="/a-followup-to-implementing-f-sharp-inspired-with-updates-in-c-sharp">A follow-up to "Implementing F#-inspired 'with' updates in C#"</a>), I said that I probably wouldn't end up using this dynamic run-time-compiled code in real world projects - but it still seems like a good sized example of something real-world-<em>ish</em>. So I'm going to walk through recreating it. If you haven't read that post, no worries, I'm going to act like you haven't and explain everything as I go (and after you're finished, if you <em>haven't</em> read that post, you can go do so :)</p>

<h3>The (slightly-contrived) example</h3>

<p>Here's the setup, which corresponds roughly to what I was trying to do last month. I've got a class <strong>RoleDetails</strong> -</p>

<pre><code>public class RoleDetails
{
  public RoleDetails(string title, DateTime startDate, DateTime? endDateIfAny)
  {
    Title = title;
    StartDate = startDate;
    EndDateIfAny = endDateIfAny;
  }

  public string Title { get; private set; }
  public DateTime StartDate { get; private set; }
  public DateTime? EndDateIfAny { get; private set; }
}
</code></pre>

<p>I wanted to generate a method at runtime which I could pass the arguments "title", "startDate" and "endDateIfAny" to and have it return a new instance of the class, using those values to define the new instance. The equivalent of </p>

<pre><code>public static RoleDetails UpdateWith(
  RoleDetails source,
  Optional&lt;string&gt; title,
  Optional&lt;DateTime&gt; startDate,
  Optional&lt;DateTime?&gt; endDateIfAny)
{
  if (source == null)
    return new ArgumentNullException("source");

  if (!title.IndicatesChangeFromValue(source.Title)
  &amp;&amp; !startDate.IndicatesChangeFromValue(source.StartDate)
  &amp;&amp; !endDateIfAny.IndicatesChangeFromValue(source.EndDateIfAny))
    return this;

  return new RoleDetails(
    title.GetValue(source.Title),
    startDate.GetValue(source.StartDate),
    endDateIfAny.GetValue(source.EndDateIfAny)
  );
}
</code></pre>

<p>where the <strong>Optional</strong> type is a struct</p>

<pre><code>public struct Optional&lt;T&gt;
{
  private T _valueIfSet;
  private bool _valueHasBeenSet;

  public T GetValue(T valueIfNoneSet)
  {
    return _valueHasBeenSet ? _valueIfSet : valueIfNoneSet;
  }

  public bool IndicatesChangeFromValue(T value)
  {
    if (!_valueHasBeenSet)
      return false;

    if ((value == null) &amp;&amp; (_valueIfSet == null))
      return false;
    else if ((value == null) || (_valueIfSet == null))
      return true;

    return !value.Equals(_valueIfSet);
  }

  public static implicit operator Optional&lt;T&gt;(T value)
  {
    return new Optional&lt;T&gt;
    {
      _valueIfSet = value,
      _valueHasBeenSet = true
    };
  }
</code></pre>

<p>The structure we need to form is a "body expression" that performs the method's internals, and for this to be packaged up with method arguments into a compiled lambda expression.</p>

<p>Before going too wild, a simple example to illustrate this is a good start:</p>

<pre><code>private Func&lt;RoleDetails, string&gt; GetRoleTitleRetriever()
{
  var sourceParameter = Expression.Parameter(typeof(RoleDetails), "source");
  var titlePropertyRetriever = Expression.Property(
    sourceParameter,
    typeof(RoleDetails).GetProperty("Title")
  );
  return
    Expression.Lambda&lt;Func&lt;RoleDetails, string&gt;&gt;(
      titlePropertyRetriever,
      sourceParameter
    ).Compile();
}
</code></pre>

<p>The "titlePropertyRetriever" is an expression that will return the value of the "Title" property from a <strong>RoleDetails</strong> instance that is represented by an expression passed into it. In this case, that expression is the "sourceParameter" which will be combined with the "titlePropertyRetriever" (which, here, represents the entirety of the "body" expression) to create a lambda expression. The "sourceParameter" is the single argument for this particlar lambda.</p>

<p>A lamba expression can be used in conjuction with other expressions if you need to form a complicated construct. Here we have a very simple action and so we call the "Compile" method and return the result. The static method "Expression.Lambda" returns an <strong>Expression&lt;Func&lt;RoleDetails, string&gt;&gt;</strong>. Calling "Compile" on it returns a <strong>Func&lt;RoleDetails, string&gt;</strong>. This is a delegate that we can call directly in our code.</p>

<p>This code could be used thusly -</p>

<pre><code>var role1 = new RoleDetails("Head Honcho", DateTime.Now, null);
var role2 = new RoleDetails("Dogsbody", DateTime.Now, null);

var titleRetriever = GetRoleTitleRetriever();
var title1 = titleRetriever(role1); // This equals "Head Honcho"
var title2 = titleRetriever(role2); // This equals "Dogsbody"
</code></pre>

<p>While obviously very simplistic, this gives us some sense of the structure we want. Note that there is no explicit representation of "return" in there - the body expression is expected to return a value and the result of the last expression is taken as the return value.</p>

<p>What I'm trying to get towards, though, is something that produces a new instance of the same type - not just a property retrieved from it. So instead of a <strong>Func&lt;RoleDetails, string&gt;</strong>, we want a <strong>Func&lt;RoleDetails, RoleDetails&gt;</strong> which does some sort of work.</p>

<p>The next (small) step is to illustrate calling a constructor. The following will return a new instance of <strong>RoleDetails</strong> using all the same property values.</p>

<pre><code>private Func&lt;RoleDetails, RoleDetails&gt; GetCloner()
{
  var sourceParameter = Expression.Parameter(typeof(RoleDetails), "source");
  var constructor = typeof(RoleDetails).GetConstructor(new[] {
    typeof(string),
    typeof(DateTime),
    typeof(DateTime?)
  });
  return
    Expression.Lambda&lt;Func&lt;RoleDetails, RoleDetails&gt;&gt;(
      Expression.New(
        constructor,
        Expression.Property(
          sourceParameter,
          typeof(RoleDetails).GetProperty("Title")
        ),
        Expression.Property(
          sourceParameter,
          typeof(RoleDetails).GetProperty("StartDate")
        ),
        Expression.Property(
          sourceParameter,
          typeof(RoleDetails).GetProperty("EndDateIfAny")
        )
      ),
      sourceParameter
    ).Compile();
}
</code></pre>

<p>Reflection is used to get a reference to the constructor that takes arguments with types <strong>string</strong>, <strong>DateTime</strong> and <strong>DateTime?</strong>. The body expression consists of the result of "Expression.New", which takes a constructor and expressions for the values and returns an expression for the new instance.</p>

<p>I'm not going to go into too much detail about using reflection to look up constructors, properties, methods, etc.. since it's easy to good find resources that cover this topic at all levels. In my original post, I was talking about code that would analyse the target type and match the best constructor to available properties (for cases where there might be multiple constructors) - here, I'm going to leave all that out and "hard code" the mappings. It shouldn't be a big deal to take what I'm (hopefully!) going to explain here and then complicate it by bolting on some reflection-based type analysis.</p>

<p>It's worth noting here, that the code above has hard-coded strings for property names and relies upon a particular constructor signature being available. As soon as you introduce reflection like this, you give up much of what the compiler can offer you and if the target types get refactored in a manner that changes the facts relied on then you won't find out until runtime that you've got a problem. But that's the cost of runtime craziness like this. I think it's a fair assumption going in that you're well aware of all this! Often this sort of code gymnastics is not appropriate, but other times runtime convenience <em>is</em> very useful - I tend to use <a href="https://github.com/AutoMapper/AutoMapper">AutoMapper</a> as the canonical example since people seem to find it very easy to grasp the pros and cons of it but it's an prime example of something that you mightn't find issues with until runtime (as opposed to less "dynamic" code that issues can be identified with at compile time, through static analysis in the IDE).</p>

<p>The next step in our example code is the introduction of additional arguments. To stick to baby steps, all we'll do is define a delegate the takes a source reference and returns a new instance by overriding a single property - specifically the "Title":</p>

<pre><code>private Func&lt;RoleDetails, string, RoleDetails&gt; GetTitleUpdater()
{
  var sourceParameter = Expression.Parameter(typeof(RoleDetails), "source");
  var titleParameter = Expression.Parameter(typeof(string), "title");
  var constructor = typeof(RoleDetails).GetConstructor(new[] {
    typeof(string),
    typeof(DateTime),
    typeof(DateTime?)
  });
  return
    Expression.Lambda&lt;Func&lt;RoleDetails, string, RoleDetails&gt;&gt;(
      Expression.New(
        constructor,
        titleParameter,
        Expression.Property(
          sourceParameter,
          typeof(RoleDetails).GetProperty("StartDate")
        ),
        Expression.Property(
          sourceParameter,
          typeof(RoleDetails).GetProperty("EndDateIfAny")
        )
      ),
      sourceParameter,
      titleParameter
    ).Compile();
}
</code></pre>

<p>Here, it's clear how to affect the <strong>Func</strong> signature - by changing the type param for "Expression.Lambda" and by specifying the corresponding number of parameters. Instead of the body expression and a single argument, we now specify <em>two</em> arguments. The types of the arguments in the <em>Func</em> are consistent with the types of the "sourceParameter" and "titleParameter". The third <em>Func</em> type param is also <strong>RoleDetails</strong> since that is what is returned by the <strong>RoleDetails</strong> constructor that "Expression.New" is using.</p>

<p>It's also clear how expressions can be interchanged - before the "Expression.New" call was taking a constructor reference and then expressions for the constructor arguments that all consisted of type <strong>MemberExpression</strong> (since this the return type of "Expression.Property"). Now we've switched the first <strong>MemberExpression</strong> out for a <strong>ParameterExpression</strong>. "Expression.New" doesn't care if the constructor argument expressions are property retrievals, method arguments, constant values - they can be anything, so long as they can be described by a type of <strong>Expression</strong>.</p>

<h3>Introducing Optional arguments</h3>

<p>Let's address two issue now. Firstly, there should be three arguments passed in - for each of the three constructor arguments - instead of one. And these arguments should be of type <strong>Optional&lt;T&gt;</strong>, so that they can effectively have "no value" and default to the value they have on the "source" reference.</p>

<pre><code>private delegate RoleDetails RoleDetailsUpdater(
  RoleDetails source,
  Optional&lt;string&gt; title,
  Optional&lt;DateTime&gt; startDate,
  Optional&lt;DateTime?&gt; endDateIfAny
);

private RoleDetailsUpdater GetSimpleUpdater()
{
  var sourceParameter = Expression.Parameter(typeof(RoleDetails), "source");
  var titleParameter = Expression.Parameter(typeof(Optional&lt;string&gt;), "title");
  var startDateParameter = Expression.Parameter(typeof(Optional&lt;DateTime&gt;), "startDate");
  var endDateIfAnyParameter = Expression.Parameter(typeof(Optional&lt;DateTime?&gt;), "endDateIfAny");
    var constructor = typeof(RoleDetails).GetConstructor(new[] {
      typeof(string),
      typeof(DateTime),
      typeof(DateTime?)
    });
    return
      Expression.Lambda&lt;RoleDetailsUpdater&gt;(
        Expression.New(
          constructor,
          Expression.Call(
            titleParameter,
            typeof(Optional&lt;string&gt;).GetMethod("GetValue"),
            Expression.Property(sourceParameter, "Title")
          ),
          Expression.Call(
            startDateParameter,
            typeof(Optional&lt;DateTime&gt;).GetMethod("GetValue"),
            Expression.Property(sourceParameter, "StartDate")
          ),
          Expression.Call(
            endDateIfAnyParameter,
            typeof(Optional&lt;DateTime?&gt;).GetMethod("GetValue"),
            Expression.Property(sourceParameter, "EndDateIfAny")
          )
        ),
        sourceParameter,
        titleParameter,
        startDateParameter,
        endDateIfAnyParameter
      ).Compile();
}
</code></pre>

<p>Now we're using the return values of "GetValue" method calls for all of the constructor arguments. Each method call is taking a property value extracted from the "source" reference as an argument (since "GetValue" takes a single argument - as per the definition of <strong>Optional</strong> earlier). I've also snuck in another change. I found that it was getting unwieldy specifying a <strong>Func</strong> with five arguments (<strong>RoleDetails</strong>, <strong>string</strong>, <strong>DateTime</strong> and <strong>DateTime?</strong> as inputs and another <strong>RoleDetails</strong> as the output) and so defined a delegate to instead. This delegate can be used with "Expression.Lambda" just as well as any <strong>Func</strong> can.</p>

<p>There are two concepts missing still, though, that are key to the original intention. We need to throw an exception if the "source" reference is null. And we need to return the source reference straight back out if none of the arguments represent a change; if the "title", "startDate" and "endDateIfAny" values all match those on the source reference then we may as well return that source reference straight back, rather than creating a new instance that we don't need - this only makes sense because <strong>RoleDetails</strong> is an immutable type (but since it is, it <em>does</em> make sense).</p>

<p>To deal with branching, there is a method "Expression.IfThenElse" which takes an expression for the condition (this expression must represent a boolean-returning operation) and then expressions for if-true and if-false. There is something to be aware of here, though - in C# (and in LINQ expressions) an "If" (or "If..Else") statement is not an "expression" where "expression" means "something that returns a value". It branches execution but, unlike with the property accessor or methods calls we've seen so far, it doesn't return a value. To make it work as required here, at the end of each branch we need to return via a "label" that marks the end of the block and has a type corresponding to the block's return type.</p>

<p>A label indicates an exit point in a block. If the block has a return type, then the label must have a compatible return value (if the block's return type is void then the label needn't specify a return value since the block will not be returning any value). The label's return value may be null, but if a type other than <strong>System.Object</strong> is being returned then that null constant must be described with the actual return type.</p>

<p>Once this label is defined, "Expression.Return" can be used to terminate the branches on an if-then-else construct. This is all illustrated in the next example.</p>

<p>The source-argument-null-check is easier; we'll combine "Expression.IfThen" (rather than "IfThenElse") with "Expression.Throw". There is no return label nonsense to worry about since, once an exception has been thrown, there's no return value involved! "Expression.Throw" takes a single argument, which is the exception that it should throw.</p>

<pre><code>private RoleDetailsUpdater GetUpdater()
{
  // These are the parameters for the RoleDetailsUpdater delegate that will be generated
  var sourceParameter = Expression.Parameter(typeof(RoleDetails), "source");
  var titleParameter = Expression.Parameter(typeof(Optional&lt;string&gt;), "title");
  var startDateParameter = Expression.Parameter(typeof(Optional&lt;DateTime&gt;), "startDate");
  var endDateIfAnyParameter = Expression.Parameter(
    typeof(Optional&lt;DateTime?&gt;),
    "endDateIfAny"
  );

  // When evaluated, these expressions will extract the property values from the "source" reference
  var sourceTitleRetriever = Expression.Property(
    sourceParameter,
    typeof(RoleDetails).GetProperty("Title")
  );
  var sourceStartDateRetriever = Expression.Property(
    sourceParameter,
    typeof(RoleDetails).GetProperty("StartDate")
  );
  var sourceEndDateIfAnyRetriever = Expression.Property(
    sourceParameter,
    typeof(RoleDetails).GetProperty("EndDateIfAny")
  );

  // When evaluated, these will determine whether any of the argument values differ from the
  // property values on the "source" reference
  var isTitleValueNew = Expression.Call(
    titleParameter,
    typeof(Optional&lt;string&gt;).GetMethod("IndicatesChangeFromValue"),
    sourceTitleRetriever
  );
  var isStartDateValueNew = Expression.Call(
    startDateParameter,
    typeof(Optional&lt;DateTime&gt;).GetMethod("IndicatesChangeFromValue"),
    sourceStartDateRetriever
  );
  var isEndDateIfAnyValueNew = Expression.Call(
    endDateIfAnyParameter,
    typeof(Optional&lt;DateTime?&gt;).GetMethod("IndicatesChangeFromValue"),
    sourceEndDateIfAnyRetriever
  );
  var areAnyValuesNew = Expression.OrElse(
    isTitleValueNew,
    Expression.OrElse(isStartDateValueNew, isEndDateIfAnyValueNew)
  );

  // This is the where the real work takes place: If "source" is null then throw an exception.
  // If any of the arguments require that a new instance being created, then construct that
  // instance with the new data and return it. Otherwise just return the source reference.
  var returnTarget = Expression.Label(typeof(RoleDetails));
  return
    Expression.Lambda&lt;RoleDetailsUpdater&gt;(
      Expression.Block(
        Expression.IfThen(
          Expression.Equal(sourceParameter, Expression.Constant(null)),
          Expression.Throw(Expression.Constant(new ArgumentNullException("source")))
        ),
        Expression.IfThenElse(
          areAnyValuesNew,
          Expression.Return(
            returnTarget,
            Expression.New(
              typeof(RoleDetails).GetConstructor(new[] {
                typeof(string),
                typeof(DateTime),
                typeof(DateTime?)
              },
              Expression.Call(
                titleParameter,
                typeof(Optional&lt;string&gt;).GetMethod("GetValue"),
                sourceTitleRetriever
              ),
              Expression.Call(
                startDateParameter,
                typeof(Optional&lt;DateTime&gt;).GetMethod("GetValue"),
                sourceStartDateRetriever
              ),
              Expression.Call(
                endDateIfAnyParameter,
                typeof(Optional&lt;DateTime?&gt;).GetMethod("GetValue"),
                sourceEndDateIfAnyRetriever
              )
            )
          ),
          Expression.Return(
            returnTarget,
            sourceParameter
          )
        ),
        Expression.Label(returnTarget, Expression.Constant(null, typeof(RoleDetails)))
      ),
      sourceParameter,
      titleParameter,
      startDateParameter,
      endDateIfAnyParameter
    ).Compile();
}
</code></pre>

<p>Note the use of "Expression.OrElse" above. We use this since we're dealing with boolean logic (eg. is the start-date-value new <em>or</em> is the end-date-value new). There is an "Expression.Or" method, but that is for numeric operations (eg. 1 &amp; 4).</p>

<h3>Winning!</h3>

<p>At this point, we've achieved what I laid out as the original intention.</p>

<p>I'm not going to pretend that it's particularly beautiful or succinct - especially compared to the code that you would write by hand. But then, if you had a scenario where you <em>could</em> write this by hand then you probably <em>would</em>, rather than having to resort to writing code that generates more code! And when I think about how LINQ expressions compare to the "old school" alternative of directly generating IL then it's a <em>lot</em> more read-and-write-able. Perhaps "maintainable" is a better word for it :)</p>

<p>IL generation, unfortunately, still has its place - it's been a while since I looked into this, but I <em>think</em> that if you wanted to generate an entire class, rather than a delegate, then you have to resort to emitting IL.</p>

<h3>Debugging</h3>

<p>Debugging compiled expressions can be a mixed bag. If you make mistakes that compile but cause errors at runtime then you <em>may</em> get a helpful error or you may get something fairly cryptic.</p>

<p>The safest approach, I've found, is to construct the code in the smallest functional units you can and to then test it with code that exercises every path in the generated expression. In the example above, this was done by starting with code that simply extracted a single property value from the source argument. Then multiple property values were extracted and passed into a constructor method. Then the delegate signature was changed to take multiple arguments and to use these with the constructor. Then these arguments were changed to the use <strong>Optional</strong> type and use its "GetValue" method to fall back to the source properties if required. Finally a guard clause was added for a null source reference and a condition added to return the source reference straight back if none of the arguments indicate that a new instance is required. If any of these steps introduced a new error, it should have been relatively easy to work out what went wrong.</p>

<p>To illustrate, if you were adding the code that will "exit early" if no new instance is required, and you forgot to specify a type for the null constant - ie. instead of</p>

<pre><code>Expression.Label(returnTarget, Expression.Constant(null, typeof(RoleDetails)))
</code></pre>

<p>you wrote</p>

<pre><code>Expression.Label(returnTarget, Expression.Constant(null))
</code></pre>

<p>then you would get an error (if you called the code with arguments that executed the no-new-instance-required code path):</p>

<blockquote>
  <p>Expression of type 'System.Object' cannot be used for label of type 'Tester.RoleDetails'</p>
</blockquote>

<p>I would say that this could be considered half way between helpful and cryptic.. if you realise what it means then it's perfectly sensible, but if you can't see what it's referring to (and it's not like you will get the line number of the incorrect <strong>Expression</strong> call to help you - you'll just get an exception when "Expression.Block" is executed) then it can appear somewhat incomprehensible.</p>

<p>As I said before, an expression block must have a consistent return type, and the block in the code above should return a <strong>RoleDetails</strong> instance - but "Expression.Constant(null)" defaults to type <strong>System.Object</strong> since it is not instructed otherwise. If the code is built and tested step-by-step, then it should be fairly simple to trace the error back to its source.</p>

<p>Another approach for examining the behaviour of expressions is to look at the "Body" property of the lambda expression. This must be done on the return value of "Expression.Lambda", before "Compile" is called. It also requires that the expression be valid. So this will not apply to the above example, where the label is of an incorrect type, since that will result in an exception being thrown when "Expression.Block" is called (since that method does work to ensure that the content described obeys its rules for consistency).</p>

<p>It may be useful, though, in a case where you have an expression that is valid but that does not behave as you expect. If you take the code above and tweaked it a bit by changing</p>

<pre><code>return
  Expression.Lambda&lt;RoleDetailsUpdater&gt;(
    // .. the rest of the expression generation code still goes here
  ).Compile();
</code></pre>

<p>into</p>

<pre><code>var lambda = Expression.Lambda&lt;RoleDetailsUpdater&gt;(
  // .. the rest of the expression generation code still goes here
);
return lambda.Compile();
</code></pre>

<p>then you could insert a break point before the return statement and look at the "Body" property of the "lambda" reference. It would have the following value:</p>

<pre><code>.Block() {
  .If ($source == null) {
    .Throw .Constant&lt;System.ArgumentNullException&gt;(
      System.ArgumentNullException: Value cannot be null.Parameter name: source
    )
  } .Else {
    .Default(System.Void)
  };
  .If (
    .Call $title.IndicatesChangeFromValue($source.Title)
      || .Call $startDate.IndicatesChangeFromValue($source.StartDate)
      || .Call $endDateIfAny.IndicatesChangeFromValue($source.EndDateIfAny)
  ) {
    .Return #Label1 { .New Tester.RoleDetails(
    .Call $title.GetValue($source.Title),
    .Call $startDate.GetValue($source.StartDate),
    .Call $endDateIfAny.GetValue($source.EndDateIfAny)) }
  } .Else {
    .Return #Label1 { $source }
  };
  .Label
    null
  .LabelTarget #Label1:
}
</code></pre>

<p>This isn't exactly C# but it <em>does</em> illustrate the code paths in a way that is fairly comprehensible and may highlight any logic errors you've made.</p>

<h3>Performing other manipulations</h3>

<p>At this point, I'd say we've covered a lot of the basic and - hopefully - you're set up to break into the reference material (such as the MSDN docs). Most of the static "Expression" methods are sensibly named and so usually fairly easy to find information for with a little searching (or just relying on intellisense).</p>

<p>If, for example, you had an <strong>Expression</strong> whose type was an array and you wanted an element from that array, you would use "Expression.ArrayAccess" (whose first parameter is the target <strong>Expression</strong> and the next is a set of index expression - the number of required index expressions will depend upon the number of dimensions the array has).</p>

<p>Something I particularly remember finding difficult to track an example for was code where you needed local variables within a block. There are examples for accessing arguments and setting lambda return values and altering the values of the arguments, but setting a local variable within a block scope.. not as easy to find.</p>

<p>I may well have been having a bad day when I was struggling with it - once you see how it's implemented, it looks easy! But I thought I'd use it as an excuse for another example. Because I'm still not an expert in writing this sort of code, I prepared this example in Visual Studio in the manner in which I explained above; bit-by-bit, starting with an implementation that returned a constant, then one that returned the hash code of a single property, then extended it to cover all of the variables and then deal with the special cases like a null "source" reference and then ValueType properties and then static properties.</p>

<p>The example I had in mind was a way to generate a method that would calculate a hash code for a given type. As it stands, in isolation, it's not quite a real-world requirement - but hopefully you can conceive of how something not completely dissimilar <em>could</em> be useful. Plus it's a nice size in that it's not quite trivial but not enormous - and it reiterates some of the same techniques seen above.</p>

<p>So.. if this was to be written using just reflection, it could be something like this:</p>

<pre><code>public Func&lt;T, int&gt; GetHashCodeGenerator&lt;T&gt;()
{
  // ToArray is called against these properties since the set is going to be enumerated every time
  // the returned hash code generator is executed - so it makes sense to do the work to retrieve
  // this data only once and then stash it away
  var properties = typeof(T).GetProperties()
    .Where(p =&gt; p.CanRead)
    .OrderBy(p =&gt; p.Name)
    .ToArray();
  var firstIndexedProperty = properties.FirstOrDefault(p =&gt; p.GetIndexParameters().Any());
  if (firstIndexedProperty != null)
  {
    throw new ArgumentException(string.Format(
      "Indexed property encountered, this is not supported: {0}",
      firstIndexedProperty.Name
    ));
  }

  return source =&gt;
  {
    if (source == null)
      throw new ArgumentNullException("source");

    var hashCode = 0;
    foreach (var property in properties)
    {
      // Even if it's a static property, there is no problem executing property.GetValue(source),
      // it will return the same value for any instance, but it won't throw an exception
      var propertyValue = property.GetValue(source);
      var propertyValueHashCode = (propertyValue == null) ? 0 : propertyValue.GetHashCode();
      hashCode = 3 * (hashCode ^ propertyValueHashCode);
    }
    return hashCode;
  };
}
</code></pre>

<p>This is called (using our faithful <strong>RoleDetails</strong> example class) in the manner:</p>

<pre><code>// Retrieve a delegate that takes a RoleDetails instance and returns a hash code
var roleDetailsHashCodeGenerator = GetHashCodeGenerator&lt;RoleDetails&gt;();

// Use this delegate to generate some hash codes
var role1HashCode = roleDetailsHashCodeGenerator(role1);
var role2HashCode = roleDetailsHashCodeGenerator(role2);
</code></pre>

<p>Note: If you look carefully you'll see something odd - when I call "GetProperties" I use "OrderBy" on the results. This is because I included the code above (which relies on reflection for every call) and the code that I'll get to below (which uses reflection to generate a compiled expression to perform the same work) in the same test program and wanted them to return the same hash code for any given reference. Which doesn't seems unreasonable. But the algorithm requires that the properties be reported in a consistent order if the two implementations of that algorithm are to return matching hash codes. However, the MSDN article for "<a href="http://msdn.microsoft.com/en-us/library/aky14axb(v=vs.110).aspx">Type.GetProperties</a>" states that</p>

<blockquote>
  <p>Your code must not depend on the order in which properties are returned, because that order varies.</p>
</blockquote>

<p>So if I was just writing a single version of this method then I probably wouldn't bother with the OrderBy call, but since I wanted to write a LINQ-expressions-based version <em>and</em> a non-expressions-based version <em>and I wanted the two versions to return identical results</em> then I <em>do</em> need to be explicit about the property ordering.</p>

<h3>Returning to the matter in hand</h3>

<p>If you're happy with everything covered so far, then the code coming up won't pose any problem.</p>

<p>There are some new <strong>Expression</strong> methods calls - "Expression.MultiplyAssign" corresponds to the C# statement "x *= y" or "x = x * y" and "Expression.ExclusiveOrAssign" corresponds to "x ^= y" or "x = x ^ y" (the XOR operation).</p>

<p>It's worth being aware that LINQ expressions <em>can</em> be used to define looping constructs - such as a for, foreach or do-while loop - using "Expression.Loop" but you'll have to implement some of the logic of yourself. For a "for" loop, for example, you'll need to declare a local variable that is altered each iteration and then checked against a particular condition each time to determine whether the loop should be exited. For a "foreach" loop, you'll need to call the "GetEnumerator" method on the loop target and use the methods on that to proceed through or exit the loop.</p>

<p>Here, though, I don't need any loops within the expressions. Since I know what properties must be considered when generating the expressions, I'm uneffectively unrolling the loop to generate a set of statements that retrieve a hash code for each property value and then combine them with an accumulator to come up with the final value.</p>

<pre><code>public Func&lt;T, int&gt; GetCompiledHashCodeGenerator&lt;T&gt;()
{
  var properties = typeof(T).GetProperties().Where(p =&gt; p.CanRead).OrderBy(p =&gt; p.Name);
  var firstIndexedProperty = properties.FirstOrDefault(p =&gt; p.GetIndexParameters().Any());
  if (firstIndexedProperty != null)
  {
    throw new ArgumentException(string.Format(
      "Indexed property encountered, this is not supported: {0}",
      firstIndexedProperty.Name
    ));
  }

  var sourceParameter = Expression.Parameter(typeof(T), "source");
  var accumulatorVariable = Expression.Variable(typeof(int), "accumulator");

  var blockExpressions = new List&lt;Expression&gt;();

  // Check for a null "source" reference (can be skipped entirely if T is a ValueType)
  if (!typeof(T).IsValueType)
  {
    blockExpressions.Add(
      Expression.IfThen(
        Expression.Equal(sourceParameter, Expression.Constant(null)),
        Expression.Throw(Expression.Constant(new ArgumentNullException("source")))
      )
    );
  }

  // Calculate a combined hash by starting with zero and then enumerating the properties -
  // performing an XOR between the accumulator and the current property value and then
  // multiplying before continuing
  blockExpressions.Add(
    Expression.Assign(accumulatorVariable, Expression.Constant(0))
  );
  var getHashCodeMethod = typeof(object).GetMethod("GetHashCode");
  foreach (var property in properties)
  {
    // Static properties must specify a null target, otherwise there will be an exception
    // thrown at runtime: "Static property requires null instance, non-static property
    // requires non-null instance."
    var isStaticProperty = property.GetGetMethod().IsStatic;
    var propertyValue = Expression.Property(isStaticProperty ? null : sourceParameter, property);
    if (property.PropertyType.IsValueType)
    {
      // If the property is a ValueType then we don't have to worry about calling GetHashCode
      // on a null reference..
      blockExpressions.Add(
        Expression.ExclusiveOrAssign(
          accumulatorVariable,
          Expression.Call(propertyValue, getHashCodeMethod)
        )
      );
    }
    else
    {
      // .. otherwise we need to check for null and default to a zero hash code if this is the
      // case (I picked zero since it's what Nullable&lt;T&gt; returns from its GetHashCode method
      // if that Nullable&lt;T&gt; is wrapping a null value).
      //
      // Proof-reading update: I've just realised that an XOR-assign operation with zero is
      // equivalent to no-operation and so we could do nothing if the property value is null.
      // But by this point, I've already completed the first draft of the post and done some
      // performance comparisons and I'm too lazy to do that all again! Maybe no-one will pick
      // up on the algorithm mistake and then also not read this comment. If you *are* reading
      // it.. well, hi! :)
      blockExpressions.Add(
        Expression.IfThenElse(
          Expression.Equal(propertyValue, Expression.Constant(null)),
          Expression.ExclusiveOrAssign(accumulatorVariable, Expression.Constant(0)),
          Expression.ExclusiveOrAssign(
            accumulatorVariable,
            Expression.Call(propertyValue, getHashCodeMethod)
          )
        )
      );
    }
    blockExpressions.Add(
      Expression.MultiplyAssign(accumulatorVariable, Expression.Constant(3))
    );
  }

  // The last expression in the block indicates the return value, so make it the
  // "accumulatorVariable" reference
  blockExpressions.Add(accumulatorVariable);

  // This Expression.Block method signature takes a set of local variable expressions (in this
  // case there's only one; the accumulatorVariable) followed by the expressions that form the
  // body of the block
  return 
    Expression.Lambda&lt;Func&lt;T, int&gt;&gt;(
      Expression.Block(
        new[] { accumulatorVariable },
        blockExpressions
      ),
      sourceParameter
    ).Compile();
}
</code></pre>

<p>I wrote this in the way I recommended earlier; in bite-size chunks. Maybe one day I'll be able to just sit down and reel out complex trees of expressions in one fell swoop and instinctively know where any errors I introduce originate.. actually, if I've got a fictional "one day" then I might as well fantasise that I won't make any mistakes that need tracking down in the first place - which will be even better! However, <em>today</em>, I need to break it down and confirm each step.</p>

<p>The first step was to take a source argument, call GetHashCode on it and return that directly - using the builtin "GetHashCode" method on <strong>System.Object</strong>, rather than implementing the logic myself. The next step was to loop through each property and generate expressions that would retrieve that property's value from the source reference and combine it with a local accumulator variable, returning this accumulator variable's final value at the end of the block. Then I added null checks to the property retrievals, defaulting to a hash code of zero to prevent trying to call GetHashCode on a null reference (zero is consistent with the hash code returned from <strong>Nullable&lt;T&gt;</strong> when it wraps a null value). Then I realised that this check could be skipped entirely if the property's PropertyType was a value-type, since that could never be null! The logic that dealt with static properties was added next. Finally, an if-null guard clause was added so that an <strong>ArgumentNullException</strong> would be raised if the source reference is null. Again, I realised that if the source type was a value-type then this was unnecessary - there's no need to check something for null if you know that it never can be null.</p>

<p>Each step was small enough that any problems could easily be traced to their source but each one contributed real functionality.</p>

<p>It was interesting that the expression-generating code lent itself to these "short cuts" in the final code (the don't-check-for-null-if-the-type-is-such-that-it-never-<em>can</em>-be-null short cuts). In the reflection version, we <em>could</em> write something like</p>

<pre><code>if (!typeof(T).IsValueType &amp;&amp; (source == null))
  throw new ArgumentNullException("source");
</code></pre>

<p>but there's no advantage to that over</p>

<pre><code>if (source == null)
  throw new ArgumentNullException("source");
</code></pre>

<p>In the LINQ expression version, the advantage is that if "T" is a value type then the hash code generation will not include the if-null clause at all!</p>

<p>This is a micro-optimisation, perhaps, especially when we're hoping for much greater saves overall due to avoiding reflection each time our version of GetHashCode is called. And, in a way, it probably <em>is</em> a micro-optimisation, but I would also argue that it's <em>correct</em> and it makes sense to do it <em>regardless</em> of any performance improvement, since it matches the object graph more closely and shows that you've thought about what you're actually doing.</p>

<p>Talking of performance.. the point of this article was to talk about <em>how</em> to write LINQ expressions, it wasn't about <em>when</em> they should be used. But since we now have two implementations of a generic GetHashCode method - one requiring reflection for each call and one using a compiled expression - surely it would be silly not to take it as anecdotal evidence of the potential performance improvements??</p>

<p>Here's the meat of a console app that should illustrate it. To be as accurate as possible, it needs to be built in release configuration and then run several times. Run at the command line (rather than through Visual Studio) to hook in as little debugging jiggery pokery as possible -</p>

<pre><code>var role1 = new RoleDetails("Penguin Cuddler", DateTime.Now, null);

var reflectionBasedHashCodeGenerator = GetHashCodeGenerator&lt;RoleDetails&gt;();
var compiledHashCodeGenerator = GetCompiledHashCodeGenerator&lt;RoleDetails&gt;();

var timerReflection = new Stopwatch();
var timerCompiled = new Stopwatch();
for (var outerLoop = 0; outerLoop &lt; 100; outerLoop++)
{
  timerReflection.Start();
  for (var innerLoop = 0; innerLoop &lt; 10000; innerLoop++)
    reflectionBasedHashCodeGenerator(role1);
  timerReflection.Stop();

  timerCompiled.Start();
  for (var innerLoop = 0; innerLoop &lt; 10000; innerLoop++)
    compiledHashCodeGenerator(role1);
  timerCompiled.Stop();
}
Console.WriteLine("Total Reflection: " + timerReflection.ElapsedMilliseconds + "ms");
Console.WriteLine("Total Compiled: " + timerCompiled.ElapsedMilliseconds + "ms");
Console.WriteLine(
  "Improvement: {0}x",
  ((double)timerReflection.ElapsedMilliseconds / timerCompiled.ElapsedMilliseconds).ToString("0.00")
);
</code></pre>

<p>I ran this three times and got an average 3000ms for the reflection-only approach and 186ms for the compiled-expression version. That's a 16.1x improvement - not bad!</p>

<p>Now, there <em>is</em> a cost to building and compiling these expressions. I would say that if you're not expecting to execute them hundreds of thousands of times, then what's the point of going through the pain of writing the expression-generating code - it would be <em>much</em> easier to just write the reflection-based version. And if you're running it (at least) hundreds of thousands of times, then the overhead of compiling the expressions will be negligible.</p>

<p>But maybe that rationalisation would be a cop-out.</p>

<p>So I changed the above code to consider the time taken to call GetHashCodeGenerator and GetCompiledHashCodeGenerator, such that it contributed to the timerReflection and timerCompiled totals.</p>

<p>With this change, the averages over three runs were now 3008ms and 204ms, giving an average performance multiplier of 14.8 times (where each run performed a million calls per implementation). Still a very respectable performance bump for somewhere that you know it will make a difference (again, why bother with all this hard work if you don't already know that it's worth it - or, rather, if a profiler hasn't <em>shown</em> you that it will be).</p>

<p>A couple of years ago, I wrote a library that basically aimed to be "like AutoMapper but supporting instantiate-by-constructor" (actually, I started it with the intention of it being an extension to AutoMapper to support instantiate-by-constructor - which it can still be used as - but then it took on a bit of a life of its own and became happy to stand on its own two feet). Earlier this year, I updated it to support optional constructor arguments and thought I'd look at how the performance of the library compared to AutoMapper. My library has less functionality than AutoMapper (though it does, of course, have the automated instantiate-by-constructor feature, which AutoMapper does not - the reason I wrote the library!) but by doing less and using compiled expressions for the entire translation, it tackled the example I was using (which was <em>not</em> chosen to try to game the system in any way, incidentally) 100x faster for each translation. Which just goes to show that if you avoid work you don't need to do (like the micro-optimisations above) and speed up the big slow bits (replacing repeated reflection with compiled expressions) you can get serious gains! You can read about it in <a href="/reflection-and-c-sharp-optional-constructor-arguments">Reflection and C# optional constructor arguments</a>.. just in case you want to pick holes in my reasoning :)</p><p class="PostTime">Posted at 23:07</p><div class="Related"><h3>You may also be interested in</h3><ul><li><a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired &quot;with&quot; updates for immutable classes in C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/LINQ" title="11 Posts">LINQ</a></li><li><a href="/Archive/Tag/Reflection" title="14 Posts">Reflection</a></li></ul></div>
			<p class="Comments">
				<a href="/writing-runtime-compiled-linq-expressions#disqus_thread" data-disqus-identifier="77">Comments</a>
			</p>
	</div>
	<div class="Content ArchiveByTag">
		<h3 class="PostDate">17 September 2014</h3><h2><a id="Post74"></a><a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired "with" updates for immutable classes in C#</a></h2>

<p>I've been prototyping a data service for a product at work that communicates with immutable types and one of the feedback comments was a question as to whether the classes supported a flexible F#-esque "with" method that would allow multiple properties to be changed without the garbage collection churn of creating intermediate references for each individual property (since, of course, the property values aren't actually changed on an instance, a <em>new</em> instance is generated that reflects the requested changes).</p>

<p>To pull an example straight from the excellent <a href="http://fsharpforfunandprofit.com/posts/records/">F# for fun and profit</a> site:</p>

<pre><code>let p1 = {first="Alice"; last="Jones"}
let p2 = {p1 with last="Smith"}
</code></pre>

<p>This creates a new record p2 that takes p1 and changes one of the fields. Multiple fields may be altered in one use "with" statement</p>

<pre><code>let p2 = {p1 with first="John";last="Smith"}
</code></pre>

<p>To start with a very simple example in C#, take the following class:</p>

<pre><code>public class RoleDetails
{
  public RoleDetails(string title, DateTime startDate, DateTime? endDateIfAny)
  {
    Title = title;
    StartDate = startDate;
    EndDateIfAny = endDateIfAny;
  }

  public string Title { get; private set; }
  public DateTime StartDate { get; private set; }
  public DateTime? EndDateIfAny { get; private set; }
}
</code></pre>

<p>This is a very close parallel to the F# record type since it just assigns read-only properties (they're not strictly read-only since they don't use the "readonly" keyword but they're not externally alterable and are only set once within the class so it's close enough).</p>

<p>If I was writing something like this for real use, I would probably try to make more guarantees.. or at least, document behaviour. Something like:</p>

<pre><code>public class RoleDetails
{
  public RoleDetails(string title, DateTime startDate, DateTime? endDateIfAny)
  {
    if (string.IsNullOrWhiteSpace(title))
      throw new ArgumentException("title");
    if ((endDateIfAny != null) &amp;&amp; (endDateIfAny &lt;= startDate))
      throw new ArgumentException("title");

    Title = title.Trim();
    StartDate = startDate;
    EndDateIfAny = endDateIfAny;
  }

  /// &lt;summary&gt;
  /// This will never be null or blank, it will not have any leading or trailing whitespace
  /// &lt;/summary&gt;
  public string Title { get; private set; }

  public DateTime StartDate { get; private set; }

  /// &lt;summary&gt;
  /// If non-null, this will greater than the StartDate
  /// &lt;/summary&gt;
  public DateTime? EndDateIfAny { get; private set; }
}
</code></pre>

<p>As I've said before, this validation and commenting is really a poor substitute for code contracts which would allow for compile time detection of invalid data rather than relying on runtime exceptions (speaking of which, I need to give the .net code contracts solution another go - last time I got stuck in I hit some problems which hopefully they've ironed out by now).</p>

<p>Another variation on the "aggressive validation" illustrated above would be a type that represents a non-blank string to prevent duplicating calls to <em>IsNullOrWhiteSpace</em> and <em>trim</em>. This concept could be taken even further to "strongly type" string values so that a "Title" can not be passed into a function that expects a "Notes" string value, for example. This is far from an original idea but it was something I was experimenting again with recently.</p>

<p>Incidentally, there is talk of a future version of C# getting a record type which would reduce boilerplate code when defining simple immutable types. For example (from the InfoQ article <a href="http://www.infoq.com/news/2014/08/Record-Class">Easier Immutable Objects in C# 6 and VB 12</a>) -</p>

<pre><code>public record class Cartesian(double x: X, double y: Y);
</code></pre>

<p>This will define an immutable class with two read-only properties that are set through a constructor call. This future C# specification is also apparently going to allow read-only auto properties - so in my RoleDetails class above instead of "get; private set;" properties, which are externally unalterable but could actually be changed within the instance, the properties could be truly readonly. This <em>is</em> possible currently but it requires a private readonly field and a property with a getter that returns that field's value, which is even <em>more</em> boring boilerplate.</p>

<h3>The obvious, verbose and potentially more GC-churny way</h3>

<p>To prevent callers from having to call the constructor every time a property needs to be altered, update methods for each "mutable" property may be added (they don't really mutate the values since a new instance is returned rather than the value changed on the current instance). This prevents the caller from having to repeat all of the constructor arguments that are <em>not</em> to be changed whenever one property needs altering. Forcing callers to call constructors in this way is particularly annoying if a constructor argument is added, removed or re-ordered at a later date; this can result in a lot of calling code that needs correcting.</p>

<pre><code>public class RoleDetails
{
  public RoleDetails(string title, DateTime startDate, DateTime? endDateIfAny)
  {
    Title = title;
    StartDate = startDate;
    EndDateIfAny = endDateIfAny;
  }

  public string Title { get; private set; }
  public DateTime StartDate { get; private set; }
  public DateTime? EndDateIfAny { get; private set; }

  public RoleDetails Update(string title)
  {
    return (title == Title)
      ? this
      : new RoleDetails(title, StartDate, EndDateIfAny);
  }
  public RoleDetails UpdateStartDate(DateTime startDate)
  {
    return (startDate == StartDate)
      ? this
      : new RoleDetails(Title, startDate, EndDateIfAny);
  }
  public RoleDetails UpdateEndDateIfAny(DateTime? endDateIfAny)
  {
    return (endDateIfAny == EndDateIfAny)
      ? this
      : new RoleDetails(Title, StartDate, endDateIfAny);
  }
}
</code></pre>

<p>To update two properties on a given instance, you would need to call</p>

<pre><code>var updatedRoleDetails = existingRoleDetails
  .UpdateStartDate(new DateTime(2014, 9, 21))
  .UpdateEndDateIfAny(new DateTime(2014, 11, 21));
</code></pre>

<p>If either of the new values is the same as the property value that it should be replacing, then no new instance is required for that property update - since the Update<em>{Whatever}</em> method will return back the same instance. But if both properties are changed then <em>two</em> new instances are required even though the first, intermediate value is immediately discarded and so is "wasted".</p>

<p>There could be an Update method that takes multiple parameters for the different properties but then you're basically just mirroing the constructor. Or there could be various Update methods that took combinations of properties to try to cover either the most common cases or <em>all</em> combinations of cases, but neither of these are particularly elegant and they would all result in quite a lot of code duplication.</p>

<h3>A better way</h3>

<p>It struck me that it should be possible to do something with named and optional method arguments (support for which was added to C# when .net 4 came out, if I remember correctly). Something like</p>

<pre><code>public RoleDetails UpdateWith(
  string title = Title,
  DateTime startDate = StartDate,
  DateTime? endDateIfAny = EndDateIfAny)
{
  if ((title == Title) &amp;&amp; (startDate == StartDate) &amp;&amp; (endDateIfAny == EndDateIfAny))
    return this;
  return new RoleDetails(title, startDate, endDateIfAny);
}
</code></pre>

<p>would allow for only a subset of the arguments to be specified and for those that are left unspecified to default to the current property value of the instance. So the earlier update code becomes</p>

<pre><code>var updatedRoleDetails = existingRoleDetails
  .UpdateWith(startDate: new DateTime(2014, 9, 21), endDateIfAny: new DateTime(2014, 11, 21));
</code></pre>

<p>However, this won't fly. The compiler gives the errors</p>

<blockquote>
  <p>Default parameter value for 'title' must be a compile-time constant</p>
  
  <p>Default parameter value for 'startDate' must be a compile-time constant</p>
  
  <p>Default parameter value for 'endDateIfAny' must be a compile-time constant</p>
</blockquote>

<p>That's a bummer.</p>

<p>Another thought that briefly crossed my mind was for the default argument values to all be null. This would work if the arguments were all reference types and would result in the method body looking something like</p>

<pre><code>if ((title == null) &amp;&amp; (startDate == null) &amp;&amp; (endDateIfAny == null))
  return this;
return new RoleDetails(title ?? Title, startDate ?? StartDate, endDateIfAny ?? EndDateIfAny);
</code></pre>

<p>But that is too restrictive a constraint since in this case we have a non-reference type argument (startDate) and we also have a reference type for which null is a valid value (endDateIfAny).</p>

<p>So what we really need is a wrapper type around the arguments that indicates when no value has been specified. Since we're being conscious of avoiding GC churn, this should be a struct since structs essentially avoid adding GC pressure since they are always copied when passed around - this means that no struct is referenced by multiple scopes and so they don't have to be traced in the same way as reference types; when the scope that has access to the struct is terminated, the struct can safely be forgotten as well. This is not a particularly precise description of what happens and more details can be found in the MSDN article <a href="http://msdn.microsoft.com/en-us/library/ms229017(v=vs.110).aspx">Choosing Between Class and Struct</a>. Particularly see the paragraph</p>

<blockquote>
  <p>The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated. Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</p>
</blockquote>

<p>The other guidelines in that article around cases where structs may be appropriate (if the type "logically represents a single value", "has an instance size under 16 bytes", "is immutable" and "will not have to be boxed frequently") are followed by this type:</p>

<pre><code>public struct Optional&lt;T&gt;
{
  private T _valueIfSet;
  private bool _valueHasBeenSet;

  public T GetValue(T valueIfNoneSet)
  {
    return _valueHasBeenSet ? _valueIfSet : valueIfNoneSet;
  }

  public bool IndicatesChangeFromValue(T value)
  {
    if (!_valueHasBeenSet)
      return false;

    if ((value == null) &amp;&amp; (_valueIfSet == null))
      return false;
    else if ((value == null) || (_valueIfSet == null))
      return true;

    return !value.Equals(_valueIfSet);
  }

  public static implicit operator Optional&lt;T&gt;(T value)
  {
    return new Optional&lt;T&gt;
    {
      _valueIfSet = value,
      _valueHasBeenSet = true
    };
  }
}
</code></pre>

<p>This type allows us to write an UpdateWith method</p>

<pre><code>public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  if (!title.IndicatesChangeFromValue(Title)
  &amp;&amp; !startDate.IndicatesChangeFromValue(StartDate)
  &amp;&amp; !endDateIfAny.IndicatesChangeFromValue(EndDateIfAny))
    return this;

  return new RoleDetails(
    title.GetValue(Title),
    startDate.GetValue(StartDate),
    endDateIfAny.GetValue(EndDateIfAny)
  );
}
</code></pre>

<p>The <strong>Optional</strong> type <em>could</em> have exposed properties for has-a-value-been-set and get-value-if-any but since each property comparison (to detemine whether a new instance is actually required) would have to follow the pattern if-value-has-been-set-and-if-value-that-has-been-set-does-not-equal-current-value, it made sense to me to hide the properties and to instead expose only the access methods "IndicatesChangeFromValue" and "GetValue". The "IndicatesChangeFromValue" method returns true if the <strong>Optional</strong> describes a value that is different to that passed in and "GetValue" returns the wrapped value if there is one, and returns the input argument if not. This enables the relatively succinct "UpdateWith" method format shown above.</p>

<p>The other method on the struct is an implicit operator for the wrapped type which makes the "UpdateWith" calling code simpler. Instead of having to do something like</p>

<pre><code>var updatedRoleDetails = existingRoleDetails
  .UpdateWith(startDate = Optional&lt;DateTime&gt;(new DateTime(2014, 9, 21)));
</code></pre>

<p>the implicit conversion allows you to write</p>

<pre><code>var updatedRoleDetails = existingRoleDetails
  .UpdateWith(startDate = new DateTime(2014, 9, 21));
</code></pre>

<p>because the <strong>DateTime</strong> will be implicitly converted into an <strong>Optional&lt;DateTime&gt;</strong>. In fact, I went one step further and made it such that this is the <em>only</em> way to create an <strong>Optional</strong> that wraps a value. There is no constructor that may be used to initialise an <strong>Optional</strong> <em>with</em> a value, you <em>must</em> rely upon the implicit conversion. This means that it's very clear that there's only one way to use this type. It also happens to be very similar to the most common way that the <strong>Nullable</strong> type is used in C# - although that does have a public constructor that accepts the value to wrap, in practice I've only ever seen values cast to <strong>Nullable</strong> (as opposed to the <strong>Nullable</strong> constructor being passed the value).</p>

<h3>Turning it up to eleven</h3>

<p>Now this is all well and good and I think it would be a solid leap forward simply to leave things as they are shown above. Unnecessary GC pressue is avoided since there are no "intermediary" instances when changing properties, while the use of structs means that we're not generating a load of property-update-value references that need to be collected either.</p>

<p>But I just couldn't resist trying to push it a bit further since there's <em>still</em> quite a lot of boring code that needs to be written for every immutable type - the UpdateWith method needs to check all of the properties to ensure that they haven't changed and then it needs to pass values into a constructor. If a class has quite a lot of properties (which is not especially unusual if the types are representing complex data) then this UpdateWith method could grow quite large. Wouldn't it be nice if we could just write something like:</p>

<pre><code>public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return magicUpdater(title, startDate, endDateIfAny);
}
</code></pre>

<p>Wouldn't it?? Yes it would.</p>

<p>And we can.. if we dip into some of the .net framework's crazier parts - reflection and stack tracing. With some LINQ expressions thrown in to make it work efficiently when called more than once or twice.</p>

<p>What this "magicUpdater" needs to do is take the names and values of the arguments passed to it and then analyse the target type (<strong>RoleDetails</strong> in this example) to find the constructor to call that will allow all of these named values to be passed into a new instance, using existing property values on the source instance for any constructor arguments that are not provided by the update arguments. It also needs to do the same work to determine whether the update arguments actually require a new instance to be generated - if only the StartDate is being provided to change but the new value is the same as the current value then no new instance is required, the source instance can be returned directly by the "magicUpdater".</p>

<p>This is handled by two steps. The first based around this line:</p>

<pre><code>var callingMethod = new StackFrame(1).GetMethod();
</code></pre>

<p>It returns a <strong>MethodBase</strong> with metadata about the method that called the "magicUpdater" (the "1" in the call above is how many steps back to go in the call stack). From this the names of the arguments can be extracted and a delegate returned which will take the argument values themselves. So the call would actually look more like (if this "magicUpdater" method return a delegate which then must itself be called):</p>

<pre><code>return magicUpdater()(title, startDate, endDateIfAny);
</code></pre>

<p>Before we move on to the second step, there are some important considerations in relation to the use of <strong>StackFrame</strong>. Firstly, there <em>is</em> some expense to performing analysis like this, as with using reflection - but we'll not worry about that here, some optimisations will be covered later which hopefully mean we can ignore it. What's more important is that analysing the call stack can seem somewhat.. unreliable, in a sense. In the real world, the code that gets executed is not always the code as it appears in the C# source. A release build will apply optimisations that won't be applied to debug builds <em>and</em> when code is manipulated by the JIT compiler more optimisations again may occur - one of the more well-known of which is "method inlining". Method inlining is when the compiler sees a chain of Method1 -> Method2 -> Method3 -> Method4 and observes that Method2 is so small that instead of being a distinct method call (which has a cost, as every method call does - the arguments have to be passed into a new scope and this must be considered by the garbage collector; as a very basic example of one of these costs) the code inside Method2 can be copied inside Method1. This would mean that if Method3 tried to access Method2's metadata through the <strong>StackFrame</strong> class, it would be unable to - it would be told it was called by Method1!</p>

<p>There's a short but informative article about this by Eric Gunnerson: <a href="http://blogs.msdn.com/b/ericgu/archive/2004/01/29/64717.aspx">More on inlining</a>. In a nutshell it says that -</p>

<ul>
<li>Methods that are greater than 32 bytes of IL will not be inlined.</li>
<li>Virtual functions are not inlined.</li>
<li>Methods that have complex flow control will not be in-lined. Complex flow control is any flow control other than if/then/else; in this case, switch or while.</li>
<li>Methods that contain exception-handling blocks are not inlined, though methods that throw exceptions are still candidates for inlining.</li>
<li>If any of the method's formal arguments are structs, the method will not be inlined.</li>
</ul>

<p>This means that we shouldn't have to worry about the UpdateWith method being inlined (since its arguments are all <strong>Optional</strong> which are structs), but the "magicUpdater" method <em>may</em> be a concern. The way that my library gets around that is that the method "GetGenerator" on the <strong>UpdateWithHelper</strong> class (it's not <em>really</em> called "magicUpdater" :) has the attribute</p>

<pre><code>[MethodImpl(MethodImplOptions.NoInlining)]
public UpdateWithSignature&lt;T&gt; GetGenerator&lt;T&gt;(int numberOfFramesFromCallSite = 1)
</code></pre>

<p>which tells the JIT compiler not to inline it and so, since the caller isn't inlined (because of the structs), we don't have to worry about stack "compressing".</p>

<p>This "GetGenerator" method, then, has access to the argument names and argument types of the method that called it. The generic type param T is the immutable type that is being targeted by the "UpdateWith" method. <strong>UpdateWithSignature&lt;T&gt;</strong> is a delegate with the signature</p>

<pre><code>public delegate T UpdateWithSignature&lt;T&gt;(T source, params object[] updateValues);
</code></pre>

<p>This delegate is what takes the property update values and creates a new instance (or returns the source instance if no changes are required). It does this by considering every public constructor that T has and determining what constructor arguments it can satisfy with update arguments. It does this by matching the update argument names to the constructor argument names and ensuring that the types are compatible. If a constructor is encountered with arguments that don't match any update arguments but T has a property whose name and type matches the constructor argument, then <em>that</em> will be used. If a constructor argument is encountered that can't be matched to an update argument <em>or</em> a property on T but the constructor argument has a default value, then the default value may be used if the constructor.</p>

<p>If a constructor does not have at least one argument that can be matched to each update argument name, then that constructor is ignored (otherwise an update argument would be ignored, which would make the UpdateWith somewhat impotent!). If there are multiple constructors that meet all of these conditions, they are sorted by the number of arguments they have that are fulfilled by update arguments and then sorted by the number of arguments that are satisfed by other properties on T - the best match from this sorted set it used.</p>

<p>The return <strong>UpdateWithSignature&lt;T&gt;</strong> delegate itself is a compiled LINQ expression so, once the cost of generating it has been paid the first time that it's required, the calls to this delegate are very fast. The "GetGenerator" method caches these compiled expressions, so the method</p>

<pre><code>public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return DefaultUpdateWithHelper.GetGenerator&lt;RoleDetails&gt;()(this, title, startDate);
}
</code></pre>

<p>can be called repeatedly and cheaply.</p>

<p>Note that in the above example, the <strong>DefaultUpdateWithHelper</strong> is used. This is a static wrapper around the <strong>UpdateWithHelper</strong> which specifies a default configuration. The <strong>UpdateWithHelper</strong> takes arguments that describe how to match update argument names to constructor argument names, for example (amongst other configuration options). The implementation in the <strong>DefaultUpdateWithHelper</strong> matches by name in a case-insensitive manner, which should cover the most common cases. But the relevant <strong>UpdateWithHelper</strong> constructor argument is of type</p>

<pre><code>public delegate bool UpdateArgumentToConstructorArgumentComparison(
  ParameterInfo updateArgument,
  ConstructorInfo constructor,
  ParameterInfo constructorArgument);
</code></pre>

<p>so a custom implementation could implement any complex scheme based upon target type or constructor or update argument type.</p>

<p>The <strong>UpdateWithHelper</strong> also requires a cache implementation for maintaining the compiled expressions, as well as matchers for other comparisons (such as property name to constructor argument name, for constructor arguments that can't be matched by an update argument). If a custom <strong>UpdateWithHelper</strong> is desired that only needs to override <em>some</em> behaviour, the <strong>DefaultUpdateWithHelper</strong> class has a static nested class <strong>DefaultValues</strong> with properties that are the references that it uses for the <strong>UpdateWithHelper</strong> constructor arguments - some of these may be reused by the custom configuration, if appropriate.</p>

<p>I considered going into some detail about how the LINQ expressions are generated since I think it's hard to find a good "how-to" walkthrough on these. It's either information that seems too simple or fine-grained that it's hard to put it together into something useful or it's the other extreme; dense code that's hard to get to grips with if you don't know much about them. But I feel that it would balloon this post too much - so maybe another day!</p>

<p>Incidentally, the <strong>DefaultUpdateWithHelper</strong>'s static "GetGenerator" method inserts another layer into the call stack, which is why the <strong>UpdateWithHelper</strong>'s method requires an (optional) "numberOfFramesFromCallSite" argument - so that it can be set to 2 in this case, rather than the default 1 (since it will need to step back through the <strong>DefaultUpdateWithHelper</strong> method before getting to the real "UpdateWith" method). This also means that <strong>DefaultUpdateWithHelper</strong> has the "MethodImplOptions.NoInlining" attribute on its "GetGenerator" method.</p>

<p>It's also worthy of note that the "GetGenerator" methods support extension methods for "UpdateWith" implementations, as opposed to requiring that they be instance methods. So the following is also acceptable</p>

<pre><code>public static RoleDetails UpdateWith(
  this RoleDetails source,
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return DefaultUpdateWithHelper.GetGenerator&lt;RoleDetails&gt;()(source, title, startDate);
}
</code></pre>

<p>The analysis detects that the first argument is not an <strong>OptionalType&lt;T&gt;</strong> and asserts that its type is assignable to the type param T and then ignores it when generating the translation expression. The extension method will pass through the "source" reference where "this" was used in the instance method implementation shown earlier.</p>

<h3>Further performance optimisations</h3>

<p>Although the compiled "generator" expressions are cached, the cache key is based upon the "UpdateWith" method's metadata. This means that the cost of accessing the <strong>StackFrame</strong> is paid for every "UpdateWith" call, along with the reflection access to get the UpdateWith argument's metadata. If you feel that this might be an unbearable toll, a simple alternative is something like</p>

<pre><code>private static UpdateWithSignature&lt;RoleDetails&gt; updater
  = DefaultUpdateWithHelper.GetGenerator&lt;RoleDetails&gt;(typeof(RoleDetails).GetMethod("UpdateWith"));
public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return updater(this, title, startDate);
}
</code></pre>

<p>The "GetGenerator" methods have alternate signatures that accept a <strong>MethodBase</strong> reference relating to the "UpdateWith" method, rather than relying upon <strong>StackFrame</strong> to retrieve it. And using a static "updater" reference means that "GetGenerator" is only ever called once, so subsequent calls that would require reflection in order to check for a cached expression are avoided entirely. The trade-off is that the method must be named in a string, which would break if the method was renamed. Not quite as convenient as relying upon stack-tracing magic.</p>

<p>If you really want to get crazy, you can go one step further. If part of the reason for this experiment was to reduce GC pressure, then surely the params array required by the <strong>UpdateWithSignature&lt;T&gt;</strong> is a step backwards from the less-automated method, where the number of update arguments is known at compile time? (Since that <em>didn't</em> require a params array for a variable number of arguments, there were no method calls where the precise number of update arguments was unknown). Well that params array can be avoided if we make some more trade-offs. Firstly, we may <em>only</em> use an approach like above, which doesn't rely on expression caching (ie. use a static property that requests a generator only once). Secondly, there may only be up to nine update arguments. The first reason is because the cache that the <strong>UpdateWithHelper</strong> uses records <strong>UpdateWithSignature&lt;T&gt;</strong> references, which are no good since they use the params array that we're trying to avoid. The second reason is because a distinct delegate is required for each number of arguments, as is a distinct method to construct the generator - so there had to be a limit somewhere and I chose nine. The methods are</p>

<pre><code>public UpdateWithSignature1&lt;T&gt; GetUncachedGenerator1&lt;T&gt;(MethodBase updateMethod)
public UpdateWithSignature2&lt;T&gt; GetUncachedGenerator2&lt;T&gt;(MethodBase updateMethod)
public UpdateWithSignature3&lt;T&gt; GetUncachedGenerator3&lt;T&gt;(MethodBase updateMethod)
// .. etc, up to 9
</code></pre>

<p>and the delegates are of the form</p>

<pre><code>public delegate T UpdateWithSignature1&lt;T&gt;(T source, object arg0);
public delegate T UpdateWithSignature2&lt;T&gt;(T source, object arg0, object arg1);
public delegate T UpdateWithSignature3&lt;T&gt;(T source, object arg0, object arg1, object arg2);
// .. etc, up to 9
</code></pre>

<p>They may be used in a similar manner to that already shown, but you must be careful to match the number of arguments required by the "UpdateWith" method. In a way, there is actually a compile-time advantage here - if you choose the wrong one, then the compiler will warn you that you have specified three update arguments when the delegate requires four (for example). With the generic form (the non-numbered "GetGenerator" method), the params array means that you can specify any number of update arguments and you won't find out until runtime that you specified the wrong amount.</p>

<p>So, to illustrate -</p>

<pre><code>private static UpdateWithSignature3&lt;RoleDetails&gt; updater
  = DefaultUpdateWithHelper.GetUncachedGenerator3&lt;RoleDetails&gt;(
    typeof(RoleDetails).GetMethod("UpdateWith"));

public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return updater(this, title, startDate, endDateIfAny);
}
</code></pre>

<p>If I'm being honest, however, if you <em>really</em> think that this optimisation is beneficial (by which, I mean you've done performance analysis and found it to be a bottleneck worth addressing), you're probably better replacing this automated approach with the hand-written code that I showed earlier. It's not all that long and it removes all of this "magic" and also gives the compiler more opportunity to pick up on mistakes. But most importantly (in terms of performance) may be the fact that all update arguments are passed as "object" in these delegates. This means that any value types (ints, structs, etc..) will be boxed when they are passed around and then unboxed when used as constructor arguments. This is explained very clearly in the article <a href="http://www.techgalaxy.net/Docs/Dev/5ways.htm">5 Basic Ways to Improve Performance in C#</a> and more information about the use of the heap and stack can be found at <a href="http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types">Six important .NET concepts: Stack, heap, value types, reference types, boxing, and unboxing</a> - I'd not seen this article before today but I thought it explained things really clearly.</p>

<p>Chances are that you won't have to worry about such low level details as whether values are being boxed-unboxed 99% of the time and I think there's a lot of mileage to be had from how convenient this automated approach is. But it's worth bearing in mind the "what ifs" of performance for the times when they <em>do</em> make a difference.</p>

<h3>Any other downsides to the automagical way?</h3>

<p>I can't claim to have this code in production anywhere yet. But I'm comfortable enough with it at this stage that I intend to start introducing it into prototype projects that it will be applicable to - and then look to using it in real-world, scary, production projects before too long! My only concern, really, is about making silly mistakes with typos in update argument names. If I mistyped "tittle" in the <strong>RoleDetails</strong> "UpdateWith" example I've been using, I wouldn't find out until runtime that I'd made the mistaken - at which point, the "GetGenerator" call would throw an exception as it wouldn't be able to match "tittle" to any argument on any accessible constructor. I think the trade-off here would be that every "UpdateWith" method that used this library would need a unit test so that discovering the problem at "runtime" doesn't mean "when I hit code in manual testing that triggers the exception" but rather equates to "whenever the test suite is run - whether locally or when pushed to the build server". I doubt that Update methods of this type would normally get a unit test since they're so basic (maybe you disagree!) but in this case the convenience of using the automated "GetGenerator" method still wins even with the (simple) unit test recommended for each one.</p>

<p>Now that I think about it, this is not a dissimilar situation to using a Dependency Injection framework or using AutoMapper in your code - there is a lot of convenience to be had, but at the risk that configuration errors are not exposed until the code is executed.</p>

<p>In summary, until I find a good reason <em>not</em> to use this library going forward, I intend to do so! To revisit my (F#) inspiration, how can it not be enticing to be able to write</p>

<pre><code>// F#
let p2 = {p1 with first="Jim";last="Smith"}

// C#
var p2 = p1.UpdateWith(first:"Jim",last:"Smith");
</code></pre>

<p>with so little code having to be written to enable it?!</p>

<p>Go get the code at <a href="https://bitbucket.org/DanRoberts/updatewith">bitbucket.org/DanRoberts/updatewith</a>!</p>

<p>Or alternatively, pull the NuGet package straight down from <a href="https://www.nuget.org/packages/CSharpImmutableUpdateWith/">nuget.org/packages/CSharpImmutableUpdateWith</a>.</p>

<p><strong>Update (19th September 2014):</strong> There's been quite a lot of interest in this post and some good comments made here and at the discussion on <a href="http://www.reddit.com/r/programming/comments/2gqx9u/implementing_finspired_with_updates_for_immutable/">Reddit/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp</a>. I intend to write a follow-up post that talks about some of the observations and includes some performance stats. In summary, though, I may have to admit to considering a slight about-turn in the crazy magical approach and strike that up as a convenience for rattling out code quickly but probably something that won't make it into production code that I write. The idea of using an "UpdateWith" method with named, optional arguments (using the <strong>Optional</strong> struct) <em>will</em> make it into my "real world" code, though! It's also strikingly similar to some of the code in Roslyn, it was pointed out (I'll touch on this in the follow-up too). I still had a lot of fun with the "Turning it up to eleven" investigation and I think there's useful information in here and in the library code I wrote - even more so when I get round to documenting how I approach writing the LINQ expression-generating code. But maybe it didn't result in something that should always be everyone's immediate go-to method for writing this sort of code. Such is life! :)</p>

<p><strong>Update (2nd October 2014):</strong> See <a href="/a-followup-to-implementing-f-sharp-inspired-with-updates-in-c-sharp">A follow-up to "Implementing F#-inspired 'with' updates in C#"</a>.</p><p class="PostTime">Posted at 23:12</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li><li><a href="/Archive/Tag/LINQ" title="11 Posts">LINQ</a></li><li><a href="/Archive/Tag/Reflection" title="14 Posts">Reflection</a></li></ul></div>
			<p class="Comments">
				<a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp#disqus_thread" data-disqus-identifier="74">Comments</a>
			</p>
	</div>
	<div class="Content ArchiveByTag">
		<h3 class="PostDate">27 February 2014</h3><h2><a id="Post68"></a><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></h2>

<p>Last month I was looking back into one of my old projects that was inspired by AutoMapper but for mapping to immutable types, rather than mapping to mutable types (that typically have a parameterless constructor and are initialised by setting individual properties)* - see <a href="/reflection-and-c-sharp-optional-constructor-arguments">Bonus provocative headline: Like AutoMapper, but 100x faster</a>.</p>

<p>When I was working on it, I had a fairly good idea of what scenarios I wanted to use it in and  had no intention of trying to replicate the entire range of functionality that AutoMapper supports. However,  something I <em>was</em> particularly taken with was the recently(ish) added support to AutoMapper for LINQ auto-projections.</p>

<p>* <em>Note from the future: There was a time when AutoMapper didn't have good support for mapping to immutable types, it wouldn't apply automatic its name / type matching logic to the case where property values are read from the source type and used to provide constructor arguments on the destination type (and it was to fill that feature gap that I started writing the <a href="https://bitbucket.org/DanRoberts/compilabletypeconverter">Compilable Type Converter</a>). However, that situation changed at some point and now AutoMapper does have good support for mapping to immutable types - though I wasn't able to track down from the release notes when precisely that was.</em></p>

<p>Projections are when data is retrieved from an <strong>IQueryable</strong> source and mapped onto either a named class or an anonymous type - eg.</p>

<pre><code>using (var context = new AlbumDataEntities())
{
  var albums = context.Albums.Select(album =&gt; new {
    Key = album.AlbumKey,
    Name = album.Name
  });
</code></pre>

<p>The clever thing about <strong>IQueryable</strong> and these projections is that the data source (Entity Framework, for example) can construct a query to retrieve only the data required. Without projections, the database querying and the mapping are completely separate steps and so it is very common for the ORM to have to retrieve much more data than is strictly necessary (and often to introduce the dreaded N+1 SELECT problem). Projections allows the mapping to directly affect how the database query is constructed so that precisely the right amount of data may be requested (and all in one query, <em>not</em> in N+1).</p>

<p>The code shown above could be referred to as a manual projection (where the the properties - "Key" and "Name" in that example - are explicitly mapped). <em>Auto-projection</em> is the utilisation of a mapping library to automatically create this projection / mapping. This means that you don't have to write the boring "Key = album.AlbumKey, Name = album.Name" code for each property in a mapping. In essence, something like:</p>

<pre><code>using (var context = new AlbumDataEntities())
{
  var albums = context.Albums.MapTo&lt;ImmutableAlbum&gt;();
</code></pre>

<p>When you've only got a couple of properties (like Key and Name in the earlier code), it's not too bad but it's still the sort of manual work that gets boring (and error prone) very quickly.</p>

<h3>IQueryable vs IEnumerable</h3>

<p>Allow me to briefly go off on a tangent..</p>

<p>The <strong>IEnumerable</strong> type in .net allows for lazy initialisation such that data is only processed as it is requested. For a really simple example, the following code starts off with a data "source" that will generate up to ten million objects, returned as an enumerable set. On this we call Take(5), which returns another enumerable set that will only enumerate the first five items. Until ToArray is called, none of the data is actually delivered and none of the objects are created. Even when ToArray <em>is</em> called, only five of the source objects are actually initialised as that is how many are actually required - the remaining 9,999,995 objects that <em>could</em> have been created are not since they are not required (this is lazy evaluation in action).</p>

<pre><code>var fiveItemsFromLargeEnumerableRange =
  Enumerable.Range(1, 10000000).Select(i =&gt; new { Name = "Item" + i })
    .Take(5)
    .ToArray();
</code></pre>

<p><strong>IEnumerable</strong> can be thought to operate on in-memory data sets. The data <em>itself</em> may not originate from an in-memory source. Above it does, but the source could also be something delivering lines from a log file or rows from a database. Each entry in the data, though, is fully loaded when required and then processed in memory. Although each entity is only loaded when required, if the loading of each entity is expensive and only a subset of its data is required for the operation at hand, then even this form of lazy evaluation can become a burden. <strong>IEnumerable</strong> sets do not inherently expose a way to "partially load" the entities.</p>

<p>It's worth noting at this point that many ORMs (including Entity Framework) support "lazy loading" of data for child properties to try to address this very point; the data for the properties of the returned objects is not loaded until the properties are accessed. At this point the database (or whatever data source is being used) is hit <em>again</em> to retrieve this information. The downside to this is that the data that <em>is</em> accessed may require multiple database hits for each entity when only a single query may have been required if "eagerly" loading all of the data for the entity. But if "eager loading" is used and only a subset of the data is required then <em>too much</em> data was being pulled down!</p>

<p><strong>IQueryable</strong> sets have similar intentions to <strong>IEnumerable</strong> but a different approach, they are more tightly tied to the data source. Where <strong>IEnumerable</strong> sets may be considered to be in-memory (for each entity), <strong>IQueryable</strong> sets are all prepared in the data source and filtering may be applied there to prevent too much data from being sent.</p>

<p>To illustrate with an example, say we have data about albums. There's an Albums table with AlbumKey, Name, Year and ArtistKey fields. There's a Tracks table with TrackKey, AlbumKey, TrackNumber and Name fields. And there's an Artists table with fields ArtistKey and Name.</p>

<p>If I point Entity Framework at this then it will generate a model to dip into all this data. The simplest retrieval is probably for all Album names -</p>

<pre><code>using (var context = new AlbumDataEntities())
{
  var allAlbumNames = context.Albums
    .Select(album =&gt; album.Name)
    .OrderBy(name =&gt; name);

  // Calling ToString on an Entity Framework IQueryable pointing at a SQL database
  // returns the SQL that will be executed to perform the query
  var allAlbumNamesQuery = allAlbumNames.ToString();
  var allAlbumNamesResults = allAlbumNames.ToArray();

  Console.WriteLine("Query:");
  Console.WriteLine(allAlbumNamesQuery);
  Console.WriteLine();

  Console.WriteLine("Results:");
  Console.WriteLine(string.Join(Environment.NewLine, allAlbumNamesResults));
}
</code></pre>

<p>This shows that the SQL executed was</p>

<pre><code>SELECT 
  [Extent1].[Name] AS [Name]
  FROM [dbo].[Albums] AS [Extent1]
  ORDER BY [Extent1].[Name] ASC
</code></pre>

<p>Which is pretty much what you would hope for.. but clever when you think about it. It's done some analysis of the request we've described and realised that it only needs to consider one particular column from that one table, even though it's all configured to potentially do so much more.</p>

<p>If instead we request </p>

<pre><code>var allCombinedAlbumAndTrackNames = context.Albums
  .SelectMany(album =&gt; album.Tracks.Select(track =&gt; new {
    AlbumName = album.Name,
    TrackName = track.Name,
    TrackNumber = track.TrackNumber
  }))
  .OrderBy(combinedEntry =&gt; combinedEntry.AlbumName)
  .ThenBy(combinedEntry =&gt; combinedEntry.TrackNumber)
  .Select(combinedEntry =&gt; combinedEntry.AlbumName + "/" + combinedEntry.TrackName);
</code></pre>

<p>then the following SQL is executed:</p>

<pre><code>SELECT 
  [Project1].[C1] AS [C1]
  FROM ( SELECT 
    [Extent1].[Name] + N'/' + [Extent2].[Name] AS [C1], 
    [Extent1].[Name] AS [Name], 
    [Extent2].[TrackNumber] AS [TrackNumber]
    FROM  [dbo].[Albums] AS [Extent1]
    INNER JOIN [dbo].[Tracks] AS [Extent2]
    ON [Extent1].[AlbumKey] = [Extent2].[AlbumKey]
  )  AS [Project1]
  ORDER BY [Project1].[Name] ASC, [Project1].[TrackNumber] ASC
</code></pre>

<p>This was not such a simple translation to make - this query got mapped into an interim anonymous type, there are multiple sorts and the final values are constructucted by concatenating two of the fields in the interim type. Nonetheless, the SQL that was generated was very efficient and a good reflection of the data that was requested.</p>

<p>One more, for fun..</p>

<pre><code>var namesOfTheFiveAlbumsWithTheGreatestNumberOfTracks = context.Albums
  .OrderByDescending(album =&gt; album.Tracks.Count())
  .Select(album =&gt; album.Name)
  .Take(5);
</code></pre>

<p>results in:</p>

<pre><code>SELECT TOP (5)
  [Project1].[Name] AS [Name]
  FROM ( SELECT 
    [Extent1].[Name] AS [Name], 
    (SELECT 
      COUNT(1) AS [A1]
      FROM [dbo].[Tracks] AS [Extent2]
      WHERE [Extent1].[AlbumKey] = [Extent2].[AlbumKey]) AS [C1]
    FROM [dbo].[Albums] AS [Extent1]
  )  AS [Project1]
  ORDER BY [Project1].[C1] DESC
</code></pre>

<p>This not only performed an aggregate operation (by considering the number of Tracks per Album) but also incorporated the "Take(5)" into the query. This is an example of how a request may be translated into something handled by the data source that ensures that it can deliver the bare minimum data; if the "Take(5)" call had not been translated into part of the query then more rows might have been returned than we cared about. (If the "Take(5)" call could not have been translated into part of the database query then the first five results could have been isolated by a similar "in-memory" operation to that illustrated by the 1,000,000 item <strong>IEnumerable</strong> example earlier, but it wouldn't be as efficient to do so since the additional rows would have had to have been delivered from the database and then filtered out.. which would have been wasteful).</p>

<p>These examples demonstrate some of the ways in which use of <strong>IQueryable</strong> can ensure that the minimum amount of data required is transmitted from the data source. None of them even touch the Artists table since none of the requests asked for Artist data! The <strong>IQueryable</strong> implementation is what performs this magic, whether that be provided by Entity Framework, NHibernate, SubSonic or whatever - <em>it</em> is responsible for translating expressions into SQL (or whatever language the backing data source uses; it could be another SQL-like database or it could be a document database such as <a href="http://www.mongodb.org/">MongoDB</a>).</p>

<h3>Applying this to mappings</h3>

<p>In the above examples, ToArray() was used to force the retrieval / evaluation of the information. This could just as easily have been a call to ToList() or been a loop that enumerated through the data.</p>

<p>With <strong>IEnumerable</strong> sets, the source data is not run through until it is explicitly enumerated. With <strong>IQueryable</strong>, the data is not retrieved from the source until the <strong>IQueryable</strong> reference is treated as an <strong>IEnumerable</strong>. This is possible since <strong>IQueryable</strong> implements <strong>IEnumerable</strong> and so any method that can operate on <strong>IEnumerable</strong> may also operate on <strong>IQueryable</strong>. But what's important here is that as soon as this is done, the <strong>IQueryable</strong> reference will then "become" an <strong>IEnumerable</strong> reference and the underlying data request will have been made in order for this to happen.</p>

<p>The clever thing above, where the "Take(5)" method resulted in "SELECT TOP (5)" becoming part of the SQL query, comes about as LINQ has a load of extension methods for operating against <strong>IQueryable</strong> as well <strong>IEnumerable</strong> - so as well as</p>

<pre><code>public static IEnumerable&lt;TSource&gt; Take&lt;TSource&gt;(
  this IEnumerable&lt;TSource&gt; source,
  int count
);
</code></pre>

<p>there is also</p>

<pre><code>public static IQueryable&lt;TSource&gt; Take&lt;TSource&gt;(
  this IQueryable&lt;TSource&gt; source,
  int count
);
</code></pre>

<p>The latter ensures that an <strong>IQueryable</strong> <em>remains</em> as an IQueryable and so postpones its evaluation.</p>

<p>By the way, I <em>am</em> finally approaching the point of this post now, so bear with me! :)</p>

<p>The LINQ "Select" extension method similarly has alternative method signatures. The more common version is</p>

<pre><code>public static IEnumerable&lt;TResult&gt; Select&lt;TSource, TResult&gt;(
  this IEnumerable&lt;TSource&gt; source,
  Func&lt;TSource, TResult&gt; selector
);
</code></pre>

<p>where a particular transformation is performed upon each item in a <strong>IEnumerable</strong> set.</p>

<p>But there is a corresponding signature</p>

<pre><code>public static IQueryable&lt;TResult&gt; Select&lt;TSource, TResult&gt;(
  this IQueryable&lt;TSource&gt; source,
  Expression&lt;Func&lt;TSource, TResult&gt;&gt; selector
);
</code></pre>

<p>where an <strong>Expression</strong> will be translated by the <strong>IQueryable</strong> provider into the language of the underlying data source (but since the <strong>IQueryable</strong> reference remains as an <strong>IQueryable</strong> this translation won't happen <em>yet</em>).</p>

<p>The difference between <strong>Expression&lt;Func&lt;TSource, TResult&gt;&gt;</strong> and <strong>Func&lt;TSource, TResult&gt;</strong> is subtle but important. The compiler is clever enough that often you needn't even be aware that you're passing an <strong>Expression</strong>. Above we were performing various manipulations (such as wrapping data up in anonymous types and combining fields with string concatenation) without having to think about it. But if we tried to do something like</p>

<pre><code>var nextId = 0;
var allAlbumNamesWithExternallGeneratedIds = context.Albums
  .Select(album =&gt; new { Name = album.Name, Id = ++nextId })
  .OrderBy(name =&gt; name);
</code></pre>

<p>we'd get a compiler error</p>

<blockquote>
  <p>An expression tree may not contain an assignment operator</p>
</blockquote>

<p>So, unfortunately, it's not just any old lambda (aka anonymous function) that can be translated into an <strong>Expression</strong>. A different problem is encountered if we attempt to use AutoMapper to process the data - eg.</p>

<pre><code>Mapper.CreateMap&lt;Album, AlbumStub&gt;();
var allAlbumKeyAndNames = context.Albums
  .Select(album =&gt; Mapper.Map&lt;Album, AlbumStub&gt;(album))
  .OrderBy(name =&gt; name);
</code></pre>

<p>where the target class is</p>

<pre><code>public class AlbumStub
{
  public int AlbumKey { get; set; }
  public string Name { get; set; }
}
</code></pre>

<p>This will result in a <strong>NotSupportedException</strong> being raised by Entity Framework with the following message:</p>

<blockquote>
  <p>LINQ to Entities does not recognize the method 'AlbumStub Map[Album,AlbumStub](ProjectionExamples.AlbumStub)' method, and this method cannot be translated into a store expression.</p>
</blockquote>

<p>What has happened here is that the compiler has recognised</p>

<pre><code>album =&gt; Mapper.Map&lt;Album, AlbumStub&gt;(album)
</code></pre>

<p>as a valid <strong>Expression</strong> but when the query provider has tried to work its magic and translate it into SQL, it doesn't know what to do.</p>

<p>We could try a different approach and call:</p>

<pre><code>Mapper.CreateMap&lt;Album, AlbumStub&gt;();
var allAlbumKeyAndNames = context.Albums
  .Select(Mapper.Map&lt;Album, AlbumStub&gt;)
  .OrderBy(name =&gt; name);
</code></pre>

<p>But here the Select method that has been called is the Select method that works against <strong>IEnumerable</strong> and so all of the data in the <em>context.Albums</em> object graph has been evaluated. Even though we only want the Album Keys and Names, <em>all</em> of the Album, Track and Artist data has been retrieved. At the point at which the <strong>IQueryable</strong> was forced into operating as an <strong>IEnumerable</strong> it had to be evaluated, and the provider is given no way way of knowing that only the Album Keys and Names are required. What a waste!</p>

<p>(Incidentally, exactly the same problem was being exhibited by my "<a href="https://bitbucket.org/DanRoberts/compilabletypeconverter">Compiler Type Converter</a>" code, this isn't something particular to AutoMapper).</p>

<p>But back in February 2011, the author of AutoMapper wrote an article talking about this and how he'd been doing some work to improve the situation (<a href="http://lostechies.com/jimmybogard/2011/02/09/autoprojecting-linq-queries/">Autoprojecting LINQ queries</a>). I believe that it became a standard part of the library in the August 2013 3.0 release (according to the <a href="https://github.com/AutoMapper/AutoMapper/releases/tag/v3.0.0">GitHub Release Notes</a>).</p>

<p>The way it works is by adding some extension methods for <strong>IQueryable</strong> that work with AutoMapper. The above example now becomes:</p>

<pre><code>Mapper.CreateMap&lt;Album, AlbumStub&gt;();
var allAlbumKeyAndNames = context.Albums
  .OrderBy(name =&gt; name);
  .Project().To&lt;AlbumStub&gt;();
</code></pre>

<p>The ".Project().To&lt;AlbumStub&gt;()" converts the <strong>IQueryable</strong> set into an <strong>IEnumerable</strong> but it does so in such a manner that only the minimum data is requested from the data source. So in this example, there will be no joins to the Tracks or Artists tables, nor will the ArtistKey field of the Album table even be mentioned in the underlying query! The "OrderBy" call is moved up so that it operates against the <strong>IQueryable</strong> and can be performed by SQL rather than retrieving the data from the db and having to sort it in-memory (which is what would happen if OrderBy was called after Project..To since it would be operating against an <strong>IEnumerable</strong> reference rather than an <strong>IQueryable</strong>).</p>

<p>There are some limitations to the projections that can be performed (which are documented in the AutoMapper GitHub wiki page <a href="https://github.com/AutoMapper/AutoMapper/wiki/Queryable-Extensions">Queryable Extensions</a>). One problem that I found early on is that, while with <strong>IEnumerable</strong> mappings you could map to an immutable type such as</p>

<pre><code>public class ImmutableAlbumStub
{
  public ImmutableAlbumStub(int albumKey, string name)
  {
    if (string.IsNullOrWhiteSpace(name))
      throw new ArgumentException("Null/blank name specified");
    AlbumKey = albumKey;
    Name = name;
  }
  public int AlbumKey { get; private set; }
  public string Name { get; private set; }
}
</code></pre>

<p>by using</p>

<pre><code>Mapper.CreateMap&lt;Album, ImmutableAlbumStub&gt;()
  .ConstructUsing(a =&gt; new ImmutableAlbumStub(a.AlbumKey, a.Name));
</code></pre>

<p>if you attempt this using this mapping with Project..To results you'll receive an <strong>ArgumentException</strong> with the message</p>

<blockquote>
  <p>'ProjectionExamples.ImmutableAlbumStub' does not have a default constructor</p>
</blockquote>

<p>Hmm. Bummer.</p>

<p>But, on the whole, I thought that this general "autoprojecting" thing was an awesome idea! And one that I wanted to steal (er.. I mean incorporate into my own code :)</p>

<h3>Auto-Projecting to Immutable Types (with the Compilable Type Converter)</h3>

<p>At its core, the problem is that we need to be able to provide <strong>Expression</strong>-based type converters that we can use with the <strong>IQueryable</strong>-based extension methods. Being able to do this will allow the <strong>IQueryable</strong> provider to analyse the <strong>Expressions</strong> and retrieve the bare minimum data required to satisfy the operation. I figured that this would be a walk in the park since the <strong>ICompilableTypeConverter</strong> is all about this - that's what enables its conversions to be compiled and be so fast!</p>

<p>Unfortunately, the very idea of analysing arbitrary expressions and translating them into SQL (or whatever) is a complex matter and, since this translation is handled by the query provider, it may vary from one provider to another. So far I've only tested this with Entity Framework and it's Entity Framework's limitations that I've encountered and worked with / around.</p>

<p>The first problem is to do with the handling of null values. If we continue with the album data model and imagine that it's actually optional to assign an artist to an album, then in such a case there would be a null ArtistKey on the Album database record. This would mean that the Artist property on the corresponding instance of the Entity-Framework-generated class would also be null. But if I try to map this onto another type structure such as with</p>

<pre><code>var albumsWithArtists = context.Albums
  .Select(a =&gt; new {
    Name = a.Name,
    Artist = (a.Artist == null) ? null : new { Name = a.Artist.Name }
  });
</code></pre>

<p>then we get another <strong>NotSupportedException</strong> as soon as the data is evaluated, this time with the message</p>

<blockquote>
  <p>Unable to create a null constant value of type 'Anonymous type'. Only entity types, enumeration types or primitive types are supported in this context.</p>
</blockquote>

<p>Unfortunately, this is - broadly speaking - what happens in the type converters that my code generates. And something similar happens with properties that are enumerable. The Tracks property, for example:</p>

<pre><code>var albumsWithTrackNames = context.Albums
  .Select(a =&gt; new {
    Name = a.Name,
    TrackNames = (a.Tracks == null) ? null : a.Tracks.Select(t =&gt; t.Name)
  });
</code></pre>

<blockquote>
  <p>Cannot compare elements of type 'System.Collections.Generic.ICollection`1[[ProjectionExamples.Album, ProjectionExamples, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]'. Only primitive types, enumeration types and entity types are supported.</p>
</blockquote>

<p>This second one doesn't seem all that unreasonable from Entity Framework's side; if there are no tracks associated with an album then an empty Tracks list would be recorded against an <strong>Album</strong> instance, not a null Tracks reference. Unfortunately my conversion methods <em>don't</em> assume this and just performing this null checking makes Entity Framework throw its toys out of the pram. We can't even check for nulls and then resort to a default empty array -</p>

<pre><code>var albumsWithTrackNames = context.Albums
  .Select(a =&gt; new {
    Name = a.Name,
    TrackNames = (a.Tracks == null) ? new string[0] : a.Tracks.Select(t =&gt; t.Name)
  });
</code></pre>

<p>as that will result in the same error.</p>

<p>And then, the killer:</p>

<pre><code>var albumsAsImmutableTypes = context.Albums
  .Select(a =&gt; new ImmutableAlbum(a.AlbumKey, a.Name));
</code></pre>

<p>This results in a <strong>NotSupportedException</strong> with the message</p>

<blockquote>
  <p>Only parameterless constructors and initializers are supported in LINQ to Entities.</p>
</blockquote>

<p>Oh dear.</p>

<p>Soooooo...</p>

<p>The approach I took to address this was two-fold. First, assume that all lists will be empty if there is no data for them and so assume that lists will never be null. Second, perform two mappings for each translation. Firstly to interim objects that have only the required properties, this is done while dealing with <strong>IQueryable</strong> data. And <em>then</em> map these interim types to the real destination objects, this is done after pushing the interim results into an <strong>IEnumerable</strong> set so that the limitations of the query provider no longer apply. The interim objects all have an "is-initialised" property on them so that if the source object is null then it can be mapped to an interim object with its "is-initialised" flag set to false, otherwise the flag will be set to true. When the interim types are mapped to the destination types, instances with "is-initialised" set to false will be mapped to null references.</p>

<p>This means that only the minimum required data will be retrieved but that the data may be mapped to immutable objects <em>and</em> that Entity Framework's awkward behaviour around nulls can be side-stepped. It's a bit like an automated version of</p>

<pre><code>var albumsAsImmutableTypes = context.Albums
  .Select(a =&gt; (a == null) ? new { AlbumKey = a.AlbumKey, Name = a.Name })
  .AsEnumerable()
  .Select(a =&gt; new ImmutableAlbumStub(a.AlbumKey, a.Name));
</code></pre>

<p>but without having to write that interim mapping by hand.</p>

<p>When building the mappings, first an "ideal mapping" is generated from the source types (the Entity Framework types) to the destination types (the <strong>ImmutableAlbumStub</strong>). This will never be used directly but performing this work reveals what property mappings are required and allows the interim types to be constructed to expose only the minimum required data.</p>

<p>Since there is an overhead to performing this work (when not dealing with <strong>IQueryable</strong> data the "ideal mapping" is fine to use and none of this extra work is required) and since there are some tweaks to behaviour (such as the assumption that enumerable sets will never be null), I created a separate static class to use, the <strong>ProjectionConverter</strong>. It works as follows (this example includes a mapping of nested types so that it's not as simple as the album "stub" example above):</p>

<pre><code>ProjectionConverter.CreateMap&lt;Track, ImmutableTrack&gt;();
ProjectionConverter.CreateMap&lt;Album, ImmutableAlbum&gt;();
using (var context = new ProjectionTestEntities1())
{
  var albumsWithTrackListings = context.Albums
    .Project().To&lt;ImmutableAlbum&gt;();
</code></pre>

<p>The target classes are:</p>

<pre><code>public class ImmutableAlbum
{
  public ImmutableAlbum(string name, IEnumerable&lt;ImmutableTrack&gt; tracks)
  {
    if (string.IsNullOrWhiteSpace(name))
      throw new ArgumentException("Null/blank name specified");
    if (tracks == null)
      throw new ArgumentNullException("tracks");

    Name = name;
    Tracks = tracks.ToList().AsReadOnly();
    if (Tracks.Any(t =&gt; t == null))
      throw new ArgumentException("Null reference encountered in tracks set");
  }

  /// &lt;summary&gt;
  /// This will never be null or blank
  /// &lt;/summary&gt;
  public string Name { get; private set; }

  /// &lt;summary&gt;
  /// This will never be null nor contain any null references
  /// &lt;/summary&gt;
  public IEnumerable&lt;ImmutableTrack&gt; Tracks { get; private set; }
}

public class ImmutableTrack
{
  public ImmutableTrack(int number, string name)
  {
    if (string.IsNullOrWhiteSpace(name))
      throw new ArgumentException("Null/blank name specified");
    if (number &lt; 1)
      throw new ArgumentOutOfRangeException("number must be greater than zero");

    Number = number;
    Name = name;
  }

  /// &lt;summary&gt;
  /// This will always be greater than zero
  /// &lt;/summary&gt;
  public int Number { get; private set; }

  /// &lt;summary&gt;
  /// This will never be null or blank
  /// &lt;/summary&gt;
  public string Name { get; private set; }
}
</code></pre>

<p>The <em>Project</em> and <em>To</em> methods are <strong>IQueryable</strong> extensions in my "<a href="https://bitbucket.org/DanRoberts/compilabletypeconverter">Compilable Type Converter</a>" project, not the ones in AutoMapper. All of the same options that I talked about <a href="/reflection-and-c-sharp-optional-constructor-arguments">last time</a> are available for the projections (so some or all of the target types may be initialised by-property-setter instead of by-constructor), the big difference is that the <strong>ProjectionConverter</strong> must be used instead of the regular <strong>Converter</strong>.</p>

<p>And with that, I'm done! <strong>IQueryable</strong>-based mappings to immutable types are now possible in a simple and efficient manner!</p>

<h3>Bonus material: Dynamic "anonymous" types</h3>

<p>The interim types that are generated by the code are created dynamically. The <strong>ProjectionConverter</strong> maintains a dictionary of generated types so if a mapping is required that requires an iterim type with the exact same set of properties as an interim type that has been used before, then a new instance of that type will be created, rather than having to build an entirely new type and then creating an instance of that. Obviously, the first time that any mapping is generated, some new types will have to be built.</p>

<p>Since the C# compiler uses anonymous types, I'd wondered if there was some .net mechanism to generate these types on-the-fly. But after doing some testing (by compiling some code and investigating the output using <a href="http://msdn.microsoft.com/en-us/library/f7dy01k1(v=vs.110).aspx">ildasm</a>), it would seem that the compiler analyses the source code at compile time and bakes in classes to the IL that may be used for all of the required anonymous types. So that was a no-go.</p>

<p>But a few years ago I'd been experimenting with a similar topic, so I was able to dust off and repurpose some old code. Which was convenient! All that I required was for a new type to be created with a particular set of non-indexed read-and-write properties. It doesn't need any methods, fields or events, it doesn't need any static properties, it doesn't need any read-only or write-only fields. It just requires a simple set of gettable/settable instance properties with particular names and types. I used the following to achieve this:</p>

<pre><code>using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Threading;

namespace CompilableTypeConverter.QueryableExtensions.ProjectionConverterHelpers
{
  public class AnonymousTypeCreator
  {
    public static AnonymousTypeCreator DefaultInstance
      = new AnonymousTypeCreator("DefaultAnonymousTypeCreatorAssembly");

    private readonly ModuleBuilder _moduleBuilder;
    public AnonymousTypeCreator(string assemblyName)
    {
      if (string.IsNullOrWhiteSpace(assemblyName))
        throw new ArgumentException("Null/blank assemblyName specified");

      var assemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(
        new AssemblyName(assemblyName),
        AssemblyBuilderAccess.Run
      );
      _moduleBuilder = assemblyBuilder.DefineDynamicModule(
        assemblyBuilder.GetName().Name,
        false // emitSymbolInfo (not required here)
      );
    }

    public Type Get(AnonymousTypePropertyInfoSet properties)
    {
      if (properties == null)
        throw new ArgumentNullException("properties");

      var typeName = "&lt;&gt;AnonymousType-" + Guid.NewGuid().ToString("N");
      var typeBuilder = _moduleBuilder.DefineType(
        typeName,
        TypeAttributes.Public
           | TypeAttributes.Class
           | TypeAttributes.AutoClass
           | TypeAttributes.AnsiClass
           | TypeAttributes.BeforeFieldInit
           | TypeAttributes.AutoLayout
      );

      var ctorBuilder = typeBuilder.DefineConstructor(
        MethodAttributes.Public,
        CallingConventions.Standard,
        Type.EmptyTypes // constructor parameters
      );
      var ilCtor = ctorBuilder.GetILGenerator();
      ilCtor.Emit(OpCodes.Ldarg_0);
      ilCtor.Emit(OpCodes.Call, typeBuilder.BaseType.GetConstructor(Type.EmptyTypes));
      ilCtor.Emit(OpCodes.Ret);

      foreach (var property in properties)
      {
        // Prepare the property we'll add get and/or set accessors to
        var propBuilder = typeBuilder.DefineProperty(
          property.Name,
          PropertyAttributes.None,
          property.PropertyType,
          Type.EmptyTypes
        );
        var backingField = typeBuilder.DefineField(
          property.Name,
          property.PropertyType,
          FieldAttributes.Private
        );

        // Define get method
        var getFuncBuilder = typeBuilder.DefineMethod(
          "get_" + property.Name,
          MethodAttributes.Public
           | MethodAttributes.HideBySig
           | MethodAttributes.NewSlot
           | MethodAttributes.SpecialName
           | MethodAttributes.Virtual
           | MethodAttributes.Final,
          property.PropertyType,
          Type.EmptyTypes
        );
        var ilGetFunc = getFuncBuilder.GetILGenerator();
        ilGetFunc.Emit(OpCodes.Ldarg_0);
        ilGetFunc.Emit(OpCodes.Ldfld, backingField);
        ilGetFunc.Emit(OpCodes.Ret);
        propBuilder.SetGetMethod(getFuncBuilder);

        // Define set method
        var setFuncBuilder = typeBuilder.DefineMethod(
          "set_" + property.Name,
          MethodAttributes.Public
           | MethodAttributes.HideBySig
           | MethodAttributes.SpecialName
           | MethodAttributes.Virtual,
          null,
          new Type[] { property.PropertyType }
        );
        var ilSetFunc = setFuncBuilder.GetILGenerator();
        ilSetFunc.Emit(OpCodes.Ldarg_0);
        ilSetFunc.Emit(OpCodes.Ldarg_1);
        ilSetFunc.Emit(OpCodes.Stfld, backingField);
        ilSetFunc.Emit(OpCodes.Ret);
        propBuilder.SetSetMethod(setFuncBuilder);
      }

      return typeBuilder.CreateType();
    }

    private static MethodInfo MethodInfoInvokeMember = typeof(Type).GetMethod(
      "InvokeMember",
      new[] {
        typeof(string),
        typeof(BindingFlags),
        typeof(Binder),
        typeof(object),
        typeof(object[])
      }
    );
  }
}
</code></pre>

<p>The <strong>AnonymousTypePropertyInfoSet</strong> data that is used to generate new classes is just a set of <strong>PropertyInfo</strong> instances that don't have the same property name used for multiple different property types and that ensures that none of the properties are indexed. It also overrides the Equals and GetHashCode method so that it can be used as a key in a dictionary of interim types to prevent creating more types that necessary. In essence, really it's an <strong>IEnumerable&lt;PropertyInfo&gt;</strong> with a few bells and whistles.</p>

<p>(These files can be found in the Bitbucket project at <a href="https://bitbucket.org/DanRoberts/compilabletypeconverter/src/f6d122508b580f70b95eb4520dd35d7fb354f42f/CompilableTypeConverterQueryableExtensions/ProjectionConverterHelpers/AnonymousTypeCreator.cs?at=default">AnonymousTypeCreator.cs</a> and <a href="https://bitbucket.org/DanRoberts/compilabletypeconverter/src/f6d122508b580f70b95eb4520dd35d7fb354f42f/CompilableTypeConverterQueryableExtensions/ProjectionConverterHelpers/AnonymousTypePropertyInfoSet.cs?at=default">AnonymousTypePropertyInfoSet.cs</a> while the dynamic type creation is required by the <a href="https://bitbucket.org/DanRoberts/compilabletypeconverter/src/f6d122508b580f70b95eb4520dd35d7fb354f42f/CompilableTypeConverterQueryableExtensions/ProjectionConverter.cs?at=default">PropertyConverter.cs</a>).</p>

<p>And on that note, I really am done!</p><p class="PostTime">Posted at 23:12</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/AutoMapper" title="8 Posts">AutoMapper</a></li><li><a href="/Archive/Tag/LINQ" title="11 Posts">LINQ</a></li><li><a href="/Archive/Tag/Reflection" title="14 Posts">Reflection</a></li></ul></div>
			<p class="Comments">
				<a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable#disqus_thread" data-disqus-identifier="68">Comments</a>
			</p>
	</div>
	<div class="Content ArchiveByTag">
		<h3 class="PostDate">22 January 2014</h3><h2><a id="Post67"></a><a href="/reflection-and-c-sharp-optional-constructor-arguments">Reflection and C# optional constructor arguments </a></h2>

<h3>Bonus provocative headline: Like AutoMapper, but 100x faster!</h3>

<p>I overheard someone at work bemoaning the fact that StructureMap doesn't seem to support optional constructor arguments (which, having a quick scout around the internet, does indeed seem to be the case, though there are solutions out there such as <a href="http://www.sep.com/sep-blog/2010/06/04/teaching-structuremap-about-c-4-0-optional-parameters-and-default-values">Teaching StructureMap About C# 4.0 Optional Parameters and Default Values</a>).</p>

<p>This put me in mind of the "<a href="http://bitbucket.org/DanRoberts/compilabletypeconverter">Compilable Type Converter</a>" project I wrote a couple of years ago. It started off life as a way to try to easily extend AutoMapper to apply all of its cleverness to constructor arguments as well as properties. So instead of using the properties on one object to populate the properties of another object, it would call a constructor on the destination class and pass in values taken from properties on the source object. (AutoMapper allows constructors to be used for creating new instances, using the "ConvertUsing" method, but it doesn't do its magic with name mappings and type conversions*).</p>

<p>* <em>Note from the future: There was a time when AutoMapper didn't have good support for mapping to immutable types, it wouldn't apply automatic its name / type matching logic to the case where property values are read from the source type and used to provide constructor arguments on the destination type (and it was to fill that feature gap that I started writing the <a href="https://bitbucket.org/DanRoberts/compilabletypeconverter">Compilable Type Converter</a>). However, that situation changed at some point and now AutoMapper does have good support for mapping to immutable types - though I wasn't able to track down from the release notes when precisely that was.</em></p>

<p>It then grew to generate conversion LINQ Expressions, which were compiled for performance. And from there it became a standalone component that could perform mappings without AutoMapper at all! It could still be used with AutoMapper since the converters it generated could be used in "ConvertUsing" calls but the property-to-constructor-argument mappings would be created automatically instead of manually. And if non-compilable type converters (not compiled to LINQ Expression and so functional but slower) were being generated with my project, there were classes to utilise AutoMapper to help perform the type conversions.</p>

<p>The last thing I had done to it was add in support so that it could generate compiled converters that would populate the desination object using property setters (like AutoMapper does) instead of by-constructor.</p>

<p>I wrote a couple of posts about this a long time ago, but they were early posts and they weren't written all that well, so I'm embarassed to link to them here. :)</p>

<p>Anyway.. the point is, I was fairly confident that the Compilable Type Converter also did not support optional constructor arguments. And I didn't actually know how optional constructor arguments would look in the reflected information (the converter uses reflection to analyses the source and destination types and decide how to perform the conversion, but then generates a LINQ Expression to do the work which should have performance comparable to custom hand-written conversion code) so it seemed like a good opportunity to brush off an old project and have a bit of fun with it!</p>

<h3>.net's representation of optional constructor arguments</h3>

<p>This is the easy bit. I hadn't known how easy until I looked into it, but very easy.</p>

<p>Say there is a class</p>

<pre><code>public class TypeWithOptionalConstructorArguments
{
  public TypeWithOptionalConstructorArguments(string name, int number = 1)
  {
    // Do initialisation work..
  }

  // Have the rest of the class here..
}
</code></pre>

<p>then to determine that the <em>number</em> argument is optional, we interrogate information about the constructor -</p>

<pre><code>var constructorParameters = typeof(TypeWithOptionalConstructorArguments)
  .GetConstructor(new[] { typeof(string), typeof(int) })
  .GetParameters();

var numberParameter = constructorParameters[1];
var numberParameterType = numberParameter.ParameterType;
var isNumberParameterOptional = numberParameter.IsOptional;
var numberParameterDefaultValue = numberParameter.DefaultValue;
</code></pre>

<p>Here we find that <em>numberParameterType</em> is int, <em>isNumberParameterOptional</em> is true and <em>numberParameterDefaultValue</em> is 1. If we considered the first parameter then IsOptional would be false.</p>

<h3>Incorporating this into the Compilable Type Converter</h3>

<p>Before I give a quick run-down of how I made my code "optional-constructor-argument aware", I'll go quickly through the core concepts it uses when trying to generate a conversion.</p>

<p>There are Property Getters which will take a value from a property on the source type in order to satisfy a value required to generate the destination type (this value may be a constructor argument or a property, depending upon whether a by-constructor or by-property-setter conversion is desired). Property Getters come in several varieties; there is one that will map a source value if the source value's type may be assigned directly to the destination type (ie. the source value matches the destination value or inherits from it / implements it). There is one that will map enum values - from one enum to another, according to a naming convention (this convention is determined by a Name Matcher, see below). There is another one that will perform one specific type translation, so if a converter is generated for mapping between <strong>SNested</strong> and <strong>DNested</strong> then a new Property Getter may be created that will help convert type <strong>SParent</strong> to <strong>DParent</strong> if <strong>SParent</strong> has a property with type <strong>SNested</strong> that needs to be mapped to a property on <strong>DParent</strong> with type <strong>DNested</strong>. There's another that's very similar but for enumerable types, so given an <strong>SNested</strong> -> <strong>DNested</strong> converter it can help map <strong>SParent</strong> to <strong>DParent</strong> if <strong>SParent</strong> has a property of type <strong>IEnumerable&lt;SNested&gt;</strong> and <strong>DParent</strong> has a property of type <strong>IEnumerable&lt;DNested&gt;</strong>.</p>

<p>Property Getters are created by Property Getter Factories. When a conversion request is being analysed, the Property Getter Factories will be asked "can you perform a mapping from Src to Dest for the property on Dest named Prop?" (the property on Dest may be an actual property or it may be a constructor argument). The factory will look at all of the properties on the Src type and see which, if any, it would map onto Prop based upon the source property's name and type. The type matching depends upon what sort of Property Getter the factory can create (whether that be an assignable-to getter, an enum-translating getter, etc.. all of the options I just described above) and what name matching approach it will use. The name matching depends upon the Name Matcher that was provided to the factory at instantiation.</p>

<p>Name Matchers simply answer the question "are these property/argument names equivalent?", the basic implementation in the project is the <strong>CaseInsensitiveSkipUnderscoreNameMatcher</strong>. This ignores underscores and case when comparing names, so "Title" and "title" and considered to be the same, as are "Person_Name" and "personName".</p>

<p>Finally, when a by-constructor conversion is being generated, there may be multiple constructors which may be satisfied (ie. all of their constructor arguments may be provided with values from the source object's properties). In this case, a decision will need to be made as to which constructor to use. For this, there is a Constructor Prioritiser. Each may-be-satisifed-constructor is represented by the fully-generated converter that would use that constructor. The prioritiser must then pick one to be used as the converter that should be used for that translation.</p>

<p>The only Constructor Prioritiser implementation that I currently have is an <strong>ArgsLengthTypeConverterPrioritiser</strong>. This simply picks the constructor which has the most arguments, the thinking being that this must be the constructor that uses the most data from the source type and so will result in the best-populated destination instance possible.</p>

<p>However, if there are two constructors, one with four compulsory arguments and one with five arguments total, but two of them optional, then the five-argument constructor may no longer be the best bet. If a conversion is available that explicitly populates those five values with data from the source object, then this is probably still the best match. But if the only conversion that uses that five-argument constructor is actually relying on the default values for those two optional arguments then it's only actually populating <em>three</em> constructor arguments from the source data, so surely the four-argument constructor is better!</p>

<h3>A quick(ish) explanation of how I introduced optional constructor arguments</h3>

<p>So I have a <strong>CompilableTypeConverterByConstructorFactory</strong>. This has a method Get&lt;TSource, TDest&gt;() which will try return an <strong>ICompilableTypeConverter&lt;TSource, TDest&gt;</strong> that maps from <strong>TSource</strong> to <strong>TDest</strong>. If it can't create such a type converter then it will throw an exception.</p>

<p>The particular implementation of <strong>ICompilableTypeConverter&lt;TSource, TDest&gt;</strong> returned from this class will be a <strong>CompilableTypeConverterByConstructor&lt;TSource, TDest&gt;</strong>.</p>

<p>This class previously required a <strong>ConstructorInfo</strong> and a set of Property Getters for each argument in that constructor. The factory's job was to select the best <strong>ConstructorInfo</strong> and provide those Property Getters from the Property Getter Factories that it had access to. The constructor of the <strong>CompilableTypeConverterByConstructor&lt;TSource, TDest&gt;</strong> class would do some validation to ensure that the number of Property Getters matched the number of constructor arguments for the specified constructor, and that the types returned by the Property Getters matched the constructor's arguments types.</p>

<p>The change I made was for the <strong>CompilableTypeConverterByConstructor&lt;TSource, TDest&gt;</strong> to also take a <strong>ICompilableConstructorDefaultValuePropertyGetter</strong> set - Property Getters which are associated with a particular constructor argument which has a default value, and which just return this default value when a value is requested.</p>

<p>These Default Value Property Getters would only be specified by the Type Converter Factory if there was no Property Getter that could otherwise provide that constructor argument with a value - if it's possible to get data from the source object for a constructor argument then there's no point using the argument's default value!</p>

<p>The benefit of providing two distinct sets of Property Getters (those relying upon default values and those not) to the <strong>CompilableTypeConverterByConstructor&lt;TSource, TDest&gt;</strong> is that it was possible to add another public property to it; the <em>NumberOfConstructorArgumentsMatchedWithNonDefaultValues</em> (this is the total number of arguments that the target constructor has minus the number of Default Value Property Getters). And the benefit of <em>this</em> is that it allows for a Constructor Prioritiser to consider the number of constructor arguments that were populated with data from the source object, as opposed to the <em>total</em> number of constructor arguments fulfilled, regardless of how many actually had to fall back on to using default values. Which addresses the problem I outlined in the section above.</p>

<h3>Code updates</h3>

<p>While I was making these changes and experimenting with various scenarios (trying to re-familiarise myself with exactly how everything worked) I found it interesting to note how some I've changed some coding conventions over the years. Particularly, I disliked a method on the <strong>ITypeConverterFactory</strong> interface -</p>

<pre><code>/// &lt;summary&gt;
/// This will return null if unable to generate the specified converter
/// &lt;/summary&gt;
ITypeConverter&lt;TSource, TDest&gt; Get&lt;TSource, TDest&gt;();
</code></pre>

<p>From some sides, this doesn't sound all that bad. And it's not uncommon to find code out there that does the same sort of thing; try to get the requested value and return null if unable to.</p>

<p>As a rule, though, I don't like this <em>at all</em>. I prefer to avoid nulls wherever humanly possible and explicitly indicate the possibility of their presence where they must crop up.</p>

<p>If a class exists where a property may be null since the data is not required for that particular structure, then I will prefix that property with "Optional". If a method may be expected to return null then I will prefix it with "TryTo". This isn't a perfect system by any means but it's a convention that I've found useful.</p>

<p>So I could change the Get method above to</p>

<pre><code>/// &lt;summary&gt;
/// This will return null if unable to generate the specified converter
/// &lt;/summary&gt;
ITypeConverter&lt;TSource, TDest&gt; TryToGet&lt;TSource, TDest&gt;();
</code></pre>

<p>if not being able to return the requested converter is not an error condition.</p>

<p>However, for the cases a converter could <em>not</em> be generated to perform the specified <strong>TSource</strong> -> <strong>TDest</strong> mapping, the caller has no additional information - all they have is a null! And I suspect that someone trying to get a converter by calling a "Get" method would indeed consider it an error condition if it didn't actually return a converter.</p>

<p>So I changed it to</p>

<pre><code>/// &lt;summary&gt;
/// This will throw an exception if unable to generate the specified converter, it will never
/// return null
/// &lt;/summary&gt;
ITypeConverter&lt;TSource, TDest&gt; Get&lt;TSource, TDest&gt;();
</code></pre>

<p>I then changed the Type Converter Factories to throw custom exceptions indicating what property could not be set on the target type or what constructor arguments could not be mappped. Changing the contract so that it is considered an error condition when a mapping could not be created resulted in more information being availble to the caller, more <em>useful and important</em> information.</p>

<h3>Static convenience wrapper</h3>

<p>Since I felt like I was cooking on gas at this point, I thought I'd address another problem with this project; trying to use this code for the first time (if you'd just cloned the project, for example) is difficult! I've got a ReadMe file in the project that tells you how to initialise a converter factory and then generate types but it's quite a lot of work to do so!</p>

<p>In some of my other projects I've included "convenience wrappers" to do the fiddly work of initialising everything for the most common case so that the code is as easy as possible to get working with. For example, the <a href="https://bitbucket.org/DanRoberts/cssparser">CSSParser</a> has the static <strong>Parser</strong> class, with its method "ParseCSS" and "ParseLESS" (with method signatures that will read from strings or from <strong>TextReader</strong>s). The <a href="https://bitbucket.org/DanRoberts/cssminifier">CSSMinifier</a> has the <strong>DefaultNonCachedLessCssLoaderFactory</strong> and <strong>EnhancedNonCachedLessCssLoaderFactory</strong> which can be initialised with only an ASP.Net "Server" reference. And, of course, AutoMapper is phenonemally easy to get going with since there is a static <strong>Mapper</strong> class with CreateMap and Map methods (amongst many others). So I thought that <em>my</em> Type Converter library would benefit from something similar!</p>

<p>It can't get much simpler than this:</p>

<pre><code>Converter.CreateMap&lt;MutablePersonDetails.RoleDetails, ImmutablePersonDetails.RoleDetails&gt;();
var dest = Converter.Convert&lt;MutablePersonDetails, ImmutablePersonDetails&gt;(source);
</code></pre>

<p>The "source" objectin this example is initialised with</p>

<pre><code>var source = new MutablePersonDetails
{
  Name = "Henry",
  Roles = new List&lt;MutablePersonDetails.RoleDetails&gt;
  {
    new MutablePersonDetails.RoleDetails
    {
      Title = "Head Penguin Cleaner",
      ClearanceLevel = ClearanceLevelOptions.Maximum
    }
  }
};
</code></pre>

<p>(The actual classes for the source and destination types will be included later on for completion's sake).</p>

<p>The types <strong>MutablePersonDetails.RoleDetails</strong> and <strong>ImmutablePersonDetails.RoleDetails</strong> are considered "nested" as they are not the target of the primary mapping (which is from <strong>MutablePersonDetails</strong> to <strong>ImmutablePersonDetails</strong>). There are properties on the source and destination types which are sets of these <strong>RoleDetails</strong> nested types.</p>

<p>So first a mapping for the nested types is created. The <strong>Converter</strong> class is able to use this mapping to generate mappings between sets of these types; so creating a <strong>MutablePersonDetails.RoleDetails</strong> to <strong>ImmutablePersonDetails.RoleDetails</strong> mapping means that a <strong>List&lt;MutablePersonDetails.RoleDetails&gt;</strong> to <strong>IEnumerable&lt;ImmutablePersonDetails.RoleDetails&gt;</strong> becomes available as well.</p>

<p>The <em>Convert</em> call will implicitly try to create a suitable mapping if one is not already available, this is why no explicit call to <em>CreateMap</em> is required for <strong>MutablePersonDetails</strong> to <strong>ImmutablePersonDetails</strong>.</p>

<p>The mapping here was a "by-constructor" mapping (which is what I originally started this project for), it takes property values from the source object and uses them to populate constructor arguments on the destination type to create a new instance of it. But "by-property-setter" mappings are also supported, so we could also create a mapping in the opposite direction to that above:</p>

<pre><code>Converter.CreateMap&lt;ImmutablePersonDetails.RoleDetails, MutablePersonDetails.RoleDetails&gt;();
var dest = Converter.Convert&lt;ImmutablePersonDetails, MutablePersonDetails&gt;(source);
</code></pre>

<p>The source and destination classes in the examples are as follow:</p>

<pre><code>public class MutablePersonDetails
{
  public string Name { get; set; }
  public List&lt;RoleDetails&gt; Roles { get; set; }

  public class RoleDetails
  {
    public string Title { get; set; }
    public ClearanceLevelOptions ClearanceLevel { get; set; }
  }
}

public class ImmutablePersonDetails
{
  public ImmutablePersonDetails(string name, IEnumerable&lt;RoleDetails&gt; roles)
  {
    if (string.IsNullOrWhiteSpace(name))
      throw new ArgumentException("Null/blank name specified");
    if (roles == null)
      throw new ArgumentNullException("roles");

    Name = name;

    Roles = roles.ToList().AsReadOnly();
    if (Roles.Any(role =&gt; role == null))
      throw new ArgumentException("Null reference encountered in roles set");
  }

  public string Name { get; private set; }
  public IEnumerable&lt;RoleDetails&gt; Roles { get; private set; }

  public class RoleDetails
  {
    public RoleDetails(string title, ClearanceLevelOptions clearanceLevel)
    {
      if (string.IsNullOrWhiteSpace(title))
        throw new ArgumentException("Null/blank title specified");
      if (!Enum.IsDefined(typeof(ClearanceLevelOptions), clearanceLevel))
        throw new ArgumentOutOfRangeException("clearanceLevel");

      Title = title;
      ClearanceLevel = clearanceLevel;
    }

    public string Title { get; private set; }
    public ClearanceLevelOptions ClearanceLevel { get; private set; }
  }
}

public enum ClearanceLevelOptions
{
  Regular,
  Maximum
}
</code></pre>

<h3>Ignoring properties / using default constructor arguments</h3>

<p>If the above classes were changed such that <strong>MutablePersonDetails.RoleDetails</strong> no longer has a <em>ClearanceLevel</em> property and the <strong>ImmutablePersonDetails.RoleDetails</strong> constructor's <em>clearanceLevel</em> argument is assigned a default value..</p>

<pre><code>// Nested type of MutablePersonDetails
public class RoleDetails
{
  public string Title { get; set; }
}

// Nested type of ImmutablePersonDetails
public RoleDetails(
  string title,
  ClearanceLevelOptions clearanceLevel = ClearanceLevelOptions.Regular)
</code></pre>

<p>.. then the <strong>Converter</strong> will take this into account and still generate the expected mapping with:</p>

<pre><code>Converter.CreateMap&lt;MutablePersonDetails.RoleDetails, ImmutablePersonDetails.RoleDetails&gt;();
var dest = Converter.Convert&lt;MutablePersonDetails, ImmutablePersonDetails&gt;(source);
</code></pre>

<p>If we reversed this such that the <strong>MutablePersonDetails.RoleDetails</strong> still has a ClearanceLevel property but the <strong>ImmutablePersonDetails.RoleDetails</strong> does <em>not</em>..</p>

<pre><code>// Nested type of MutablePersonDetails
public class RoleDetails
{
  public string Title { get; set; }
  public ClearanceLevelOptions ClearanceLevel { get; set; }
}

// Nested type of ImmutablePersonDetails
public class RoleDetails
{
  public RoleDetails(string title)
  {
    if (string.IsNullOrWhiteSpace(title))
      throw new ArgumentException("Null/blank title specified");
    Title = title;
  }
  public string Title { get; private set; }
}
</code></pre>

<p>.. then the mapping will fail as the <strong>Converter</strong> will throw an exception if it can't map every property on the target when performing a by-property-setter conversion. <em>Unless</em> it is explicitly instructed to ignore the property -</p>

<pre><code>Converter.BeginCreateMap&lt;ImmutablePersonDetails.RoleDetails, MutablePersonDetails.RoleDetails&gt;()
  .Ignore(
    r =&gt; r.ClearanceLevel
  )
  .Create();
var dest = Converter.Convert&lt;ImmutablePersonDetails, MutablePersonDetails&gt;(source);
</code></pre>

<p>The <em>BeginCreateMap</em> allows for exceptions to be made to the normal mapping process. The <strong>Create</strong> call (at the end of the <em>BeginCreateMap</em>, <em>Ignore</em>, <em>Create</em> chain) is important since the work to try to generate the converter will not be performed without that call (and all of the <strong>BeginCreateMap</strong> and any subsequent calls in that chain will be ignored without <em>Create</em> being called).</p>

<p>This is different to the AutoMapper approach since AutoMapper will take in information about how the mappings should be created but not use it until a conversion is required. This means that mappings can be specified in any order with AutoMapper; the following would be fine, for example -</p>

<pre><code>Mapper.CreateMap&lt;ImmutablePersonDetails, MutablePersonDetails&gt;();
Mapper.CreateMap&lt;ImmutablePersonDetails.RoleDetails, MutablePersonDetails.RoleDetails&gt;();
</code></pre>

<p>AutoMapper doesn't mind the mappings for the nested type appearing after the mapping for the "containing type" since it won't try to use this information until it actually performs a conversion.</p>

<p>My <strong>Converter</strong> class, however, generates the converters when <em>CreateMap</em> (or <em>Convert</em> is called). So a mapping for the nested types must be specified before the containing type as a converter for the containing type can't be generated without knowing how to convert the nested types! While I think there are advantages to the flexibility of AutoMapper's approach (not having to worry about converter dependencies; not having to worry about the order in which mappings are specified) I also think there are advantages to my approach since an exception will be raised as soon as a mapping is requested that can not be created (along with information about what properties or constructor arguments could not be satisfied).</p>

<p>Another advantage of the converters being generated as the mappings are specified is that the <strong>Converter</strong> is keeping track of them and can provide a reference to any of them through a call to <em>GetConverter</em>. The converters are all immutable and if a converter is returned from the <em>GetConverter</em> method then no further changes to the <strong>Converter</strong> class may affect it. This is reassuring in that the converter may be used elsewhere without having to worry about the mutability of the static <strong>Converter</strong> class but it also has performance benefits; calls to the <strong>Converter</strong>'s <em>Convert</em> method (and <em>CreateMap</em> and <em>GetConverter</em> methods) require cache lookups and locks. If you use a converter reference delivered by the <em>GetConverter</em> method then you don't need to worry about these lookups and locks. Which brings me neatly to..</p>

<h3>The Compilable Type Converter's Performance</h3>

<p>First off, the Compilable Type Converter isn't intended to compete feature-for-feature with AutoMapper. AutoMapper is a well-rounded library with all sorts of functionality that address all sorts of edge cases. For example, I only encountered the <em>BeforeMap</em> and <em>AfterMap</em> calls when looking into it more deeply to write this article! It also offers <a href="https://automapper.codeplex.com/wikipage?title=Flattening">object model flattening</a> and retrieval of data through Get methods rather than properties. I don't have any intention of supporting any of these, though I <em>do</em> intend to add some custom property mappings at some point. Something like</p>

<pre><code>Converter.BeginCreateMap&lt;ImmutablePersonDetails.RoleDetails, MutablePersonDetails.RoleDetails&gt;()
  .Custom(
    dest =&gt; dest.ClearanceLevel,
    src =&gt; src.GetClearanceLevel()
  )
  .Create();
</code></pre>

<p>(Let's not forget the killer feature of my library - for me, at least - is that it performs the name matching magic from properties onto constructor arguments so that immutable classes can be instantiated by the mappers).</p>

<p>So anyway.. making performance comparisons between the two libraries is probably not all that productive. But since I've banged on about the Compilable Type Converter producing LINQ-Expression-compiled converters, I'm going to anyway! :)</p>

<p>We'll stick with the <strong>ImmutablePersonDetails</strong> to <strong>MutablePersonDetails</strong> mapping that was in the earlier examples. </p>

<p>There are two aspects that need considering - the startup time and the conversion time. If the Compilable Type Converter can perform conversions faster than AutoMapper but with a greater initialisation cost (which we'd expect since there is expensive LINQ Expression compilation going on) then there will have to be a certain number of conversion performed before we "break even" on the startup time. But after that, it should be all win!</p>

<p>So I've set up a test program that times the initialisation processes, repeated in a loop. At the end of each loop, the <em>Reset</em> method is called for both the <strong>Mapper</strong> and <strong>Converter</strong> (these calls are outside of the initialisation work that is timed, since we're not interested in the efficiency of the <em>Reset</em> methods). The last loop doesn't call <em>Reset</em> so that everything is ready for the next section of the program, where I time a conversion from an <strong>ImmutablePersonDetails</strong> instance to a new <strong>MutablePersonDetails</strong> (over and over again).</p>

<p>The init sections looks like this (basically the same as we've already seen above). We have to actually perform one mapping in the init code since AutoMapper postpones doing work until a mapping is actually requested, as I've already spoken about.</p>

<pre><code>Mapper.CreateMap&lt;ImmutablePersonDetails, MutablePersonDetails&gt;();
Mapper.CreateMap&lt;ImmutablePersonDetails.RoleDetails, MutablePersonDetails.RoleDetails&gt;();
var destAutoMapperInitialise = Mapper.Map&lt;ImmutablePersonDetails, MutablePersonDetails&gt;(source);

Converter.CreateMap&lt;ImmutablePersonDetails.RoleDetails, MutablePersonDetails.RoleDetails&gt;();
var converter = Converter.GetConverter&lt;ImmutablePersonDetails, MutablePersonDetails&gt;();
var destCompilableTypeConverterInitialise = converter.Convert(source);
</code></pre>

<p>Then there are three operations that are individually timed in the "convert loop":</p>

<pre><code>// Convert using AutoMapper
Mapper.Map&lt;ImmutablePersonDetails, MutablePersonDetails&gt;(source);

// Convert using the Compilable Type Converter, through the static convenience wrapper
Converter.Convert&lt;ImmutablePersonDetails, MutablePersonDetails&gt;(source);

// Convert using the Compilable Type Converter, using the converter reference from a GetConverter
// call in the init phase (this will be quicker as the cache lookups and locks in the convenience
// wrapper are not required)
converter.Convert(source);
</code></pre>

<p>I've run this whole process half a dozen times and got comparable results each time. The last time I ran it, the average time to initialise <strong>AutoMapper was 8ms</strong> and to initialise the <strong>Compilable Type Converter was 41ms</strong> (average taken over 100 repeated initialisations). The average time (taken over 100,000 loops) to perform the conversions was <strong>310 ticks for AutoMapper</strong>, <strong>46 ticks for the Compilable Type Converter via the convenience wrapper</strong> and <strong>3 ticks for the Compilable Type Converter via the <em>converter</em> reference</strong> that was obtained as part of the initialisation work.</p>

<p>The standout result here is that the Compilable Type Converter was able to perform the conversion 100x faster.</p>

<p><em>100x faster!</em></p>

<p>That's good times! :)</p>

<p>However, this ignores the initialisation overhead. If you were only ever going to perform a single conversion then speed of the initialised converter is more than offset by the additional initialisation time required. However, if you're expecting to perform a lot of these conversions then this initialisation overhead should be easily offset. (My original aim for this work was to translate a WCF web service's public-facing mutable classes into their internal immutable counterparts, so there <em>would</em> be many conversions in that case). In the example above, it would take 349 conversions to break even if using the <strong>Converter</strong> wrapper and only 300 if using the <em>converter</em> reference directly.</p>

<p><em>Another note from the future: AutoMapper 5.0 (released July 2016) has some significant performance improvements such that now the performance tests above (which would need tweaking to compile with modern AutoMapper) are only between 2x and 2.5x faster with the CompilableTypeMapper than with AutoMapper. This is fantastic work from the AutoMapper authors! See <a href="https://lostechies.com/jimmybogard/2016/06/24/automapper-5-0-speed-increases/">AutoMapper 5.0 speed increases</a> for more details.</em></p><p class="PostTime">Posted at 23:19</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/AutoMapper" title="8 Posts">AutoMapper</a></li><li><a href="/Archive/Tag/LINQ" title="11 Posts">LINQ</a></li><li><a href="/Archive/Tag/Reflection" title="14 Posts">Reflection</a></li></ul></div>
			<p class="Comments">
				<a href="/reflection-and-c-sharp-optional-constructor-arguments#disqus_thread" data-disqus-identifier="67">Comments</a>
			</p>
	</div>
	<div class="Content ArchiveByTag">
		<h3 class="PostDate">17 December 2012</h3><h2><a id="Post40"></a><a href="/the-full-text-indexer-post-roundup">The Full Text Indexer Post Round-up</a></h2>

<p>This is a compilation of links to articles outlining some of the details of the Full Text Indexer project I put together, just so I could point a link to everything all in one place (like from the BitBucket ReadMe!)</p>

<p>I wrote about the basic building blocks of the Index Generator, went off on a few tangents about how using different key types could allow for searches over data with multi-lingual content (or support Product data that has different descriptions for different web sites, for example) and then came back round to illustrate how I've used the code for this blog's search functionality.</p>

<ul>
<li><a href="/the-full-text-indexer">The Full Text Indexer</a></li>
<li><a href="/the-full-text-indexer-adding-and-subtracting">The Full Text Indexer - Adding and Subtracting</a></li>
<li><a href="/the-full-text-indexer-going-international">The Full Text Indexer - Going International!</a></li>
<li><a href="/the-full-text-indexer-token-breaker-and-string-normaliser-variations">The Full Text Indexer - Token Breaker and String Normaliser variations (+AutoComplete)</a></li>
<li><a href="/the-full-text-indexer-automating-index-generation">The Full Text Indexer - Automating Index Generation</a></li>
<li><a href="/the-full-text-indexer-structured-queries">The Full Text Indexer - Structured Queries</a></li>
<li><a href="/the-full-text-indexer-source-locations">The Full Text Indexer: Source Locations</a></li>
<li><a href="/the-full-text-indexer-search-term-highlighting-with-source-locations">Search Term Highlighting with Source Locations</a></li>
<li><a href="/the-neocities-challenge-aka-the-full-text-indexer-goes-clientside">The Full Text Indexer goes Client-side!</a></li>
</ul>

<p>Along the journey, I got to learn a few new things, take advantage of other's research and have fun trying to improve the performance of some of the bottlenecks in the index generation process.</p>

<ul>
<li><a href="/the-net-dictionary-is-fast">The .Net Dictionary is FAST!</a></li>
<li><a href="/an-englishlanguage-pluralityhandling-string-normaliser">An English-language Plurality-handling String Normaliser</a></li>
<li><a href="/optimising-the-pluralityhandling-normaliser">Optimising the Plurality-Handling Normaliser</a></li>
<li><a href="/a-pluralityhandling-normaliser-correction">A Plurality-Handling Normaliser Correction</a></li>
<li><a href="/compiled-linq-expressions-dont-serialise">Compiled LINQ Expressions don't serialise :(</a></li>
<li><a href="/javascript-compression-putting-my-json-search-indexes-on-a-diet">JavaScript Compression (Putting my JSON Search Indexes on a diet)</a></li>
</ul>

<p>I also had a chance to revisit the basic immutable list structure that I used from the get-go in this project and improve its performance characteristics as well (again, taking a lot of inspiration from cleverer people who've tackled the same problems before me! :)</p>

<ul>
<li><a href="/persistent-immutable-lists">Persistent Immutable Lists</a></li>
<li><a href="/persistent-immutable-lists-extended">Persistent Immutable Lists - Extended</a></li>
</ul>

<p>The code can be found in the <a href="https://bitbucket.org/DanRoberts/full-text-indexer/">Full Text Indexer BitBucket Repository</a>. I've still got a few ideas I'm contemplating toying with - but I've also got other projects I want to investigate! So we'll just have to see what happens with this next..</p>

<p><strong>Update (5th March 2013):</strong> I just can't seem to let this lie! :) I've added another post <a href="/the-full-text-indexer-automating-index-generation">The Full Text Indexer - Automating Index Generation</a> which demonstrates some new code that will examine your source data type and generate an index for you, all on its own! Easy! (Added to the list above).</p>

<p><strong>Update (14th March 2013):</strong> And another! This time about support for structured querying, a way to combine terms with AND, OR, NOT operators. See <a href="/the-full-text-indexer-structured-queries">The Full Text Indexer - Structured Queries</a>.  (Added to the list above).</p>

<p><strong>Update (28th March 2013):</strong> Documenting an extension to the index data that allow for more performant consecutive term matching: <a href="/the-full-text-indexer-source-locations">The Full Text Indexer: Source Locations</a>. Followed by a way to utilise this information for <a href="/the-full-text-indexer-search-term-highlighting-with-source-locations">Search Term Highlighting with Source Locations</a>. (Added to the list above).</p>

<p><strong>Update (25th July 2013):</strong> Inspired by the "<a href="http://10mbmanifesto.neocities.org">The 10 Megabyte Manifesto</a>" and <a href="http://neocities.org">NeoCities</a>, I've developed a way to consume search index data with JavaScript to enable a copy of this blog to be hosted where the searching is done entirely client-side. Read about it at <a href="/the-neocities-challenge-aka-the-full-text-indexer-goes-clientside">The Full Text Indexer goes client-side!</a> and see it in action live at <a href="http://productiverage.neocities.org">productiverage.neocities.org</a>! (Added to the list above).</p>

<p><strong>Update (30th July 2013):</strong> A follow-up to the "The Full Text Indexer goes client-side" describing how the search index data can be compressed to take up less space on the host: <a href="/javascript-compression-putting-my-json-search-indexes-on-a-diet">JavaScript Compression (Putting my JSON Search Indexes on a diet)</a>. (Added to the list above).</p><p class="PostTime">Posted at 18:06</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/FullTextIndexer" title="17 Posts">FullTextIndexer</a></li><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li><li><a href="/Archive/Tag/LINQ" title="11 Posts">LINQ</a></li><li><a href="/Archive/Tag/Optimisation" title="8 Posts">Optimisation</a></li></ul></div>
			<p class="Comments">
				<a href="/the-full-text-indexer-post-roundup#disqus_thread" data-disqus-identifier="40">Comments</a>
			</p>
	</div>
	<div class="Content ArchiveByTag">
		<h3 class="PostDate">24 June 2012</h3><h2><a id="Post29"></a><a href="/compiled-linq-expressions-dont-serialise">Compiled LINQ Expressions don't serialise :(</a></h2>

<p>In the last post (<a href="/optimising-the-pluralityhandling-normaliser">Optimising the Plurality-Handling Normaliser</a>) I got all excited about improving the performance of what is essentially a string comparer for use in a Full Text Indexer I'm playing around with (which is now handling the search facilities on this blog so it must be half way to working at least! :) but the use of compiled LINQ expressions brought about their own problems when I tried to write away a fully-generated index to a disk cache. The generated lambda expression is not serialisable!</p>

<p>There was something in me that thought that since it had been formed through simple LINQ Expressions tied together that it would be easy to serialise and so not be a problem. But I suppose that once it becomes a generic lambda function then all bets are off since they can have references to all sort and so mightn't be easily serialisable anymore.</p>

<p>As usual there's a Stack Overflow post showing I'm hardly the first person to have encountered this issue, and this particular one even has the authority Eric Lippert getting involved! :) Interesting to see him make the point that this was was work that was required with all of the "LINQ-to-whatever" integrations..</p>

<p><a href="http://stackoverflow.com/questions/6443433/how-can-i-pass-a-lambda-expression-to-a-wcf-service">Stack Overflow: How can I pass a lambda expression to a WCF Service?</a></p>

<h3>A solution.. for now</h3>

<p>I essentially just want to write to disk a custom string-keyed dictionary object with a particular key comparer to act as another level of caching when it drops out of memory so I didn't have any issues so complicated as passing expressions to a query service so I went for a relatively simple approach; I record all of the data as class members that are required to generate the LINQ Expressions so that I can implement ISerializable and write away just this data when an instance is serialised. Then when it's de-serialised I use this data to regenerate the lambdas.</p>

<pre><code>// This de-serialising constructor takes the values that are stored in the GetObjectData
// method and passes them through to the standard public constructor
protected EnglishPluralityStringNormaliser(SerializationInfo info, StreamingContext context)
    : this(
        (IEnumerable&lt;PluralEntry&gt;)info.GetValue(
            "_plurals",
            typeof(IEnumerable&lt;PluralEntry&gt;)
        ),
        (IEnumerable&lt;string&gt;)info.GetValue(
            "_fallbackSuffixes",
            typeof(IEnumerable&lt;string&gt;)
        ),
        (IStringNormaliser)info.GetValue(
            "_optionalPreNormaliser",
            typeof(IStringNormaliser)
        ),
        (PreNormaliserWorkOptions)info.GetValue(
            "_preNormaliserWork",
            typeof(PreNormaliserWorkOptions)
        )
    ) { }

public void GetObjectData(SerializationInfo info, StreamingContext context)
{
    // Unfortunately we can't serialise the generated normaliser (we'll get a "Cannot
    // serialize delegates over unmanaged function pointers, dynamic methods or methods
    // outside the delegate creator's assembly" error) so if we have to serialise this
    // instance we'll store all of the dat and then re-generate the normaliser on
    // de-serialisation. Not ideal from a performance point of view but at least
    // it will work.
    info.AddValue("_plurals", _plurals);
    info.AddValue("_fallbackSuffixes", _fallbackSuffixes);
    info.AddValue("_optionalPreNormaliser", _optionalPreNormaliser);
    info.AddValue("_preNormaliserWork", _preNormaliserWork);
}
</code></pre>

<h3>However..</h3>

<p>Then I tried integrating the project as a search facility into my blog which is running ASP.Net MVC 3 (.Net 4.0) and ran into another snag; "Inheritance security rules violated while overriding member: MyBusinessException.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)'. Security accessibility of the overriding method must match the security accessibility of the method being overriden."</p>

<p>Hmmm...</p>

<p>Stack Overflow to the rescue again! <a href="http://stackoverflow.com/questions/3055792/inheritance-security-rules-violated-while-overriding-member-securityruleset-le">Inheritance security rules violated with overriding member</a>. Reading the post led me to click "Use Definition" on ISerializable and observice that the "SecurityCritical" attribute was marked on the GetObjectData method - and from what I understand from what I read, I should be able to fix this by marking that attribute on my GetObjectData method. Sortio!</p>

<p>Not sortio.. :( And now I must admit to being a bit lazy in my eagerness to get the search functionality integrated on the site. One of the Stack Overflow answers was to specify "Full Trust" for the web application but I got the impression that this was cheating a bit and bypassing some of the new .Net 4.0 security mechanisms. However, for now I've gone with it by adding this to the web.config (as per one of the posted answers):</p>

<pre><code>&lt;system.web&gt;
    &lt;trust level="Full" /&gt;
&lt;system.web&gt;
</code></pre>

<p>and now it <em>is</em> working! Still, something to look into further another day I think.</p>

<h3>For the curious</h3>

<p>The project I've been talking about is publicly accessible at BitBucket but I'm yet to sort out a decent Readme for it and I'm hoping to write some posts about its development, its use so far and a range of examples - watch this space! <a href="https://bitbucket.org/DanRoberts/full-text-indexer">Full Text Indexer BitBucket repo</a></p>

<p><strong>Update (17th December 2012):</strong> This has been included as part of a later <a href="/the-full-text-indexer-post-roundup">Full Text Indexer Round-up Post</a> that brings together several Posts into one series, incorporating code and techniques from each of them.</p><p class="PostTime">Posted at 16:01</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/FullTextIndexer" title="17 Posts">FullTextIndexer</a></li><li><a href="/Archive/Tag/LINQ" title="11 Posts">LINQ</a></li></ul></div>
			<p class="Comments">
				<a href="/compiled-linq-expressions-dont-serialise#disqus_thread" data-disqus-identifier="29">Comments</a>
			</p>
	</div>
	<div class="Content ArchiveByTag">
		<h3 class="PostDate">9 June 2012</h3><h2><a id="Post27"></a><a href="/optimising-the-pluralityhandling-normaliser">Optimising the Plurality-Handling Normaliser</a></h2>

<p>In the last post I took a first stab at an <a href="/an-englishlanguage-pluralityhandling-string-normaliser">English-language Plurality-handling String Normaliser</a> to work with a Full Text Indexer research project I'm playing with. I've been using it in conjunction with a normaliser that strips out punctuation from words, replaces accented characters with latin versions (eg. "é" replaced with "e") and lower-cases the content. This originally used a few regular expressions along with some character replacement but I wasn't delighted with the performance, so that was re-written to do one pass through the character and do it all at once and is now running much better. Whether that ties back into my <a href="/css-minification-regular-expressions">I don't like regular expressions</a> ramble well or not I'm not sure :)</p>

<p>The point at which it does the most work is here:</p>

<pre><code>public bool TryToTransform(string value, out string valueTransformed)
{
    if (value == null)
        throw new ArgumentNullException("value");

    if (_matchType == MatchTypeOptions.SuffixOnly)
    {
        var matchedSuffix = _values.FirstOrDefault(
            suffix =&gt; (value.Length &gt; suffix.Length) &amp;&amp; value.EndsWith(suffix)
        );
        if (matchedSuffix != null)
        {
            valueTransformed =
                value.Substring(0, value.Length - matchedSuffix.Length) + _combinedValues;
            return true;
        }
    }
    else
    {
        if (_values.Contains(value))
        {
            valueTransformed = _combinedValues;
            return true;
        }
    }

    valueTransformed = null;
    return false;
}
</code></pre>

<p>The first approach I took was to take out some of the LINQ - it makes it easy to read but I don't actually know for sure what it's doing! I thought it was worth checking if being more explicit about what I want to do would reap any performance benefit.. So the lengths are explicitly checked first (if matching WholeWord then the value length must match the suffix length, if matching SuffixOnly then the value length must be <em>greater</em> than the suffix length) and then count back through the last characters of the input value and ensure that each one matches the suffix. Not <em>quite</em> as readable but no big deal.</p>

<pre><code>public bool TryToTransform(string value, out string valueTransformed)
{
    if (value == null)
        throw new ArgumentNullException("value");

    foreach (var suffix in _values)
    {
        if (_matchType == MatchTypeOptions.WholeWord)
        {
            if (value.Length != suffix.Length)
                continue;
        }
        else if (!(value.Length &gt; suffix.Length))
            continue;

        var matchedSuffixLength = 0;
        for (var index = 0; index &lt; suffix.Length; index++)
        {
            if (value[value.Length - (index + 1)] != suffix[suffix.Length - (index + 1)])
            {
                matchedSuffixLength = 0;
                break;
            }
            matchedSuffixLength++;
        }
        if (matchedSuffixLength == 0)
            continue;

        valueTransformed =
            value.Substring(0, value.Length - matchedSuffixLength) + _combinedValues;
        return true;
    }

    valueTransformed = null;
    return false;
}
</code></pre>

<p>Running a few loops of the All English Words data I mentioned in the <a href="/an-englishlanguage-pluralityhandling-string-normaliser">last post</a> saw an performance improvement (when run in release mode) over 3x - success!</p>

<p>But with what I've been learning about LINQ Expressions over the last year or so (culminating in <a href="/the-artist-previously-known-as-the-automapperbyconstructor">The artist previously known as the AutoMapper-By-Constructor</a> and <a href="https://bitbucket.org/DanRoberts/compilabletypeconverter">The CompilableTypeConverter BitBucket repository</a>) I couldn't help wondering if writing code that would generate expressions that unrolled the comparison loop and pre-generated the combined suffix extensions might not be faster. The only way to find out is to try!</p>

<p>The idea is that it would effectively generate code along the lines of:</p>

<pre><code>if ((value.length &gt; 1)
&amp;&amp; (value[value.length - 1] == 'y'))
    return value.substring(0, value.length - 1) + "[y][ies]";

if ((value.length &gt; 3)
&amp;&amp; (value[value.length - 3] == 'i')
&amp;&amp; (value[value.length - 2] == 'e')
&amp;&amp; (value[value.length - 1] == 's'))
    return value.substring(0, value.length - 3) + "[y][ies]";
</code></pre>

<p>for all of the various plurality suffixes but while still maintaining the ability to easily define new suffix sets. And so, without further ado, I ended up with this:</p>

<pre><code>/// &lt;summary&gt;
/// This will match common strings where one is the plural and the other the singular version
/// of the same word. It not intended to be perfect and may match a few false positives, but
/// it should catch most of the most common cases.
/// &lt;/summary&gt;
[Serializable]
public class EnglishPluralityStringNormaliser : IStringNormaliser
{
    private Func&lt;string, string&gt; _normaliser;
    private IStringNormaliser _optionalPreNormaliser;
    private PreNormaliserWorkOptions _preNormaliserWork;
    public EnglishPluralityStringNormaliser(
        IEnumerable&lt;PluralEntry&gt; plurals,
        IEnumerable&lt;string&gt; fallbackSuffixes,
        IStringNormaliser optionalPreNormaliser,
        PreNormaliserWorkOptions preNormaliserWork)
    {
        if (plurals == null)
            throw new ArgumentNullException("pluralEntries");
        if (fallbackSuffixes == null)
            throw new ArgumentNullException("fallbackSuffixes");
        var allPreNormaliserOptions = (PreNormaliserWorkOptions)0;
        foreach (PreNormaliserWorkOptions option in
            Enum.GetValues(typeof(PreNormaliserWorkOptions)))
        {
            allPreNormaliserOptions = allPreNormaliserOptions | option;
        }
        if ((preNormaliserWork &amp; allPreNormaliserOptions) != preNormaliserWork)
            throw new ArgumentOutOfRangeException("preNormaliserWork");

        _normaliser = GenerateNormaliser(plurals, fallbackSuffixes);
        _optionalPreNormaliser = optionalPreNormaliser;
        _preNormaliserWork = preNormaliserWork;
    }

    public EnglishPluralityStringNormaliser(
        IStringNormaliser optionalPreNormaliser,
        PreNormaliserWorkOptions preNormaliserWork
    ) : this(DefaultPlurals, DefaultFallback, optionalPreNormaliser, preNormaliserWork) { }

    public EnglishPluralityStringNormaliser()
        : this(null, PreNormaliserWorkOptions.PreNormaliserDoesNothing) { }

    public string GetNormalisedString(string value)
    {
        if (value == null)
            throw new ArgumentNullException("value");

        // If an additional normaliser was specified in the constructor then process the
        // string with that first (eg. a normaliser that removes punctuation from values
        // may be beneficial depending upon the the content that may be passed in)
        if (_optionalPreNormaliser != null)
            value = _optionalPreNormaliser.GetNormalisedString(value);

        if ((_preNormaliserWork &amp; PreNormaliserWorkOptions.PreNormaliserTrims)
        != PreNormaliserWorkOptions.PreNormaliserTrims)
            value = value.Trim();
        if (value == "")
            return "";

        // We have to lower case the trimmed value since the suffixes are all stored as
        // lower case values
        if ((_preNormaliserWork &amp; PreNormaliserWorkOptions.PreNormaliserLowerCases)
        != PreNormaliserWorkOptions.PreNormaliserLowerCases)
            value = value.ToLower();
        return _normaliser(value);
    }

    public bool Equals(string x, string y)
    {
        if (x == null)
            throw new ArgumentNullException("x");
        if (y == null)
            throw new ArgumentNullException("y");

        return GetNormalisedString(x) == GetNormalisedString(y);
    }

    public int GetHashCode(string obj)
    {
        if (obj == null)
            throw new ArgumentNullException("obj");

        return GetNormalisedString(obj).GetHashCode();
    }

    private static Func&lt;string, string&gt; GenerateNormaliser(
        IEnumerable&lt;PluralEntry&gt; plurals,
        IEnumerable&lt;string&gt; fallbackSuffixes)
    {
        if (plurals == null)
            throw new ArgumentNullException("pluralEntries");
        if (fallbackSuffixes == null)
            throw new ArgumentNullException("fallbackSuffixes");

        // Build up if statements for each suffix - if a match is found, return the input
        // value with the matched suffix replaced with a combination of all the other
        // suffixes in PluralEntry
        var result = Expression.Parameter(typeof(string), "result");
        var endLabel = Expression.Label(typeof(string));
        var valueTrimmed = Expression.Parameter(typeof(string), "valueTrimmed");
        var expressions = new List&lt;Expression&gt;();
        foreach (var plural in plurals)
        {
            if (plural == null)
                throw new ArgumentException("Null reference encountered in plurals set");

            foreach (var suffix in plural.Values)
            {
                var assignNormalisedValueToResult = Expression.Assign(
                    result,
                    GenerateStringConcatExpression(
                        GenerateRemoveLastCharactersExpression(valueTrimmed, suffix.Length),
                        Expression.Constant(
                            CreateSuffixExtension(plural.Values),
                            typeof(string)
                        )
                    )
                );
                expressions.Add(
                    Expression.IfThen(
                        GeneratePredicate(suffix, valueTrimmed, plural.MatchType),
                        Expression.Block(
                            assignNormalisedValueToResult,
                            Expression.Return(endLabel, result)
                        )
                    )
                );
            }
        }

        // If any fallback suffixes are specified, add a statement to append them if none
        // of the PluralEntry matches are made
        fallbackSuffixes = TidyStringList(fallbackSuffixes, v =&gt; v.Trim().ToLower());
        if (fallbackSuffixes.Any())
        {
            expressions.Add(
                Expression.Assign(
                    result,
                    GenerateStringConcatExpression(
                        valueTrimmed,
                        Expression.Constant(
                            CreateSuffixExtension(fallbackSuffixes),
                            typeof(string)
                        )
                    )
                )
            );
        }
        else
            expressions.Add(Expression.Assign(result, valueTrimmed));

        // Add the return-point label, configured to return the string value in "result"
        expressions.Add(Expression.Label(endLabel, result));

        return Expression.Lambda&lt;Func&lt;string, string&gt;&gt;(
            Expression.Block(
                new[] { result },
                expressions
            ),
            valueTrimmed
        ).Compile();
    }

    /// &lt;summary&gt;
    /// Generate an expression that determines whether a string parameter matches a specified
    /// suffix / matchType combination
    /// &lt;/summary&gt;
    private static Expression GeneratePredicate(
        string suffix,
        ParameterExpression valueTrimmed,
        MatchTypeOptions matchType)
    {
        if (string.IsNullOrWhiteSpace(suffix))
            throw new ArgumentException("Null/blank suffix specified");
        if (valueTrimmed == null)
            throw new ArgumentNullException("valueTrimmed");
        if (!Enum.IsDefined(typeof(MatchTypeOptions), matchType))
            throw new ArgumentOutOfRangeException("matchType");

        suffix = suffix.Trim();

        var conditionElements = new List&lt;Expression&gt;();
        var lengthProperty = typeof(string).GetProperty("Length");
        var indexedProperty = typeof(string).GetProperties().First(
            p =&gt; (p.GetIndexParameters() ?? new ParameterInfo[0]).Any()
        );
        if (matchType == MatchTypeOptions.SuffixOnly)
        {
            conditionElements.Add(
                Expression.GreaterThan(
                    Expression.Property(valueTrimmed, lengthProperty),
                    Expression.Constant(suffix.Length, typeof(int))
                )
            );
        }
        else
        {
            conditionElements.Add(
                Expression.Equal(
                    Expression.Property(valueTrimmed, lengthProperty),
                    Expression.Constant(suffix.Length, typeof(int))
                )
            );
        }
        for (var index = 0; index &lt; suffix.Length; index++)
        {
            conditionElements.Add(
                Expression.Equal(
                    Expression.Constant(suffix[index], typeof(char)),
                    Expression.Property(
                        valueTrimmed,
                        indexedProperty,
                        Expression.Subtract(
                            Expression.Property(valueTrimmed, lengthProperty),
                            Expression.Constant(suffix.Length - index, typeof(int))
                        )
                    )
                )
            );
        }
        return CombineExpressionsWithAndAlso(conditionElements);
    }

    private static Expression CombineExpressionsWithAndAlso(
        IEnumerable&lt;Expression&gt; expressions)
    {
        if (expressions == null)
            throw new ArgumentNullException("expressions");

        var expressionsTidied = new List&lt;Expression&gt;();
        foreach (var expression in expressions)
        {
            if (expression == null)
                throw new ArgumentException("Null reference encountered in expressions set");
            expressionsTidied.Add(expression);
        }
        if (!expressionsTidied.Any())
            throw new Exception("No entries in expressions set");
        else if (expressionsTidied.Count == 1)
            return expressionsTidied[0];

        var reducedExpressions = new List&lt;Expression&gt;();
        for (var index = 0; index &lt; expressionsTidied.Count; index += 2)
        {
            var expression = expressionsTidied[index];
            if (index &lt; (expressionsTidied.Count - 1))
            {
                var expressionNext = expressionsTidied[index + 1];
                reducedExpressions.Add(Expression.AndAlso(expression, expressionNext));
            }
            else
                reducedExpressions.Add(expression);
        }

        return (reducedExpressions.Count == 1)
            ? reducedExpressions[0]
            : CombineExpressionsWithAndAlso(reducedExpressions);
    }

    /// &lt;summary&gt;
    /// The value Expression must represent a non-null string that is as at least as long as
    /// the specified length or an exception will
    /// be thrown upon exection
    /// &lt;/summary&gt;
    private static Expression GenerateRemoveLastCharactersExpression(
        Expression value,
        int length)
    {
        if (value == null)
            throw new ArgumentNullException("value");
        if (length &lt; 0)
            throw new ArgumentOutOfRangeException("length");

        return Expression.Call(
            value,
            typeof(string).GetMethod("Substring", new[] { typeof(int), typeof(int) }),
            Expression.Constant(0),
            Expression.Subtract(
                Expression.Property(value, typeof(string).GetProperty("Length")),
                Expression.Constant(length, typeof(int))
            )
        );
    }

    /// &lt;summary&gt;
    /// The values Expressions must represent strings otherwise the expression will fail when
    /// executed
    /// &lt;/summary&gt;
    private static Expression GenerateStringConcatExpression(params Expression[] values)
    {
        if (values == null)
            throw new ArgumentNullException("values");

        var valuesTidied = values.ToList();
        if (!valuesTidied.Any())
            throw new ArgumentException("No entries in values set");
        if (valuesTidied.Any(v =&gt; v == null))
            throw new ArgumentException("Null reference encountered in values set");

        return Expression.Call(
            typeof(string).GetMethod("Concat", new[] { typeof(string[]) }),
            Expression.NewArrayInit(
                typeof(string),
                valuesTidied
            )
        );
    }

    private static string CreateSuffixExtension(IEnumerable&lt;string&gt; suffixes)
    {
        if (suffixes == null)
            throw new ArgumentNullException("suffixes");

        var suffixesTidied = suffixes.ToList();
        if (!suffixesTidied.Any())
            throw new ArgumentException("No entries in suffixes set");
        if (suffixesTidied.Any(s =&gt; string.IsNullOrWhiteSpace(s)))
            throw new ArgumentException("Null/blank entry encountered in suffixes set");

        return "|" + string.Join("|", suffixesTidied.Select(s =&gt; s.Trim()));
    }

    /// &lt;summary&gt;
    /// Given a set of values, ensure that none are null and return them de-duplicated after
    /// having been pushed through a string manipulation. This will throw an exception for
    /// null arguments or if any null value is encountered in the values set.
    /// &lt;/summary&gt;
    private static IEnumerable&lt;string&gt; TidyStringList(
        IEnumerable&lt;string&gt; values,
        Func&lt;string, string&gt; transformer)
    {
        if (values == null)
            throw new ArgumentNullException("values");
        if (transformer == null)
            throw new ArgumentNullException("transformer");

        var valuesTidied = new List&lt;string&gt;();
        foreach (var value in values)
        {
            if (value == null)
                throw new ArgumentException("Null entry encountered in values");

            var valueToStore = transformer(value);
            if (!valuesTidied.Contains(valueToStore))
                valuesTidied.Add(valueToStore);
        }
        return valuesTidied.Distinct();
    }

    public readonly static IEnumerable&lt;string&gt; DefaultFallback = new[] { "ses", "es", "s" };
    public readonly static PluralEntry[] DefaultPlurals = new[]
    {
        // eg. formula / formulae / formulas
        new PluralEntry(new[] { "ula", "ulae", "ulas" }, MatchTypeOptions.SuffixOnly),

        // eg. category / categories
        new PluralEntry(new[] { "y", "ies" }, MatchTypeOptions.SuffixOnly),

        // eg. cactus / cactii
        new PluralEntry(new[] { "us", "ii" }, MatchTypeOptions.SuffixOnly),

        // eg. child / children
        new PluralEntry(new[] { "ld", "ldren" }, MatchTypeOptions.SuffixOnly),

        // eg. medium / media
        new PluralEntry(new[] { "ium", "ia" }, MatchTypeOptions.SuffixOnly),

        // Common special cases that have to come before the "ses", es", "s" form
        new PluralEntry(new[] { "index", "indexes", "indices" }, MatchTypeOptions.WholeWord),
        new PluralEntry(new[] { "matrix", "matrices" }, MatchTypeOptions.WholeWord),
        new PluralEntry(new[] { "vertex", "vertices" }, MatchTypeOptions.WholeWord),

        // eg. Abacuses, matching "s" here means we must use "ses", "es" AND "s" as fallbacks
        new PluralEntry(new[] { "ses", "es", "s" }, MatchTypeOptions.SuffixOnly),

        // Other common special cases
        new PluralEntry(new[] { "datum", "data" }, MatchTypeOptions.WholeWord),
        new PluralEntry(new[] { "man", "men" }, MatchTypeOptions.WholeWord),
        new PluralEntry(new[] { "woman", "women" }, MatchTypeOptions.WholeWord)
    };

    [Serializable]
    public class PluralEntry
    {
        public PluralEntry(IEnumerable&lt;string&gt; values, MatchTypeOptions matchType)
        {
            if (values == null)
                throw new ArgumentNullException("values");
            if (!Enum.IsDefined(typeof(MatchTypeOptions), matchType))
                throw new ArgumentOutOfRangeException("matchType");

            var valuesTidied = TidyStringList(values, v =&gt; v.Trim().ToLower());
            if (!valuesTidied.Any())
                throw new ArgumentException("No entries in values set");

            Values = valuesTidied.Distinct().ToList().AsReadOnly();
            MatchType = matchType;
        }

        /// &lt;summary&gt;
        /// This will never be null or an empty set, nor will it contain any null, empty or
        /// duplicate values (all values are lower-cased and trimmed)
        /// &lt;/summary&gt;
        public ReadOnlyCollection&lt;string&gt; Values { get; private set; }

        public MatchTypeOptions MatchType { get; private set; }
    }

    [Serializable]
    public enum MatchTypeOptions
    {
        SuffixOnly,
        WholeWord
    }
}
</code></pre>

<p>It still takes me a far while to craft the generation LINQ Expressions but I do think that once written the resulting code is actually fairly easy to follow. For each suffix in a "PluralEntry" (where the PluralEntry might describe the group "y", "ies" as a SuffixOnly extension - as clearly seen in the <a href="/an-englishlanguage-pluralityhandling-string-normaliser">last post</a>) a predicate is generated with LINQ Expressions that compares the input string's length and each of the characters that could correlate with the suffix string. Very similar to inside the loop of the first optimisation at the top of this post. An IfThen Expression will consider this predicate and - if matched - generate result that removes the suffix from the input value and appends a combined string consisting of the the suffix values in the group before jumping to the end of the Expression block (effectively "returning" out of the block). Again, just like the setting of the valueTransformed string in the earlier code. If none of the suffix groups are found to match then it will append a default set of suffixes, so that "cat" is transformed to "cat|s|es|ses" in order to match "cats" which would also be transformed to "cat|s|es|ses", for example.</p>

<p>There are couple of oddities in the code - I struggled for a while to find a nice way to access characters by index in a string since the ArrayAccess Expressions can't be used since a string isn't <em>technically</em> an array of characters; you have to first use reflection to get hold of the indexed property of the string type, there's only one so that must be the property we want to access! When comparing the string length and the individual characters, the Expressions are combined with the AndAlso Expression as this ensures that short-circuiting of the conditions is utilised - as soon as one condition is not met, any further ones are ignored.</p>

<p>This brought on another performance improvement of over 3x - success again!</p>

<h3>Additional tweaks</h3>

<p>There are a couple more minor optimisations in the new code that were made with knowledge of how I intended to integrate it. I was intending to use this "DefaultStringNormaliser" mentioned earlier that would trim, lower-case, remove punctuation and replace non-latin characters. This can be passed in as the "optionalPreNormaliser" constructor parameter and will process the string before the plurality normalisation is handled. However, if this "pre-normaliser" is going to trim and lower-case the input then there's no need for the EnglishPluralityStringNormaliser to do it as well! So there's a PreNormaliserWorkOptions enum that allows the instantiator to pass in hints as to whether the optionalPreNormaliser (if any) is going to do any of this work.</p>

<p>Sending a few passes of the All English Words data through an EnglishPluralityStringNormaliser that wraps the DefaultStringNormaliser (code below) with PreNormaliserLowerCases and PreNormaliserTrims specified compared to running it with PreNormaliserDoesNothing (which force the Trim and ToLower calls to be made by the EnglishPluralityStringNormaliser even though the DefaultStringNormaliser has already done this work) resulted in a performance boost of over 1.4x. Not as dramatic, but definitely not to be sniffed at!</p>

<p>There's one final tweak to note; I've switched from appending the suffix groups as "[s][es][ses]" to "|s|es|ses" since I'm intended to store the resulting normalised strings in a Ternary Search Tree (as discussed in <a href="/the-net-dictionary-is-fast">The .Net Dictionary is FAST!</a>) and if the string is shorter then less comparisons have to be made when matching a string in that structure!</p>

<h3>The "Default String Normaliser"</h3>

<p>Since I've made reference a few times to the DefaultStringNormaliser which I've made use of, here's the current code:</p>

<pre><code>/// &lt;summary&gt;
/// This will perform string comparisons where the values have any accented characters
/// replaced with non-accented versions, all whitespace converted to spaces and runs of
/// whitespace replaced with a single space, all punctuation removed and the content
/// then lower-cased.
/// &lt;/summary&gt;
[Serializable]
public sealed class DefaultStringNormaliser : IStringNormaliser
{
    private readonly static HashSet&lt;Char&gt; PunctuationCharacters = new HashSet&lt;char&gt;(
        Enumerable.Range(char.MinValue, char.MaxValue)
            .Select(c =&gt; (char)c)
            .Where(c =&gt; char.IsPunctuation(c))
    );

    public string GetNormalisedString(string value)
    {
        if (value == null)
            throw new ArgumentNullException("value");

        var normalisedValue = value.Normalize(NormalizationForm.FormKD);
        var content = new char[normalisedValue.Length];
        var contentIndex = 0;
        var contentIndexOfLastNonWhitespace = 0;
        var lastCharWasWhitespace = false;
        var gotContent = false;
        for (var index = 0; index &lt; normalisedValue.Length; index++)
        {
            var currentChar = normalisedValue[index];
            if (PunctuationCharacters.Contains(currentChar))
                continue;
            if ((currentChar == '\r') || (currentChar == '\n') || (currentChar == '\t'))
                currentChar = ' ';
            else
            {
                var unicodeCategory = CharUnicodeInfo.GetUnicodeCategory(currentChar);
                if ((unicodeCategory == UnicodeCategory.EnclosingMark)
                || (unicodeCategory == UnicodeCategory.NonSpacingMark)
                || (unicodeCategory == UnicodeCategory.SpacingCombiningMark))
                    currentChar = ' ';
            }
            if (currentChar == ' ')
            {
                if (!lastCharWasWhitespace &amp;&amp; gotContent)
                {
                    content[contentIndex] = currentChar;
                    contentIndex++;
                    lastCharWasWhitespace = true;
                }
                continue;
            }
            if (!char.IsLower(currentChar))
                currentChar = char.ToLower(currentChar);
            content[contentIndex] = currentChar;
            contentIndex++;
            contentIndexOfLastNonWhitespace = contentIndex;
            lastCharWasWhitespace = false;
            gotContent = true;
        }
        return new string(content, 0, contentIndexOfLastNonWhitespace);
    }

    public bool Equals(string x, string y)
    {
        if (x == null)
            throw new ArgumentNullException("x");
        if (y == null)
            throw new ArgumentNullException("y");

        return GetNormalisedString(x) == GetNormalisedString(y);
    }

    public int GetHashCode(string obj)
    {
        if (obj == null)
            throw new ArgumentNullException("obj");

        return GetNormalisedString(obj).GetHashCode();
    }
}
</code></pre>

<h3>Conclusion</h3>

<p>I'm still a firm believer in writing the code to work and be easily understood and maintained first. But when a section of code is measurably a bottleneck, and that bottleneck is worth removing, then little adventures like this can be fun <em>and</em> beneficial! And, to be honest, I don't think the resulting code is <em>that</em> difficult to understand. There are probably a few more tweaks that could be made to really eke out some more performance but I'm perfectly happy with it for now :)</p>

<p><strong>Update (17th December 2012):</strong> This has been included as part of a later <a href="/the-full-text-indexer-post-roundup">Full Text Indexer Round-up Post</a> that brings together several Posts into one series, incorporating code and techniques from each of them.</p><p class="PostTime">Posted at 00:04</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/FullTextIndexer" title="17 Posts">FullTextIndexer</a></li><li><a href="/Archive/Tag/LINQ" title="11 Posts">LINQ</a></li><li><a href="/Archive/Tag/Optimisation" title="8 Posts">Optimisation</a></li></ul></div>
			<p class="Comments">
				<a href="/optimising-the-pluralityhandling-normaliser#disqus_thread" data-disqus-identifier="27">Comments</a>
			</p>
	</div>
	<div class="Content ArchiveByTag">
		<h3 class="PostDate">26 February 2012</h3><h2><a id="Post23"></a><a href="/the-artist-previously-known-as-the-automapperbyconstructor">The artist previously known as the AutoMapper-By-Constructor</a></h2>

<p>I've had a series of posts that was initiated by a desire to integrate AutoMapper more easily with classes that are instantiated with so-called "verbose constructors"..</p>

<ul>
<li><a href="/teaching-automapper-about-verbose-constructors">Teaching AutoMapper about "verbose constructors"</a></li>
<li><a href="/automapperbyconstructor-without-automapper-and-faster">AutoMapper-By-Constructor without AutoMapper.. and faster</a></li>
<li><a href="/extendable-linqcompilable-mappers">Extendable LINQ-compilable Mappers</a></li>
<li><a href="/the-lesseffort-extendable-linqcompilable-mappers">The Less-Effort Extendable LINQ-compilable Mappers</a></li>
</ul>

<p>.. that ended up going on somewhat of a tangent and enabled the generation of compilable converters (using LINQ Expressions) that didn't utilise AutoMapper for the majority of simple cases.</p>

<p>While the original intention of the project was to handle the conversion to these "verbose constructor"-based types, it struck me a few days ago that it shouldn't be much work to put together a class similar to the CompilableTypeConverterByConstructor that instead instantiates a type with a parameter-less constructor and sets the data through property-setters rather than by converter. The concept that started this all off in my head was a service that exposed xml-serialisable objects at the boundary but used "always-valid" internal representations (ie. immutable data where all values were specified and validated by constructor) - I wanted a way to convert <em>to</em> internal types. But with this property-setting approach the code could transform both ways.</p>

<p>(Just a quick side-node that for transformations <em>to</em> data-set-by-property types, <a href="http://automapper.org">AutoMapper</a> is actually a much more full-featured package but for what I had in mind the simple name-matching in my project coupled with the significantly improved performance from the compiled converters was a better fit).</p>

<h3>I still find LINQ Expressions hard to write</h3>

<p>I envisaged something along the lines of a new class</p>

<pre><code>public class CompilableTypeConverterByPropertySetting&lt;TSource, TDest&gt;
    : ICompilableTypeConverter&lt;TSource, TDest&gt; where TDest : new()
{
    public CompilableTypeConverterByPropertySetting(
        IEnumerable&lt;ICompilablePropertyGetter&gt; propertyGetters,
        IEnumerable&lt;PropertyInfo&gt; propertiesToSet)
    {
        // Do constructor work..
</code></pre>

<p>where the number of propertyGetters would match the number of propertiesToSet. I won't go back over the ICompilableTypeConverter since it's not that important right this second but the property getters are:</p>

<pre><code>public interface ICompilablePropertyGetter : IPropertyGetter
{
    /// &lt;summary&gt;
    /// This must return a Linq Expression that retrieves the value from SrcType.Property as
    /// TargetType - the specified "param" Expression must have a type that is assignable to
    /// SrcType.
    /// &lt;/summary&gt;
    Expression GetPropertyGetterExpression(Expression param);
}

public interface IPropertyGetter
{
    /// &lt;summary&gt;
    /// The type whose property is being accessed
    /// &lt;/summary&gt;
    Type SrcType { get; }

    /// &lt;summary&gt;
    /// The property on the source type whose value is to be retrieved
    /// &lt;/summary&gt;
    PropertyInfo Property { get; }

    /// &lt;summary&gt;
    /// The type that the property value should be converted to and returned as
    /// &lt;/summary&gt;
    Type TargetType { get; }

    /// &lt;summary&gt;
    /// Try to retrieve the value of the specified Property from the specified object (which
    /// must be of type SrcType) - this will throw an exception for null or if retrieval fails
    /// &lt;/summary&gt;
    object GetValue(object src);
}
</code></pre>

<p>So this should be easy! All I need is to create LINQ Expressions that can take a ParameterExpression of type TSource, use it to instantiate a new TDest and set each of the properties that I already have. And I've already got Expressions to retrieve the data from the TSource instance for each of the properties!</p>

<pre><code>private Func&lt;TSource, TDest&gt; GenerateCompiledConverter()
{
    // Declare an expression to represent the src parameter
    var src = Expression.Parameter(typeof(TSource), "src");

    // Declare a local variable that will be used within the Expression block to have a new
    // instance assigned to it and properties set
    var dest = Expression.Parameter(typeof(TDest));

    // Build up a list of Expressions that:
    // 1. Instantiate a new TDest instance
    var newInstanceGenerationExpressions = new List&lt;Expression&gt;
    {
        Expression.Assign(
            dest,
            Expression.New(typeof(TDest).GetConstructor(new Type[0]))
        )
    };

    // 2 Set properties on the new instance
    for (var index = 0; index &lt; _propertiesToSet.Count; index++)
    {
        newInstanceGenerationExpressions.Add(
            Expression.Call(
                dest,
                _propertiesToSet[index].GetSetMethod(),
                _propertyGetters[index].GetPropertyGetterExpression(src)
            )
        );
    }

    // 3. Return the reference
    newInstanceGenerationExpressions.Add(
        dest
    );

    // Return compiled expression that instantiates a new object by retrieving properties
    // from the source and passing as constructor arguments
    return Expression.Lambda&lt;Func&lt;TSource, TDest&gt;&gt;(
        Expression.Block(
            new[] { dest },
            newInstanceGenerationExpressions
        ),
        src
    ).Compile();
}
</code></pre>

<p>(Take it as read that _propertiesToSet and _propertyGetters are PropertyInfo[] and ICompilablePropertyGetter[] that are validated and set as class-scoped members by the constructor).</p>

<p>And indeed it <em>does</em> look easy! And I'm kinda wondering what all the fuss was about, but it took me a fair bit of tinkering and reasoning to get here since the LINQ Expression tutorials and examples just aren't that easy to track down! And it's not like you can easily take apart arbitrary example code like when dealing with IL (see the IL Disassembler mention in <a href="/dynamically-applying-interfaces-to-objects">Dynamically applying interfaces to objects</a>).</p>

<p>But I got there in the end! The only slightly odd thing is that the last expression has to be the ParameterExpression "dest" that we've constructed, otherwise the block won't return anything - it just returns the result of the last expression.</p>

<p>Ok. I've actually lied. That <em>isn't</em> quite all of it. As an ICompilableTypeConverter, the CompilableTypeConverterByPropertySetting should be able to handle null values so that the CompilableTypeConverterPropertyGetter class can take any ICompilableTypeConverter reference and use it to retrieve and convert property values.. even when they're null. So the last section becomes:</p>

<pre><code>    // Return compiled expression that instantiates a new object by retrieving properties
    // from the source and passing as constructor arguments
    return Expression.Lambda&lt;Func&lt;TSource, TDest&gt;&gt;(

        Expression.Condition
            Expression.Equal(
                src,
                Expression.Constant(null)
            ),
            Expression.Constant(default(TDest), typeof(TDest)),
            Expression.Block(
                new[] { dest },
                newInstanceGenerationExpressions
            )
        ),

        src

    ).Compile();
</code></pre>

<p>.. so that it will return the default value to TDest (null unless TDest is a ValueType) if the TSource value is null.</p>

<h3>Wrapping in a Factory</h3>

<p>As with the similar CompilableTypeConverterByConstructor class there's a factory class which will examine given TSource and TDest types and try to generate a CompilableTypeConverterByPropertySetting&lt;TSource, TDest&gt; instance based on the ICompilablePropertyGetter set it has (and the INameMatcher for matching source and destination properties).</p>

<p>I've also updated the ExtendableCompilableTypeConverterFactory (see <a href="/the-lesseffort-extendable-linqcompilable-mappers">The Less-Effort Extendable LINQ-compilable Mappers</a>) such that it is more generic and doesn't insist on being based around CompilableTypeConverterByConstructorFactory. There is now a static helper class to instantiate an ExtendableCompilableTypeConverterFactory instance based upon whether the target type is to have its data set by-constructor or by-property-setting since the changes to ExtendableCompilableTypeConverterFactory have made it very abstract!</p>

<h3>Splitting the AutoMapper dependency</h3>

<p>Since the majority of work in this solution no longer requires AutoMapper, I've broken out a separate project "AutoMapperIntegration" which houses the AutoMapperEnabledpropertyGetter and AutoMapperEnabledpropertyGetterFactory classes so now the main project has no AutoMapper reference. My original intention was improve how AutoMapper worked with by-constructor conversions and this functionality is still available - without taking advantage of the compiled converters - by referencing the main project along with AutoMapperItegration (and so the example in <a href="/teaching-automapper-about-verbose-constructors">Teaching AutoMapper about "verbose constructors"</a> is still applicable).</p>

<p>And so I've renamed the solution itself to...</p>

<h3>The Compilable Type Converter!</h3>

<p>Yeah, yeah, not too imaginative a title, I will admit! :)</p>

<p>I've actually moved my code over to BitBucket (see <a href="/being-a-dirty-githubtobitbucket-turncoat">upcoming post</a>!) from GitHub, so the code that I've been talking about can now be found at:</p>

<p><a href="https://bitbucket.org/DanRoberts/compilabletypeconverter">https://bitbucket.org/DanRoberts/compilabletypeconverter</a></p>

<h3>An apology</h3>

<p>This has been a particularly dry and largely self-involved post but if the Compilable Type Converter sounds like it might be useful to you, check out that BitBucket link and there's an introduction on the Overview page which jumps straight into example code.</p>

<h3>Examples</h3>

<p>To demonstrate the generation of a converter from a generic SourceType class to one that is based upon verbose constructors:</p>

<pre><code>// Prepare a converter factory using the base types (AssignableType and
// EnumConversion property getter factories)
var nameMatcher = new CaseInsensitiveSkipUnderscoreNameMatcher();
var converterFactory = ExtendableCompilableTypeConverterFactoryHelpers.GenerateConstructorBasedFactory(
    nameMatcher,
    new ArgsLengthTypeConverterPrioritiserFactory(),
    new ICompilablePropertyGetterFactory[]
    {
        new CompilableAssignableTypesPropertyGetterFactory(nameMatcher),
        new CompilableEnumConversionPropertyGetterFactory(nameMatcher)
    }
);

// Extend the converter to handle SourceType.Sub1 to ConstructorDestType.Sub1 and
// IEnumerable&lt;SourceType.Sub1&gt; to IEnumerable&lt;ConstructorDestType.Sub1&gt;
// - This will raise an exception if unable to create the mapping
converterFactory = converterFactory.CreateMap&lt;SourceType.Sub1, ConstructorDestType.Sub1&gt;();

// This will enable the creation of a converter for SourceType to ConstructorDestType
// - This will return null if unable to generate an appropriate converter
var converter = converterFactory.Get&lt;SourceType, ConstructorDestType&gt;();
if (converter == null)
    throw new Exception("Unable to obtain a converter");

var result = converter.Convert(new SourceType()
{
    Value = new SourceType.Sub1() { Name = "Bo1" },
    ValueList = new[]
    {
        new SourceType.Sub1() { Name = "Bo2" },
        null,
        new SourceType.Sub1() { Name = "Bo3" }
    },
    ValueEnum = SourceType.Sub2.EnumValue2
});

public class SourceType
{
    public Sub1 Value { get; set; }
    public IEnumerable&lt;Sub1&gt; ValueList { get; set; }
    public Sub2 ValueEnum { get; set; }
    public class Sub1
    {
        public string Name { get; set; }
    }
    public enum Sub2
    {
        EnumValue1,
        EnumValue2,
        EnumValue3,
        EnumValue4,
        EnumValue5,
        EnumValue6,
        EnumValue7,
        EnumValue8
    }
}

public class ConstructorDestType
{
    public ConstructorDestType(Sub1 value, IEnumerable&lt;Sub1&gt; valueList, Sub2 valueEnum)
    {
        if (value == null)
            throw new ArgumentNullException("value");
        if (valueList == null)
            throw new ArgumentNullException("valueList");
        if (!Enum.IsDefined(typeof(Sub2), valueEnum))
            throw new ArgumentOutOfRangeException("valueEnum");
        Value = value;
        ValueList = valueList;
        ValueEnum = valueEnum;
    }
    public Sub1 Value { get; private set; }
    public IEnumerable&lt;Sub1&gt; ValueList { get; private set; }
    public Sub2 ValueEnum { get; private set; }
    public class Sub1
    {
        public Sub1(string name)
        {
            name = (name ?? "").Trim();
            if (name == "")
                throw new ArgumentException("Null/empty name specified");
            Name = name;
        }
        public string Name { get; private set; }
    }
    public enum Sub2 : uint
    {
        EnumValue1 = 99,
        EnumValue2 = 100,
        EnumValue3 = 101,
        EnumValue4 = 102,
        EnumValue5 = 103,
        enumValue_6 = 104,
        EnumValue7 = 105
    }
}
</code></pre>

<p>.. and the equivalent where the destination types are based upon property-setting:</p>

<pre><code>// Prepare a converter factory using the base types (AssignableType and EnumConversion property
// getter factories)
var nameMatcher = new CaseInsensitiveSkipUnderscoreNameMatcher();
var converterFactory = ExtendableCompilableTypeConverterFactoryHelpers.GeneratePropertySetterBasedFactory(
    nameMatcher,
    CompilableTypeConverterByPropertySettingFactory.PropertySettingTypeOptions.MatchAsManyAsPossible,
    new ICompilablePropertyGetterFactory[]
    {
        new CompilableAssignableTypesPropertyGetterFactory(nameMatcher),
        new CompilableEnumConversionPropertyGetterFactory(nameMatcher)
    }
);

// Extend the converter to handle SourceType.Sub1 to ConstructorDestType.Sub1 and
// IEnumerable&lt;SourceType.Sub1&gt; to IEnumerable&lt;ConstructorDestType.Sub1&gt;
// - This will raise an exception if unable to create the mapping
converterFactory = converterFactory.CreateMap&lt;SourceType.Sub1, PropertySettingDestType.Sub1&gt;();

// This will enable the creation of a converter for SourceType to ConstructorDestType
// - This will return null if unable to generate an appropriate converter
var converter = converterFactory.Get&lt;SourceType, PropertySettingDestType&gt;();
if (converter == null)
    throw new Exception("Unable to obtain a converter");

var result = converter.Convert(new SourceType()
{
    Value = new SourceType.Sub1() { Name = "Bo1" },
    ValueList = new[]
    {
        new SourceType.Sub1() { Name = "Bo2" },
        null,
        new SourceType.Sub1() { Name = "Bo3" }
    },
    ValueEnum = SourceType.Sub2.EnumValue2
});

public class SourceType
{
    public Sub1 Value { get; set; }
    public IEnumerable&lt;Sub1&gt; ValueList { get; set; }
    public Sub2 ValueEnum { get; set; }
    public class Sub1
    {
        public string Name { get; set; }
    }
    public enum Sub2
    {
        EnumValue1,
        EnumValue2,
        EnumValue3,
        EnumValue4,
        EnumValue5,
        EnumValue6,
        EnumValue7,
        EnumValue8
    }
}

public class PropertySettingDestType
{
    public Sub1 Value { get; set; }
    public IEnumerable&lt;Sub1&gt; ValueList { get; set; }
    public Sub2 ValueEnum { get; set; }
    public class Sub1
    {
        public string Name { get; set; }
    }
    public enum Sub2 : uint
    {
        EnumValue1 = 99,
        EnumValue2 = 100,
        EnumValue3 = 101,
        EnumValue4 = 102,
        EnumValue5 = 103,
        enumValue_6 = 104,
        EnumValue7 = 105
    }
}
</code></pre><p class="PostTime">Posted at 21:39</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/AutoMapper" title="8 Posts">AutoMapper</a></li><li><a href="/Archive/Tag/LINQ" title="11 Posts">LINQ</a></li><li><a href="/Archive/Tag/Reflection" title="14 Posts">Reflection</a></li></ul></div>
			<p class="Comments">
				<a href="/the-artist-previously-known-as-the-automapperbyconstructor#disqus_thread" data-disqus-identifier="23">Comments</a>
			</p>
	</div>
	<div class="Content ArchiveByTag">
		<h3 class="PostDate">3 January 2012</h3><h2><a id="Post19"></a><a href="/the-lesseffort-extendable-linqcompilable-mappers">The Less-Effort Extendable LINQ-compilable Mappers</a></h2>

<p>The <a href="/extendable-linqcompilable-mappers">last post</a> almost finished off something I originally started back last April and enabled the creation of Compilable Type Converters which take properties from a source type and feed them in as constructor arguments on a destination type.</p>

<p>The only issue I had is that the final code to set up conversions was a bit verbose. To create a Converter from SourceEmployee to DestEmployee -</p>

<pre><code>public class SourceEmployee
{
    public string Name { get; set; }
    public SourceRole Role { get; set; }
}

public class SourceRole
{
    public string Description { get; set; }
}

public class DestEmployee
{
    public DestEmployee(string name, DestRole role)
    {
        Name = name;
        Role = role;
    }
    public string Name { get; private set; }
    public DestRole Role { get; private set; }
}

public class DestRole
{
    public DestRole(string description)
    {
        Description = description;
    }
    public string Description { get; private set; }
}
</code></pre>

<p>the following code was required:</p>

<pre><code>var nameMatcher = new CaseInsensitiveSkipUnderscoreNameMatcher();

var roleConverterFactory = new CompilableTypeConverterByConstructorFactory(
    new ArgsLengthTypeConverterPrioritiserFactory(),
    new CombinedCompilablePropertyGetterFactory(
        new ICompilablePropertyGetterFactory[]
        {
            new CompilableAssignableTypesPropertyGetterFactory(nameMatcher),
            new CompilableEnumConversionPropertyGetterFactory(nameMatcher)
        }
    )
);

var employeeConverterFactory = new CompilableTypeConverterByConstructorFactory(
    new ArgsLengthTypeConverterPrioritiserFactory(),
    new CombinedCompilablePropertyGetterFactory(
        new ICompilablePropertyGetterFactory[]
        {
            new CompilableAssignableTypesPropertyGetterFactory(nameMatcher),
            new CompilableEnumConversionPropertyGetterFactory(nameMatcher),
            new CompilableTypeConverterPropertyGetterFactory&lt;SourceRole, DestRole&gt;(
                nameMatcher,
                roleConverterFactory.Get&lt;SourceRole, DestRole&gt;()
            )
        }
    )
);

var employeeConverter = employeeConverterFactory.Get&lt;SourceEmployee, DestEmployee&gt;();
</code></pre>

<p>For more complicated type graphs this could quickly get tiring! What I <em>really</em> wanted to do was this:</p>

<pre><code>var nameMatcher = new CaseInsensitiveSkipUnderscoreNameMatcher();
var converterFactory = new ExtendableCompilableTypeConverterFactory(
    nameMatcher,
    new ArgsLengthTypeConverterPrioritiserFactory(),
    new ICompilablePropertyGetterFactory[]
    {
        new CompilableAssignableTypesPropertyGetterFactory(nameMatcher),
        new CompilableEnumConversionPropertyGetterFactory(nameMatcher)
    }
);
converterFactory = converterFactory.CreateMap&lt;SourceRole, DestRole&gt;();
var converter = converterFactory.Get&lt;SourceEmployee, DestEmployee&gt;();
</code></pre>

<h3>The ExtendableCompilableTypeConverterFactory</h3>

<p>This class basically wraps up the duplication seen above and returns a new ExtendableCompilableTypeConverterFactory instance each time that CreateMap is successfully called, the new instance having a Compilable Property Getter than can support that mapping. If the CreateMap calls was <em>not</em> successful then an exception will be raised - this will be case if there is no constructor on the destination type whose arguments can all be satisified by properties on the source type (this also covers cases where additional mappings are required for referenced types). This exception is equivalent to the AutoMapperMappingException that AutoMapper throws in similar circumstances.</p>

<p>I'm just going to jump right in with this - if you've been reading this far then this will hold no challenges or surprises.</p>

<pre><code>public class ExtendableCompilableTypeConverterFactory : ICompilableTypeConverterFactory
{
    private INameMatcher _nameMatcher;
    private ITypeConverterPrioritiserFactory _converterPrioritiser;
    private List&lt;ICompilablePropertyGetterFactory&gt; _basePropertyGetterFactories;
    private Lazy&lt;ICompilableTypeConverterFactory&gt; _typeConverterFactory;
    public ExtendableCompilableTypeConverterFactory(
        INameMatcher nameMatcher,
        ITypeConverterPrioritiserFactory converterPrioritiser,
        IEnumerable&lt;ICompilablePropertyGetterFactory&gt; basePropertyGetterFactories)
    {
        if (nameMatcher == null)
            throw new ArgumentNullException("nameMatcher");
        if (converterPrioritiser == null)
            throw new ArgumentNullException("converterPrioritiser");
        if (basePropertyGetterFactories == null)
            throw new ArgumentNullException("basePropertyGetterFactories");

        var basePropertyGetterFactoryList = new List&lt;ICompilablePropertyGetterFactory&gt;();
        foreach (var basePropertyGetterFactory in basePropertyGetterFactories)
        {
            if (basePropertyGetterFactory == null)
                throw new ArgumentException("Null entry encountered in basePropertyGetterFactories");
            basePropertyGetterFactoryList.Add(basePropertyGetterFactory);
        }

        _nameMatcher = nameMatcher;
        _converterPrioritiser = converterPrioritiser;
        _basePropertyGetterFactories = basePropertyGetterFactoryList;
        _typeConverterFactory = new Lazy&lt;ICompilableTypeConverterFactory&gt;(
            getConverterFactory,
            true
        );
    }

    private ICompilableTypeConverterFactory getConverterFactory()
    {
        return new CompilableTypeConverterByConstructorFactory(
            _converterPrioritiser,
            new CombinedCompilablePropertyGetterFactory(_basePropertyGetterFactories)
        );
    }

    /// &lt;summary&gt;
    /// This will return null if a converter could not be generated
    /// &lt;/summary&gt;
    public ICompilableTypeConverterByConstructor&lt;TSource, TDest&gt; Get&lt;TSource, TDest&gt;()
    {
        return _typeConverterFactory.Value.Get&lt;TSource, TDest&gt;();
    }

    ITypeConverter&lt;TSource, TDest&gt; ITypeConverterFactory.Get&lt;TSource, TDest&gt;()
    {
        return Get&lt;TSource, TDest&gt;();
    }

    /// &lt;summary&gt;
    /// This will throw an exception if unable to generate the requested mapping - it will
    /// never return null. If the successful, the returned converter factory will be able
    /// to convert instances of TSourceNew as well as IEnumerable / Lists of them.
    /// &lt;/summary&gt;
    public ExtendableCompilableTypeConverterFactory CreateMap&lt;TSourceNew, TDestNew&gt;()
    {
        // Try to generate a converter for the requested mapping
        var converterNew = _typeConverterFactory.Value.Get&lt;TSourceNew, TDestNew&gt;();
        if (converterNew == null)
            throw new Exception("Unable to create mapping");
        return AddNewConverter&lt;TSourceNew, TDestNew&gt;(converterNew);
    }

    /// &lt;summary&gt;
    /// Generate a further extended converter factory that will be able to handle conversion
    /// of instances of TSourceNew as well as IEnumerable / Lists of them. This will never
    /// return null.
    /// &lt;/summary&gt;
    public ExtendableCompilableTypeConverterFactory AddNewConverter&lt;TSourceNew, TDestNew&gt;(
        ICompilableTypeConverter&lt;TSourceNew, TDestNew&gt; converterNew)
    {
        if (converterNew == null)
            throw new ArgumentNullException("converterNew");

        // Create a property getter factory that retrieves and convert properties using this
        // converter and one that does the same for IEnumerable properties, where the
        // IEnumerables' elements are the types handled by the converter
        var extendedPropertyGetterFactories = new List&lt;ICompilablePropertyGetterFactory&gt;(
            _basePropertyGetterFactories
        );
        extendedPropertyGetterFactories.Add(
            new CompilableTypeConverterPropertyGetterFactory&lt;TSourceNew, TDestNew&gt;(
                _nameMatcher,
                converterNew
            )
        );
        extendedPropertyGetterFactories.Add(
            new ListCompilablePropertyGetterFactory&lt;TSourceNew, TDestNew&gt;(
                _nameMatcher,
                converterNew
            )
        );

        // Return a new ExtendableCompilableTypeConverterFactory that can make use of these
        // new property getter factories
        return new ExtendableCompilableTypeConverterFactory(
            _nameMatcher,
            _converterPrioritiser,
            extendedPropertyGetterFactories
        );
    }
}
</code></pre>

<p>Ok.. except one. I've sprung the ListCompilablePropertyGetterFactory. The ListCompilablePropertyGetter is similar to the CompilableTypeConverterPropertyGetter but will deal with properties and constructor arguments which are IEnumerable&lt;SourceType&gt; and IEnumerable&lt;DestType&gt;, resp.</p>

<p>This means that the ExtendableCompilableTypeConverterFactory setup code above would have worked if the SourceType and DestType were</p>

<pre><code>public class SourceEmployee
{
    public string Name { get; set; }
    public SourceRole[] Role { get; set; }
}

public class DestEmployee
{
    public DestEmployee(string name, IEnumerable&lt;DestRole&gt; role)
    {
        Name = name;
        Role = role;
    }
    public string Name { get; private set; }
    public DestRole Role { get; private set; }
}
</code></pre>

<p>as the CreateMap would return a Converter Factory that could map SourceRole to DestRole <em>and</em> IEnumerable&lt;SourceRole&gt; to IEnumerable&lt;DestRole&gt;.</p>

<h3>CreateMap vs AddNewConverter</h3>

<p>The CreateMap method will try to generate a new Converter and build new Property Getter Factories using that by passing it to AddNewConverter. If you need to add any custom mapping mechanisms then AddNewConverter may be called with an ICompilableTypeConverter.</p>

<p>For example, if our types now looked like</p>

<pre><code>public class SourceEmployee
{
    public int Id { get; set; }
    public string Name { get; set; }
    public SourceRole[] Role { get; set; }
}

public class DestEmployee
{
    public DestEmployee(string id, string name, IEnumerable&lt;DestRole&gt; role)
    {
        Id = id;
        Name = name;
        Role = role;
    }
    public string Id { get; private set; }
    public string Name { get; private set; }
    public DestRole Role { get; private set; }
}
</code></pre>

<p>then we would need a way to translate int to string when the name matcher identifies the potential "Id" to "id" mapping. We could do that with AddNewConverter and a custom ICompilableTypeConverter implementation -</p>

<pre><code>var nameMatcher = new CaseInsensitiveSkipUnderscoreNameMatcher();
var converterFactory = new ExtendableCompilableTypeConverterFactory(
    nameMatcher,
    new ArgsLengthTypeConverterPrioritiserFactory(),
    new ICompilablePropertyGetterFactory[]
    {
        new CompilableAssignableTypesPropertyGetterFactory(nameMatcher),
        new CompilableEnumConversionPropertyGetterFactory(nameMatcher)
    }
);
converterFactory = converterFactory.CreateMap&lt;SourceRole, DestRole&gt;();
converterFactory = converterFactory.AddNewConverter&lt;int, string&gt;(
    new CompilableIntToStringTypeConverter()
);
var converter = converterFactory.Get&lt;SourceEmployee, DestEmployee&gt;();

public class CompilableIntToStringTypeConverter : ICompilableTypeConverter&lt;int, string&gt;
{
    public string Convert(int src)
    {
        return src.ToString();
    }

    public Expression GetTypeConverterExpression(Expression param)
    {
        if (param == null)
            throw new ArgumentNullException("param");
        return Expression.Call(
            param,
            typeof(int).GetMethod("ToString", new Type[0])
        );
    }
}
</code></pre>

<p>See, I promised last time that splitting ICompilableTypeConverter away from ICompilableTypeConverterByConstructor at some point! :)</p>

<h3>Signing off</h3>

<p>This has all turned into a bit of a saga! The final code for all this can be found at</p>

<p><a href="https://github.com/ProductiveRage/AutoMapper-By-Constructor-1/">https://github.com/ProductiveRage/AutoMapper-By-Constructor-1/</a></p>

<p>I've not done <em>loads</em> of performance testing but the generated Converters have consistently been around 1.1 or 1.2 times as slow as hand-rolled code (ie. approximately the same), not including the work required to generate the Converters. Compared to AutoMapper, this is quite a win (which was what originally inspired me to go on this journey). But out of the box it doesn't support all the many configurations that AutoMapper does! My main use case was to map legacy WebService objects (with parameter-less constructors) onto internal objects (with verbose constructors) which is all done. But there's currently no way to map back.. I think that's something to worry about another day! :)</p><p class="PostTime">Posted at 21:52</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/AutoMapper" title="8 Posts">AutoMapper</a></li><li><a href="/Archive/Tag/LINQ" title="11 Posts">LINQ</a></li><li><a href="/Archive/Tag/Reflection" title="14 Posts">Reflection</a></li></ul></div>
			<p class="Comments">
				<a href="/the-lesseffort-extendable-linqcompilable-mappers#disqus_thread" data-disqus-identifier="19">Comments</a>
			</p>
	</div>
	<div class="Content ArchiveByTag">
		<h3 class="PostDate">2 January 2012</h3><h2><a id="Post18"></a><a href="/extendable-linqcompilable-mappers">Extendable LINQ-compilable Mappers</a></h2>

<p>To pick up from where I left off in a <a href="/automapperbyconstructor-without-automapper-and-faster">previous post</a>, I was trying to write something that could automatically generate LINQ Expressions that could translate from (for example) -</p>

<pre><code>public class SourceEmployee
{
    public string Name { get; set; }
    public SourceRole Role { get; set; }
}

public class SourceRole
{
    public string Description { get; set; }
}
</code></pre>

<p>to</p>

<pre><code>public class DestEmployee
{
    public DestEmployee(string name, DestRole role)
    {
        Name = name;
        Role = role;
    }
    public string Name { get; private set; }
    public DestRole Role { get; private set; }
}

public class DestRole
{
    public DestRole(string description)
    {
        Description = description;
    }
    public string Description { get; private set; }
}
</code></pre>

<p>by applying name matching logic between properties on the source types and constructor arguments on the destination types. Having this all performed by LINQ Expressions should allow the final conversion to be comparatively fast to hand-rolled code.</p>

<p>This was all kicked off initially since I was using <a href="http://automapper.codeplex.com/">AutoMapper</a> for some work and wasn't happy with its approach to mapping to types that have to be initialised with verbose constructors (as opposed to a parameter-less constructor and then the setting of individual properties). This much was achieved and the solution can be found here -</p>

<p><a href="https://github.com/ProductiveRage/AutoMapper-By-Constructor-1/tree/FirstImplementation">https://github.com/ProductiveRage/AutoMapper-By-Constructor-1/tree/FirstImplementation</a>.</p>

<p>But I wanted to see if I could improve the performance by removing AutoMapper from the equation and using LINQ Expressions.</p>

<h3>A more detailed recap</h3>

<p>Where we left the code as of</p>

<p><a href="https://github.com/ProductiveRage/AutoMapper-By-Constructor-1/tree/LinqExpressionPropertyGetters">https://github.com/ProductiveRage/AutoMapper-By-Constructor-1/tree/LinqExpressionPropertyGetters</a></p>

<p>we had the class</p>

<pre><code>public class CompilableTypeConverterByConstructor&lt;TSource, TDest&gt;
    : ITypeConverterByConstructor&lt;TSource, TDest&gt;
{
    // ..
    private Lazy&lt;Func&lt;TSource, TDest&gt;&gt; _converter;
    public CompilableTypeConverterByConstructor(
        IEnumerable&lt;ICompilablePropertyGetter&gt; propertyGetters,
        ConstructorInfo constructor)
    {
        // ..
        _converter = new Lazy&lt;Func&lt;TSource, TDest&gt;&gt;(generateCompiledConverter, true);
    }

    public ConstructorInfo Constructor
    {
        get
        {
            // ..
        }
    }

    public TDest Convert(TSource src)
    {
        if (src == null)
            throw new ArgumentNullException("src");

        return _converter.Value(src);
    }

    private Func&lt;TSource, TDest&gt; generateCompiledConverter()
    {
        var srcParameter = Expression.Parameter(typeof(TSource), "src");
        var constructorParameterExpressions = new List&lt;Expression&gt;();
        foreach (var constructorParameter in _constructor.GetParameters())
        {
            var index = constructorParameterExpressions.Count;
            constructorParameterExpressions.Add(
                _propertyGetters[index].GetPropertyGetterExpression(srcParameter)
            );
        }

        return Expression.Lambda&lt;Func&lt;TSource, TDest&gt;&gt;(
            Expression.New(
                _constructor,
                constructorParameterExpressions.ToArray()
            ),
            srcParameter
        ).Compile();
    }
}

public interface ITypeConverterByConstructor&lt;TSource, TDest&gt;
{
    ConstructorInfo Constructor { get; }
    TDest Convert(TSource src);
}
</code></pre>

<p>which took a set of "Compilable Property Getters" that matched the arguments for a specified ConstructorInfo </p>

<pre><code>public interface ICompilablePropertyGetter : IPropertyGetter
{
    Expression GetPropertyGetterExpression(Expression param);
}

public interface IPropertyGetter
{
    Type SrcType { get; }
    PropertyInfo Property { get; }
    Type TargetType { get; }
    object GetValue(object src);
}
</code></pre>

<p>and generated an internal conversion using LINQ Expressions.</p>

<p>There were only two Compilable Property Getters - CompilableAssignableTypesPropertyGetter, which would work with property-to-constructor-arguments where no conversion was required (eg. the available property was a string array and the constructor argument was an IEnumerable&lt;string&gt;) and CompilableEnumConversionPropertyGetter, which mapped one enum to another using an INameMatcher implementation. (The enum mapping LINQ Expression is generated by first coming up with a set of mappings and then generating a LINQ Expression consisting of a set of nested "if" statements for each mapped enum value).</p>

<pre><code>public class CompilableAssignableTypesPropertyGetter&lt;TSourceObject, TPropertyAsRetrieved&gt;
    : AbstractGenericCompilablePropertyGetter&lt;TSourceObject, TPropertyAsRetrieved&gt;
{
    private PropertyInfo _propertyInfo;
    public CompilableAssignableTypesPropertyGetter(PropertyInfo propertyInfo)
    {
        if (propertyInfo == null)
            throw new ArgumentNullException("propertyInfo");
        if (!propertyInfo.DeclaringType.Equals(typeof(TSourceObject)))
            throw new ArgumentException("Invalid propertyInfo - DeclaringType must match TSourceObject");

        _propertyInfo = propertyInfo;
    }

    public override PropertyInfo Property
    {
        get { return _propertyInfo; }
    }

    public override Expression GetPropertyGetterExpression(Expression param)
    {
        if (param == null)
            throw new ArgumentNullException("param");
        if (!typeof(TSourceObject).IsAssignableFrom(param.Type))
            throw new ArgumentException("param.Type must be assignable to typeparam TSourceObject");

        Expression getter = Expression.Property(
            param,
            _propertyInfo
        );

        var targetType = typeof(TPropertyAsRetrieved);
        if (!targetType.IsAssignableFrom(_propertyInfo.PropertyType))
            getter = Expression.Convert(getter, targetType);

        if (!targetType.IsValueType &amp;&amp; _propertyInfo.PropertyType.IsValueType)
            getter = Expression.TypeAs(getter, typeof(object));

        return getter;
    }
}

public abstract class AbstractGenericCompilablePropertyGetter&lt;TSourceObject, TPropertyAsRetrieved&gt;
    : ICompilablePropertyGetter
{
    private Lazy&lt;Func&lt;TSourceObject, TPropertyAsRetrieved&gt;&gt; _getter;
    public AbstractGenericCompilablePropertyGetter()
    {
        _getter = new Lazy&lt;Func&lt;TSourceObject, TPropertyAsRetrieved&gt;&gt;(generateGetter, true);
    }

    public Type SrcType
    {
        get { return typeof(TSourceObject); }
    }

    public abstract PropertyInfo Property { get; }

    public Type TargetType
    {
        get { return typeof(TPropertyAsRetrieved); }
    }

    object IPropertyGetter.GetValue(object src)
    {
        if (src == null)
            throw new ArgumentNullException("src");
        if (!src.GetType().Equals(typeof(TSourceObject)))
            throw new ArgumentException("The type of src must match typeparam TSourceObject");
        return GetValue((TSourceObject)src);
    }

    public TPropertyAsRetrieved GetValue(TSourceObject src)
    {
        if (src == null)
            throw new ArgumentNullException("src");
        return _getter.Value(src);
    }

    public abstract Expression GetPropertyGetterExpression(Expression param);

    private Func&lt;TSourceObject, TPropertyAsRetrieved&gt; generateGetter()
    {
        var param = Expression.Parameter(typeof(TSourceObject), "src");
        return Expression.Lambda&lt;Func&lt;TSourceObject, TPropertyAsRetrieved&gt;&gt;(
            GetPropertyGetterExpression(param),
            param
        ).Compile();
    }
}

public interface ICompilablePropertyGetter : IPropertyGetter
{
    /// &lt;summary&gt;
    /// This Linq Expression will retrieves the value from SrcType.Property as TargetType,
    /// the specified "param" Expression must have a type that is assignable to SrcType.
    /// &lt;/summary&gt;
    Expression GetPropertyGetterExpression(Expression param);
}

public interface IPropertyGetter
{
    /// &lt;summary&gt;
    /// This is the type whose property is being accessed
    /// &lt;/summary&gt;
    Type SrcType { get; }

    /// &lt;summary&gt;
    /// This is the property on the source type whose value is to be retrieved
    /// &lt;/summary&gt;
    PropertyInfo Property { get; }

    /// &lt;summary&gt;
    /// This is the type that the property value should be converted to and returned as
    /// &lt;/summary&gt;
    Type TargetType { get; }

    /// &lt;summary&gt;
    /// Try to retrieve the value of the specified Property from the specified object
    /// (which must be of type SrcType)
    /// &lt;/summary&gt;
    object GetValue(object src);
}
</code></pre>

<p>and to generate instances of these classes we had some factories (CompilableTypeConverterByConstructorFactory, CompilableAssignableTypesPropertyGetterFactory and CompilableEnumConversionPropertyGetterFactory). These would do the work of examining the properties and constructors of specified source and destination type pairs and determining the best constructor that could be satisfied (if any) with the Compilable Property Getters. The code in these factories is none too exciting.</p>

<h3>The problem</h3>

<p>If the mappings we want to generate are for very simple structures (in this case, "simple" means that all property-to-constructor-argument mappings are either directly assignable-to or are enum mappings) then everything's rosy - eg.</p>

<pre><code>public class SourceEmployee
{
    public string Name { get; set; }
    public SourceRole Role { get; set; }
}

public enum SourceRole
{
    big_boss_man,
    worker_bee
}
</code></pre>

<p>to</p>

<pre><code>public class DestEmployee
{
    public DestEmployee(string name, DestRole role)
    {
        Name = name;
        Role = role;
    }
    public string Name { get; private set; }
    public DestRole Role { get; private set; }
}

public enum DestRole
{
    BigBossMan,
    WorkerBee
}
</code></pre>

<p>(The enum mapping in this example would be handled by specifying a CaseInsensitiveSkipUnderscoreNameMatcher for the CompilableEnumConversionPropertyGetterFactory).</p>

<p>But the problem I opened with does <em>not</em> come under this "simple structure" umbrella as in that case SourceRole and DestRole are types for which we have no Compilable Property Getter! Oh nos!</p>

<h3>The CompilableTypeConverterPropertyGetter</h3>

<p>For inspiration, I go back to AutoMapper since it too can not magically handle nested types - </p>

<pre><code>class Program
{
    static void Main(string[] args)
    {
        AutoMapper.Mapper.CreateMap&lt;SourceTypeSub1, DestTypeSub1&gt;();
        AutoMapper.Mapper.CreateMap&lt;SourceType, DestType&gt;();
        var dest = AutoMapper.Mapper.Map&lt;SourceType, DestType&gt;(
            new SourceType()
            {
                Value = new SourceTypeSub1() { Name = "N1" }
            }
        );
    }
}

public class SourceType
{
    public SourceTypeSub1 Value { get; set; }
}

public class SourceTypeSub1
{
    public string Name { get; set; }
}

public class DestType
{
    public DestTypeSub1 Value { get; set; }
}

public class DestTypeSub1
{
    public string Name { get; set; }
}
</code></pre>

<p>without the CreateMap call for SourceTypeSub1 to DestTypeSub1, the Map call from SourceType to DestType would fail with an AutoMapperMappingException.</p>

<p>Following the same tack, a way to create a new Compilable Property Getter from a CompilableTypeConverterByConstructor (which could then be used alongside the existing AssignableType and Enum Compilable Property Getters) should solve the problem. A plan!</p>

<p>Step one is going to be to expose a way to request the LINQ Expression that the CompilableTypeConverterByConstructor uses in its conversion. To address this we'll update CompilableTypeConverterByConstructor to implement a new interface ICompilableTypeConverterByConstructor which in turn implements ITypeConverterByConstructor (which is all that CompilableTypeConverterByConstructor implemented previously) -</p>

<pre><code>public interface ICompilableTypeConverterByConstructor&lt;TSource, TDest&gt;
    : ICompilableTypeConverter&lt;TSource, TDest&gt;,
      ITypeConverterByConstructor&lt;TSource, TDest&gt; { }

public interface ICompilableTypeConverter&lt;TSource, TDest&gt;
    : ITypeConverter&lt;TSource, TDest&gt;
{
    /// &lt;summary&gt;
    /// This Linq Expression will generate a new TDest instance - the specified "param"
    /// Expression must have a type that is assignable to TSource
    /// &lt;/summary&gt;
    Expression GetTypeConverterExpression(Expression param);
}

public interface ITypeConverterByConstructor&lt;TSource, TDest&gt; : ITypeConverter&lt;TSource, TDest&gt;
{
    ConstructorInfo Constructor { get; }
}

public interface ITypeConverter&lt;TSource, TDest&gt;
{
    TDest Convert(TSource src);
}
</code></pre>

<p>The ITypeConverterByConstructor has now become a specialised form of ITypeConverter (with corresponding Compilable variants) which inherently makes sense but will also be useful where we're going (but let's not get ahead of ourselves, that's coming up later in the post).</p>

<p>More importantly is the ICompilableTypeConverter GetTypeConverterExpression method which allows the creation of a Compilable Property Getter that is based upon a conversion that we want to feed back into the mapper -</p>

<pre><code>public class CompilableTypeConverterPropertyGetter&lt;TSourceObject, TPropertyOnSource, TPropertyAsRetrieved&gt;
    : AbstractGenericCompilablePropertyGetter&lt;TSourceObject, TPropertyAsRetrieved&gt;
{
    private PropertyInfo _propertyInfo;
    private ICompilableTypeConverter&lt;TPropertyOnSource, TPropertyAsRetrieved&gt; _compilableTypeConverter;
    public CompilableTypeConverterPropertyGetter(
        PropertyInfo propertyInfo,
        ICompilableTypeConverter&lt;TPropertyOnSource, TPropertyAsRetrieved&gt; compilableTypeConverter)
    {
        if (propertyInfo == null)
            throw new ArgumentNullException("propertyInfo");
        if (!propertyInfo.DeclaringType.Equals(typeof(TSourceObject)))
            throw new ArgumentException("Invalid propertyInfo - DeclaringType must match TSourceObject");
        if (!propertyInfo.PropertyType.Equals(typeof(TPropertyOnSource)))
            throw new ArgumentException("Invalid propertyInfo - PropertyType must match TPropertyOnSource");
        if (compilableTypeConverter == null)
            throw new ArgumentNullException("compilableTypeConverter");

        _propertyInfo = propertyInfo;
        _compilableTypeConverter = compilableTypeConverter;
    }

    public override PropertyInfo Property
    {
        get { return _propertyInfo; }
    }

    /// &lt;summary&gt;
    /// This Linq Expression will retrieves the value from SrcType.Property as TargetType,
    /// the specified "param" Expression must have a type that is assignable to SrcType.
    /// &lt;/summary&gt;
    public override Expression GetPropertyGetterExpression(Expression param)
    {
        if (param == null)
            throw new ArgumentNullException("param");
        if (typeof(TSourceObject) != param.Type)
            throw new ArgumentException("param.NodeType must match typeparam TSourceObject");

        // Get property value (from object of type TSourceObject) without conversion (this
        // will be as type TPropertyOnSource)
        // - If value is null, return default TPropertyAsRetrieved (not applicable if a
        //   value type)
        // - Otherwise, pass through type converter (to translate from TPropertyOnSource
        //   to TPropertyAsRetrieved)
        var propertyValue = Expression.Property(param, _propertyInfo);
        var conversionExpression = _compilableTypeConverter.GetTypeConverterExpression(propertyValue);
        if (typeof(TPropertyOnSource).IsValueType)
            return conversionExpression;
        return Expression.Condition(
            Expression.Equal(
                propertyValue,
                Expression.Constant(null)
            ),
            Expression.Constant(default(TPropertyAsRetrieved), typeof(TPropertyAsRetrieved)),
            conversionExpression
        );
    }
}
</code></pre>

<p>A corresponding CompilableTypeConverterPropertyGetterFactory is straight-forward to write. Like the other Property Getter Factories, it doesn't do a huge amount - it will determine whether a named property can be retreived from a specified type and converted <em>into</em> a specified type based upon name match rules and what kind of Property Getter that Factory can generate)</p>

<pre><code>public class CompilableTypeConverterPropertyGetterFactory&lt;TPropertyOnSource, TPropertyAsRetrieved&gt;
    : ICompilablePropertyGetterFactory
{
    private INameMatcher _nameMatcher;
    private ICompilableTypeConverter&lt;TPropertyOnSource, TPropertyAsRetrieved&gt; _typeConverter;
    public CompilableTypeConverterPropertyGetterFactory(
        INameMatcher nameMatcher,
        ICompilableTypeConverter&lt;TPropertyOnSource, TPropertyAsRetrieved&gt; typeConverter)
    {
        if (nameMatcher == null)
            throw new ArgumentNullException("nameMatcher");
        if (typeConverter == null)
            throw new ArgumentNullException("typeConverter");

        _nameMatcher = nameMatcher;
        _typeConverter = typeConverter;
    }

    /// &lt;summary&gt;
    /// This will return null if unable to return an ICompilablePropertyGetter for the
    /// named property that will return a value as the requested type
    /// &lt;/summary&gt;
    public ICompilablePropertyGetter Get(
        Type srcType,
        string propertyName,
        Type destPropertyType)
    {
        if (srcType == null)
            throw new ArgumentNullException("srcType");
        propertyName = (propertyName ?? "").Trim();
        if (propertyName == "")
            throw new ArgumentException("Null/empty propertyName specified");
        if (destPropertyType == null)
            throw new ArgumentNullException("destPropertyType");

        // If destination type does not match type converter's destination type then can
        // not handle the request; return null
        if (destPropertyType != typeof(TPropertyAsRetrieved))
            return null;

        // Try to get a property we CAN retrieve and convert as requested..
        var property = srcType.GetProperties().FirstOrDefault(p =&gt;
            p.GetIndexParameters().Length == 0
            &amp;&amp; _nameMatcher.IsMatch(propertyName, p.Name)
            &amp;&amp; p.PropertyType == typeof(TPropertyOnSource)
        );
        if (property == null)
            return null;

        // .. if successful, use to instantiate a CompilableTypeConverterPropertyGetter
        return (ICompilablePropertyGetter)Activator.CreateInstance(
            typeof(CompilableTypeConverterPropertyGetter&lt;,,&gt;).MakeGenericType(
                srcType,
                property.PropertyType,
                destPropertyType
            ),
            property,
            _typeConverter
        );
    }

    IPropertyGetter IPropertyGetterFactory.Get(
        Type srcType,
        string propertyName,
        Type destPropertyType)
    {
        return Get(srcType, propertyName, destPropertyType);
    }
}
</code></pre>

<p>Note: I skipped over actually altering the CompilableTypeConverterByConstructor class to implement the GetTypeConverterExpression but it wasn't anything too complex, the generateCompiledConverter method was changed from</p>

<pre><code>private Func&lt;TSource, TDest&gt; generateCompiledConverter()
{
    var srcParameter = Expression.Parameter(typeof(TSource), "src");
    var constructorParameterExpressions = new List&lt;Expression&gt;();
    foreach (var constructorParameter in _constructor.GetParameters())
    {
        var index = constructorParameterExpressions.Count;
        constructorParameterExpressions.Add(
            _propertyGetters[index].GetPropertyGetterExpression(srcParameter)
        );
    }

    return Expression.Lambda&lt;Func&lt;TSource, TDest&gt;&gt;(
        Expression.New(
            _constructor,
            constructorParameterExpressions.ToArray()
        ),
        srcParameter
    ).Compile();
}
</code></pre>

<p>and expanded into</p>

<pre><code>private Func&lt;TSource, TDest&gt; generateCompiledConverter()
{
    var srcParameter = Expression.Parameter(typeof(TSource), "src");
    return Expression.Lambda&lt;Func&lt;TSource, TDest&gt;&gt;(
        GetTypeConverterExpression(srcParameter),
        srcParameter
    ).Compile();
}

/// &lt;summary&gt;
/// This Linq Expression will generate a new TDest instance - the specified "param"
/// Expression must have a type that is assignable to TSource
/// &lt;/summary&gt;
public Expression GetTypeConverterExpression(Expression param)
{
    if (param == null)
        throw new ArgumentNullException("param");
    if (!typeof(TSource).IsAssignableFrom(param.Type))
        throw new ArgumentException("param.Type must be assignable to typeparam TSource");

    // Instantiate expressions for each constructor parameter by using each of the
    // property getters against the source value
    var constructorParameterExpressions = new List&lt;Expression&gt;();
    foreach (var constructorParameter in _constructor.GetParameters())
    {
        var index = constructorParameterExpressions.Count;
        constructorParameterExpressions.Add(
            _propertyGetters[index].GetPropertyGetterExpression(param)
        );
    }

    // Return an expression that to instantiate a new TDest by using property getters
    // as constructor arguments
    return Expression.Condition(
        Expression.Equal(
            param,
            Expression.Constant(null)
        ),
        Expression.Constant(default(TDest), typeof(TDest)),
        Expression.New(
            _constructor,
            constructorParameterExpressions.ToArray()
        )
    );
}
</code></pre>

<p>The only notable difference is that GetTypeConverterExpression should return an Expression that can deal with null values - we need this so that null properties can be retrieved from source types and passed to destination type constructors. Previously there was a null check against the "src" parameter passed to the Convert method, but this can be relaxed now that nulls have to be supported for this class to work as part of a Property Getter.</p>

<h3>Almost there!</h3>

<p>With the introduction of a CombinedCompilablePropertyGetterFactory (which will run through a set a Compilable Property Getter Factories for each request until one of the returns a non-null value to the Get request), we end up with this structure:</p>

<pre><code>var nameMatcher = new CaseInsensitiveSkipUnderscoreNameMatcher();
var converterFactory = new CompilableTypeConverterByConstructorFactory(
    new ArgsLengthTypeConverterPrioritiserFactory(),
    new CombinedCompilablePropertyGetterFactory(
        new ICompilablePropertyGetterFactory[]
        {
            // Insert Compilable Property Getter Factories here..
        }
    )
);
</code></pre>

<p>which finally allows a setup such as:</p>

<pre><code>var nameMatcher = new CaseInsensitiveSkipUnderscoreNameMatcher();

var roleConverterFactory = new CompilableTypeConverterByConstructorFactory(
    new ArgsLengthTypeConverterPrioritiserFactory(),
    new CombinedCompilablePropertyGetterFactory(
        new ICompilablePropertyGetterFactory[]
        {
            new CompilableAssignableTypesPropertyGetterFactory(nameMatcher),
            new CompilableEnumConversionPropertyGetterFactory(nameMatcher)
        }
    )
);

var employeeConverterFactory = new CompilableTypeConverterByConstructorFactory(
    new ArgsLengthTypeConverterPrioritiserFactory(),
    new CombinedCompilablePropertyGetterFactory(
        new ICompilablePropertyGetterFactory[]
        {
            new CompilableAssignableTypesPropertyGetterFactory(nameMatcher),
            new CompilableEnumConversionPropertyGetterFactory(nameMatcher),
            new CompilableTypeConverterPropertyGetterFactory&lt;SourceRole, DestRole&gt;(
                nameMatcher,
                roleConverterFactory.Get&lt;SourceRole, DestRole&gt;()
            )
        }
    )
);

var employeeConverter = employeeConverterFactory.Get&lt;SourceEmployee, DestEmployee&gt;();

var dest = employeeConverter.Convert(
    new SourceEmployee()
    {
        Name = "Richard",
        Role = new SourceRole() { Description = "Penguin Cleaner" }
    }
);
</code></pre>

<p>Hoorah!</p>

<p>Now, there's a slight refinement that I want to look at <a href="/the-lesseffort-extendable-linqcompilable-mappers">next time</a> but I think this post has gone on more than long enough.</p>

<h3>Footnote</h3>

<p>For the super-observant, I mentioned that the use of ITypeConverter (as opposed to necessarily requiring ITypeConverterByConstructor) would be touched on again in this post. Since I've run out of steam that will be covered <a href="/the-lesseffort-extendable-linqcompilable-mappers">next time</a> too.</p><p class="PostTime">Posted at 14:11</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/AutoMapper" title="8 Posts">AutoMapper</a></li><li><a href="/Archive/Tag/LINQ" title="11 Posts">LINQ</a></li><li><a href="/Archive/Tag/Reflection" title="14 Posts">Reflection</a></li></ul></div>
			<p class="Comments">
				<a href="/extendable-linqcompilable-mappers#disqus_thread" data-disqus-identifier="18">Comments</a>
			</p>
	</div>
	<div class="Content ArchiveByTag">
		<h3 class="PostDate">13 July 2011</h3><h2><a id="Post7"></a><a href="/automapperbyconstructor-without-automapper-and-faster">AutoMapper-By-Constructor without AutoMapper.. and faster</a></h2>

<p>I've been wanting to see if I can improve the performance of the by-constructor type converter I wrote about (<a href="/teaching-automapper-about-verbose-constructors">here</a>). The plan is to implement Property Getters that can retrieve the property values - translated, if required - from a source object using LINQ Expressions. Then to push these through a ConstructorInfo call using more LINQ Expressions such that a single expression can be constructed that converts from source to destination types at the same speed that hand-rolled code would. In a lot of cases, this could be merely academic but if 1000s of instances are being converted together, then the overhead of AutoMapper could make a signficant difference.</p>

<p>So I want to expand</p>

<pre><code>public interface IPropertyGetter
{
    Type SrcType { get; }
    PropertyInfo Property { get; }
    Type TargetType { get; }
    object GetValue(object src);
}
</code></pre>

<p>with</p>

<pre><code>public interface ICompilablePropertyGetter : IPropertyGetter
{
    Expression GetPropertyGetterExpression(Expression param);
}
</code></pre>

<p>and to expand</p>

<pre><code>public interface ITypeConverterByConstructor&lt;TSource, TDest&gt;
{
    ConstructorInfo Constructor { get; }
    TDest Convert(TSource src);
}
</code></pre>

<p>with</p>

<pre><code>public interface ICompilableTypeConverterByConstructor&lt;TSource, TDest&gt;
    : ITypeConverterByConstructor&lt;TSource, TDest&gt;
{
    Expression GetTypeConverterExpression(Expression param);
}
</code></pre>

<h3>Compilable Property Getter</h3>

<p>Turns it out this was quite easy to implement if you know how.. but quite difficult to find examples out there if you don't! One of the things I like about LINQ Expressions code is that when you read it back it scans quite well and kinda makes sense. However, I'm still really not that experienced with it and when I want to try something new it takes me quite a while to get to grips with how I need to form the code.</p>

<p>The first property getter I've got will retrieve the value of a property from a specified source type TSourceObject, where the property value is of type TPropertyAsRetrieved. TPropertyAsRetrieved in this case must be assignable-to from the type of the property on TSourceObject. So TPropertyAsRetrieved could be a string IEnumerable if the property on TSourceObject was a string array, for example (as IEnumerable&lt;string&gt; is assignable-to from string[]).</p>

<pre><code>public class CompilableAssignableTypesPropertyGetter&lt;TSourceObject, TPropertyAsRetrieved&gt;
    : AbstractGenericCompilablePropertyGetter&lt;TSourceObject, TPropertyAsRetrieved&gt;
{
    private PropertyInfo _propertyInfo;
    public CompilableAssignableTypesPropertyGetter(PropertyInfo propertyInfo)
    {
        if (propertyInfo == null)
            throw new ArgumentNullException("propertyInfo");
        if (!propertyInfo.DeclaringType.Equals(typeof(TSourceObject)))
            throw new ArgumentException("Invalid propertyInfo - DeclaringType must match TSourceObject");

        _propertyInfo = propertyInfo;
    }

    public override PropertyInfo Property
    {
        get { return _propertyInfo; }
    }

    public override Expression GetPropertyGetterExpression(Expression param)
    {
        if (param == null)
            throw new ArgumentNullException("param");
        if (!typeof(TSourceObject).IsAssignableFrom(param.Type))
            throw new ArgumentException("param.Type must be assignable to typeparam TSourceObject");

        // Prepare to grab the property value from the source object directly
        Expression getter = Expression.Property(
            param,
            _propertyInfo
        );

        // Try to convert types if not directly assignable (eg. this covers some common enum type conversions)
        var targetType = typeof(TPropertyAsRetrieved);
        if (!targetType.IsAssignableFrom(_propertyInfo.PropertyType))
            getter = Expression.Convert(getter, targetType);

        // Perform boxing, if required (eg. when enum being handled and TargetType is object)
        if (!targetType.IsValueType &amp;&amp; _propertyInfo.PropertyType.IsValueType)
            getter = Expression.TypeAs(getter, typeof(object));

        return getter;
    }
}
</code></pre>

<p>In order to keep the interesting compilable getter code separate from the boring stuff which implements the rest of IPropertyGetter, I've used a base class AbstractGenericCompilablePropertyGetter -</p>

<pre><code>public abstract class AbstractGenericCompilablePropertyGetter&lt;TSourceObject, TPropertyAsRetrieved&gt;
    : ICompilablePropertyGetter
{
    private Lazy&lt;Func&lt;TSourceObject, TPropertyAsRetrieved&gt;&gt; _getter;
    public AbstractGenericCompilablePropertyGetter()
    {
        _getter = new Lazy&lt;Func&lt;TSourceObject, TPropertyAsRetrieved&gt;&gt;(generateGetter, true);
    }

    public Type SrcType
    {
        get { return typeof(TSourceObject); }
    }

    public abstract PropertyInfo Property { get; }

    public Type TargetType
    {
        get { return typeof(TPropertyAsRetrieved); }
    }

    object IPropertyGetter.GetValue(object src)
    {
        if (src == null)
            throw new ArgumentNullException("src");
        if (!src.GetType().Equals(typeof(TSourceObject)))
            throw new ArgumentException("The type of src must match typeparam TSourceObject");
        return GetValue((TSourceObject)src);
    }

    public TPropertyAsRetrieved GetValue(TSourceObject src)
    {
        if (src == null)
            throw new ArgumentNullException("src");
        return _getter.Value(src);
    }

    public abstract Expression GetPropertyGetterExpression(Expression param);

    private Func&lt;TSourceObject, TPropertyAsRetrieved&gt; generateGetter()
    {
        var param = Expression.Parameter(typeof(TSourceObject), "src");
        return Expression.Lambda&lt;Func&lt;TSourceObject, TPropertyAsRetrieved&gt;&gt;(
            GetPropertyGetterExpression(param),
            param
        ).Compile();
    }
}
</code></pre>

<h3>Compilable Type-Converter-By-Constructor</h3>

<p />The general concept for this is straight-forward; a CompilableTypeConverterByConstructor<tsource, tdest=""> class will take a set of compilable property getters and a ConstructorInfo reference (that is used to instantiates instances of TDest and that takes the same number of parameters are there are property getters specified). The compilable type converter generates a LINQ Expression to perform the translation from TSource to TDest, given a ParameterExpression for the source object -<p />

<pre><code>public Expression GetTypeConverterExpression(Expression param)
{
    if (param == null)
        throw new ArgumentNullException("param");
    if (!typeof(TSource).IsAssignableFrom(param.Type))
        throw new ArgumentException("param.Type must be assignable to typeparam TSource");

    // Instantiate expressions for each constructor parameter by using each of the
    // property getters against the source value
    var constructorParameterExpressions = new List&lt;Expression&gt;();
    foreach (var constructorParameter in _constructor.GetParameters())
    {
        var index = constructorParameterExpressions.Count;
        constructorParameterExpressions.Add(
            _propertyGetters[index].GetPropertyGetterExpression(param)
        );
    }

    // Return an expression that to instantiate a new TDest by using property getters
    // as constructor arguments
    return Expression.Condition(
        Expression.Equal(
            param,
            Expression.Constant(null)
        ),
        Expression.Constant(default(TDest), typeof(TDest)),
        Expression.New(
            _constructor,
            constructorParameterExpressions.ToArray()
        )
    );
}
</code></pre>

<p>There's some handling in there to return default(TDest) if a null source reference is passed in but there are no other particular areas of note.</p>

<h2>Limitations</h2>

<p>There's a lot more work to be done down this avenue, since currently there's only Compilable Property Getters for Assignable Types (where no real conversion is happening) and Enums (where lookups from the source values to destination values are attempted by name before falling back to a straight numeric mapping). The code as described here is available in this tagged release:</p>

<p><a href="https://github.com/ProductiveRage/AutoMapper-By-Constructor-1/tree/LinqExpressionPropertyGetters">https://github.com/ProductiveRage/AutoMapper-By-Constructor-1/tree/LinqExpressionPropertyGetters</a></p>

<p>However, there's more on the way! I want to be able to take these simple compilable classes and use them to create more complicated type converters, so that once we have a compilable converter from:</p>

<pre><code>public class SourceRole
{
    public string Description { get; set; }
}
</code></pre>

<p>to</p>

<pre><code>public class DestRole
{
    public DestRole(string description)
    {
        Description = description;
    }
    public string Description { get; private set; }
}
</code></pre>

<p>we could leverage it translate</p>

<pre><code>public class SourceEmployee
{
    public string Name { get; set; }
    public SourceRole Role { get; set; }
}
</code></pre>

<p>to</p>

<pre><code>public class DestEmployee
{
    public DestEmployee(string name, DestRole role)
    {
        Name = name;
        Roles = roles;
    }
    public string Name { get; private set; }
    public DestRole Role { get; private set; }
}
</code></pre>

<p>or:</p>

<pre><code>public class SourceRole
{
    public string Description { get; set; }
    public DateTime StartDate { get; set; }
    public DateTime EndDate { get; set; }
}

public class SourceEmployee
{
    public string Name { get; set; }
    public IEnumerable&lt;SourceRole&gt; Roles { get; set; }
}
</code></pre>

<p>to</p>

<pre><code>public class DestRole
{
    public DestRole(string description, DateTime startDate, DateTime endDate)
    {
        Description = description;
        StartDate = startDate;
        EndDate = endDate
    }
    public string Description { get; private set; }
    public DateTime StartDate { get; private set; }
    public DateTime EndDate { get; private set; }
}

public class DestEmployee
{
    public DestEmployee(string name, IEnumerable&lt;DestRole&gt; roles)
    {
        Name = name;
        Roles = roles;
    }
    public string Name { get; private set; }
    public IEnumerable&lt;DestRole&gt; Roles { get; private set; }
}
</code></pre>

<p>.. something similar to the way in which AutoMapper's CreateMap method works.</p>

<h3>Update (2nd January 2012)</h3>

<p>I've finally got round to writing up this conclusion; <a href="/extendable-linqcompilable-mappers">here</a>.</p><p class="PostTime">Posted at 20:11</p><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/AutoMapper" title="8 Posts">AutoMapper</a></li><li><a href="/Archive/Tag/LINQ" title="11 Posts">LINQ</a></li><li><a href="/Archive/Tag/Reflection" title="14 Posts">Reflection</a></li></ul></div>
			<p class="Comments">
				<a href="/automapperbyconstructor-without-automapper-and-faster#disqus_thread" data-disqus-identifier="7">Comments</a>
			</p>
	</tsource,></div>

	<script type="text/javascript">
					(function () {
						var s = document.createElement("script");
						s.type = "text/javascript";
						s.async = true;
						s.src = "https://" + disqus_shortname + ".disqus.com/count.js";
						(document.getElementsByTagName("HEAD")[0] || document.getElementsByTagName("BODY")[0]).appendChild(s);
					} ());
	</script>

				<div class="Footer">
					Productive Rage 2017
				</div>
			</div>

			<div class="SideBar">
				<div class="About">
					<h2>About</h2>
					<p>Dan is a big geek who likes making stuff with computers! He can be quite outspoken so clearly needs a blog :)</p>
					<p>In the last few minutes he seems to have taken to referring to himself in the third person. He's quite enjoying it.</p>
					<p><a href="mailto:dangger36@gmail.com" class="Email">dangger36@gmail.com</a></p>

				</div>
				<div class="Search">
<form action="/Search" method="get" />						<div>
							<input type="text" class="SiteSearch" name="term" value="" />
							<input type="submit" class="SiteSearchSubmit" value="Search" />
						</div>
</form>				</div>
				<div class="Recent"><h2>Recent Posts</h2><ul><li><a href="/revisiting-net-core-tooling-visual-studio-2017">Revisiting .NET Core tooling (Visual Studio 2017)</a></li><li><a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face (finding faces in photos using C# and Accord.NET)</a></li><li><a href="/migrating-my-full-text-indexer-to-net-core-supporting-multitarget-nuget-packages">Migrating my Full Text Indexer to .NET Core (supporting multi-target NuGet packages)</a></li><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li></ul><div class="RSSFeedLink"><a href="http://www.productiverage.com/feed">RSS Feed</a></div></div>
				<div class="Featured"><h2>Highlights</h2><ul><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/translating-vbscript-into-c-sharp">Translating VBScript into C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div>
				<div class="History"><h2>Archives</h2><ul><li><a href="/Archive/6/2017">June 2017 (1)</a></li><li><a href="/Archive/2/2017">February 2017 (1)</a></li><li><a href="/Archive/11/2016">November 2016 (1)</a></li><li><a href="/Archive/9/2016">September 2016 (2)</a></li><li><a href="/Archive/8/2016">August 2016 (1)</a></li><li><a href="/Archive/7/2016">July 2016 (1)</a></li><li><a href="/Archive/6/2016">June 2016 (1)</a></li><li><a href="/Archive/5/2016">May 2016 (3)</a></li><li><a href="/Archive/3/2016">March 2016 (3)</a></li><li><a href="/Archive/2/2016">February 2016 (2)</a></li><li><a href="/Archive/12/2015">December 2015 (1)</a></li><li><a href="/Archive/11/2015">November 2015 (2)</a></li><li><a href="/Archive/8/2015">August 2015 (3)</a></li><li><a href="/Archive/7/2015">July 2015 (1)</a></li><li><a href="/Archive/6/2015">June 2015 (1)</a></li><li><a href="/Archive/5/2015">May 2015 (2)</a></li><li><a href="/Archive/4/2015">April 2015 (1)</a></li><li><a href="/Archive/3/2015">March 2015 (1)</a></li><li><a href="/Archive/1/2015">January 2015 (2)</a></li><li><a href="/Archive/12/2014">December 2014 (1)</a></li><li><a href="/Archive/11/2014">November 2014 (1)</a></li><li><a href="/Archive/10/2014">October 2014 (2)</a></li><li><a href="/Archive/9/2014">September 2014 (2)</a></li><li><a href="/Archive/8/2014">August 2014 (1)</a></li><li><a href="/Archive/7/2014">July 2014 (1)</a></li><li><a href="/Archive/6/2014">June 2014 (1)</a></li><li><a href="/Archive/5/2014">May 2014 (2)</a></li><li><a href="/Archive/2/2014">February 2014 (1)</a></li><li><a href="/Archive/1/2014">January 2014 (1)</a></li><li><a href="/Archive/12/2013">December 2013 (1)</a></li><li><a href="/Archive/11/2013">November 2013 (1)</a></li><li><a href="/Archive/10/2013">October 2013 (1)</a></li><li><a href="/Archive/8/2013">August 2013 (3)</a></li><li><a href="/Archive/7/2013">July 2013 (3)</a></li><li><a href="/Archive/6/2013">June 2013 (1)</a></li><li><a href="/Archive/5/2013">May 2013 (2)</a></li><li><a href="/Archive/4/2013">April 2013 (1)</a></li><li><a href="/Archive/3/2013">March 2013 (8)</a></li><li><a href="/Archive/2/2013">February 2013 (2)</a></li><li><a href="/Archive/1/2013">January 2013 (2)</a></li><li><a href="/Archive/12/2012">December 2012 (3)</a></li><li><a href="/Archive/11/2012">November 2012 (4)</a></li><li><a href="/Archive/9/2012">September 2012 (1)</a></li><li><a href="/Archive/8/2012">August 2012 (1)</a></li><li><a href="/Archive/7/2012">July 2012 (3)</a></li><li><a href="/Archive/6/2012">June 2012 (3)</a></li><li><a href="/Archive/5/2012">May 2012 (2)</a></li><li><a href="/Archive/2/2012">February 2012 (3)</a></li><li><a href="/Archive/1/2012">January 2012 (4)</a></li><li><a href="/Archive/12/2011">December 2011 (7)</a></li><li><a href="/Archive/8/2011">August 2011 (2)</a></li><li><a href="/Archive/7/2011">July 2011 (1)</a></li><li><a href="/Archive/5/2011">May 2011 (1)</a></li><li><a href="/Archive/4/2011">April 2011 (2)</a></li><li><a href="/Archive/3/2011">March 2011 (3)</a></li></ul><div class="EveryTitle"><a href="/Archive/All">Every Post Title</a></div></div>
			</div>

		</div>
	</div>

	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
	<script type="text/javascript" src="/Scripts/jquery.autocomplete.min.js"></script>
	<script type="text/javascript" src="/Scripts/prettify.js"></script>
	<script type="text/javascript" src="/Scripts/Site.js"></script>
	<script type="text/javascript" src="/Scripts/IndexSearchGenerator.js"></script>
	<script type="text/javascript" src="/Scripts/SearchTermHighlighter.js"></script>
	<script type="text/javascript" src="/Scripts/SearchPage.js"></script>
	<script type="text/javascript" src="/Scripts/LZString.js"></script>

</body>
</html>
