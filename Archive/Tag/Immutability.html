<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Productive Rage - Immutability</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta name="theme-color" content="#393939" />
	<link rel="stylesheet" type="text/css" media="all" href="/Content/Styles.css" />
	<link rel="stylesheet" type="text/css" media="print" href="/Content/PrintOverrides.css" />
	<meta name="robots" content="noindex, follow" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.productiverage.com/feed" />
	<script type="text/javascript">
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

		ga('create', "UA-32312857-1", { 'storage': 'none' });
		ga('send', 'pageview');
	</script>
    <meta name="description" content="Archive for tag: Immutability" />
</head>

<body>

	<div class="Header">
		<div class="HeaderContent">
			<h1>
				<a href="/">Productive Rage</a>
			</h1>
			<span class="Tagline">Dan's techie ramblings</span>
		</div>
	</div>

	<div class="WrapperOuter">
		<div class="Wrapper">
			<div class="Main HasSideBar">
				

        <script type="text/javascript">
            var disqus_shortname = "productiverage";
            document.addEventListener(
                "DOMContentLoaded",
                function () {
                    var commentsLinks = document.querySelectorAll("div.Content p.Comments");
                    for (var i = 0; i < commentsLinks.length; i++) {
                        commentsLinks[i].style.display = "block";
                    }
                }
            );
        </script>

    <div class="Content ArchiveByTag">
        <p class="PostDate">4 May 2016</p><h2><a id="using-roslyn-code-fixes-to-make-the-frictionless-immutable-objects-in-bridge-even-easier" href="/using-roslyn-code-fixes-to-make-the-frictionless-immutable-objects-in-bridge-even-easier">Using Roslyn code fixes to make the &quot;Friction-less immutable objects in Bridge&quot; even easier</a></h2>
<p>This is going to be a short post about a Roslyn (or &quot;The .NET Compiler Platform&quot;, if you're from Microsoft) analyser and code fix that I've added to a library. I'm not going to try to take you through the steps required to create an analyser nor how the Roslyn object model describes the code that you've written in the IDE* but I want to talk about the analyser itself because it's going to be very useful if you're one of the few people using my <a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a> library. Also, I feel like the inclusion of analysers with libraries is something that's going to become increasingly common (and I want to be able to have something to refer back to if I get the chance to say &quot;told you!&quot; in the future).</p>
<p>* <em>(This is largely because I'm still struggling with it a bit myself; my current process is to start with <a href="https://msdn.microsoft.com/en-gb/magazine/dn879356.aspx">Use Roslyn to Write a Live Code Analyzer for Your API</a> and the &quot;Analyzer with Code Fix (NuGet + VSIX)&quot; Visual Studio template. I then tinker around a bit and try running what I've got so far, so that I can use the &quot;Syntax Visualizer&quot; in the Visual Studio instance that is being debugged. Then I tend to do a lot of Google searches when I feel like I'm getting close to something useful.. how do I tell if a <strong>FieldDeclarationSyntax</strong> is for a readonly field or not? Oh, good, someone else has already written some code doing something like what  I want to do - I look at the &quot;Modifiers&quot; property on the <strong>FieldDeclarationSyntax</strong> instance).</em></p>
<p>As new .net libraries get written, some of them will have guidelines and rules that can't easily be described through the type system. In the past, the only option for such rules would be to try to ensure that the documentation (whether this be the project README and / or more in-depth online docs and / or the xml summary comment documentation for the types, methods, properties and fields that intellisense can bring to your attention in the IDE). The support that Visual Studio 2015 introduced for customs analysers* allows these rules to be communicated in a different manner.</p>
<p>* <em>(I'm being English and stubborn, hence my use of &quot;analysers&quot; rather than &quot;analyzers&quot;)</em></p>
<p>In short, they allow these library-specific guidelines and rules to be higlighted in the Visual Studio Error List, just like any error or warning raised by Visual Studio itself (even refusing to allow the project to be built, if an error-level message is recorded).</p>
<p>An excellent example that I've seen recently was encountered when I was writing some of my own analyser code. To do this, you can start with the &quot;Analyzer with Code Fix (NuGet + VSIX)&quot; template, which pulls in a range of NuGet packages and includes some template code of its own. You then need to write a class that is derived from <strong>DiagnosticAnalyzer</strong>. Your class will declare one of more <strong>DiagnosticDescriptor</strong> instances - each will be a particular rule that is checked. You then override an &quot;Initialize&quot; method, which allows your code to register for syntax changes and to raise any rules that have been broken. You must also override a &quot;SupportedDiagnostics&quot; property and return the set of <strong>DiagnosticDescriptor</strong> instances (ie. rules) that your analyser will cover. If the code that the &quot;Initialize&quot; method hooks up tries to raise a rule that &quot;SupportedDiagnostics&quot; did not declare, the rule will be ignored by the analysis engine. This would be a kind of (silent) runtime failure and it's something that is documented - but it's still a very easy mistake to make; you might create a new <strong>DiagnosticDescriptor</strong> instance and raise it from your &quot;Initialize&quot; method but forget to add it to the &quot;SupportedDiagnostics&quot; set.. whoops. In the past, you may not realise until runtime that you'd made a mistake and, as a silent failure, you might end up getting very frustrated and be stuck wondering what had gone wrong. But, mercifully (and I say this as I made this very mistake), there is an analyser in the &quot;Microsoft.CodeAnalysis.CSharp&quot; NuGet package that brings this error immediately to your attention with the message:</p>
<blockquote>
<p>RS1005 ReportDiagnostic invoked with an unsupported DiagnosticDescriptor</p>
</blockquote>
<p>The entry in the Error List links straight to the code that called &quot;context.ReportDiagnostic&quot; with the unexpected rule. This is fantastic - instead of suffering a runtime failure, you are informed at compile time precisely what the problem is. Compile time is <em>always</em> better than run time (for many reasons - it's more immediate, so you don't have to <em>wait</em> until runtime, and it's more thorough; a runtime failure may only happen if a particular code path is followed, but static analysis such as this is like having <em>every possible</em> code path tested).</p>
<h3>The analysers already in ProductiveRage.Immutable</h3>
<p>The ProductiveRage uber-fans (who, surely exist.. yes? ..no? :D) may be thinking &quot;doesn't the ProductiveRage.Immutable library already have some analysers built into it?&quot;</p>
<p>And they would be correct, for some time now it has included a few analysers that try to prevent some simple mistakes. As a quick reminder, the premise of the library is that it will make creating immutable types in <a href="http://www.bridge.net">Bridge.NET</a> easier.</p>
<p>Instead of writing something like this:</p>
<pre><code>public sealed class EmployeeDetails
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
    if (id == null)
      throw new ArgumentNullException(&quot;id&quot;);
    if (name == null)
      throw new ArgumentNullException(&quot;name&quot;);

    Id = id;
    Name = name;
  }

  /// &lt;summary&gt;
  /// This will never be null
  /// &lt;/summary&gt;
  public PersonId Id { get; }

  /// &lt;summary&gt;
  /// This will never be null
  /// &lt;/summary&gt;
  public NameDetails Name { get; }

  public EmployeeDetails WithId(PersonId id)
  {
    return Id.Equals(id) ? this : return new EmployeeDetails(id, Name);
  }
  public EmployeeDetails WithName(NameDetails name)
  {
    return Name.Equals(name) ? this : return new EmployeeDetails(Id, name);
  }
}
</code></pre>
<p>.. you can express it just as:</p>
<pre><code>public sealed class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
    this.CtorSet(_ =&gt; _.Id, id);
    this.CtorSet(_ =&gt; _.Name, name);
  }
  public PersonId Id { get; }
  public NameDetails Name { get; }
}
</code></pre>
<p>The if-null-then-throw validation is encapsulated in the CtorSet call (since the library takes the view that no value should ever be null - it introduces an <strong>Optional</strong> struct so that you can identify properties that may be without a value). And it saves you from having to write &quot;With&quot; methods for the updates as <strong>IAmImmutable</strong> implementations may use the &quot;With&quot; extension method whenever you want to create a new instance with an altered property - eg.</p>
<pre><code>var updatedEmployee = employee.With(_ =&gt; _.Name, newName);
</code></pre>
<p>The library can only work if certain conditions are met. For example, every property must have a getter and a setter - otherwise, the &quot;CtorSet&quot; extension method won't know how to actually set the value &quot;under the hood&quot; when populating the initial instance (nor would the &quot;With&quot; method know how to set the value on the new instance that it would create).</p>
<p>If you forgot this and wrote the following (note the &quot;DisplayNameLength&quot; property that is now effectively a computed value and there would be no way for us to directly set it via a &quot;With&quot; call) -</p>
<pre><code>public sealed class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
    this.CtorSet(_ =&gt; _.Id, id);
    this.CtorSet(_ =&gt; _.Name, name);
  }
  public PersonId Id { get; }
  public NameDetails Name { get; }
  public int DisplayNameLength { get { return Name.DisplayName.Length; } }
}
</code></pre>
<p>.. then you would see the following errors reported by Visual Studio (presuming you are using 2015 or later) -</p>
<p><img src="/Content/Images/Posts/ProductiveRageImmutableAnalyserError1.png" alt="Example analyser errors raised by the ProductiveRage.Immutable library" title="Example analyser errors raised by the ProductiveRage.Immutable library" /></p>
<p>.. which is one of the &quot;common IAmImmutable mistakes&quot; analysers identifying the problem for you.</p>
<h3>Getting Visual Studio to write code for you, using code fixes</h3>
<p>I've been writing more code with this library and I'm still, largely, happy with it. Making the move to assuming never-allow-null (which is baked into the &quot;CtorSet&quot; and &quot;With&quot; calls) means that the classes that I'm writing are a lot shorter and that type signatures are more descriptive. (I wrote about all this in my post at the end of last year &quot;<a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a>&quot; if you're curious for more details).</p>
<p>However.. I <em>still</em> don't really like typing out as much code for each class as I have to. Each class has to repeat the property names four times - once in the constructor, twice in the &quot;CtorSet&quot; call and a fourth time in the public property. Similarly, the type name has to be repeated twice - once in the constructor and once in the property.</p>
<p>This is better than the obvious alternative, which is to not bother with immutable types. I will gladly take the extra lines of code (and the effort required to write them) to get the additional confidence that a &quot;stronger&quot; type system offers - I wrote about this recently in my &quot;<a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">Writing React with Bridge.NET - The Dan Way</a>&quot; posts; I think that it's really worthwhile to bake assumptions into the type system where possible. For example, the Props types of React components are assumed, by the React library, to be immutable - so having them defined as immutable types represents this requirement in the type system. If the Props types are <em>mutable</em> then it would be possible to write code that tries to change that data and then bad things could happen (you're doing something that library expects not to happen). If the Props types are <em>immutable</em> then it's not even possible to write this particular kind of bad-things-might-happen code, which is a positive thing.</p>
<p>But <em>still</em> I get a niggling feeling that things could be better. And now they are! With Roslyn, you can not only identify particular patterns but you can also offer automatic fixes for them. So, if you were to start writing the <strong>EmployeeDetails</strong> class from scratch and got this far:</p>
<pre><code>public sealed class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
  }
}
</code></pre>
<p>.. then an analyser could identify that you were writing an <strong>IAmImmutable</strong> implementation and that you have an empty constructor - it could then offer to fix that for you by filling in the rest of the class.</p>
<p>The latest version of the ProductiveRage.Immutable library (1.7.0) does just that. The empty constructor will not only be identified with a warning but a light bulb will also appear alongside the code. Clicking this (or pressing [Ctrl]-[.] while within the empty constructor, for fellow keyboard junkies) will present an option to &quot;Populate class from constructor&quot; -</p>
<p><img src="/Content/Images/Posts/ProductiveRageImmutableAnalyserCodeFix1.png" alt="Screenshot showing the analyser identifying an empty constructor on an IAmImmutable implementation" title="Screenshot showing the analyser identifying an empty constructor on an IAmImmutable implementation" /></p>
<p>Selecting the &quot;Populate class from constructor&quot; option -</p>
<p><img src="/Content/Images/Posts/ProductiveRageImmutableAnalyserCodeFix2.png" alt="Screenshot showing the code fix that may auto-populate the incomplete IAmImmutable implementation" title="Screenshot showing the code fix that may auto-populate the incomplete IAmImmutable implementation" /></p>
<p>.. will take the constructor arguments and generate the &quot;CtorSet&quot; calls and the public properties automatically. Now you can have all of the safety of the immutable type with no more typing effort than the mutable version!</p>
<pre><code>// This is what you have to type of the immutable version,
// then the code fix will expand it for you
public sealed class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
  }
}

// This is what you would have typed if you were feeling
// lazy and creating mutable types because you couldn't
// be bothered with the typing overhead of immutability
public sealed class EmployeeDetails
{
  public PersonId Id;
  public NameDetails name;
}
</code></pre>
<h3>To summarise</h3>
<p>If you're already using the library, then all you need to do to start taking advantage of this code fix is update your NuGet reference* (presuming that you're using VS 2015 - analysers weren't supported in previous versions of Visual Studio).</p>
<p>* <em>(Sometimes you have to restart Visual Studio after updating, you will know that this is the case if you get a warning in the Error List about Visual Studio not being able to load the Productive.Immutable analyser)</em></p>
<p>If you're writing your own library that has any guidelines or common gotchas that you have to describe in documentation somewhere (that the users of your library may well not read unless they have a problem - at which point they may even abandon the library, if they're only having an investigative play around with it) then I highly recommend that you consider using analysers to surface some of these assumptions and best practices. While I'm aware that I've not offered much concrete advice on <em>how</em> to write these analysers, the reason is that I'm still very much a beginner at it - but that puts me in a good position to be able to say that it really is fairly easy if you read a few articles about it (such as <a href="https://msdn.microsoft.com/en-gb/magazine/dn879356.aspx">Use Roslyn to Write a Live Code Analyzer for Your API</a>) and then just get stuck in. With some judicious Google'ing, you'll be making progress in no time!</p>
<p>I guess that only time will tell whether library-specific analysers become as prevalent as I imagine. It's very possible that I'm biased because I'm such a believer in static analysis. Let's wait and see*!</p>
<p>* <em>Unless YOU are a library writer that this might apply to - in which case, make it happen rather than just sitting back to see what MIGHT happen! :)</em></p>
<p class="PostTime">Posted at 22:33</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/using-roslyn-to-identify-unused-and-undeclared-variables-in-vbscript-wsc-components">Using Roslyn to identify unused and undeclared variables in VBScript WSC components</a></li><li><a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/using-roslyn-code-fixes-to-make-the-frictionless-immutable-objects-in-bridge-even-easier#disqus_thread" data-disqus-identifier="99">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">11 February 2016</p><h2><a id="easy-purecomponent-react-performance-boosts-for-bridgenet" href="/easy-purecomponent-react-performance-boosts-for-bridgenet">Easy &quot;PureComponent&quot; React performance boosts for Bridge.Net</a></h2>
<p>React's great strength is that it makes creating UIs simple(r) because you can treat the view as a pure function - often, you essentially give a props reference into a top level component and it works out what to draw. Then, when something changes, you do the same again; trigger a full re-draw and rely upon React's Virtual DOM to work out what changed in an efficient manner and apply those changes to the browser DOM. The browser DOM is slow, which is why interactions with it should be minimised. The Virtual DOM is fast.</p>
<p>The common pre-React way to deal with UIs was to have some code to render the UI in an initial state and then further code that would change the UI based upon user interactions. React reduces these two types of state-handling (initial-display and update-for-specific-interaction) into one (full re-render).</p>
<p>And a lot of the time, the fast Virtual DOM performs quickly enough that you don't have to worry about what it's doing. But sometimes, you may have a UI that is so complicated that it's a lot of work for the Virtual DOM to calculate the diffs to apply to the browser DOM. Or you might have particularly demanding performance requirements, such as achieving 60 fps animations on mobile.</p>
<p>Handily, React has a way for you to give it hints - namely the <a href="https://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate">ShouldComponentUpdate</a> method that components may implement. This method can look at the component's current props and state values and the <em>next</em> props and state values and let React know if any changes are required. The method returns a boolean - false meaning &quot;no, I don't need to redraw, this data looks the same&quot; and true meaning &quot;yes, I need to redraw for this new data&quot;. The method is optional, if a component doesn't implement it then it's equivalent to it always returning true. Remember, if a component returns true for &quot;do I need to be redrawn?&quot;, the Virtual DOM is still what is responsible for dealing with the update - and it usually deals with it in a very fast and efficient manner. Returning true is not something to necessarily be worried about. However, if you <em>can</em> identify cases where ShouldComponentUpdate can return false then you can save the Virtual DOM from working out whether that component <em>or any of its child components</em> need to be redrawn. If this can be done high up in a deeply-nested component tree then it could save the Virtual DOM a lot of work.</p>
<p>The problem is, though, that coming up with a mechanism to reliably and efficiently compare object references (ie. props and / or state) to determine whether they describe the same data is difficult to do in the general case.</p>
<p>Let me paint a picture by describing a very simple example React application..</p>
<h3>The Message Editor Example</h3>
<p>Imagine an app that can read a list of messages from an API and allow the user of the app to edit these messages. Each message has &quot;Content&quot; and &quot;Author&quot; properties that are strings. Either of these values may be edited in the app. These messages are part of a message group that has a title - this also may be edited in the app.</p>
<p><em>(I didn't say that it was a useful or realistic app, it's just one to illustrate a point :)</em></p>
<p>The way that I like to create React apps is to categorise components as one of two things; a &quot;Container Component&quot; or a &quot;Presentation Component&quot;. Presentation Components should be state-less, they should just be handed a props reference and then go off and draw themselves. Any interactions that the user makes with this component or any of its child components are effectively passed up (via change handlers on the props reference) until it reaches a Container Component. The Container Component will translate these interaction into actions to send to the Dispatcher. Actions will be handled by a store (that will be listening out for Dispatcher actions that it's interested in). When a store handles an action, it emits a change event. The Container Component will be listening out for change events on stores that it is interested in - when this happens, the Container Component will trigger a re-render of itself by updating its state based upon data now available in the store(s) it cares about. This is a fairly standard Flux architecture and, I believe, the terms &quot;Container Component&quot; / &quot;Presentation Component are in reasonably common use (I didn't make them up, I just like the principle - one of the articles that I've read that uses these descriptions is <a href="https://medium.com/making-internets/component-brick-and-mortar-8bde51899b00#.6yi3i9hou">Component Brick and Mortar: The React documentation I wish I had a year ago</a>).</p>
<p>So, for my example app, I might have a component hierarchy that looks this:</p>
<pre><code>AppContainer
  Title
    TextInput
      Input
  MessageList
    MessageRow
      TextInput
        Input
      TextInput
        Input
    MessageRow
      TextInput
        Input
      TextInput
        Input
</code></pre>
<p>There will be as many &quot;MessageRow&quot; components as there are messages to edit. <strong>Input</strong> is a standard React-rendered element and all of the others (<strong>AppContainer</strong>, <strong>Title</strong>, <strong>MessageList</strong>, <strong>MessageRow</strong> and <strong>TextInput</strong>) are custom components.</p>
<p>(Note: This is <em>not</em> a sufficiently deeply-nested hierarchy that React would have any problems with rendering performance, it's intended to be <em>just</em> complicated enough to demonstrate the point that I'm working up to).</p>
<p>The <strong>AppContainer</strong> is the only &quot;Container Component&quot; and so is the only component that has a React state reference as well as props. A state reference is, essentially, what prevents a component from being what you might consider a &quot;pure function&quot; - where the props that are passed in are all that affects what is rendered out. React &quot;state&quot; is required to trigger a re-draw of the UI, but it should be present in as few places as possible - ie. there should only be one, or a small number of, top level component(s) that have state. Components that render <em>only</em> according to their props data are much easier to reason about (and hence easier to write, extend and maintain).</p>
<p>My <a href="https://www.nuget.org/packages/Bridge.React">Bridge.NET React bindings</a> NuGet package makes it simple to differentiate between stateful (ie. Container) components and stateless (ie. Presentation) components as it has both a <strong>Component&lt;TProps, TState&gt;</strong> base class and a <strong>StatelessComponent&lt;TProps&gt;</strong> base class - you derive from the appropriate one when you create custom components (for more details, see <a href="/react-and-flux-with-bridgenet-redux">React (and Flux) with Bridge.net - Redux</a>).</p>
<p>To start with the simplest example, below is the <strong>TextInput</strong> component. This just renders a text Input with a specified value and communicates up any requests to change that string value via an &quot;OnChange&quot; callback -</p>
<pre><code>public class TextInput : StatelessComponent&lt;TextInput.Props&gt;
{
  public TextInput(Props props) : base(props) { }

  public override ReactElement Render()
  {
    return DOM.Input(new InputAttributes
    {
      Type = InputType.Text,
      Value = props.Content,
      OnChange = OnTextChange
    });
  }

  private void OnTextChange(FormEvent&lt;InputElement&gt; e)
  {
    props.OnChange(e.CurrentTarget.Value);
  }

  public class Props
  {
    public string Content { get; set; }
    public Action&lt;string&gt; OnChange { get; set; }
  }
}
</code></pre>
<p>It is fairly easy to envisage how you might try to implement &quot;ShouldComponentUpdate&quot; here - given a &quot;this is the new props value&quot; reference (which gets passed into ShouldComponentUpdate as an argument called &quot;nextProps&quot;) and the current props reference, you need only  look at the &quot;Content&quot; and &quot;OnChange&quot; references on the current and next props and, if both Content/Content and OnChange/OnChange references are the same, then we can return false (meaning &quot;no, we do not need to re-draw this TextInput&quot;).</p>
<p><em>(Two things to note here: Firstly, it is not usually possible to directly compare the current props reference with the &quot;nextProps&quot; reference because it is common for the parent component to create a new props instance for each proposed re-render of a child component, rather than re-use a previous props instance - so the individual property values within the props references may all be consistent between the current props and nextProps, but the actual props references will usually be distinct. Secondly, the Bridge.NET React bindings only support React component life cycle method implementations on custom components derived from <strong>Component&lt;TProps, TState&gt;</strong> classes and not those derived from <strong>StatelessComponent&lt;TProps&gt;</strong>, so you couldn't actually write your own &quot;ShouldComponentUpdate&quot; for a <strong>StatelessComponent</strong> - but that's not important here, we're just working through a thought experiment).</em></p>
<p>Now let's move on to the <strong>MessageList</strong> and <strong>MessageRow</strong> components, since things get more complicated there -</p>
<pre><code>public class MessageList : StatelessComponent&lt;MessageList.Props&gt;
{
  public MessageList(Props props) : base(props) { }

  public override ReactElement Render()
  {
    var messageRows = props.IdsAndMessages
      .Select(idAndMessage =&gt; new MessageRow(new MessageRow.Props
      {
        Key = idAndMessage.Item1,
        Message = idAndMessage.Item2,
        OnChange = newMessage =&gt; props.OnChange(idAndMessage.Item1, newMessage)
      }));
    return DOM.Div(
      new Attributes { ClassName = &quot;message-list&quot; },
      messageRows
    );
  }

  public class Props
  {
    public Tuple&lt;int, MessageEditState&gt;[] IdsAndMessages;
    public Action&lt;int, MessageEditState&gt; OnChange;
  }
}

public class MessageRow : StatelessComponent&lt;MessageRow.Props&gt;
{
  public MessageRow(Props props) : base(props) { }

  public override ReactElement Render()
  {
    // Note that the &quot;Key&quot; value from the props reference does not explicitly need
    // to be mentioned here, the React bindings will deal with it (it is important
    // to give dynamic children components unique key values, but it is handled by
    // the bindings and the React library so long as a &quot;Key&quot; property is present
    // on the props)
    // - See https://facebook.github.io/react/docs/multiple-components.html for
    //   more details
    return DOM.Div(new Attributes { ClassName = &quot;message-row&quot; },
      new TextInput(new TextInput.Props
      {
        Content = props.Message.Content,
        OnChange = OnContentChange
      }),
      new TextInput(new TextInput.Props
      {
        Content = props.Message.Author,
        OnChange = OnAuthorChange
      })
    );
  }

  private void OnContentChange(string newContent)
  {
    props.OnChange(new MessageEditState
    {
      Content = newContent,
      Author = props.Message.Author
    });
  }
  private void OnAuthorChange(string newAuthor)
  {
    props.OnChange(new MessageEditState
    {
      Content = props.Message.Content,
      Author = newAuthor
    });
  }

  public class Props
  {
    public int Key;
    public MessageEditState Message;
    public Action&lt;MessageEditState&gt; OnChange;
  }
}

public class MessageEditState
{
  public string Content;
  public string Author;
}
</code></pre>
<p>If the <strong>MessageList</strong> component wanted to implement &quot;ShouldComponentUpdate&quot; then its job is more difficult as it has an array of message data to check. It could do one of several things - the first, and most obviously accurate, would be to perform a &quot;deep compare&quot; of the arrays from the current props and the &quot;nextProps&quot;; ensuring firstly that there are the same number of items in both and then comparing each &quot;Content&quot; and &quot;Author&quot; value in each item of the arrays. If everything matches up then the two arrays contain the same data and (so long as the &quot;OnChange&quot; callback hasn't changed) the component doesn't need to re-render. Avoiding re-rendering this component (and, subsequently, any of its child components) would be a big win because it accounts for a large portion of the total UI. Not re-rendering it would give the Virtual DOM much less work to do. But would a deep comparison of this type actually be any cheaper than letting the Virtual DOM do what it's designed to do?</p>
<p>The second option is to presume that whoever created the props references would have re-used any <strong>MessageEditState</strong> instances that haven't changed. So the array comparison could be reduced to ensuring that the current and next props references both have the same number of elements and then performing reference equality checks on each item.</p>
<p>The third option is to presume that whoever created the props reference would have re-used the array itself if the data hadn't changed, meaning that a simple reference equality check could be performed on the current and next props' arrays.</p>
<p>The second and third options are both much cheaper than a full &quot;deep compare&quot; but they both rely upon the caller following some conventions. This is why I say that this is a difficult problem to solve for the general case.</p>
<h3>Immutability to the rescue</h3>
<p>There is actually another option to consider, the object models for the props data could be rewritten to use immutable types. These have the advantage that if you find that two references are equal then they are guaranteed to contain the same data. They also have the advantage that it's much more common to re-use instances to describe the same data - partly because there is some overhead to initialising immutable types and partly because there is no fear that &quot;if I give this reference to this function, I want to be sure that it can't change the data in <em>my</em> reference while doing its work&quot; because it is <em>impossible</em> to change an immutable reference's data. (I've seen defensively-written code that clones mutable references that it passes into other functions, to be sure that no other code can change the data in the original reference - this is never required with immutable types).</p>
<p>Conveniently, I've recently written a library to use with Bridge.NET which I think makes creating and working with immutable types easier than C# makes it on its own. I wrote about it in &quot;<a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a>&quot; but the gist is that you re-write <strong>MessageEditState</strong> as:</p>
<pre><code>// You need to pull in the &quot;ProductiveRage.Immutable&quot; NuGet package to use IAmImmutable
public class MessageEditState : IAmImmutable
{
  public MessageEditState(string content, string author)
  {
    this.CtorSet(_ =&gt; _.Content, content);
    this.CtorSet(_ =&gt; _.Author, author);
  }
  public string Content { get; private set; }
  public string Author { get; private set; }
}
</code></pre>
<p>It's still a little more verbose than the mutable version, admittedly, but I'm hoping to convince you that it's worth it (if you need convincing!) for the benefits that we'll get.</p>
<p>When you have an instance of this new <strong>MessageEditState</strong> class, if you need to change one of the properties, you don't have to call the constructor each time to get a new instance, you can use the &quot;With&quot; extension methods that may be called on any <strong>IAmImmutable</strong> instance - eg.</p>
<pre><code>var updatedMessage = message.With(_ =&gt; _.Content, &quot;New information&quot;);
</code></pre>
<p>This would mean that the change handlers from <strong>MessageRow</strong> could be altered from:</p>
<pre><code>private void OnContentChange(string newContent)
{
  props.OnChange(new MessageEditState
  {
    Content = newContent,
    Author = props.Message.Author
  });
}
private void OnAuthorChange(string newAuthor)
{
  props.OnChange(new MessageEditState
  {
    Content = props.Message.Content,
    Author = newAuthor
  });
}
</code></pre>
<p>and replaced with:</p>
<pre><code>private void OnContentChange(string newContent)
{
  props.OnChange(props.Message.With(_ =&gt; _.Content, newContent));
}
private void OnAuthorChange(string newAuthor)
{
  props.OnChange(props.Message.With(_ =&gt; _.Author, newAuthor));
}
</code></pre>
<p>Immediately, the verbosity added to <strong>MessageEditState</strong> is being offset with tidier code! (And it's nice not having to set both &quot;Content&quot; <em>and</em> &quot;Author&quot; when only changing <em>one</em> of them).</p>
<p>The &quot;With&quot; method also has a small trick up its sleeve in that it won't return a new instance if the new property value is the same as the old property value. This is an eventuality that <em>could</em> happen in the code above as an &quot;Input&quot; element rendered by React will raise an &quot;OnChange&quot; event for any action that <em>might</em> have altered the text input's content. For example, if you had a text box with the value &quot;Hello&quot; in it and you selected all of that text and then pasted in text from the clipboard over the top of it, if the clipboard text was also &quot;Hello&quot; then the &quot;OnChange&quot; event will be raised, even though the actual value has not changed (it was &quot;Hello&quot; before and it's still &quot;Hello&quot; now). The &quot;With&quot; method will deal with this, though, and just pass the same instance straight back out. This is an illustration of the &quot;reuse of instances for unchanged data&quot; theme that I alluded to above.</p>
<p>The next step would be to change the array type in the <strong>MessageList.Props</strong> type from</p>
<pre><code>public Tuple&lt;int, MessageEditState&gt;[] IdsAndMessages;
</code></pre>
<p>to</p>
<pre><code>public NonNullList&lt;Tuple&lt;int, MessageEditState&gt;&gt; IdsAndMessages;
</code></pre>
<p>The <strong>NonNullList</strong> class is also in the <a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a> NuGet package. It's basically an immutable <strong>IEnumerable</strong> that may be used in Bridge.NET projects. A simple example of it in use is:</p>
<pre><code>// Create a new set of values (the static &quot;Of&quot; method uses type inference to determine
// the type of &quot;T&quot; in the returned &quot;NonNullList&lt;T&gt;&quot; - since 1, 2 and 3 are all ints, the
// &quot;numbers&quot; reference will be of type &quot;NonNullList&lt;int&gt;&quot;)
var numbers = NonNullList.Of(1, 2, 3);

// SetValue takes an index and a new value, so calling SetValue(2, 4) on a set
// containing 1, 2, 3 will return a new set containing the values 1, 2, 4
numbers = numbers.SetValue(2, 4);

// Calling SetValue(2, 4) on a set containing values 1, 2, 4 does not require any
// changes, so the input reference is passed straight back out
numbers = numbers.SetValue(2, 4);
</code></pre>
<p>As with <strong>IAmImmutable</strong> instances we get two big benefits - we can rely on reference equality comparisons more often, since the data with any given reference can never change, and references will be reused in many cases if operations are requested that would not actually change the data. (It's worth noting that the guarantees fall apart if any property on an <strong>IAmImmutable</strong> reference is a of a mutable type, similarly if a <strong>NonNullList</strong> has elements that are a mutable type, or that have nested properties that are of a mutable type.. but so long as immutability is used &quot;all the way down&quot; then all will be well).</p>
<p>If this philosophy was followed, then suddenly the &quot;ShouldComponentUpdate&quot; implementation for the <strong>MessageList</strong> component would be very easy to write - just perform reference equality comparisons on the &quot;IdsAndMessages&quot; and &quot;OnChange&quot; values on the current props and on the nextProps. While solving the problem for the general case is very difficult, solving it when you introduce some constraints (such as the use of immutable and persistent data types) can be very easy!</p>
<p>If we <em>did</em> implement this <strong>MessageList</strong> &quot;ShouldComponentUpdate&quot; method, then we could be confident that when a user makes changes to the &quot;Title&quot; text input that the Virtual DOM would not have to work out whether the <strong>MessageList</strong> or any of its child components had changed - because we'd have told the Virtual DOM that they hadn't (because the &quot;IdsAndMessages&quot; and &quot;OnChange&quot; property references wouldn't have changed).</p>
<p>We could take this a step further, though, and consider the idea of implementing &quot;ShouldComponentUpdate&quot; on other components - such as <strong>MessageRow</strong>. If the user edits a text value within one row, then the <strong>MessageList</strong> will have to perform some re-rendering work, since one of its child components needs to be re-rendered. But there's no need for any of the other rows to re-render, it could be <em>just</em> the single row in which the change was requested by the user.</p>
<p>So the <strong>MessageRow</strong> could look at its props values and, if they haven't changed between the current props and the nextProps, then inform React (via &quot;ShouldComponentUpdate&quot;) that no re-render is required.</p>
<p>And why not go even further and just do this on <em>all</em> Presentation Components? The <strong>TextInput</strong> could avoid the re-render of its child Input if the props' &quot;Content&quot; and &quot;OnChange&quot; reference are not being updated.</p>
<h3>Introducing the Bridge.React &quot;PureComponent&quot;</h3>
<p>To make this easy, I've added a new base class to the React bindings (available in 1.4 of <a href="https://www.nuget.org/packages/Bridge.React">Bridge.React</a>); the <strong>PureComponent&lt;TProps&gt;</strong>.</p>
<p>This, like the <strong>StatelessComponent&lt;TProps&gt;</strong>, is very simple and does not support state and only allows the &quot;Render&quot; method to be implemented - no other React lifecycle functions (such &quot;ComponentWillMount&quot;, &quot;ShouldComponentUpdate&quot;, etc..) may be defined on components deriving from this class.</p>
<p>The key difference is that it has its own &quot;ShouldComponentUpdate&quot; implementation that presumes that the props data is immutable and basically does what I've been describing above automatically - when React checks &quot;ShouldComponentUpdate&quot;, it will look at the &quot;props&quot; and &quot;nextProps&quot; instances and compare their property values. (It also deals with the cases where one or both of them are null, in case you want components whose props reference is optional).</p>
<p>This is not an original idea, by a long shot. I first became aware of people doing this in 2013 when I read <a href="http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/">The Future of JavaScript MVC Frameworks</a>, which was talking about using <a href="https://github.com/clojure/clojurescript">ClojureScript</a> and its React interface &quot;<a href="https://github.com/omcljs/om">Om</a>&quot;. More recently, I was reading <a href="http://benchling.engineering/performance-engineering-with-react/">Performance Engineering with React (Part 1)</a>, which talks about roughly the same subject but with vanilla JavaScript. And, of course, Facebook has long had its <a href="https://facebook.github.io/react/docs/pure-render-mixin.html">PureRenderMixin</a> - though mixins can't be used with ES6 components (which seems to be the approach to writing components that Facebook is pushing at the moment).</p>
<p>So, this is largely just making it easy it when writing React applications with <em>Bridge</em>. However, using Bridge to do this <em>does</em> give us some extra advantages (on top of the joy of being able to write React apps in C#!). In the code earlier (from the <strong>MessageRow</strong> Render method) -</p>
<pre><code>new TextInput(new TextInput.Props
{
  Content = props.Message.Content,
  OnChange = OnContentChange
})
</code></pre>
<p>Bridge will bind the &quot;OnContentChange&quot; method to the current <strong>MessageRow</strong> instance so that when it is called by the <strong>TextInput</strong>'s &quot;OnChange&quot; event, &quot;this&quot; is the <strong>MessageRow</strong> and not the <strong>TextInput</strong> (which is important because OnContentChange needs to access the &quot;props&quot; reference scoped to the <strong>MessageRow</strong>).</p>
<p>This introduces a potential wrinkle in our plan, though, as this binding process creates a new JavaScript method each time and means that each time the <strong>TextInput</strong> is rendered, the &quot;OnChange&quot; reference is new. So if we try to perform simple reference equality checks on props values, then we won't find the current &quot;OnChange&quot; and the new &quot;OnChange&quot; to be the same.</p>
<p>This problem is mentioned in the &quot;Performance Engineering&quot; article I linked above:</p>
<blockquote>
<p>Unfortunately, each call to Function.bind produces a new function.. No amount of prop checking will help, and your component will always re-render.</p>
</blockquote>
<blockquote>
<p>..</p>
</blockquote>
<blockquote>
<p>The simplest solution we've found is to pass the unbound function.</p>
</blockquote>
<p>When using Bridge, we don't have the option of using an unbound function since the function-binding is automatically introduced by the C#-to-JavaScript translation process. And it's very convenient, so it's not something that I'd ideally <em>like</em> to have to workaround.</p>
<p>Having a dig through Bridge's source code, though, revealed some useful information. When Bridge.fn.bind is called, it returns a new function (as just discussed).. but with some metadata attached to it. When it returns a new function, it sets two properties on it &quot;$scope&quot; and &quot;$method&quot;. The $scope reference is what &quot;this&quot; will be set to when the bound function is called and the $method reference is the original function that is being bound. This means that, when the props value comparisons are performed, if a value is a function and it the reference equality comparison fails, a fallback approach may be attempted - if both functions have $scope and $method references defined then compare them and, if they are both consistent between the function value on the current props and the function value on the nextProps, then consider the value to be unchanged.</p>
<p>The <strong>PureComponent</strong>'s &quot;ShouldComponentUpdate&quot; implementation deals with this automatically, so you don't have to worry about it.</p>
<p>It's possibly worth noting that the &quot;Performance Engineering&quot; post did briefly consider something similar -</p>
<blockquote>
<p>Another possibility we've explored is using a custom bind function that stores metadata on the function itself, which in combination with a more advanced check function, could detect bound functions that haven't actually changed.</p>
</blockquote>
<p>Considering that Bridge automatically includes this additional metadata, it seemed to me to be sensible to use it.</p>
<p>There's one other equality comparison that is supported; as well as simple referential equality and the function equality gymnastics described above, if both of the values are non-null and the first has an &quot;Equals&quot; function then this function will be considered. This means that any custom &quot;Equals&quot; implementations that you define on classes will be automatically taken into consideration by the <strong>PureComponent</strong>'s logic.</p>
<h3>Another Bridge.NET bonus: Lambda support</h3>
<p>When I started writing this post, there was going to be a section here with a warning about using lambdas as functions in props instances, rather than using named functions (which the examples thus far have done).</p>
<p>As with bound functions, anywhere that an anonymous function is present in JavaScript, it will result in a new function value being created. If, for example, we change the <strong>MessageRow</strong> class from:</p>
<pre><code>public class MessageRow : PureComponent&lt;MessageRow.Props&gt;
{
  public MessageRow(Props props) : base(props) { }

  public override ReactElement Render()
  {
    return DOM.Div(new Attributes { ClassName = &quot;message-row&quot; },
      new TextInput(new TextInput.Props
      {
        Content = props.Message.Content,
        OnChange = OnContentChange
      }),
      new TextInput(new TextInput.Props
      {
        Content = props.Message.Author,
        OnChange = OnAuthorChange
      })
    );
  }

  private void OnContentChange(string newContent)
  {
    props.OnChange(props.Message.With(_ =&gt; _.Content, newContent));
  }
  private void OnAuthorChange(string newAuthor)
  {
    props.OnChange(props.Message.With(_ =&gt; _.Author, newAuthor));
  }

  public class Props
  {
    public int Key;
    public MessageEditState Message;
    public Action&lt;MessageEditState&gt; OnChange;
  }
}
</code></pre>
<p>to:</p>
<pre><code>public class MessageRow : PureComponent&lt;MessageRow.Props&gt;
{
  public MessageRow(Props props) : base(props) { }

  public override ReactElement Render()
  {
    return DOM.Div(new Attributes { ClassName = &quot;message-row&quot; },
      new TextInput(new TextInput.Props
      {
        Content = props.Message.Content,
        OnChange = newContent =&gt;
          props.OnChange(props.Message.With(_ =&gt; _.Content, newContent))
      }),
      new TextInput(new TextInput.Props
      {
        Content = props.Message.Author,
        OnChange = newAuthor =&gt;
          props.OnChange(props.Message.With(_ =&gt; _.Author, newAuthor))
      })
    );
  }

  public class Props
  {
    public int Key;
    public MessageEditState Message;
    public Action&lt;MessageEditState&gt; OnChange;
  }
}
</code></pre>
<p>then there would be problems with the &quot;OnChange&quot; props values specified because each new lambda - eg..</p>
<pre><code>OnChange = newContent =&gt;
  props.OnChange(props.Message.With(_ =&gt; _.Content, newContent))
</code></pre>
<p>would result in a new JavaScript function being passed to Bridge.fn.bind every time that it was called:</p>
<pre><code>onChange: Bridge.fn.bind(this, function (newContent) {
  this.getprops().onChange(
    ProductiveRage.Immutable.ImmutabilityHelpers.$with(
       this.getprops().message,
      function (_) { return _.getContent(); },
      newContent
    )
  );
})
</code></pre>
<p>And this would prevent the <strong>PureComponent</strong>'s &quot;ShouldComponentUpdate&quot; logic from being effective, since the $method values from the current props &quot;OnChange&quot; and the nextProps &quot;OnChange&quot; bound functions would always be different.</p>
<p>I was quite disappointed when I realised this and was considering trying to come up with some sort of workaround - maybe calling &quot;toString&quot; on both $method values and comparing their implementations.. but I couldn't find definitive information about the performance implications of this and I wasn't looking forward to constructing my own suite of tests to investigate any potential performance impact of this across different browsers and different browser versions.</p>
<p>My disappointment was two-fold: firstly, using the lambdas allows for more succinct code and less syntactic noise - since the types of the lambda's argument(s) and return value (if any) are inferred, rather than having to be explicitly typed out.</p>
<pre><code>newContent =&gt; props.OnChange(props.Message.With(_ =&gt; _.Content, newContent))
</code></pre>
<p>is clearly shorter than</p>
<pre><code>private void OnContentChange(string newContent)
{
  props.OnChange(props.Message.With(_ =&gt; _.Content, newContent));
}
</code></pre>
<p>The other reason that I was deflated upon realising this was that it meant that the &quot;ShouldComponentUpdate&quot; implementation would, essentially, silently fail for components that used lambdas - &quot;ShouldComponentUpdate&quot; would return true in cases where I would like it to return false. There would be no compiler error and the UI code would still function, but it wouldn't be as efficient as it could be (the Virtual DOM would have to do more work than necessary).</p>
<p>Instead, I had a bit of a crazy thought.. lambdas like this, that only need to access their own arguments and the &quot;this&quot; reference, could be &quot;lifted&quot; into named functions quite easily. Essentially, I'm doing this manually by writing methods such as &quot;OnContentChange&quot;. But could the Bridge translator do something like this automatically - take those C# lambdas and convert them into named functions in JavaScript? That way, I would get the benefit of the succinct lambda format in C# <em>and</em> the <strong>PureComponent</strong> optimisations would work.</p>
<p>Well, once again the Bridge.NET Team came through for me! I raised a <a href="http://forums.bridge.net/forum/general/feature-requests/1515-open-921-lift-simple-anonymous-functions-into-named-functions-for-performance-wins">Feature Request</a> about this, explained what I'd like in an ideal world (and why) and five days later there was a branch on GitHub where I could preview changes that did precisely what I wanted!</p>
<p>This is not just an example of fantastic support from the Bridge Team, it is also, I believe, an incredible feature for Bridge and a triumph for writing front-end code in C#! Having this &quot;translation step&quot; from C# to JavaScript provides the opportunity for handy features to be included for free - earlier we saw how the insertion of Bridge.fn.bind calls by the translator meant that we had access to $method and $scope metadata (which side-steps one of the problems that were had by the author of <a href="http://benchling.engineering/performance-engineering-with-react/">Performance Engineering with React</a>) but, here, the translation step can remove the performance overhead that anonymous functions were going to cause for our &quot;ShouldComponentUpdate&quot; implementation, without there being <em>any</em> burden on the developer writing the C# code.</p>
<p>It's also worth considering the fact that every allocation made in JavaScript is a reference that needs to be tidied up by the browser's garbage collector at some point. A big reason why judicious use of &quot;ShouldComponentUpdate&quot; can make UIs faster is that there is less work for the Virtual DOM to do, but it <em>also</em> eases the load on the garbage collector because none of the memory allocations need to be made for child components of components that do not need to be re-rendered. Since anonymous JavaScript functions are created over and over again (every time that the section of code that declares the anonymous function is executed), lifting them into named functions means that there will be fewer allocations in your SPA and hence even less work for the garbage collector to do.</p>
<p><em>Note: As of the 11th of February 2016, this Bridge.NET improvement has not yet been made live - but their release cycles tend to be fairly short and so I don't imagine that it will be very long until it is included in an official release. If you were desperate to write any code with <strong>PureComponent</strong> before then, you could either avoid lambdas in your C# code or you could use lambdas now, knowing that the <strong>PureComponent</strong> won't be giving you the full benefit immediately - but that you WILL get the full benefit when the Bridge Team release the update.</em></p>
<h3>So it's an unequivocable success then??</h3>
<p>Well, until it transpired that the Bridge translator would be altered to convert these sorts of lambdas into named functions, I was going to say &quot;this is good, but..&quot;. However, <em>with</em> that change in sight, I'm just going to say outright &quot;yes, and I'm going to change all classes that derive from <strong>StatelessComponent</strong> in my projects to derive from <strong>PureComponent</strong>&quot;. This will work fine, so long as your props references are all immutable (meaning that they are immutable <em>all the way down</em> - you shouldn't have, say, a props property that is an immutable <strong>NonNullList</strong> of references, but where those references have mutable properties).</p>
<p>And, if you're not using immutable props types - sort yourself out! While a component is being rendered (according to the <a href="https://facebook.github.io/react/docs/tutorial.html">Facebook React Tutorial</a>):</p>
<blockquote>
<p>props are immutable: they are passed from the parent and are &quot;owned&quot; by the parent</p>
</blockquote>
<p>So, rather than having props only be immutable during component renders (by a convention that the React library enforces), why not go whole-hog and use fully immutable classes to describe your props types - that way props are <em>fully</em> immutable and you can use the <a href="https://www.nuget.org/packages/Bridge.React">Bridge.React</a>'s <strong>PureComponent</strong> to get performance boosts for free!</p>
<p><em>(Now seems like a good time to remind you of my post &quot;<a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a>&quot;, which illustrates how to use the <a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a> NuGet package to make defining immutable classes just that bit easier).</em></p>
<p class="PostTime">Posted at 20:11</p><div class="Related"><h3>You may also be interested in:</h3><ul><li><a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a></li><li><a href="/react-and-flux-with-bridgenet-redux">React (and Flux) with Bridge.net - Redux</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/React" title="11 Posts">React</a></li><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/easy-purecomponent-react-performance-boosts-for-bridgenet#disqus_thread" data-disqus-identifier="95">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">16 December 2015</p><h2><a id="frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications" href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a></h2>
<p>One of the posts that I've written that got the most &quot;audience participation*&quot; was one from last year &quot;<a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired 'with' updates for immutable classes in C#</a>&quot;, where I spoke about trying to ease the burden in C# or representing data with immutable classes by reducing the repetitive typing involved.</p>
<p>* <em>(I'd mis-remembered receiving more criticism about this than I actually did - now that I looking back at the comments left on the <a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">post</a> and on <a href="https://www.reddit.com/r/programming/comments/2gqx9u/implementing_finspired_with_updates_for_immutable/">reddit</a>, the conversations and observations are pretty interesting and largely constructive!)</em></p>
<p>The gist was that if I wanted to have a class that represented, for the sake of a convoluted example, an employee that had a name, a start-of-employment date and some notes (which are optional and so may not be populated) then we might have something like the following:</p>
<pre><code>public class EmployeeDetails
{
  public EmployeeDetails(string name, DateTime startDate, string notesIfAny)
  {
    if (string.IsNullOrWhiteSpace(name))
      throw new ArgumentException(&quot;name&quot;);

    Name = name.Trim();
    StartDate = startDate;
    NotesIfAny = (notesIfAny == null) ? null : notesIfAny.Trim();
  }

  /// &lt;summary&gt;
  /// This will never be null or blank, it will not have any leading or trailing whitespace
  /// &lt;/summary&gt;
  public string Name { get; private set; }

  public DateTime StartDate { get; private set; }

  /// &lt;summary&gt;
  /// This will be null if it has not value, otherwise it will be a non-blank string with no
  /// leading or trailing whitespace
  /// &lt;/summary&gt;
  public string NotesIfAny { get; private set; }
}
</code></pre>
<p>If we wanted to update a record with some notes where previously it had none then we'd need to create a new instance, something like:</p>
<pre><code>var updatedEmployee = new EmployeeDetails(
  employee.Name,
  employee.StartDate,
  &quot;Awesome attitude!&quot;
);
</code></pre>
<p>This sort of thing (calling the constructor explicitly) gets old quickly, particularly if the class gets extended in the future since then anywhere that did something like this would have to add more arguements to the constructor call.</p>
<p>So an alternative is to include &quot;With&quot; functions in the class -</p>
<pre><code>public class EmployeeDetails
{
  public EmployeeDetails(string name, DateTime startDate, string notesIfAny)
  {
    if (string.IsNullOrWhiteSpace(name))
      throw new ArgumentException(&quot;name&quot;);

    Name = name.Trim();
    StartDate = startDate;
    NotesIfAny = (notesIfAny == null) ? null : notesIfAny.Trim();
  }

  /// &lt;summary&gt;
  /// This will never be null or blank, it will not have any leading or trailing whitespace
  /// &lt;/summary&gt;
  public string Name { get; private set; }

  public DateTime StartDate { get; private set; }

  /// &lt;summary&gt;
  /// This will be null if it has not value, otherwise it will be a non-blank string with no
  /// leading or trailing whitespace
  /// &lt;/summary&gt;
  public string NotesIfAny { get; private set; }

  public EmployeeDetails WithName(string value)
  {
      return (value == Name) ? this : new EmployeeDetails(value, StartDate, NotesIfAny);
  }
  public EmployeeDetails WithStartDate(DateTime value)
  {
      return (value == StartDate) ? this : new EmployeeDetails(Name, value, NotesIfAny);
  }
  public EmployeeDetails WithNotesIfAny(string value)
  {
      return (value == NotesIfAny) ? this : new EmployeeDetails(Name, StartDate, value);
  }
}
</code></pre>
<p>Now the update code is more succinct -</p>
<pre><code>var updatedEmployee = employee.WithNotesIfAny(&quot;Awesome attitude!&quot;);
</code></pre>
<p>Another benefit of this approach is that the With functions can include a quick check to ensure that the new value is not the same as the current value - if it is then there's no need to generate a new instance, the current instance can be returned straight back out. This saves generating a new object reference and it makes it easier to rely upon simple reference equality tests when determining whether data has changed - eg.</p>
<pre><code>var updatedEmployee = employee.WithNotesIfAny(&quot;Awesome attitude!&quot;);
var didEmployeeAlreadyHaveAwesomeAttitude = (updatedEmployee == employee);
</code></pre>
<p><a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Last year's post</a> went off on a few wild tangents but basically was about allowing something like the following to be written:</p>
<pre><code>public class EmployeeDetails
{
  public EmployeeDetails(string name, DateTime startDate, string notesIfAny)
  {
    if (string.IsNullOrWhiteSpace(name))
      throw new ArgumentException(&quot;name&quot;);

    Name = name.Trim();
    StartDate = startDate;
    NotesIfAny = (notesIfAny == null) ? null : notesIfAny.Trim();
  }

  /// &lt;summary&gt;
  /// This will never be null or blank, it will not have any leading or trailing whitespace
  /// &lt;/summary&gt;
  public string Name { get; private set; }

  public DateTime StartDate { get; private set; }

  /// &lt;summary&gt;
  /// This will be null if it has not value, otherwise it will be a non-blank string with no
  /// leading or trailing whitespace
  /// &lt;/summary&gt;
  public string NotesIfAny { get; private set; }

  public EmployeeDetails With(
    Optional&lt;string&gt; name = new Optional&lt;string&gt;(),
    Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
    Optional&lt;Optional&lt;string&gt;&gt; notesIfAny = new Optional&lt;Optional&lt;string&gt;&gt;())
  {
    return DefaultUpdateWithHelper.GetGenerator&lt;EmployeeDetails&gt;()(
      this, name, startDate, notesIfAny
    );
  }
}
</code></pre>
<p>It allowed you to include a single &quot;With&quot; function that could change one or more of the properties in a single call like this:</p>
<pre><code>var updatedEmployee = employee.With(name: &quot;Jimbo&quot;, notesIfAny: &quot;So lazy!&quot;);
</code></pre>
<p><em>And</em> it would do it with magic, so you wouldn't have to write all of the &quot;return-same-instance-if-no-values-changed&quot; logic and it would.. erm.. well, to be honest, I've forgotten some of the finer details! But I remember that it was fun messing around with, getting my hands dirty with reflection, compiled LINQ expressions, stack-trace-sniffing (and some required JIT-method-inlining-disabling).</p>
<p>A couple of weeks later I wrote a follow-up, taking on board some of the feedback and criticisms in the comments and doing some performance testing. One of the ways I came up with to create the &quot;magic With method&quot; was only twice as slow as writing it by hand.. which, now, doesn't sound all that <em>awesome</em> - <em>twice</em> as slow is often a bad thing, but I was quite proud of it at the time!</p>
<h3>Immutable Classes in 2015</h3>
<p>Recently, I've been making <a href="http://bridge.net/">Bridge.NET</a> applications and I've been favouring writing immutable types for the messages passed around the system. And, again, I've gotten a bit bored of writing the same lines of code over and over -</p>
<pre><code>if (value == null)
  throw new ArgumentNullException(&quot;value&quot;);
</code></pre>
<p>and</p>
<pre><code>/// &lt;summary&gt;
/// This will never be null
/// &lt;/summary&gt;
</code></pre>
<p>and</p>
<pre><code>/// &lt;summary&gt;
/// This will never be null, nor blank, nor have any leading or trailing whitespace
/// &lt;/summary&gt;
</code></pre>
<p><em>Never mind</em> contemplating writing all of those &quot;WithName&quot;, &quot;WithStartDate&quot; methods (checking in them that the values have actually changed and returning the same instance back out if not). I love the benefits of having these immutable types (reducing places where it's possible for state to change makes reasoning about code soooooooo much easier) but I'm getting tired of banging out the same constructs and sentences! follows a</p>
<p>So I've started on a new tack. I want to find those places where repetition is getting me down and I want to reduce it as much as possible. <em>But</em> I don't want to sacrifice my validation checks or the guarantess of immutability. And, again, to put this into context - I'm going to be concentrating on the classes that I write in C# but that Bridge.NET then translates into JavaScript, so there are different considerations to take into account. First of which being that Bridge doesn't support reflection and so none of the crazy stuff I was doing in &quot;pure&quot; C# will be possible! Not in the same way that I wrote it last time, at least..</p>
<p>Before I get into any silly stuff, though, I want to talk about a couple of techniques that hopefully aren't <em>too</em> controversial and that I think have improved my code as well as requiring me to type less.</p>
<p>First off is a variation of the &quot;<strong>Optional</strong>&quot; struct that I used in my C# library last time. Previously, as illustrated in the code at the top of this post, I was relying on argument names and comments to indicate when values may and may not be null. The &quot;Name&quot; property has a comment saying that it will not be null while the &quot;NotesIfAny&quot; property has a comment saying that it <em>might</em> be null - and it follows a convention of having an &quot;IfAny&quot; suffix, which suggests that it <em>might not</em> always have a value.</p>
<p>Instead, I want to move to assuming that all references are non-null and that values that <em>may</em> be null have their type wrapped in an <strong>Optional</strong> struct.</p>
<p>This would change the <strong>EmployeeDetails</strong> example to look like this:</p>
<pre><code>public class EmployeeDetails
{
  public EmployeeDetails(string name, DateTime startDate, Optional&lt;string&gt; notes)
  {
    if (string.IsNullOrWhiteSpace(name))
      throw new ArgumentException(&quot;name&quot;);
    Name = name.Trim();
    StartDate = startDate;
    Notes = !notes.IsDefined || (notes.Value.Trim() == &quot;&quot;) ? null : notes.Value.Trim();
  }
  public string Name { get; private set; }
  public DateTime StartDate { get; private set; }
  public Optional&lt;string&gt; Notes { get; private set; }
}
</code></pre>
<p>The &quot;IfAny&quot; suffix is gone, along with all of the comments about null / non-null. Now the type system indicates whether a value may be null (in which case it will be wrapped in an Optional) or not.</p>
<p><em>(Note: I'll talk more about <strong>Optional</strong> later in this post - there's nothing too revolutionary or surprising in there, but it will distract from what I'm trying to build up to here).</em></p>
<p>We have lost something, though, because in the earlier code the Name and Notes fields had comments that stated that the values (if non-null, in the case of Notes) would <em>not</em> be blank and would <em>not</em> have any leading or trailing whitespace. This information is no longer included in comments, because I want to lose the comments. But, if I've solved the null / non-null problem by leveraging the type system, why not do the same with the non-blank-trimmed strings?</p>
<p>Introducing..</p>
<pre><code>public class NonBlankTrimmedString
{
  public NonBlankTrimmedString(string value)
  {
    if (string.IsNullOrWhiteSpace(value))
      throw new ArgumentException(&quot;Must be non-null and have some non-whitespace content&quot;);
    Value = value.Trim();
  }

  /// &lt;summary&gt;
  /// This will never have any leading or trailing whitespace, it will never be blank
  /// &lt;/summary&gt;
  public string Value { get; private set; }

  public static implicit operator NonBlankTrimmedString(string value)
  {
    return new NonBlankTrimmedString(value);
  }
  public static implicit operator string(NonBlankTrimmedString value)
  {
    return value.Value;
  }
}
</code></pre>
<p>Ok, so it looks like the comments are back.. but the idea is that the &quot;will never have any leading or trailing whitespace, it will never be blank&quot; need only appear <em>once</em> (in this class) and <em>not</em> for every property that should be non-null and non-blank and not-have-any-leading-or-trailing-whitespace.</p>
<p>Now the <strong>EmployeeDetails</strong> class can become:</p>
<pre><code>public class EmployeeDetails
{
  public EmployeeDetails(
      NonBlankTrimmedString name,
    DateTime startDate,
    Optional&lt;NonBlankTrimmedString&gt; notes)
  {
    if (name == null)
      throw new ArgumentNullException(&quot;name&quot;);
    Name = name;
    StartDate = startDate;
    Notes = notes;
  }
  public NonBlankTrimmedString Name { get; private set; }
  public DateTime StartDate { get; private set; }
  public Optional&lt;NonBlankTrimmedString&gt; Notes { get; private set; }
}
</code></pre>
<p>This looks a lot better. Not only is there less to read, there was less repetitive code (and comments) to write but the same information is still available for someone reading / using the code. In fact, I think that it's better on that front now because the constructor signature and the property types themselves communicate this information - which makes it harder to ignore than a comment does. And the type system is the primary reason that I want to write my front-end applications in C# rather than JavaScript!</p>
<p>However, there are <em>still</em> a couple of things that I'm not happy with. Firstly, in an ideal world, the constructors would magically have if-null-then-throw conditions injected for every argument - there are <em>no</em> arguments that should be null now; <strong>Optional</strong> is a struct and so can never be null, while any references that <em>could</em> be null should be wrapped in an <strong>Optional</strong>. One way to achieve that this in regular C# is with <a href="http://haacked.com/archive/2013/01/05/mitigate-the-billion-dollar-mistake-with-aspects.aspx/">IL rewriting</a> but I'm not a huge fan of that because I have suspicions about PostSharp (that I should probably revisit one day because I'm no longer completely sure what grounds they're based on). But, aside from that, it would be use when writing C# for Bridge, since IL doesn't come into the process - C# source code is translated into JavaScript and IL isn't involved!</p>
<p>Secondly, I need to tackle the &quot;With&quot; function(s) and I'd like to make that as painless as possible, really. Writing them all by hand is tedious.</p>
<h3>Get to the point, already!</h3>
<p>So.. I've been playing around and I've written a Bridge.NET library that allows me to write something like this:</p>
<pre><code>public class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(
    NonBlankTrimmedString name,
    DateTime startDate,
    Optional&lt;NonBlankTrimmedString&gt; notes)
  {
    this.CtorSet(_ =&gt; _.Name, name);
    this.CtorSet(_ =&gt; _.StartDate, startDate);
    this.CtorSet(_ =&gt; _.Notes, notes);
  }
  public NonBlankTrimmedString Name { get; private set; }
  public DateTime StartDate { get; private set; }
  public Optional&lt;NonBlankTrimmedString&gt; Notes { get; private set; }
}
</code></pre>
<p>Which is not too bad! Unfortunately, yes, there is <em>some</em> duplication still - there are <em>three</em> places that each of the properties are mentioned; in the constructor argument list, in the constructor body and as public properties. However, I think that this is the bare minimum number of times that they <em>could</em> be repeated without sacrificing any type guarantees. The constructor has to accept a typed argument list and it has to somehow map them onto properties. The properties have to repeat the types so that any one accessing those property values know what they're getting.</p>
<p>But let's talk about the positive things, rather than the negative (such as the fact that while the format shown above is fairly minimal, it's <em>still</em> marginally more complicated in appearance than a simple mutable type). Actually.. maybe we should first talk about the <em>weird</em> things - like what is this &quot;CtorSet&quot; method?</p>
<p>&quot;CtorSet&quot; is an extension method that sets a specified property on the target instance to a particular value. It has the following signature:</p>
<pre><code>public static void CtorSet&lt;T, TPropertyValue&gt;(
  this T source,
  Func&lt;T, TPropertyValue&gt; propertyIdentifier,
  TPropertyValue value)
    with T : IAmImmutable
</code></pre>
<p>It doesn't <em>just</em> set it, though, it ensures that the value is not null first and throws an <strong>ArgumentNullException</strong> if it is. This allows me to avoid the repetitive and boring if-null-then-throw statements. I don't need to worry about cases where I <em>do</em> want to allow nulls, though, because I would use an <strong>Optional</strong> type in that case, which is a struct and so never can be null!</p>
<p>The method signature ensures that the type of the value is consistent with the type of the target property. If not, then the code won't compile. I <em>always</em> favour static type checking where possible, it means that there's no chance that a mistake you make will only reveal itself when a particular set of condition are met (ie. when a particular code path is executed) at runtime - instead the error is right in your face in the IDE, not even letting you <em>try</em> to run it!</p>
<p>Which makes the next part somewhat unfortunate. The &quot;propertyIdentifier&quot; must be:</p>
<ol>
<li>A simple lambda expression..</li>
<li>.. that identifies a property getter which has a corresponding setter (though it's fine for that setter to be private)..</li>
<li>.. where neither the getter nor setter have a Bridge [Name] / [Template] / [Ignore] / etc.. attribute on it..</li>
</ol>
<p>If any of these conditions are not met then the &quot;CtorSet&quot; method will throw an exception. But you might not find out until runtime because C#'s type system is not strong enough to describe all of these requirements.</p>
<p>The good news, though, is that while the C# type system itself isn't powerful enough, with Visual Studio 2015 it's possible to write a <a href="https://msdn.microsoft.com/en-us/magazine/dn879356.aspx">Roslyn Analyser</a> that <em>can</em> pick up any invalid propertRetriever before run time, so that errors <em>will</em> be thrown right in your face without you ever executing the code. The even better news is that such an analyser is included in the NuGet package! But let's not get ahead of ourselves, let me finish describing what this new method actually does first..</p>
<p>If it's not apparent from looking at the example code above, &quot;CtorSet&quot; is doing some magic. It's doing some basic sort of reflection in JavaScript to work out <em>how</em> to identify and set the target property. Bridge won't support reflection until v2 but my code does an approximation where it sniffs about in the JavaScript representation of the &quot;propertyIdentifier&quot; and gets a hold of the setter. Once it has done the work to identify the setter for a given &quot;T&quot; and &quot;propertyIdentifier&quot; combination, it saves it away in an internal cache - while we can't control and performance-tune JavaScript in quite the same way that we can with the CLR, it doesn't mean that we should do the same potentially-complicated work over and over again if we don't need to!</p>
<p>Another thing to note, if you haven't already spotted it: &quot;CtorSet&quot; will call <em>private</em> setters. This has the potential to be disastrous, if it could be called without restrictions, since it could change the data on types that <em>should</em> be able to give the appearance of immutability (ie. classes that set their state in their constructor and have private-only setters.. the pedantic may wish to argue that classes with private setters should not be considered strictly immutable because private functions <em>could</em> change those property values, but it's entirely possible to have classes that have the attribute of being <a href="https://blogs.msdn.microsoft.com/ericlippert/2007/11/13/immutability-in-c-part-one-kinds-of-immutability/">Observational Immutability</a> in this manner, and that's all I'm really interested in).</p>
<p>So there are two fail-safes built in. Firstly, the type constraint on &quot;CtorSet&quot; means that the target must implement the <strong>IAmImmutable</strong> interface. This is completely empty and so there is no burden on the class that implements it, it merely exists as an identifier that the current type should be allowed to work with &quot;CtorSet&quot;.</p>
<p>The second protection is that once &quot;CtorSet&quot; has been called for a particular target instance and a particular property, that property's value is &quot;locked&quot; - meaning that a subsequent call to &quot;CtorSet&quot; for the same instance and property will result in an exception being thrown. This prevents the situation from occurring where an <strong>EmployeeDetails</strong> is initialised using &quot;CtorSet&quot; in its constructor but then gets manipulated externally via further calls to &quot;CtorSet&quot;. Since the <strong>EmployeeDetails</strong> properties are all set in its constructor using &quot;CtorSet&quot;, no-one can change them later with another call to &quot;CtorSet&quot;. (This is actually something else that is picked up by the analyser - &quot;CtorSet&quot; may <em>only</em> be called from within constructor - so if you're using this library within Visual Studio 2015 then you wouldn't have to worry about &quot;CtorSet&quot; being called from elsewhere, but if you're <em>not</em> using VS 2015 then this extra runtime protection may be reassuring).</p>
<p>Now that &quot;CtorSet&quot; is explained, I can get to the next good bit. I have <em>another</em> extension method:</p>
<pre><code>public T With&lt;T, TPropertyValue&gt;(
  this T source,
  Func&lt;T, TPropertyValue&gt; propertyIdentifier,
  TPropertyValue value)
    with T : IAmImmutable
</code></pre>
<p>This works in a similar manner to &quot;CtorSet&quot; but, instead of setting a property value on the current instance, it will clone the target instance then update the property on <em>that</em> instance and then return that instance. Unless the new property value is the same as the current one, in which case this work will be bypassed and the current instance will be returned unaltered. As with &quot;CtorSet&quot;, null values are not allowed and will return in an <strong>ArgumentNullException</strong> being thrown.</p>
<p>With this method, having specific &quot;With&quot; methods on classes is not required. Continuing with the <strong>EmployeeDetails</strong> class from the example above, if we have:</p>
<pre><code>var employee = new EmployeeDetails(
  &quot;John Smith&quot;,
  new DateTime(2014, 9, 3),
  null
);
</code></pre>
<p>.. and we then discover that his start date was recorded incorrectly, then this instance of the record could be replaced by calling:</p>
<pre><code>employee = employee.With(_ =&gt; _.StartDate, new DateTime(2014, 9, 2));
</code></pre>
<p>And, just to illustrate that if-value-is-the-same-return-instance-immediately logic, if we <em>then</em> did the following:</p>
<pre><code>var employeeUpdatedAgain= employee.With(_ =&gt; _.StartDate, new DateTime(2014, 9, 2));
</code></pre>
<p>.. then we could use referential equality to determine whether any change was made -</p>
<pre><code>// This will be false because the &quot;With&quot; call specified a StartDate value that was
// the same as the StartDate value that the employee reference already had
var wasAnyChangeMade = (employeeUpdatedAgain != employee);
</code></pre>
<h3>Bonus features</h3>
<p>So, in this library, there are the &quot;CtorSet&quot; and &quot;With&quot; extensions methods and there is an <strong>Optional</strong> type -</p>
<pre><code>public struct Optional&lt;T&gt; : IEquatable&lt;Optional&lt;T&gt;&gt;
{
  public static Optional&lt;T&gt; Missing { get; }

  public bool IsDefined { get; }
  public T Value { get { return this.value; } }
  public T GetValueOrDefault(T defaultValue);

  public static implicit operator Optional&lt;T&gt;(T value);
}
</code></pre>
<p>This has a convenience static function -</p>
<pre><code>public static class Optional
{
  public static Optional&lt;T&gt; For&lt;T&gt;(T value)
  {
    return value;
  }
}
</code></pre>
<p>.. which makes it easier any time that you explicitly need to create an <strong>Optional&lt;&gt;</strong> wrapper for a value. It lets you take advantage of C#'s type inference to save yourself from having to write out the type name yourself. For example, instead of writing something like</p>
<pre><code>DoSomething(new Optional&lt;string&gt;(&quot;Hello!&quot;));
</code></pre>
<p>.. you could just write</p>
<pre><code>DoSomething(Optional.For(&quot;Hello!&quot;));
</code></pre>
<p>.. and type inference will know that the <strong>Optional</strong>'s type is a string.</p>
<p>However, this is often unnecessary due to <strong>Optional</strong>'s implicit operator from &quot;<strong>T</strong>&quot; to <strong>Optional&lt;T&gt;</strong>. If you have a function</p>
<pre><code>public void DoSomething(Optional&lt;string&gt; value)
{
  // Do.. SOMETHING
</code></pre>
<p>.. then you can call it with <em>any</em> of the following:</p>
<pre><code>// The really-explicit way
DoSomething(new Optional&lt;string&gt;(&quot;Hello!&quot;));

// The rely-on-type-inference way
DoSomething(Optional.For(&quot;Hello!&quot;));

// The rely-on-Optional's-implicit-operator way
DoSomething(&quot;Hello!&quot;);
</code></pre>
<p>There is also an immutable collection type; the <strong>NonNullList&lt;T&gt;</strong>. This has a very basic interface -</p>
<pre><code>public sealed class NonNullList&lt;T&gt; : IEnumerable&lt;T&gt;
{
  public static NonNullList&lt;T&gt; Empty { get; }

  public int Count { get; }
  public T this[int index] { get; }
  public NonNullList&lt;T&gt; SetValue(int index, T value);
  public NonNullList&lt;T&gt; Insert(T item);
}
</code></pre>
<p>.. and it comes with a similar convenience static function -</p>
<pre><code>public static class NonNullList
{
    public static NonNullList&lt;T&gt; Of&lt;T&gt;(params T[] values);
}
</code></pre>
<p>The reason for this type is that it's so common to need collections of values but there is nothing immediately available in Bridge that allows me to do this while maintaining guarantees about non-null values and immutability.</p>
<p>I thought about using the <a href="https://facebook.github.io/immutable-js/">Facebook Immutable-Js</a> library but..</p>
<ol>
<li>It's a further dependency</li>
<li>I <em>really</em> wanted to continue the do-not-allow-null philosophy that I use with &quot;CtorSet&quot; and &quot;With&quot;</li>
</ol>
<p>I actually considered calling the &quot;<strong>NonNullList</strong>&quot; type the &quot;<strong>NonNullImmutableList</strong>&quot; but &quot;NonNull&quot; felt redundant when I was trying to encourage non-null-by-default and &quot;Immutable&quot; felt redundant since immutability is what this library is for. So that left my with <strong>List&lt;T&gt;</strong> and that's already used! So I went with simply <strong>NonNullList&lt;T&gt;</strong>.</p>
<p>Immutable lists like this are commonly written using linked lists since, if the nodes are immutable, then sections of the list can often be shared between multiple lists - so, if you have a list with three items in it and you call &quot;Insert&quot; to create a new list with four items that has the new item as the new first first item in the linked list then the following three items will be the same three node instances that existed in the original list. This reuse of data is a way to make immutable types more efficient than the naive copy-the-entire-list-and-then-manipulate-the-new-version approach would be. I'm 99% sure that this is what the Facebook library uses for the simple list type and it's something I wrote about doing in C# a few years ago if you want to read more (see &quot;<a href="/persistent-immutable-lists">Persistent Immutable Lists</a>&quot;).</p>
<p>The reason that I mention this is to try to explain why the <strong>NonNullList</strong> interface is so minimal - there are no Add, InsertAt, etc.. functions. The cheapest operations to do to this structure are to add a new item at the start of the list and to iterate through the items from the start, so I started off with only those facilities initially. Then I added a getter (which is an O(n) operation, rather than the O(1) that you get with a standard array) and a setter (which is similarly O(n) in cost, compared to O(1) for an array) because they are useful in many situations. In the future I might expand this class to include more List-like functions, but I haven't for now.</p>
<p>Just to make this point clear one more time: <strong>NonNullList&lt;T&gt;</strong> functions will throw exceptions if null values are ever specified - all values should be non-null and the type of &quot;T&quot; should be an <strong>Optional</strong> if null values <em>are</em> required (in which case none of the actual elements of the set will be null since they will all be <strong>Optional</strong> instances and <strong>Optional</strong> is a struct).</p>
<p>To make it easier to work with properties that are collections of items, there is another &quot;With&quot; method signature:</p>
<pre><code>public T With&lt;T, TPropertyElement&gt;(
  this T source,
  Func&lt;T, NonNullList&lt;TPropertyElement&gt;&gt; propertyIdentifier,
  int index,
  TPropertyElement value)
</code></pre>
<p>So, if you had a class like this -</p>
<pre><code>public class Something : IAmImmutable
{
  public Something(int id, NonNullList&lt;string&gt; items)
  {
    this.CtorSet(_ =&gt; _.Id, id);
    this.CtorSet(_ =&gt; _.Items, items);
  }
  public int Id { get; private set; }
  public NonNullList&lt;string&gt; Items { get; private set; }
}
</code></pre>
<p>.. and an instance of one created with:</p>
<pre><code>var s = new Something(1, NonNullList.Of(&quot;ZERO&quot;, &quot;One&quot;));
</code></pre>
<p>.. and you then wanted to change the casing of that second item, then you could do so with:</p>
<pre><code>s = s.With(_ =&gt; _.Items, 1, &quot;ONE&quot;);
</code></pre>
<p>If you specified an invalid index then it would fail at runtime, as it would if you tried to pass a null value. If you tried to specify a value that was of an incompatible type then you would get a compile error as the method signature ensures that the specified value matches the <strong>NonNullList&lt;T&gt;</strong>'s item type.</p>
<h3>Getting hold of the library</h3>
<p>If this has piqued your interest then you can get the library from NuGet - it's called &quot;<a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a>&quot;. It should work fine with Visual Studio 2013 but I would recommend that you use 2015, since then the analysers that are part of the NuGet package will be installed and enabled as well. The analysers confirm that every &quot;property retriever&quot; argument is <em>always</em> a simple lambda, such as</p>
<pre><code>_ =&gt; _.Name
</code></pre>
<p>.. and ensures that &quot;Name&quot; is a property that both &quot;CtorSet&quot; and &quot;With&quot; are able to use in their manipulations*. If this is not the case, then you will get a descriptive error message explaining why.</p>
<p>* <em>(For example, properties may not be used whose getter or setter has a Bridge [Name], [Template] or [Ignore] attribute attached to it).</em></p>
<p>One think to be aware of with using Visual Studio 2015 with Bridge.Net, though, is that Bridge does not yet support C# 6 syntax. So don't get carried away with the wonderful new capabilities (like my beloved <a href="https://msdn.microsoft.com/en-us/library/dn986596.aspx">nameof</a>). Support for this new syntax is, I believe, coming in Bridge v2..</p>
<p>If you want to look at the actual code then feel free to check it out at <a href="https://github.com/ProductiveRage/Bridge.Immutable">github.com/ProductiveRage/Bridge.Immutable</a>. That's got the library code itself as well as the analysers and the unit tests <em>for</em> the analysers. It's the first time that I've tried to produce a full, polished analyser and I had fun! As well as a few speed bumps.. (possibly a topic for another day).</p>
<p>While the library, as delivered through the NuGet package, should work fine for both VS 2013 and VS 2015, building the solution yourself requires VS 2015 <em>Update 1</em>.</p>
<h3>Is this proven and battle-hardened?</h3>
<p>No.</p>
<p>At this point in time, this is mostly still a concept that I wanted to try out. I think that what I've got is reliable and quite nicely rounded - I've <em>tried</em> to break it and haven't been able to yet. And I intend to use it in some projects that I'm working on. However, at this moment in time, you might want to consider it somewhat experimental. Or you could just be brave and starting using it all over the place to see if it fits in with your world view regarding how you should write C# :)</p>
<h3>Is &quot;IAmImmutable&quot; really necessary?</h3>
<p>If you've <em>really</em> been paying attention to all this, you might have noticed that I said earlier that the <strong>IAmImmutable</strong> interface is used to identify types that have been designed to work with &quot;CtorSet&quot;, to ensure that you can't call &quot;CtorSet&quot; on references that weren't expecting it and whose should-be-private internals you could then meddle with. Well, it would be a reasonable question to ask:</p>
<blockquote>
<p>Since there is an analyser to ensure that &quot;CtorSet&quot; is only called from within a constructor, surely <strong>IAmImmutable</strong> is unnecessary because it would not be possible to call &quot;CtorSet&quot; from places where it shouldn't be?</p>
</blockquote>
<p>I have given this some thought and have decided (for now, at least) to stick with the <strong>IAmImmutable</strong> marker interface for two reasons:</p>
<ol>
<li>If you're writing code where the analyser is not being used (such as in Visual Studio versions before 2015) then it makes it harder to write code that could change private state where it should not be possible</li>
<li>It avoids polluting the auto-complete matches by only allowing &quot;CtorSet&quot; and &quot;With&quot; to be called against <em>any</em> type, even where it's not applicable (such as on the <strong>string</strong> class, for example)</li>
</ol>
<p>The first point refers to the fallback defense mechanism that will not allow properties to have their value set more than once using &quot;CtorSet&quot;, attempting to do so will result in a runtime error. If a class has all of its properties set using &quot;CtorSet&quot; within its constructor then any external, subsequent &quot;CtorSet&quot; call will fail. Having to implement the <strong>IAmImmutable</strong> interface when writing immutable types hopefully acts as a reminder to do this. Without this extra protection (and without the analyser), your code could contain &quot;CtorSet&quot; calls that manipulate private state in classes that have no idea what's hit them!</p>
<p>Meanwhile, the second just <em>feels</em> like a good practice so that &quot;CtorSet&quot; and &quot;With&quot; don't crop up over and over again on types that you would not want to use them with.</p>
<p>If anyone really wanted the <strong>IAmImmutable</strong>-requirement to be relaxed (which would allow the immutable types to be written in an even more succinct manner, since they wouldn't need to implement that interface) then I would definitely be up for a debate.</p>
<p class="PostTime">Posted at 22:22</p><div class="Related"><h3>You may also be interested in:</h3><ul><li><a href="/using-roslyn-code-fixes-to-make-the-frictionless-immutable-objects-in-bridge-even-easier">Using Roslyn code fixes to make the &quot;Friction-less immutable objects in Bridge&quot; even easier</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications#disqus_thread" data-disqus-identifier="93">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">2 November 2014</p><h2><a id="locating-todo-comments-with-roslyn" href="/locating-todo-comments-with-roslyn">Locating TODO comments with Roslyn</a></h2>
<p>I picked up an old project recently that I knew I'd made good progress on and that the bits that were finished were looking good.. but also I knew that it had TODO comments littered throughout it to remind me what I <em>hadn't</em> finished.</p>
<p>To get an idea just how many of these there were, I did a solution-wide search for &quot;TODO&quot; in Visual Studio. There were just over two hundred of them. The search results gave me a fair idea of where they were but I got it into my head that I wanted to export this into a list and then map them onto projects and - ideally - classes and methods. The first part is easy, the search results output contains the path to the file, which indicates the project name. The classes, also, could often be extracted from the filename - so long as there was only one class (or interface or enum or whatever) per file, though no nested types would be awkward.</p>
<p>And this, really, would have been enough information to start tracking my progress and have a checklist that I could take satisfaction in crossing items off from. But of course I wanted more! Isn't this new* Roslyn thing supposed to be about parsing code, shouldn't I be able to use it to find out what properties or methods the TODO comments I've found are associated with? And don't I sometimes need a break from genuinely productive work to play with something new and shiny under the pretense of doing something useful with it?? :)</p>
<p>* <em>(Not that new, actually, seeing as it was announced for preview back in 2011)</em>.</p>
<h3>The two sides of Roslyn</h3>
<p>Roslyn is often talked about as enabling a &quot;compiler as a service&quot; - where code can be compiled and executed on-the-fly. So some sort of scripting engine could be created to dynamically change behaviour on already-executing code. Essentially, Roslyn can take source code (C# or VB) and generate IL, which can then be executed and interacted with by the application that fed that source code through it.</p>
<p>However, the other side of it is that it provides &quot;rich code analysis APIs&quot; (according to its <a href="http://msdn.microsoft.com/en-gb/vstudio/roslyn.aspx">page on MSDN</a>) - meaning that it will help you examine the source code, even if you have no intention of executing that code. Which sounds exactly like what I want to try to locate my TODO comments within a containing method / property / type / namespace.</p>
<p>If I had more ambitious aims in mind then it could also be used for all manner of IDE extensions for code investigation, refactoring or &quot;best practices analysis&quot;. A bit like many of the features that <a href="https://www.jetbrains.com/resharper">ReSharper</a> provides (though ReSharper predates it, and woe betide anyone who asks if they are thinking of integrating with Roslyn so that they don't have to maintain as much parsing code of their own - <a href="http://blog.jetbrains.com/dotnet/2014/04/10/resharper-and-roslyn-qa">Ask me again if ReSharper will use Roslyn.. I dare you</a>).</p>
<p>To getting started with Roslyn, you install it through NuGet - though, currently, it's marked as pre-release so mightn't show up when you search for it. The best thing to do is follow the instruction on the <a href="https://www.nuget.org/packages/Microsoft.CodeAnalysis">NuGet package</a> page and run</p>
<blockquote>
<p>Install-Package Microsoft.CodeAnalysis -Pre</p>
</blockquote>
<p>at the Package Manager Console.</p>
<p>With this done, parsing code is as easy as</p>
<pre><code>var parsedContent = CSharpSyntaxTree.ParseText(content);
</code></pre>
<p>where &quot;content&quot; is a string. This string may be an entire file as you would expect to encounter it in a project - with a namespace containing class / interface / enum and fields / properties / methods / values - or it may be a &quot;fragment&quot;, such as a single method or method call (as often illustrated when people talk about using Roslyn for scripting).</p>
<p>The &quot;ParseText&quot; method returns a <strong>SyntaxTree</strong> instance. This is an immutable structure that describes the parsed content. I'm a huge fan of immutable structures since I think it makes code much easier to reason about (my love of immutability has been a theme through many of the posts I've written). In Roslyn's design it has been stated that</p>
<blockquote>
<p>The short answer to why syntax trees are immutable in Roslyn is that it makes parallel work much easier.  You can take a syntax tree and pass it to any thread and not worry that someone else will mutate it while you are in the middle of doing analysis.  This is useful in the command line compiler so that multiple trees can have their methods bound in parallel (which may need to occasionally access information from a different tree), but it's EXTREMELY important for VS scenarios where we want to have an extensibility model that allows many extensions to analyze and transform the same tree in parallel, and it doesn't really work to have a model that forces all those separate extensions to co-ordinate locking a single tree.  Similarly, providing each extension its own copy of the tree would be prohibitive from a memory overhead point of view.</p>
</blockquote>
<p>(I took this from a Google Groups thread <a href="http://groups.google.com/d/msg/altnetisrael/0yUJJdg2D5g/CBk2Kn-mK9sJ">Why are Roslyn Syntax Trees Immutable?</a> and the answer is attributed to &quot;the Roslyn PM&quot;).</p>
<p>Eric Lippert has also written about the design, saying that they wanted the data structures to be immutable and persistent and that</p>
<blockquote>
<p>By persistence I mean the ability to reuse most of the existing nodes in the tree when an edit is made to the text buffer. Since the nodes are immutable, there's no barrier to reusing them, as I've discussed many times on this blog. We need this for performance; we cannot be re-parsing huge wodges of text every time you hit a key. We need to re-lex and re-parse only the portions of the tree that were affected by the edit, because we are potentially re-doing this analysis between every keystroke.</p>
</blockquote>
<p>This is in the context of using Roslyn to analyse code being written within Visual Studio - the full post is titled <a href="http://blogs.msdn.com/b/ericlippert/archive/2012/06/08/persistence-facades-and-roslyn-s-red-green-trees.aspx">Persistence, Facades and Roslyn's Red-Green Trees</a>.</p>
<h3>Get to the point already!</h3>
<p>So. Enough history. Back to my TODO-search.</p>
<p>The <strong>SyntaxTree</strong> returned from &quot;ParseText&quot; looks quite complex at first glance when you starting poking around it with Visual Studio's &quot;QuickWatch&quot; facility, at least (which is the first thing I did).</p>
<p>However, Roslyn helpfully provides a <strong>SyntaxWalker</strong> class, which may be used to easily examine every node within the tree. It uses the vistor pattern to do this. Design patterns are said to be a benefit when their form is appropriate to your problem such that they extend your vocabulary to describe the solution. There seem like there are times, unfortunately, that people layer on design patterns and abstractions only because they think they should - which is why it's nice in cases like this where it makes perfect sense and succeeds in makings things simple if you know the pattern being used. Last year, I was writing a plugin for <a href="http://www.dotlesscss.org">dotLess</a> which used the visitor pattern to traverse the nodes in a stylesheet (see <a href="/cross-browser-pseudo-source-mapping-with-less">Cross Browser (Pseudo) Source Mapping with LESS</a>) and it was nice to see the exact same concept in use here.</p>
<p>The simplest implementation is</p>
<pre><code>public class TriviaVisitor : SyntaxWalker
{
  public TriviaVisitor() : base(SyntaxWalkerDepth.StructuredTrivia) { }
  protected override void VisitTrivia(SyntaxTrivia trivia)
  {
    // Examine Trivia here..
  }
}
</code></pre>
<p>When the &quot;Visit&quot; method is called (which is defined by the <strong>SyntaxWalker</strong> class) and given a parsed tree, the &quot;VisitTrivia&quot; method is called for every <strong>SyntaxTrivia</strong> instance that is encountered within that tree - eg.</p>
<pre><code>(new TriviaVisitor()).Visit(
  CSharpSyntaxTree.ParseText(content).GetRoot()
);
</code></pre>
<p>Comments and whitespace are <strong>SyntaxTrivia</strong>. Everything else will be represented by the <strong>SyntaxNode</strong> and <strong>SyntaxToken</strong> types. A <strong>SyntaxNode</strong> is made up on <strong>SyntaxToken</strong>s. For example, a &quot;<strong>UsingDirectiveSyntax</strong>&quot; represents a &quot;using&quot; statement such as</p>
<pre><code>using System;
</code></pre>
<p>and will contain <strong>SyntaxTokens</strong> for the &quot;using&quot;, &quot;System&quot; and &quot;;&quot; components of the statement.</p>
<p>These <strong>SyntaxNode</strong>s and <strong>SyntaxToken</strong>s are part of the tree that describes that parsed content. Trivia, however, are not directly part of the hierarchical data - rather, they are related to tokens  and accessible through the token's &quot;LeadingTrivia&quot; and &quot;TrailingTrivia&quot; properties. Conversely, <strong>SyntaxTrivia</strong> instances have a &quot;Token&quot; property which allows you to map from the trivia back to the associated token.</p>
<p>So, within a &quot;VisitTrivia&quot; method, we can identify trivia we're interested in (comments, in this case, rather than whitespace) and determine what token they're associated with. The token will have a &quot;Parent&quot; property, which is the <strong>SyntaxNode</strong> that it's part of. The node is part of a hierarchy, which can be traversed up through via the &quot;Parent&quot; property values - each node may be something we're interested in identifying; such as the method containing the comment, the type containing that method or the namespace containing that type (must remember, though, that not all comments will be within methods - some may be TODO comments annotating a class, or even just sitting out on their own in an otherwise-empty file).</p>
<pre><code>public class CommentLocatingVisitor : SyntaxWalker
{
  private readonly Action&lt;ToDoComment&gt; _commentLocated;
  public CommentLocatingVisitor(Action&lt;ToDoComment&gt; commentLocated)
    : base(SyntaxWalkerDepth.StructuredTrivia)
  {
    if (commentLocated == null)
      throw new ArgumentNullException(&quot;commentLocated&quot;);

    _commentLocated = commentLocated;
  }

  protected override void VisitTrivia(SyntaxTrivia trivia)
  {
    if (_commentTypes.Contains(trivia.CSharpKind()))
    {
      string triviaContent;
      using (var writer = new StringWriter())
      {
        trivia.WriteTo(writer);
        triviaContent = writer.ToString();
      }

      // Note: When looking for the containingMethodOrPropertyIfAny, we want MemberDeclarationSyntax
      // types such as ConstructorDeclarationSyntax, MethodDeclarationSyntax, IndexerDeclarationSyntax,
      // PropertyDeclarationSyntax but NamespaceDeclarationSyntax and TypeDeclarationSyntax also
      // inherit from MemberDeclarationSyntax and we don't want those
      var containingNode = trivia.Token.Parent;
      var containingMethodOrPropertyIfAny = TryToGetContainingNode&lt;MemberDeclarationSyntax&gt;(
        containingNode,
        n =&gt; !(n is NamespaceDeclarationSyntax) &amp;&amp; !(n is TypeDeclarationSyntax)
      );
      var containingTypeIfAny = TryToGetContainingNode&lt;TypeDeclarationSyntax&gt;(containingNode);
      var containingNameSpaceIfAny = TryToGetContainingNode&lt;NamespaceDeclarationSyntax&gt;(containingNode);
      _commentLocated(new ToDoComment(
        triviaContent,
        trivia.SyntaxTree.GetLineSpan(trivia.Span).StartLinePosition.Line,
        containingMethodOrPropertyIfAny,
        containingTypeIfAny,
        containingNameSpaceIfAny
      ));
    }
    base.VisitTrivia(trivia);
  }

  private static HashSet&lt;SyntaxKind&gt; _commentTypes = new HashSet&lt;SyntaxKind&gt;(new[] {
    SyntaxKind.SingleLineCommentTrivia,
    SyntaxKind.MultiLineCommentTrivia,
    SyntaxKind.DocumentationCommentExteriorTrivia,
    SyntaxKind.SingleLineDocumentationCommentTrivia,
    SyntaxKind.MultiLineDocumentationCommentTrivia
  });

  private T TryToGetContainingNode&lt;T&gt;(SyntaxNode node, Predicate&lt;T&gt; optionalFilter = null)
    where T : SyntaxNode
  {
    if (node == null)
      throw new ArgumentNullException(&quot;node&quot;);

    var currentNode = node;
    while (true)
    {
      var nodeOfType = currentNode as T;
      if (nodeOfType != null)
      {
        if ((optionalFilter == null) || optionalFilter(nodeOfType))
          return nodeOfType;
      }
      if (currentNode.Parent == null)
        break;
      currentNode = currentNode.Parent;
    }
    return null;
  }
}
</code></pre>
<p>This <strong>CommentLocatingVisitor</strong> class is instantiated with a callback that is executed for every comment that is encountered when its &quot;ParseText&quot; method is called and the provided root traversed.</p>
<p>To keep things organised, this callback passes a <strong>Comment</strong> instance, as follows:</p>
<pre><code>public class Comment
{
  public Comment(
    string content,
    int lineNumber,
    MemberDeclarationSyntax methodOrPropertyIfAny,
    TypeDeclarationSyntax typeIfAny,
    NamespaceDeclarationSyntax namespaceIfAny)
  {
    if (string.IsNullOrEmpty(content))
      throw new ArgumentException(&quot;Null/blank content specified&quot;);
    if (lineNumber &lt; 1)
      throw new ArgumentOutOfRangeException(&quot;lineNumber&quot;);

    Content = content;
    LineNumber = lineNumber;
    MethodOrPropertyIfAny = methodOrPropertyIfAny;
    TypeIfAny = typeIfAny;
    NamespaceIfAny = namespaceIfAny;
  }

  /// &lt;summary&gt;
  /// This will never be null or blank
  /// &lt;/summary&gt;
  public string Content { get; private set; }

  /// &lt;summary&gt;
  /// This will always be a positive integer
  /// &lt;/summary&gt;
  public int LineNumber { get; private set; }

  /// &lt;summary&gt;
  /// This may be null since the comment may not exist within a method or property
  /// &lt;/summary&gt;
  public MemberDeclarationSyntax MethodOrPropertyIfAny { get; private set; }

  /// &lt;summary&gt;
  /// This may be null since the comment may not exist within an class, interface or struct
  /// &lt;/summary&gt;
  public TypeDeclarationSyntax TypeIfAny { get; private set; }

  /// &lt;summary&gt;
  /// This may be null since the comment may not exist within a method or property
  /// &lt;/summary&gt;
  public NamespaceDeclarationSyntax NamespaceIfAny { get; private set; }
}
</code></pre>
<p>So now, given the contents of any C# file, the comments can be identified and traced to the constructs that they're associated with. Now they just need to be filtered to those containing the text &quot;TODO&quot;, since those are the particular comments of interest.</p>
<p>For the first stab I took at this, I did a search-all-solution for &quot;TODO&quot; and copy-pasted the results into a file. I then read in this file, extracted the filenames and ran the above against the contents of each file.</p>
<p>But surely there's a better way..</p>
<h3>Parsing the solution</h3>
<p>What would be ideal would be the ability to point some code at a solution file, for it to determine what projects are in the solution, what C# code files are in the projects and then to extract all of the locations of TODO comments within those. None of this search-all / copy-paste / parse-the-results-and-read-the-files-from-there nonsense.</p>
<p>There are two parts to this - reading the solution file to get the projects and reading the individual project files. I'll start with the latter since it turned out to be easier.</p>
<p>If you add a reference to &quot;Microsoft.Build&quot; then you can can use the <strong>ProjectCollection</strong> type in a method such as</p>
<pre><code>private static IEnumerable&lt;FileInfo&gt; GetCSharpCompileItemFilesForProject(FileInfo projectFile)
{
  if (projectFile == null)
    throw new ArgumentNullException(&quot;projectFile&quot;);

  return (new ProjectCollection()).LoadProject(projectFile.FullName).AllEvaluatedItems
    .Where(item =&gt; item.ItemType == &quot;Compile&quot;)
    .Select(item =&gt; item.EvaluatedInclude)
    .Where(include =&gt; include.EndsWith(&quot;.cs&quot;, StringComparison.OrdinalIgnoreCase))
    .Select(include =&gt; new FileInfo(Path.Combine(projectFile.Directory.FullName, include)));
}
</code></pre>
<p>Nice when the framework provides you just what you need! This is basically just looking for &quot;.cs&quot; items in a given project file and returning <strong>FileInfo</strong> instances such that the full path is made available (the filenames in the project will be paths relative to the location of the project file and so need to be combined with the project file location to get the full path of the file).</p>
<p>The solution file parsing is not quite so elegant.</p>
<p>There is a Stack Overflow question &quot;<a href="http://stackoverflow.com/questions/13280008/how-do-i-compile-a-c-sharp-solution-with-roslyn">How do I compile a C# solution with Roslyn?</a>&quot; which talks about parsing a solution file. But it's very out of date and the code doesn't compile. But it leads to another question &quot;<a href="http://stackoverflow.com/questions/23160685/roslyn-find-references-cant-properly-load-workspace">Roslyn / Find References - Can't properly load Workspace</a>&quot; which looks like it's going to help but I encountered the same problem as this question: &quot;<a href="http://stackoverflow.com/questions/25504951/msbuildworkspace-create-throws-exception">MSBuildWorkspace.Create() throws exception</a>&quot;. The gist is that to use this you need to Microsoft.Build version 14, whereas the version available (for VS 2013, at least) is version 4. It seems like the solution is to download the VS 2014 CTP or get the ISO file and root around for the version 14 assembly.</p>
<p>At this point, I got bored with it and fell back to parsing the solution field with a regular expression, looking for &quot;.csproj&quot; files in what look like project declarations.</p>
<pre><code>private static IEnumerable&lt;FileInfo&gt; GetProjectFilesForSolution(FileInfo solutionFile)
{
  if (solutionFile == null)
    throw new ArgumentNullException(&quot;solutionFile&quot;);

  var projectFileMatcher = new Regex(
    @&quot;Project\(&quot;&quot;\{\w{8}-\w{4}-\w{4}-\w{4}-\w{12}\}&quot;&quot;\) = &quot;&quot;(.*?)&quot;&quot;, &quot;&quot;(?&lt;projectFile&gt;(.*?\.csproj))&quot;&quot;, &quot;&quot;\{\w{8}-\w{4}-\w{4}-\w{4}-\w{12}\}&quot;&quot;&quot;
  );
  foreach (Match match in projectFileMatcher.Matches(solutionFile.OpenText().ReadToEnd()))
  {
    yield return new FileInfo(
      Path.Combine(solutionFile.Directory.FullName, match.Groups[&quot;projectFile&quot;].Value)
    );
  }
}
</code></pre>
<p>It feels a bit dirty but it seems to do the job! And this is hardly production code so I can live with it.</p>
<h3>Cryptic warnings</h3>
<p>There is another small niggle with all this code. It works but there's a compile warning</p>
<blockquote>
<p>Found conflicts between different versions of the same dependent assembly that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</p>
</blockquote>
<p>I don't like compile warnings, if something's wrong then I want to make it right. Plenty of people have eloquently made the case for always resolving compile warnings so I won't go over old ground here - just suffice to say that I agree!</p>
<p>The log verbosity can be altered by going to Tools / Option / Projects and Solutions / Build and Run, from there &quot;MSBuild project build output verbosity&quot; can be changed. So I set it to &quot;Detailed&quot; as instructed in the warning message and found.. nothing useful.</p>
<p>It turns out that this warning is telling a bit of a fib and you actually need to bump the verbosity up another step to &quot;Diagnostic&quot;. <em>Then</em> the log includes the following</p>
<blockquote>
<p>There was a conflict between <code>Microsoft.Build, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</code> and <code>Microsoft.Build, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</code>.</p>
</blockquote>
<p>It also includes lots of other useful information like what references have what dependencies, so I can see that Microsoft Build v4 is required by project item &quot;Microsoft.Build&quot; (meaning that is the version that I explicitly added as a reference to parse the project files). And I can see that Microsoft Build v14 is required by the project items &quot;Microsoft.CodeAnalysis.Workspaces&quot;, &quot;Microsoft.CodeAnalysis.VisualBasic.Workspaces&quot; and &quot;Microsoft.CodeAnalysis.CSharp.Workspaces&quot;, which are references pulled in by the Roslyn NuGet package.</p>
<p>Unfortunately, I've already explained that I gave up trying to install Microsoft.Build v14! If this was &quot;real&quot; code then I would do it properly and investigate installing that package properly to get rid of this warning.. but for this sort of one-off task (pulling the TODO comments out of a solution, once) I decided I can live with the warning. At least I have an idea how to sort it out if I ever do want to use this code in a more demanding environment.</p>
<h3>Parting words</h3>
<p>This first foray into Roslyn's capabilities has been interesting. I've clearly scratched only the very outer surface of it but it seems like a really well considered product, I think it could be useful in many scenarios and fully intend to have a poke around with its compiling capabilities at some point (since I do love a bit of dynamic compilation, as I was writing about last time!).</p>
<p>If anything that I've written about today could be useful to you, I've put a complete solution up on Bitbucket - find it at <a href="https://bitbucket.org/DanRoberts/todocommentretriever">The TODOCommentRetriever</a>.</p>
<p class="PostTime">Posted at 19:38</p><div class="Related"><h3>You may also be interested in:</h3><ul><li><a href="/cross-browser-pseudo-source-mapping-with-less">Cross Browser (Pseudo) Source Mapping with LESS</a></li><li><a href="/c-sharp-state-machines">C# State Machines</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li><li><a href="/Archive/Tag/Roslyn" title="4 Posts">Roslyn</a></li></ul></div>
            <p class="Comments">
                <a href="/locating-todo-comments-with-roslyn#disqus_thread" data-disqus-identifier="78">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">2 October 2014</p><h2><a id="a-followup-to-implementing-f-sharp-inspired-with-updates-in-c-sharp" href="/a-followup-to-implementing-f-sharp-inspired-with-updates-in-c-sharp">A follow-up to &quot;Implementing F#-inspired 'with' updates in C#&quot;</a></h2>
<p>A couple of weeks ago, I was talking about a way to structure an &quot;UpdateWith&quot; method that immutable classes in C# could have so that callers can change one or more properties in a single call, resulting in a new instance of the class. Presuming, of course, that the new property values varied from the old values - otherwise the original instance should be returned (there's no point creating a new instance to represent the exact same data when the containing type is an immutable &quot;value&quot;). Feel free to go read <a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired &quot;with&quot; updates for immutable classes in C#</a> if you didn't already!</p>
<p>The really simple way to do something like this is to actually not have an &quot;UpdateWith&quot; method at all and for the calling code to call the constructor directly, but means that there will potentially be a lot places that need fixing if the constructor arguments are changed or re-ordered at any time. Another simple approach is for there to be multiple &quot;Update&quot; methods, one for each property (so you might have an &quot;UpdateName&quot; method, an &quot;UpdateStartDate&quot;; a distinct &quot;Update{whatever}&quot; for each individual property).</p>
<p>I was feeling oh so proud of myself for thinking to combine a multiple-parameter &quot;Update&quot; method with an &quot;<strong>Optional</strong>&quot; struct so that the best of every world could be had - a single call could update one or more properties without having to specify values for properties that are <em>not</em> to be updated. Unlike with the &quot;Update{whatever}&quot; methods, if two properties need to be updated, only a single new instance will be required - there will not be new instances for <em>each separate</em> property update - so there would be no added GC pressure from unnecessary &quot;intemediate&quot; instances.</p>
<p>To illustrate -</p>
<pre><code>public class RoleDetails
{
  public RoleDetails(string title, DateTime startDate, DateTime? endDateIfAny)
  {
    Title = title;
    StartDate = startDate;
    EndDateIfAny = endDateIfAny;
  }

  public string Title { get; private set; }
  public DateTime StartDate { get; private set; }
  public DateTime? EndDateIfAny { get; private set; }

  public RoleDetails UpdateWith(
    Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
    Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
    Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
  {
    if (!title.IndicatesChangeFromValue(Title)
    &amp;&amp; !startDate.IndicatesChangeFromValue(StartDate)
    &amp;&amp; !endDateIfAny.IndicatesChangeFromValue(EndDateIfAny))
      return this;

    return new RoleDetails(
      title.GetValue(Title),
      startDate.GetValue(StartDate),
      endDateIfAny.GetValue(EndDateIfAny)
    );
  }
}
</code></pre>
<p>The <strong>Optional</strong> struct looked like this:</p>
<pre><code>public struct Optional&lt;T&gt;
{
  private T _valueIfSet;
  private bool _valueHasBeenSet;

  public T GetValue(T valueIfNoneSet)
  {
    return _valueHasBeenSet ? _valueIfSet : valueIfNoneSet;
  }

  public bool IndicatesChangeFromValue(T value)
  {
    if (!_valueHasBeenSet)
      return false;

    if ((value == null) &amp;&amp; (_valueIfSet == null))
      return false;
    else if ((value == null) || (_valueIfSet == null))
      return true;

    return !value.Equals(_valueIfSet);
  }

  public static implicit operator Optional&lt;T&gt;(T value)
  {
    return new Optional&lt;T&gt;
    {
      _valueIfSet = value,
      _valueHasBeenSet = true
    };
  }
}
</code></pre>
<p>I then went on a bit of a wild tangent and thought &quot;if pretty much all of these UpdateWith methods are going to look the same and be boring to write, could I have some magic code generate it for me on the fly?&quot; - this led me to write a small library that allows the following:</p>
<pre><code>public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return DefaultUpdateWithHelper.GetGenerator&lt;RoleDetails&gt;()(this, title, startDate);
}
</code></pre>
<p>I got a variety of feedback on the post. One of the really interesting things to find was that the main idea itself was already in real-world use, in Microsoft's Roslyn .net compiler, for example. The file <a href="https://roslyn.codeplex.com/SourceControl/latest#Src/Workspaces/Core/Workspace/Solution/ProjectInfo.cs">ProjectInfo.cs</a> has a &quot;With&quot; method that follows a very similar structure with a corresponding <a href="https://roslyn.codeplex.com/SourceControl/latest#Src/Compilers/Core/Portable/Optional.cs">Optional.cs</a> struct that is also very similar to what I'd written. I found this very encouraging.. even if it did steal the thunder from &quot;my&quot; idea!</p>
<p>More of the feedback related to performance concerns regarding the &quot;DefaultUpdateWithHelper.GetGenerator&quot; method. It returns a delegate to create a new instance, based upon the provided arguments. This delegate is a compiled LINQ Expression, cached against the target type and the provided argument structure. The problem was that <em>some</em> reflection was required in order to determine whether there was a compiled expression in the cache that could be re-used, so each call to &quot;GetGenerator&quot; carried that reflection overhead. The question was just how much..</p>
<p>But before I go into that, one of the constructive comments was that I wasn't generating a hash code on my cache key type correctly. The cache key contained the information about the target type, along with the number of arguments and their types. The function to produce a combined hash for this information was</p>
<pre><code>public int GetHashCode(CacheKeyData obj)
{
  if (obj == null)
    throw new ArgumentNullException(&quot;obj&quot;);
  var hash = obj.DeclaringType.GetHashCode() ^ obj.TargetType.GetHashCode();
  for (var index = 0; index &lt; obj.NumberOfUpdateParameters; index++)
    hash = hash ^ obj.GetUpdateParameter(index).GetHashCode();
  return hash;
}
</code></pre>
<p>This goes through each aspect of the cache key data and performs XOR operations to get a combined result. It was pointed out by <a href="http://www.reddit.com/r/programming/comments/2gqx9u/implementing_finspired_with_updates_for_immutable/cklrh1d">Strilanc</a> on Reddit that it's better practice to multiple by a prime number after every XOR. This way, if there are two references that report the same hash code then they won't cancel each other out.</p>
<p>The reason that I'd used XOR without thinking about it too much was that I knew that XOR on two ints could never cause an overflow and so seemed like a safe easy option. But, in C#, this isn't something we normally have to worry about - for example</p>
<pre><code>// Trying to set &quot;var i0 = int.MaxValue + 1;&quot; will result in a compile error
//   &quot;The operation overflows at compile time in checked mode&quot;
// but performing in two steps will not
var i0 = int.MaxValue;
var i1 = i0 + 1;
</code></pre>
<p>does <em>not</em> result in an overflow exception. Instead, it wraps around (so i1 will be equal to int.MinValue). In order to &quot;opt in&quot; to overflow exceptions being raised for theses sorts of operations, the &quot;<a href="http://msdn.microsoft.com/en-us/library/74b4xzyw.aspx">checked</a>&quot; keyword needs to be used (or there's a &quot;checked&quot; compiler option that does the same).</p>
<p>So we can safely change the implementation to</p>
<pre><code>public int GetHashCode(CacheKeyData obj)
{
  if (obj == null)
    throw new ArgumentNullException(&quot;obj&quot;);
  var hash = obj.DeclaringType.GetHashCode() ^ obj.TargetType.GetHashCode();
  for (var index = 0; index &lt; obj.NumberOfUpdateParameters; index++)
    hash = (3 * hash) ^ obj.GetUpdateParameter(index).GetHashCode();
  return hash;
}
</code></pre>
<p>There was also a comment left on my blog</p>
<blockquote>
<p>.. your usage of the object.Equals() method also creates garbage..</p>
</blockquote>
<p>which I had to think about to understand what was meant. When I realised, I kicked myself that I'd missed it! In the <strong>Optional</strong> struct there's the method</p>
<pre><code>public bool IndicatesChangeFromValue(T value)
{
  if (!_valueHasBeenSet)
    return false;

  if ((value == null) &amp;&amp; (_valueIfSet == null))
    return false;
  else if ((value == null) || (_valueIfSet == null))
    return true;

  return !value.Equals(_valueIfSet);
}
</code></pre>
<p>That final call has to resort to</p>
<pre><code>public virtual bool Equals(object obj);
</code></pre>
<p>on the base <strong>Object</strong> type since the compiler has no other choice that could apply to any &quot;T&quot;. But if &quot;T&quot; is not a reference type then it has to be boxed in order to access it as an <strong>Object</strong> (which is necessary to access this lowest-common-denominator &quot;Equals&quot; method).</p>
<p>A better solution is to check whether &quot;obj&quot; implements <strong>IEquatable&lt;T&gt;</strong>. Microsoft recommends that structs implement this interface (see the article <a href="http://msdn.microsoft.com/en-us/library/ms229031(v=vs.110).aspx">Struct Design</a> on MSDN) and the primitive types such <strong>System.Int32</strong> (aka <strong>int</strong>) all follow this suggestion.</p>
<p>So the boxing can be avoided in most cases by changing the method to</p>
<pre><code>public bool IndicatesChangeFromValue(T value)
{
  if (!_valueHasBeenSet)
    return false;

  if ((value != null) &amp;&amp; (value is IEquatable&lt;T&gt;))
    return !((IEquatable&lt;T&gt;)value).Equals(value);

  if ((value == null) &amp;&amp; (_valueIfSet == null))
    return false;
  else if ((value == null) || (_valueIfSet == null))
    return true;

  return !value.Equals(_valueIfSet);
}
</code></pre>
<p>I'm chalking up these two recommendations as even more evidence that code reviewing can be helpful.. :)</p>
<h3>So how <em>does</em> it perform?</h3>
<p>Having addressed the above improvements, the question about how the code actually performs still remains.</p>
<p>There are three candidates to conside when weighing up the automagical <strong>DefaultUpdateWithHelper</strong>. The first two appear above. One is the hand-written version shown in the <strong>RoleDetails</strong> class right at the top of the post. The other is the one-liner &quot;GetGenerator&quot; call. There is a third option, however, that allows multiple calls to avoid the cache-check and so avoid reflection entirely on all but the first request; that is to call &quot;GetGenerator&quot; once and record it in a static reference -</p>
<pre><code>private static UpdateWithSignature&lt;RoleDetails&gt; updater
  = DefaultUpdateWithHelper.GetGenerator&lt;RoleDetails&gt;(typeof(RoleDetails).GetMethod(&quot;UpdateWith&quot;));
public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return updater(this, title, startDate);
}
</code></pre>
<p>To get an idea of the raw performance of these methods, I wrote a console app that would repeatedly call a variation of an &quot;UpdateWith&quot; method. I've named the three varieties that I'm interested in: &quot;ManualWith&quot; (the hand-written version), &quot;SimpleWith&quot; (the one-liner) and &quot;StaticWith&quot; (shown above; the one-liner where the result is stored in a static reference to avoid multiple calls to &quot;GetGenerator&quot;).</p>
<p>Having a console app meant that the process would be started fresh and then torn down for each run, hopefully ensuring an even playing field. This is particularly in relation to GC, which can introduce variance into longer-running processes. In this case, I'm interested in the direct execution performance of the various methods and I'm not trying to compare GC overhead (which is something that <em>can</em> be investigated, but which can be very complicated to do correctly).</p>
<p>The source code for this app can be found at <a href="https://gist.github.com/anonymous/31b752d24212ad43836e">gist.github.com/anonymous/31b752d24212ad43836e</a>. It's as simple as possible and must be run in Release configuration in order to provide the most realistic results. I ran it multiple times for each of the variations, running a complete set of each before repeating (just to try to give everything the best odds of averaging out as possible).</p>
<p>For &quot;ManualWith&quot;, the loop count had to be ten million to get any sensible measurements. The average time per execution was <strong>1.0 ticks</strong> (an average of 3538ms for 10,000,000 calls).</p>
<p>For &quot;SimpleWith&quot;, the loop count had to be 100,000. The average per execution was <strong>81.7 ticks</strong> (averaging 2997ms for 100,00 calls).</p>
<p>&quot;StaticWith&quot; needed the loop count bumping back up to ten million again - averaging <strong>2.1 ticks</strong> per execution (7874ms average for 10,000,000 calls).</p>
<p>Now, actually, I don't think that's too bad (the &quot;StaticWith&quot; result, I mean). If something's a real convenience and the only overhead it introduces is that object instantiation is twice as slow, I think that in most cases it could be considered a win - the reality is that instantiating objects is <em>not</em> likely to be a bottleneck where performance becomes a concern*. The reason for the performance difference between &quot;ManualWith&quot; and &quot;StaticWith&quot; is going to be from the boxing of the <strong>Optional</strong> values when they are passed to the delegate, combined with the fact that the arguments are passed to the &quot;updater&quot; as a params array; ie. an <strong>object[]</strong> - which must be instantiated. My <a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">original post</a> talked about more tweaks that the library allowed to specify the number of arguments and so not require the object array, but it would still have to box the <strong>Optional</strong> values.</p>
<p>* <em>(Insert comment here about profiling before assigning blame for performance and another about how exchanging convenience for performance only works if any performance cost is offset by having said convenience).</em></p>
<p>So.. all things considered, do I genuinely expect to use one of the &quot;magic&quot; approaches in my code going forward? Well, no. I <em>will</em> be using the format of the &quot;UpdateWith&quot; method and utilising the <strong>Optional</strong> struct in the method signature, but I probably won't bother with the <strong>DefaultUpdateWithHelper</strong> and the library I wrote. It was fun to write and I learnt a lot doing it <em>and</em> through the feedback on it, but I still have a niggly feeling about the worry that changes to the constructor (in a refactor, or whatever) will not cause compile-time errors in the &quot;UpdateWith&quot; method if I forget to update that as well. I won't find out until runtime that there's a problem (or until the unit tests, that I suggested last time as one of the trade-offs for the convenience, are executed). And I'm a <em>big</em> fan of helping the compiler to help me.</p>
<p><em>Plus</em> there's the fact that the difference in code size between the &quot;StaticWith&quot; code and the &quot;ManualWith&quot; isn't really that large. Even as more properties are added, it's still very scannable and doesn't bloat up <em>too</em> much even though you have to write the code for each property's &quot;IndicatesChangeFromValue&quot; check and manually pass the &quot;GetValue&quot; result for each constructor argument. Looking at that Roslyn code doesn't make me think that the methods (written in the &quot;ManualWith&quot; manner) are too big, and some of them have a lot of constructor arguments.</p>
<p>If only there was some way to get the best of both worlds; brevity in type definitions but all the benefits of static analysis..</p>
<h3>The &quot;ImmutableObjectGraph&quot; T4 Templates</h3>
<p>This was <em>another</em> thing that came from the comments on my blog (thanks Ian Yates! :), a library of templates that take a simple definition such as</p>
<pre><code>class Fruit
{
  string color;
  int skinThickness;
}
</code></pre>
<p>and transforms it into a fully-fledged immutable class <em>with</em> a &quot;With&quot; method (which is exactly like the &quot;UpdateWith&quot; method I've been talking about). It has its own <strong>Optional</strong> struct, the same as in Roslyn's source. The generated types even have a nested <strong>Builder</strong> type which has mutable properties and a &quot;ToImmutable&quot; method which returns an immutable type with the described data - for times when it's just easier to prepare a reference in a few steps before &quot;freezing&quot; it (or for &quot;efficient multi-step mutation&quot;, according to the README). It's little indications of attention to detail such as this that I liked when I looked into the project: <a href="https://github.com/AArnott/ImmutableObjectGraph">github.com/AArnott/ImmutableObjectGraph</a>.</p>
<p>The idea of constructing T4 templates like this is one that I've kicked around before but never gotten round to actually implementing, so finding this was a nice surprise!</p>
<p>Now, there <em>are</em> a few flies in the ointment. The library relies on a pre-release version of Microsoft's <a href="http://blogs.msdn.com/b/dotnet/archive/2013/09/25/immutable-collections-ready-for-prime-time.aspx">Immutable Collections</a>, and references to the binary's location are hard-coded into the template files. Also, the template files currently need to be copied into every project that you want to use them with. There's no NuGet package to make it easy to pull into a project - and if you try to pull down the code from GitHub using &quot;Download Zip&quot; then it refuses to compile (though cloning it in GitHub for Windows works fine). It assumes that all generated types should support a &quot;DefaultInstance&quot; (which I disagree with since it's basically too close to another version of null - an instance that has not been given any information to represent real information.. for a list type, this may make sense - the empty list - but not for types such as the <strong>RoleDetails</strong> I've been using as an example so far).</p>
<p>But hopefully this is where the wonders of open source will come to the fore! I've submitted a pull request to try to encourage the templates into a NuGet package (putting the impetus on the consumer to include a version of the Immutable Collections, if required). You can find it at <a href="https://github.com/AArnott/ImmutableObjectGraph/pull/25">Generate a NuGet package (and prevent the templates being copied into each consuming project)</a>. However, there is another pull request that has been open for some time (since April) which I think has merit and which I have tested myself, that has been acknowledged by the author but not merged: <a href="https://github.com/AArnott/ImmutableObjectGraph/pull/22">Fixing compiler warnings with collections and inheritance</a>. I don't know <em>why</em> it hasn't been merged. Considering that one of the decisions in my request may be contentious (pulling &quot;CollectionHelper&quot; methods into the generated types that require them, in order to prevent the imported binary requiring an Immutable Collection reference), I'm not sure how confident I am at the moment that it will be accepted.</p>
<p>Further changes to address my other concerns could be made as well - such as an attribute that could be added to indicate that a default instance should not be defined. Depending upon how the pull request is received, I might submit more or I might go rogue and maintain my own fork. As I understand the &quot;MS-PL&quot; license, I'm fairly sure this is allowed (though I'd be much happier to end up with everything merged into one beautiful definitive version).</p>
<p>The really big question that I want to answer, though, is whether the use of the templates will mesh well with code contracts. The generated types do specify &quot;partial class&quot; and so can be extended - they could implement an interface, for example, which has contracts specified on it. And the classes call an optional &quot;Validate&quot; method, which could be used to verify the constructor arguments. I'm not sure yet if this will all be capable of what I have in mind, I've only had a very preliminary look into it.. but I think it has promise!</p>
<p>Just imagine: the brevity of the type declarations above, the guarantees of contracts (though this will necessarily affect the succinctness of the code - even if a separate &quot;contract interface&quot; is implemented, the contract for that interface must still be written somewhere), the static analysis benefits for the generated types.. all this goodness in one solution! So maybe I don't actually have all the pieces together just yet.. but I'm certainly going to be trying to get them over the next few weeks and carrying it all onward to programming nirvana!</p>
<p class="PostTime">Posted at 21:49</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/writing-f-sharp-to-implement-the-single-layer-perceptron">Writing F# to implement &#x27;The Single Layer Perceptron&#x27;</a></li><li><a href="/learning-f-sharp-via-some-machine-learning-the-single-layer-percepton">Learning F# via some Machine Learning: The Single Layer Perceptron</a></li><li><a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired &quot;with&quot; updates for immutable classes in C#</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/a-followup-to-implementing-f-sharp-inspired-with-updates-in-c-sharp#disqus_thread" data-disqus-identifier="76">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">17 September 2014</p><h2><a id="implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp" href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired &quot;with&quot; updates for immutable classes in C#</a></h2>
<p>I've been prototyping a data service for a product at work that communicates with immutable types and one of the feedback comments was a question as to whether the classes supported a flexible F#-esque &quot;with&quot; method that would allow multiple properties to be changed without the garbage collection churn of creating intermediate references for each individual property (since, of course, the property values aren't actually changed on an instance, a <em>new</em> instance is generated that reflects the requested changes).</p>
<p>To pull an example straight from the excellent <a href="http://fsharpforfunandprofit.com/posts/records/">F# for fun and profit</a> site:</p>
<pre><code>let p1 = {first=&quot;Alice&quot;; last=&quot;Jones&quot;}
let p2 = {p1 with last=&quot;Smith&quot;}
</code></pre>
<p>This creates a new record p2 that takes p1 and changes one of the fields. Multiple fields may be altered in one use &quot;with&quot; statement</p>
<pre><code>let p2 = {p1 with first=&quot;John&quot;;last=&quot;Smith&quot;}
</code></pre>
<p>To start with a very simple example in C#, take the following class:</p>
<pre><code>public class RoleDetails
{
  public RoleDetails(string title, DateTime startDate, DateTime? endDateIfAny)
  {
    Title = title;
    StartDate = startDate;
    EndDateIfAny = endDateIfAny;
  }

  public string Title { get; private set; }
  public DateTime StartDate { get; private set; }
  public DateTime? EndDateIfAny { get; private set; }
}
</code></pre>
<p>This is a very close parallel to the F# record type since it just assigns read-only properties (they're not strictly read-only since they don't use the &quot;readonly&quot; keyword but they're not externally alterable and are only set once within the class so it's close enough).</p>
<p>If I was writing something like this for real use, I would probably try to make more guarantees.. or at least, document behaviour. Something like:</p>
<pre><code>public class RoleDetails
{
  public RoleDetails(string title, DateTime startDate, DateTime? endDateIfAny)
  {
    if (string.IsNullOrWhiteSpace(title))
      throw new ArgumentException(&quot;title&quot;);
    if ((endDateIfAny != null) &amp;&amp; (endDateIfAny &lt;= startDate))
      throw new ArgumentException(&quot;title&quot;);

    Title = title.Trim();
    StartDate = startDate;
    EndDateIfAny = endDateIfAny;
  }

  /// &lt;summary&gt;
  /// This will never be null or blank, it will not have any leading or trailing whitespace
  /// &lt;/summary&gt;
  public string Title { get; private set; }

  public DateTime StartDate { get; private set; }

  /// &lt;summary&gt;
  /// If non-null, this will greater than the StartDate
  /// &lt;/summary&gt;
  public DateTime? EndDateIfAny { get; private set; }
}
</code></pre>
<p>As I've said before, this validation and commenting is really a poor substitute for code contracts which would allow for compile time detection of invalid data rather than relying on runtime exceptions (speaking of which, I need to give the .net code contracts solution another go - last time I got stuck in I hit some problems which hopefully they've ironed out by now).</p>
<p>Another variation on the &quot;aggressive validation&quot; illustrated above would be a type that represents a non-blank string to prevent duplicating calls to <em>IsNullOrWhiteSpace</em> and <em>trim</em>. This concept could be taken even further to &quot;strongly type&quot; string values so that a &quot;Title&quot; can not be passed into a function that expects a &quot;Notes&quot; string value, for example. This is far from an original idea but it was something I was experimenting again with recently.</p>
<p>Incidentally, there is talk of a future version of C# getting a record type which would reduce boilerplate code when defining simple immutable types. For example (from the InfoQ article <a href="http://www.infoq.com/news/2014/08/Record-Class">Easier Immutable Objects in C# 6 and VB 12</a>) -</p>
<pre><code>public record class Cartesian(double x: X, double y: Y);
</code></pre>
<p>This will define an immutable class with two read-only properties that are set through a constructor call. This future C# specification is also apparently going to allow read-only auto properties - so in my RoleDetails class above instead of &quot;get; private set;&quot; properties, which are externally unalterable but could actually be changed within the instance, the properties could be truly readonly. This <em>is</em> possible currently but it requires a private readonly field and a property with a getter that returns that field's value, which is even <em>more</em> boring boilerplate.</p>
<h3>The obvious, verbose and potentially more GC-churny way</h3>
<p>To prevent callers from having to call the constructor every time a property needs to be altered, update methods for each &quot;mutable&quot; property may be added (they don't really mutate the values since a new instance is returned rather than the value changed on the current instance). This prevents the caller from having to repeat all of the constructor arguments that are <em>not</em> to be changed whenever one property needs altering. Forcing callers to call constructors in this way is particularly annoying if a constructor argument is added, removed or re-ordered at a later date; this can result in a lot of calling code that needs correcting.</p>
<pre><code>public class RoleDetails
{
  public RoleDetails(string title, DateTime startDate, DateTime? endDateIfAny)
  {
    Title = title;
    StartDate = startDate;
    EndDateIfAny = endDateIfAny;
  }

  public string Title { get; private set; }
  public DateTime StartDate { get; private set; }
  public DateTime? EndDateIfAny { get; private set; }

  public RoleDetails Update(string title)
  {
    return (title == Title)
      ? this
      : new RoleDetails(title, StartDate, EndDateIfAny);
  }
  public RoleDetails UpdateStartDate(DateTime startDate)
  {
    return (startDate == StartDate)
      ? this
      : new RoleDetails(Title, startDate, EndDateIfAny);
  }
  public RoleDetails UpdateEndDateIfAny(DateTime? endDateIfAny)
  {
    return (endDateIfAny == EndDateIfAny)
      ? this
      : new RoleDetails(Title, StartDate, endDateIfAny);
  }
}
</code></pre>
<p>To update two properties on a given instance, you would need to call</p>
<pre><code>var updatedRoleDetails = existingRoleDetails
  .UpdateStartDate(new DateTime(2014, 9, 21))
  .UpdateEndDateIfAny(new DateTime(2014, 11, 21));
</code></pre>
<p>If either of the new values is the same as the property value that it should be replacing, then no new instance is required for that property update - since the Update*{Whatever}* method will return back the same instance. But if both properties are changed then <em>two</em> new instances are required even though the first, intermediate value is immediately discarded and so is &quot;wasted&quot;.</p>
<p>There could be an Update method that takes multiple parameters for the different properties but then you're basically just mirroing the constructor. Or there could be various Update methods that took combinations of properties to try to cover either the most common cases or <em>all</em> combinations of cases, but neither of these are particularly elegant and they would all result in quite a lot of code duplication.</p>
<h3>A better way</h3>
<p>It struck me that it should be possible to do something with named and optional method arguments (support for which was added to C# when .net 4 came out, if I remember correctly). Something like</p>
<pre><code>public RoleDetails UpdateWith(
  string title = Title,
  DateTime startDate = StartDate,
  DateTime? endDateIfAny = EndDateIfAny)
{
  if ((title == Title) &amp;&amp; (startDate == StartDate) &amp;&amp; (endDateIfAny == EndDateIfAny))
    return this;
  return new RoleDetails(title, startDate, endDateIfAny);
}
</code></pre>
<p>would allow for only a subset of the arguments to be specified and for those that are left unspecified to default to the current property value of the instance. So the earlier update code becomes</p>
<pre><code>var updatedRoleDetails = existingRoleDetails
  .UpdateWith(startDate: new DateTime(2014, 9, 21), endDateIfAny: new DateTime(2014, 11, 21));
</code></pre>
<p>However, this won't fly. The compiler gives the errors</p>
<blockquote>
<p>Default parameter value for 'title' must be a compile-time constant</p>
</blockquote>
<blockquote>
<p>Default parameter value for 'startDate' must be a compile-time constant</p>
</blockquote>
<blockquote>
<p>Default parameter value for 'endDateIfAny' must be a compile-time constant</p>
</blockquote>
<p>That's a bummer.</p>
<p>Another thought that briefly crossed my mind was for the default argument values to all be null. This would work if the arguments were all reference types and would result in the method body looking something like</p>
<pre><code>if ((title == null) &amp;&amp; (startDate == null) &amp;&amp; (endDateIfAny == null))
  return this;
return new RoleDetails(title ?? Title, startDate ?? StartDate, endDateIfAny ?? EndDateIfAny);
</code></pre>
<p>But that is too restrictive a constraint since in this case we have a non-reference type argument (startDate) and we also have a reference type for which null is a valid value (endDateIfAny).</p>
<p>So what we really need is a wrapper type around the arguments that indicates when no value has been specified. Since we're being conscious of avoiding GC churn, this should be a struct since structs essentially avoid adding GC pressure since they are always copied when passed around - this means that no struct is referenced by multiple scopes and so they don't have to be traced in the same way as reference types; when the scope that has access to the struct is terminated, the struct can safely be forgotten as well. This is not a particularly precise description of what happens and more details can be found in the MSDN article <a href="http://msdn.microsoft.com/en-us/library/ms229017(v=vs.110).aspx">Choosing Between Class and Struct</a>. Particularly see the paragraph</p>
<blockquote>
<p>The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated. Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</p>
</blockquote>
<p>The other guidelines in that article around cases where structs may be appropriate (if the type &quot;logically represents a single value&quot;, &quot;has an instance size under 16 bytes&quot;, &quot;is immutable&quot; and &quot;will not have to be boxed frequently&quot;) are followed by this type:</p>
<pre><code>public struct Optional&lt;T&gt;
{
  private T _valueIfSet;
  private bool _valueHasBeenSet;

  public T GetValue(T valueIfNoneSet)
  {
    return _valueHasBeenSet ? _valueIfSet : valueIfNoneSet;
  }

  public bool IndicatesChangeFromValue(T value)
  {
    if (!_valueHasBeenSet)
      return false;

    if ((value == null) &amp;&amp; (_valueIfSet == null))
      return false;
    else if ((value == null) || (_valueIfSet == null))
      return true;

    return !value.Equals(_valueIfSet);
  }

  public static implicit operator Optional&lt;T&gt;(T value)
  {
    return new Optional&lt;T&gt;
    {
      _valueIfSet = value,
      _valueHasBeenSet = true
    };
  }
}
</code></pre>
<p>This type allows us to write an UpdateWith method</p>
<pre><code>public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  if (!title.IndicatesChangeFromValue(Title)
  &amp;&amp; !startDate.IndicatesChangeFromValue(StartDate)
  &amp;&amp; !endDateIfAny.IndicatesChangeFromValue(EndDateIfAny))
    return this;

  return new RoleDetails(
    title.GetValue(Title),
    startDate.GetValue(StartDate),
    endDateIfAny.GetValue(EndDateIfAny)
  );
}
</code></pre>
<p>The <strong>Optional</strong> type <em>could</em> have exposed properties for has-a-value-been-set and get-value-if-any but since each property comparison (to detemine whether a new instance is actually required) would have to follow the pattern if-value-has-been-set-and-if-value-that-has-been-set-does-not-equal-current-value, it made sense to me to hide the properties and to instead expose only the access methods &quot;IndicatesChangeFromValue&quot; and &quot;GetValue&quot;. The &quot;IndicatesChangeFromValue&quot; method returns true if the <strong>Optional</strong> describes a value that is different to that passed in and &quot;GetValue&quot; returns the wrapped value if there is one, and returns the input argument if not. This enables the relatively succinct &quot;UpdateWith&quot; method format shown above.</p>
<p>The other method on the struct is an implicit operator for the wrapped type which makes the &quot;UpdateWith&quot; calling code simpler. Instead of having to do something like</p>
<pre><code>var updatedRoleDetails = existingRoleDetails
  .UpdateWith(startDate = Optional&lt;DateTime&gt;(new DateTime(2014, 9, 21)));
</code></pre>
<p>the implicit conversion allows you to write</p>
<pre><code>var updatedRoleDetails = existingRoleDetails
  .UpdateWith(startDate = new DateTime(2014, 9, 21));
</code></pre>
<p>because the <strong>DateTime</strong> will be implicitly converted into an <strong>Optional&lt;DateTime&gt;</strong>. In fact, I went one step further and made it such that this is the <em>only</em> way to create an <strong>Optional</strong> that wraps a value. There is no constructor that may be used to initialise an <strong>Optional</strong> <em>with</em> a value, you <em>must</em> rely upon the implicit conversion. This means that it's very clear that there's only one way to use this type. It also happens to be very similar to the most common way that the <strong>Nullable</strong> type is used in C# - although that does have a public constructor that accepts the value to wrap, in practice I've only ever seen values cast to <strong>Nullable</strong> (as opposed to the <strong>Nullable</strong> constructor being passed the value).</p>
<h3>Turning it up to eleven</h3>
<p>Now this is all well and good and I think it would be a solid leap forward simply to leave things as they are shown above. Unnecessary GC pressue is avoided since there are no &quot;intermediary&quot; instances when changing properties, while the use of structs means that we're not generating a load of property-update-value references that need to be collected either.</p>
<p>But I just couldn't resist trying to push it a bit further since there's <em>still</em> quite a lot of boring code that needs to be written for every immutable type - the UpdateWith method needs to check all of the properties to ensure that they haven't changed and then it needs to pass values into a constructor. If a class has quite a lot of properties (which is not especially unusual if the types are representing complex data) then this UpdateWith method could grow quite large. Wouldn't it be nice if we could just write something like:</p>
<pre><code>public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return magicUpdater(title, startDate, endDateIfAny);
}
</code></pre>
<p>Wouldn't it?? Yes it would.</p>
<p>And we can.. if we dip into some of the .net framework's crazier parts - reflection and stack tracing. With some LINQ expressions thrown in to make it work efficiently when called more than once or twice.</p>
<p>What this &quot;magicUpdater&quot; needs to do is take the names and values of the arguments passed to it and then analyse the target type (<strong>RoleDetails</strong> in this example) to find the constructor to call that will allow all of these named values to be passed into a new instance, using existing property values on the source instance for any constructor arguments that are not provided by the update arguments. It also needs to do the same work to determine whether the update arguments actually require a new instance to be generated - if only the StartDate is being provided to change but the new value is the same as the current value then no new instance is required, the source instance can be returned directly by the &quot;magicUpdater&quot;.</p>
<p>This is handled by two steps. The first based around this line:</p>
<pre><code>var callingMethod = new StackFrame(1).GetMethod();
</code></pre>
<p>It returns a <strong>MethodBase</strong> with metadata about the method that called the &quot;magicUpdater&quot; (the &quot;1&quot; in the call above is how many steps back to go in the call stack). From this the names of the arguments can be extracted and a delegate returned which will take the argument values themselves. So the call would actually look more like (if this &quot;magicUpdater&quot; method return a delegate which then must itself be called):</p>
<pre><code>return magicUpdater()(title, startDate, endDateIfAny);
</code></pre>
<p>Before we move on to the second step, there are some important considerations in relation to the use of <strong>StackFrame</strong>. Firstly, there <em>is</em> some expense to performing analysis like this, as with using reflection - but we'll not worry about that here, some optimisations will be covered later which hopefully mean we can ignore it. What's more important is that analysing the call stack can seem somewhat.. unreliable, in a sense. In the real world, the code that gets executed is not always the code as it appears in the C# source. A release build will apply optimisations that won't be applied to debug builds <em>and</em> when code is manipulated by the JIT compiler more optimisations again may occur - one of the more well-known of which is &quot;method inlining&quot;. Method inlining is when the compiler sees a chain of Method1 -&gt; Method2 -&gt; Method3 -&gt; Method4 and observes that Method2 is so small that instead of being a distinct method call (which has a cost, as every method call does - the arguments have to be passed into a new scope and this must be considered by the garbage collector; as a very basic example of one of these costs) the code inside Method2 can be copied inside Method1. This would mean that if Method3 tried to access Method2's metadata through the <strong>StackFrame</strong> class, it would be unable to - it would be told it was called by Method1!</p>
<p>There's a short but informative article about this by Eric Gunnerson: <a href="http://blogs.msdn.com/b/ericgu/archive/2004/01/29/64717.aspx">More on inlining</a>. In a nutshell it says that -</p>
<ul>
<li>Methods that are greater than 32 bytes of IL will not be inlined.</li>
<li>Virtual functions are not inlined.</li>
<li>Methods that have complex flow control will not be in-lined. Complex flow control is any flow control other than if/then/else; in this case, switch or while.</li>
<li>Methods that contain exception-handling blocks are not inlined, though methods that throw exceptions are still candidates for inlining.</li>
<li>If any of the method's formal arguments are structs, the method will not be inlined.</li>
</ul>
<p>This means that we shouldn't have to worry about the UpdateWith method being inlined (since its arguments are all <strong>Optional</strong> which are structs), but the &quot;magicUpdater&quot; method <em>may</em> be a concern. The way that my library gets around that is that the method &quot;GetGenerator&quot; on the <strong>UpdateWithHelper</strong> class (it's not <em>really</em> called &quot;magicUpdater&quot; :) has the attribute</p>
<pre><code>[MethodImpl(MethodImplOptions.NoInlining)]
public UpdateWithSignature&lt;T&gt; GetGenerator&lt;T&gt;(int numberOfFramesFromCallSite = 1)
</code></pre>
<p>which tells the JIT compiler not to inline it and so, since the caller isn't inlined (because of the structs), we don't have to worry about stack &quot;compressing&quot;.</p>
<p>This &quot;GetGenerator&quot; method, then, has access to the argument names and argument types of the method that called it. The generic type param T is the immutable type that is being targeted by the &quot;UpdateWith&quot; method. <strong>UpdateWithSignature&lt;T&gt;</strong> is a delegate with the signature</p>
<pre><code>public delegate T UpdateWithSignature&lt;T&gt;(T source, params object[] updateValues);
</code></pre>
<p>This delegate is what takes the property update values and creates a new instance (or returns the source instance if no changes are required). It does this by considering every public constructor that T has and determining what constructor arguments it can satisfy with update arguments. It does this by matching the update argument names to the constructor argument names and ensuring that the types are compatible. If a constructor is encountered with arguments that don't match any update arguments but T has a property whose name and type matches the constructor argument, then <em>that</em> will be used. If a constructor argument is encountered that can't be matched to an update argument <em>or</em> a property on T but the constructor argument has a default value, then the default value may be used if the constructor.</p>
<p>If a constructor does not have at least one argument that can be matched to each update argument name, then that constructor is ignored (otherwise an update argument would be ignored, which would make the UpdateWith somewhat impotent!). If there are multiple constructors that meet all of these conditions, they are sorted by the number of arguments they have that are fulfilled by update arguments and then sorted by the number of arguments that are satisfed by other properties on T - the best match from this sorted set it used.</p>
<p>The return <strong>UpdateWithSignature&lt;T&gt;</strong> delegate itself is a compiled LINQ expression so, once the cost of generating it has been paid the first time that it's required, the calls to this delegate are very fast. The &quot;GetGenerator&quot; method caches these compiled expressions, so the method</p>
<pre><code>public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return DefaultUpdateWithHelper.GetGenerator&lt;RoleDetails&gt;()(this, title, startDate);
}
</code></pre>
<p>can be called repeatedly and cheaply.</p>
<p>Note that in the above example, the <strong>DefaultUpdateWithHelper</strong> is used. This is a static wrapper around the <strong>UpdateWithHelper</strong> which specifies a default configuration. The <strong>UpdateWithHelper</strong> takes arguments that describe how to match update argument names to constructor argument names, for example (amongst other configuration options). The implementation in the <strong>DefaultUpdateWithHelper</strong> matches by name in a case-insensitive manner, which should cover the most common cases. But the relevant <strong>UpdateWithHelper</strong> constructor argument is of type</p>
<pre><code>public delegate bool UpdateArgumentToConstructorArgumentComparison(
  ParameterInfo updateArgument,
  ConstructorInfo constructor,
  ParameterInfo constructorArgument);
</code></pre>
<p>so a custom implementation could implement any complex scheme based upon target type or constructor or update argument type.</p>
<p>The <strong>UpdateWithHelper</strong> also requires a cache implementation for maintaining the compiled expressions, as well as matchers for other comparisons (such as property name to constructor argument name, for constructor arguments that can't be matched by an update argument). If a custom <strong>UpdateWithHelper</strong> is desired that only needs to override <em>some</em> behaviour, the <strong>DefaultUpdateWithHelper</strong> class has a static nested class <strong>DefaultValues</strong> with properties that are the references that it uses for the <strong>UpdateWithHelper</strong> constructor arguments - some of these may be reused by the custom configuration, if appropriate.</p>
<p>I considered going into some detail about how the LINQ expressions are generated since I think it's hard to find a good &quot;how-to&quot; walkthrough on these. It's either information that seems too simple or fine-grained that it's hard to put it together into something useful or it's the other extreme; dense code that's hard to get to grips with if you don't know much about them. But I feel that it would balloon this post too much - so maybe another day!</p>
<p>Incidentally, the <strong>DefaultUpdateWithHelper</strong>'s static &quot;GetGenerator&quot; method inserts another layer into the call stack, which is why the <strong>UpdateWithHelper</strong>'s method requires an (optional) &quot;numberOfFramesFromCallSite&quot; argument - so that it can be set to 2 in this case, rather than the default 1 (since it will need to step back through the <strong>DefaultUpdateWithHelper</strong> method before getting to the real &quot;UpdateWith&quot; method). This also means that <strong>DefaultUpdateWithHelper</strong> has the &quot;MethodImplOptions.NoInlining&quot; attribute on its &quot;GetGenerator&quot; method.</p>
<p>It's also worthy of note that the &quot;GetGenerator&quot; methods support extension methods for &quot;UpdateWith&quot; implementations, as opposed to requiring that they be instance methods. So the following is also acceptable</p>
<pre><code>public static RoleDetails UpdateWith(
  this RoleDetails source,
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return DefaultUpdateWithHelper.GetGenerator&lt;RoleDetails&gt;()(source, title, startDate);
}
</code></pre>
<p>The analysis detects that the first argument is not an <strong>OptionalType&lt;T&gt;</strong> and asserts that its type is assignable to the type param T and then ignores it when generating the translation expression. The extension method will pass through the &quot;source&quot; reference where &quot;this&quot; was used in the instance method implementation shown earlier.</p>
<h3>Further performance optimisations</h3>
<p>Although the compiled &quot;generator&quot; expressions are cached, the cache key is based upon the &quot;UpdateWith&quot; method's metadata. This means that the cost of accessing the <strong>StackFrame</strong> is paid for every &quot;UpdateWith&quot; call, along with the reflection access to get the UpdateWith argument's metadata. If you feel that this might be an unbearable toll, a simple alternative is something like</p>
<pre><code>private static UpdateWithSignature&lt;RoleDetails&gt; updater
  = DefaultUpdateWithHelper.GetGenerator&lt;RoleDetails&gt;(typeof(RoleDetails).GetMethod(&quot;UpdateWith&quot;));
public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return updater(this, title, startDate);
}
</code></pre>
<p>The &quot;GetGenerator&quot; methods have alternate signatures that accept a <strong>MethodBase</strong> reference relating to the &quot;UpdateWith&quot; method, rather than relying upon <strong>StackFrame</strong> to retrieve it. And using a static &quot;updater&quot; reference means that &quot;GetGenerator&quot; is only ever called once, so subsequent calls that would require reflection in order to check for a cached expression are avoided entirely. The trade-off is that the method must be named in a string, which would break if the method was renamed. Not quite as convenient as relying upon stack-tracing magic.</p>
<p>If you really want to get crazy, you can go one step further. If part of the reason for this experiment was to reduce GC pressure, then surely the params array required by the <strong>UpdateWithSignature&lt;T&gt;</strong> is a step backwards from the less-automated method, where the number of update arguments is known at compile time? (Since that <em>didn't</em> require a params array for a variable number of arguments, there were no method calls where the precise number of update arguments was unknown). Well that params array can be avoided if we make some more trade-offs. Firstly, we may <em>only</em> use an approach like above, which doesn't rely on expression caching (ie. use a static property that requests a generator only once). Secondly, there may only be up to nine update arguments. The first reason is because the cache that the <strong>UpdateWithHelper</strong> uses records <strong>UpdateWithSignature&lt;T&gt;</strong> references, which are no good since they use the params array that we're trying to avoid. The second reason is because a distinct delegate is required for each number of arguments, as is a distinct method to construct the generator - so there had to be a limit somewhere and I chose nine. The methods are</p>
<pre><code>public UpdateWithSignature1&lt;T&gt; GetUncachedGenerator1&lt;T&gt;(MethodBase updateMethod)
public UpdateWithSignature2&lt;T&gt; GetUncachedGenerator2&lt;T&gt;(MethodBase updateMethod)
public UpdateWithSignature3&lt;T&gt; GetUncachedGenerator3&lt;T&gt;(MethodBase updateMethod)
// .. etc, up to 9
</code></pre>
<p>and the delegates are of the form</p>
<pre><code>public delegate T UpdateWithSignature1&lt;T&gt;(T source, object arg0);
public delegate T UpdateWithSignature2&lt;T&gt;(T source, object arg0, object arg1);
public delegate T UpdateWithSignature3&lt;T&gt;(T source, object arg0, object arg1, object arg2);
// .. etc, up to 9
</code></pre>
<p>They may be used in a similar manner to that already shown, but you must be careful to match the number of arguments required by the &quot;UpdateWith&quot; method. In a way, there is actually a compile-time advantage here - if you choose the wrong one, then the compiler will warn you that you have specified three update arguments when the delegate requires four (for example). With the generic form (the non-numbered &quot;GetGenerator&quot; method), the params array means that you can specify any number of update arguments and you won't find out until runtime that you specified the wrong amount.</p>
<p>So, to illustrate -</p>
<pre><code>private static UpdateWithSignature3&lt;RoleDetails&gt; updater
  = DefaultUpdateWithHelper.GetUncachedGenerator3&lt;RoleDetails&gt;(
    typeof(RoleDetails).GetMethod(&quot;UpdateWith&quot;));

public RoleDetails UpdateWith(
  Optional&lt;string&gt; title = new Optional&lt;string&gt;(),
  Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
  Optional&lt;DateTime?&gt; endDateIfAny = new Optional&lt;DateTime?&gt;())
{
  return updater(this, title, startDate, endDateIfAny);
}
</code></pre>
<p>If I'm being honest, however, if you <em>really</em> think that this optimisation is beneficial (by which, I mean you've done performance analysis and found it to be a bottleneck worth addressing), you're probably better replacing this automated approach with the hand-written code that I showed earlier. It's not all that long and it removes all of this &quot;magic&quot; and also gives the compiler more opportunity to pick up on mistakes. But most importantly (in terms of performance) may be the fact that all update arguments are passed as &quot;object&quot; in these delegates. This means that any value types (ints, structs, etc..) will be boxed when they are passed around and then unboxed when used as constructor arguments. This is explained very clearly in the article <a href="http://www.techgalaxy.net/Docs/Dev/5ways.htm">5 Basic Ways to Improve Performance in C#</a> and more information about the use of the heap and stack can be found at <a href="http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types">Six important .NET concepts: Stack, heap, value types, reference types, boxing, and unboxing</a> - I'd not seen this article before today but I thought it explained things really clearly.</p>
<p>Chances are that you won't have to worry about such low level details as whether values are being boxed-unboxed 99% of the time and I think there's a lot of mileage to be had from how convenient this automated approach is. But it's worth bearing in mind the &quot;what ifs&quot; of performance for the times when they <em>do</em> make a difference.</p>
<h3>Any other downsides to the automagical way?</h3>
<p>I can't claim to have this code in production anywhere yet. But I'm comfortable enough with it at this stage that I intend to start introducing it into prototype projects that it will be applicable to - and then look to using it in real-world, scary, production projects before too long! My only concern, really, is about making silly mistakes with typos in update argument names. If I mistyped &quot;tittle&quot; in the <strong>RoleDetails</strong> &quot;UpdateWith&quot; example I've been using, I wouldn't find out until runtime that I'd made the mistaken - at which point, the &quot;GetGenerator&quot; call would throw an exception as it wouldn't be able to match &quot;tittle&quot; to any argument on any accessible constructor. I think the trade-off here would be that every &quot;UpdateWith&quot; method that used this library would need a unit test so that discovering the problem at &quot;runtime&quot; doesn't mean &quot;when I hit code in manual testing that triggers the exception&quot; but rather equates to &quot;whenever the test suite is run - whether locally or when pushed to the build server&quot;. I doubt that Update methods of this type would normally get a unit test since they're so basic (maybe you disagree!) but in this case the convenience of using the automated &quot;GetGenerator&quot; method still wins even with the (simple) unit test recommended for each one.</p>
<p>Now that I think about it, this is not a dissimilar situation to using a Dependency Injection framework or using AutoMapper in your code - there is a lot of convenience to be had, but at the risk that configuration errors are not exposed until the code is executed.</p>
<p>In summary, until I find a good reason <em>not</em> to use this library going forward, I intend to do so! To revisit my (F#) inspiration, how can it not be enticing to be able to write</p>
<pre><code>// F#
let p2 = {p1 with first=&quot;Jim&quot;;last=&quot;Smith&quot;}

// C#
var p2 = p1.UpdateWith(first:&quot;Jim&quot;,last:&quot;Smith&quot;);
</code></pre>
<p>with so little code having to be written to enable it?!</p>
<p>Go get the code at <a href="https://bitbucket.org/DanRoberts/updatewith">bitbucket.org/DanRoberts/updatewith</a>!</p>
<p>Or alternatively, pull the NuGet package straight down from <a href="https://www.nuget.org/packages/CSharpImmutableUpdateWith/">nuget.org/packages/CSharpImmutableUpdateWith</a>.</p>
<p><strong>Update (19th September 2014):</strong> There's been quite a lot of interest in this post and some good comments made here and at the discussion on <a href="http://www.reddit.com/r/programming/comments/2gqx9u/implementing_finspired_with_updates_for_immutable/">Reddit/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp</a>. I intend to write a follow-up post that talks about some of the observations and includes some performance stats. In summary, though, I may have to admit to considering a slight about-turn in the crazy magical approach and strike that up as a convenience for rattling out code quickly but probably something that won't make it into production code that I write. The idea of using an &quot;UpdateWith&quot; method with named, optional arguments (using the <strong>Optional</strong> struct) <em>will</em> make it into my &quot;real world&quot; code, though! It's also strikingly similar to some of the code in Roslyn, it was pointed out (I'll touch on this in the follow-up too). I still had a lot of fun with the &quot;Turning it up to eleven&quot; investigation and I think there's useful information in here and in the library code I wrote - even more so when I get round to documenting how I approach writing the LINQ expression-generating code. But maybe it didn't result in something that should always be everyone's immediate go-to method for writing this sort of code. Such is life! :)</p>
<p><strong>Update (2nd October 2014):</strong> See <a href="/a-followup-to-implementing-f-sharp-inspired-with-updates-in-c-sharp">A follow-up to &quot;Implementing F#-inspired 'with' updates in C#&quot;</a>.</p>
<p class="PostTime">Posted at 23:12</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/writing-f-sharp-to-implement-the-single-layer-perceptron">Writing F# to implement &#x27;The Single Layer Perceptron&#x27;</a></li><li><a href="/hasslefree-immutable-type-updates-in-c-sharp">Hassle-free immutable type updates in C#</a></li><li><a href="/a-followup-to-implementing-f-sharp-inspired-with-updates-in-c-sharp">A follow-up to &quot;Implementing F#-inspired &#x27;with&#x27; updates in C#&quot;</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li><li><a href="/Archive/Tag/LINQ" title="13 Posts">LINQ</a></li><li><a href="/Archive/Tag/Reflection" title="15 Posts">Reflection</a></li></ul></div>
            <p class="Comments">
                <a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp#disqus_thread" data-disqus-identifier="74">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">19 June 2013</p><h2><a id="parsing-css" href="/parsing-css">Parsing CSS</a></h2>
<p>A few months ago I wrote about some <a href="/extending-the-css-minifier">extensions to the CSS Minifer</a> to support pseudo-Source-Mapping for compiled and minified content (among other things) and I've been meaning to write about the code I used to analyse the style sheet content.</p>
<h3>History Lesson</h3>
<p>A long time ago I wrote some code to parse javascript to remove comments and minify the content, this was before there were a proliferation of excellent plugins and such like to do it all for you - I think the YUI Compressor might have been around but since it required java to be installed where it would be used, we couldn't use it to compile scripts on-the-fly.</p>
<p>The first pass through the content would break it down into strings representing javacript code, javascript strings and comments. Strings can be quoted with either single or double quotes, single-quote-wrapped strings could contain double quotes without escaping them and vice versa, either string format could contain their own quotes so long as they were formatted. Comments could be multi-line if they were wrapped in /* and */ or single line if they started with // (terminating with a line return or end-of-file). So similar to CSS in a lot of ways! (Particularly if you consider parsing LESS which supports single line comments, unlike regular CSS).</p>
<p>I wrote it in a fairly naive manner, trying to handle each case at a time, building up a primary loop which went through each character, deciding what to do with it based upon what character it was and whether the current content was a string (and what would indicate the end of the string), a comment (and what would terminate that) or javascript code. There were various variables to keep track of these items of state. It did the job but I was keen not to repeat the same approach when writing this &quot;CSS Parser&quot; I wanted.</p>
<h3>Employing Immutability (what a surprise!)</h3>
<p>Keeping track of the changing state in this way meant that at any point in time there was a lot to hold in my head while I was trying to understand what was going on if something appeared to be misbehaving and made each change to add new functionality increasingly difficult. But reducing the places where state change is a large part of the <a href="/Search?term=immutable">immutability obsession</a> I've got going on so I figured there must be a better way.</p>
<p>The idea was to start with two interfaces</p>
<pre><code>public interface IProcessCharacters
{
  CharacterProcessorResult Process(IWalkThroughStrings stringNavigator);
}

public interface IWalkThroughStrings
{
  char? CurrentCharacter { get; }
  IWalkThroughStrings Next { get; }
}
</code></pre>
<p>with corresponding class and enum</p>
<pre><code>public class CharacterProcessorResult
{
  public CharacterProcessorResult(
    CharacterCategorisationOptions characterCategorisation,
    IProcessCharacters nextProcessor)
  {
    if (!Enum.IsDefined(typeof(CharacterCategorisationOptions), characterCategorisation))
      throw new ArgumentOutOfRangeException(&quot;characterCategorisation&quot;);
    if (nextProcessor == null)
      throw new ArgumentNullException(&quot;nextProcessor&quot;);

    CharacterCategorisation = characterCategorisation;
    NextProcessor = nextProcessor;
  }

  public CharacterCategorisationOptions CharacterCategorisation { get; private set; }
  public IProcessCharacters NextProcessor { get; private set; }
}

public enum CharacterCategorisationOptions
{
  Comment,
  CloseBrace,
  OpenBrace,
  SemiColon,
  SelectorOrStyleProperty,
  StylePropertyColon,
  Value,
  Whitespace
}
</code></pre>
<p>such that a given string can be traversed character-by-character with a processor returning the type of that character and providing a processor appropriate to the next character.</p>
<p>The clever part being each processor will have very tightly-scoped behaviour and responsibility. For example, if a string is encountered that starts with double quotes then a processor whose entire job is string-handling would be used. This processor would know what quote character would terminate the string and that processing should go back to the previous processor when the string has terminated. All characters encountered within the string would be identified as the same type (generally this will be of type <strong>Value</strong> since strings are most commonly used in style properties - eg. a url string as part of a background property - so if a semi-colon is encountered it would be identified as type <strong>Value</strong> despite a semi-colon having more significant meaning when not part of a string value). Handling escape characters becomes very simple if a skip-characters processor is used; when a backslash is encountered, the quoted-section processor hands off to a processor that returns a fixed type for the next character and then returns control back to the quoted-section processor. This means that the quoted-section processor doesn't need to maintain any state such as even-if-the-next-character-is-the-terminating-quote-character-do-not-terminate-the-string-yet-as-it-is-being-escaped.</p>
<p>Comment sections can be handled in a very similar manner, with different processors for multiline comments than single line since the termination manners are different (and this helps keep things really easy).</p>
<p>There is a primary processor which is a bit meatier than I'd like (but still only 320-odd commented lines) that looks out for the start of string or comments and hands off processing appropriately, but also identifies single signficant characters such as opening or closing braces, colons (usually indicating the a separator between a style property name and its value but sometimes a pseudo-class indicator - eg. in &quot;a:hover&quot;) and semi-colons.</p>
<p>Parsing is made more challenging as I wanted to support <a href="http://lesscss.org/">LESS</a> which allows for nesting of rules whereas the only nesting that regular CSS supports is selectors within media queries. CSS 2.1 only allows for a single media query to wrap a selector while CSS 3 <em>may</em> support nesting media rules - see this answer on Stack Overflow: <a href="http://stackoverflow.com/questions/11746581/nesting-media-rules-in-css/11747166#11747166">Nesting @media rules in CSS</a>.</p>
<p>As a bit of a cop-out, I don't differentiate between a selector and a property name in the <strong>CharacterCategorisationOptions</strong> enum, they are both rolled into the value <strong>SelectorOrStyleProperty</strong> (similarly, media query content is classified as a <strong>SelectorOrStyleProperty</strong>). While this feels lazy on the one hand, on the other I wanted to make this pass through the content as cheap and clean as possible and accurately determining whether a given character is a selector or a property name could involve significant reading back and forth through the content to find out for sure.</p>
<p>This way, not only is the implementation easier to follow but it enables the main loop to parse only as much content as required to enumerate as far through the content as the caller requires.</p>
<p>To explain what I mean, I need to introduce the class that wraps <strong>IProcessCharacters</strong> and <strong>IWalkThroughStrings</strong> -</p>
<pre><code>public interface ICollectStringsOfProcessedCharacters
{
  IEnumerable&lt;CategorisedCharacterString&gt; GetStrings(
    IWalkThroughStrings contentWalker,
    IProcessCharacters contentProcessor
  );
}
</code></pre>
<p>and its return type..</p>
<pre><code>public class CategorisedCharacterString
{
  public CategorisedCharacterString(
    string value,
    int indexInSource,
    CharacterCategorisationOptions characterCategorisation)
  {
    if (string.IsNullOrEmpty(value))
      throw new ArgumentException(&quot;Null/blank value specified&quot;);
    if (indexInSource &lt; 0)
      throw new ArgumentOutOfRangeException(&quot;indexInSource&quot;, &quot;must be zero or greater&quot;);
    if (!Enum.IsDefined(typeof(CharacterCategorisationOptions), characterCategorisation))
      throw new ArgumentOutOfRangeException(&quot;characterCategorisation&quot;);

    Value = value;
    IndexInSource = indexInSource;
    CharacterCategorisation = characterCategorisation;
  }

  public string Value { get; private set; }

  public int IndexInSource { get; private set; }

  public CharacterCategorisationOptions CharacterCategorisation { get; private set; }
}
</code></pre>
<p>The default <strong>ICollectStringsOfProcessedCharacters</strong> implementation will traverse through the <strong>IWalkThroughStrings</strong> content and group together characters of the same <strong>CharacterCategorisationOptions</strong> into a single <strong>CategorisedCharacterString</strong>, using <a href="http://msdn.microsoft.com/en-us/library/vstudio/9k7k7cf0.aspx">yield return</a> to return the values.</p>
<p>This means that</p>
<pre><code>/* Test */ .Content { color: black; }
</code></pre>
<p>would return content identified as</p>
<pre><code>&quot;/* Test */&quot;     Comment
&quot; &quot;              Whitespace
&quot;.Content&quot;       SelectorOrStyleProperty
&quot; &quot;              Whitespace
&quot;{&quot;              OpenBrace
&quot; &quot;              Whitespace
&quot;color&quot;          SelectorOrStyleProperty
&quot;:&quot;              StylePropertyColon
&quot; &quot;              Whitespace
&quot;black&quot;          Value
&quot;;&quot;              SemiColon
&quot; &quot;              Whitespace
&quot;}&quot;              CloseBrace
</code></pre>
<p>But if the enumeration of the data returned from the <strong>GetStrings</strong> method stopped after the &quot;.Content&quot; string was returned then no more parsing of the CSS would be carried out. If accurate differentiation of selectors, media queries and style property names was required at this point then a lot more parsing may be required to ensure that that string (&quot;.Content&quot;) was indeed a selector.</p>
<p>Another benefit arises if a large amount of content is to be parsed; an <strong>IWalkThroughStrings</strong> implementation that wraps a <strong>TextReader</strong> may be used so the content could be loaded from disk in chunks and as much or as little parsed as desired, using relatively few resources.</p>
<h3>No Read-ahead at <em>all</em>??</h3>
<p>Having just jabbered on about how amazing it is that this <strong>SelectorOrStyleProperty</strong> categorisation requires absolutely zero reading ahead in order to categorise any given character (so long as all of the preceeding characters have been parsed), there are a couple of exceptions to this rue:</p>
<ol>
<li>When a @media rule is encountered, all of the following content needs to be considered to be either <strong>Whitespace</strong> or <strong>SelectorOrStyleProperty</strong> until the opening brace for the rule is encountered, since the rule may contain otherwise-significant characters such as colon (eg. the &quot;:&quot; in &quot;@media (min-width:500px)&quot; is part of the media query and does not signify the separator symbol between a property name and a property value), so when a &quot;@&quot; is encountered, the next characters are read to determine whether it's a media rule or not</li>
<li>A colon in a pseudo class should also not be identified as a <strong>StylePropertyColon</strong>, it should be considered part of the <strong>SelectorOrStyleProperty</strong>, so if a colon is encountered while processing what is thought to be a selector then some reading ahead is done to try to determine whether the content indicates that it is indeed a psuedo-class selector and not a separator between a property name and its value</li>
</ol>
<p>To make this easier, the <strong>IWalkThroughStrings</strong> interface has an additional method</p>
<pre><code>/// &lt;summary&gt;
/// This will try to extract a string of length requiredNumberOfCharacters from the current
/// position in the string navigator. If there are insufficient characters available, then
/// a string containing all of the remaining characters will be returned. This will be an
/// empty string if there is no more content to deliver. This will never return null.
/// &lt;/summary&gt;
string TryToGetCharacterString(int requiredNumberOfCharacters);
</code></pre>
<p>I contemplated making this an extension method since the data can always be retrieved using the CurrentCharacter and Next properties, but depending upon the implementation there may be more efficient ways to retrieve the data and so it became an interface method.</p>
<h3>An original idea?</h3>
<p>I'm really happy with the way this approach to the problem has influenced the final design. There were a few issues that I hadn't foreseen when I started (the complications with pseudo classes giving different meaning to the colon character, for example, as outlined above, had somehow slipped my mind entirely when I got going) but extending it to cover these cases wasn't particularly difficult as keeping all of the complicated bits as segregated as possible made it easy to reason about where changes needed to be made and whether they could have any unpleasant side effects.</p>
<p>I don't think I can take credit for the originality of the idea, though. The overarching plan is to have a processor instance which is posed to start processing content, at this point it has produced no results and is in an uninitialised state. This is the first <strong>IProcessCharacters</strong> instance. When its <strong>Process</strong> method is called, the first character from the <strong>IWalkThroughStrings</strong> is taken and a <strong>CharacterProcessorResult</strong> returned which identifies the type of that first character and specifies an <strong>IProcessCharacters</strong> instance to process the next character. That character triggered the change in state. The next call to <strong>Process</strong> might return a result with a different type of <strong>IProcessCharacters</strong> and/or a different <strong>CharacterCategorisationOptions</strong>.</p>
<p>The point is that for any current state, there are a finite number of states that can be moved to next (since there are a limited number of <strong>CharacterCategorisationOptions</strong> values and <strong>IProcessCharacters</strong> implementations) and a finite number of triggers for each change in state (since there are only so many possible characters, even if we do consider the huge extended alphabets available). This puts me in mind of a Finite State Machine which is a well-documented concept.. the article on <a href="https://en.wikipedia.org/wiki/Finite-state_machine">Wikipedia</a> is thorough and there's another article on <a href="http://learnyousomeerlang.com/finite-state-machines">learn you some Erlang for great good!</a> which I haven't read all of, but I've heard good things about that site so intend to read that article properly before hopefully reading and following more of the tutorials on there.</p>
<h3>Overview of processors</h3>
<p>Just to emphasise how this approach made things easier and spread much of the logic across self-contained components, I'll spin through the processors which loop through the content, passing control back and forth as appropriate.</p>
<p>The first is always the <strong>SelectorOrStylePropertySegment</strong>, which is actually the one that has to deal with the most different circumstances. By default it will identify each character as being of type <strong>SelectorOrStyleProperty</strong> unless it encounters any one-offs like an <strong>OpenBrace</strong> or a <strong>SemiColon</strong> or anything that consititues <strong>Whitespace</strong>. If it encounters the &quot;:&quot; character then it has to do a little reading ahead to try to determine whether that indicates that a delimiter between a Style Property Name and the Property Value or whether it's part of a pseudo class (eg. &quot;:hover&quot;). If it's a Property Value then it hands off to the <strong>StyleValueSegment</strong> class which walks through content, marking it as either type <strong>Value</strong> or <strong>Whitespace</strong> until it hits a &quot;;&quot; and returns control back to the <strong>SelectorOrStylePropertySegment</strong>.</p>
<p>If the <strong>StyleValueSegment</strong> encounters a quote character then it hands off control to a <strong>QuotedSegment</strong> instance which walks through the content marking it as type <strong>Value</strong> until it encounters the closing quote and returns control back to where it came from. The <strong>QuotedSegment</strong> has a constructor argument for the termination character (the closing quote) so doesn't have to do anything complicated other than wait for that character to show up!</p>
<p>The <strong>SelectorOrStylePropertySegment</strong> does something similar to handing off to the <strong>StyleValueSegment</strong> when it encounters an opening square bracket as that indicates the start of an attribute selector (eg. &quot;a[href]&quot;) - control is given to a <strong>BracketedSelectorSegment</strong> which identifies all content as being type <strong>SelectorOrStyleProperty</strong> until the closing &quot;]&quot; character is encountered.</p>
<p>All three of <strong>SelectorOrStylePropertySegment</strong>, <strong>StyleValueSegment</strong> and <strong>BracketedSelectorSegment</strong> have to make exceptions for comments. When a &quot;/&quot; is encountered, they will look ahead to see if the next is either &quot;/&quot; or &quot;<em>&quot; and hand off to a <strong>SingleLineCommentSegment</strong> or <strong>MultiLineCommentSegment</strong>, respectively. The first simply has to mark everything as <strong>Comment</strong> content until passing back control when a line break is encountered. The second marks content as <strong>Comment</strong> until it encounters a &quot;</em>&quot; which the character after is a &quot;/&quot;. When this &quot;*&quot; is encountered it hands off to a <strong>SkipCharactersSegment</strong> which marks the next character as <strong>Comment</strong> as well and then hands back to whatever handed control to the <strong>MultiLineCommentSegment</strong>. Only a single character can be identified at once, hence the use of the <strong>SkipCharactersSegment</strong>, but even this small hoop is only a small one to jump through. These three classes are very minor specialisation of a shared base class so that this logic is shared.</p>
<p>The <strong>QuotedSegment</strong> doesn't inherit from the same since <em>all</em> content should be identified as being of a particular type, comment-like content within a quoted string does not constitute an actual comment. The <strong>QuotedSegment</strong> class takes a constructor argument to indicate the type of content that it will be representing since a quoted section while processing <strong>Value</strong> content should be identified as type <strong>Value</strong> while a quoted section in <strong>SelectorOrStyleProperty</strong> content (eg. in &quot;input[type='text']&quot;) should also be identified as type <strong>SelectorOrStyleProperty</strong>.</p>
<p>So essentially it all boils down to is-the-current-processor-ok-for-this-character? If yes, then continue to use it. If a condition is encountered where the processor should change (either handing control to a new processor or handing control <em>back</em> to a previous processor) then do that and let it continue.</p>
<p>When I started writing it, I somehow forgot all about attribute selectors (there's a fair argument that more planning might have been beneficial but I wanted to do it an exercise in jumping in with this approach and then hoping that the entire design would lend itself well to &quot;changing requirements&quot; - aka. me overlooking things!). If this had been processed in some contorted single loop full of complicated interacting conditions - like that javascript parser of my past - then adding that extra set of conditions would have filled me with dread. With this approach, it was no big deal.</p>
<h3>The Processor Factory</h3>
<p>There was only one thing that struck me with the idea of all of these processor instances being created left, right and centre; that there could be a lot of churn. That if there was content being processed then there could thousands of <strong>MultiLineCommentSegment</strong> instances being created, for instance, when they're nearly all to perform the same task - record comment content and pass back to the primary <strong>SelectorOrStylePropertySegment</strong> processor. If these instances could be shared then the churn could be reduced. And since each processor is immutable there is no state to worry about and so they are inherently shareable.</p>
<p>To achieve this, an <strong>IGenerateCharacterProcessors</strong> is passed as a constructor argument to classes that need to instantiate other processors. The simplest implementation of this is to spin up a new instance of the requested processor type, passing the provided constructor arguments. This is what the <strong>CharacterProcessorsFactory</strong> class does. But the <strong>CachingCharacterProcessorsFactory</strong> class will wrap this and keep a record of everything it's instantiated and return a previous reference if it has the same type and constructor arguments as the request specifies. This enables the reuse that I had in mind.</p>
<p>I will admit that there is a slight air of premature optimisation around this, worrying about churn with no evidence that it's a problem, but I intend for these processors to be used on substantial sized chunks of CSS / LESS - and when the <strong>IWalkThroughStrings</strong> interface allows for a class to be written backed onto a <strong>TextReader</strong> (as described earlier) so that only the minimum content need be held in memory at any one time, then this extra work to reuse processor instances seems to make sense.</p>
<h3>Deeper Analysis</h3>
<p>Ok, that explanation of how simple everything was ended up longer and quite possibly more detailed than I'd originally expected but there's one more thing I want to address!</p>
<p>All of the code described above really only allows for quite a simplistic representation of the data. But it paves the way for more complicated processing.</p>
<p>What I really needed was a way to analyse the structure of LESS content - this is all looping back to the idea of &quot;linting&quot; stylesheets to see if they adhere to the rules in the <a href="/noncascading-css-a-revolution">Non-cascading CSS Post</a>. A simple example is being able to determine whether all content in a stylesheet (that has been identified as not being one of the Resets or Themes sheets) should have the content wrapped in a html tag which limits the scope of any declared mixins or values.</p>
<p>A naive way approach would be trim the raw string content and see if it starts with &quot;html {&quot; or some variation with whitespace, hoping that there is no comment content that needs to be ignored. A better way is to use the CSS Processor as-is and skip over any leading comment and whitespace content and look for a html tag at the start of the content. However, more work would have to be done to ensure that that html tag isn't closed and then followed with more content which may or may not be wrapped in a scope-restricting html tag.</p>
<p>To deal with cases like this which require &quot;deep analysis&quot;, the &quot;ExtendedLESSParser&quot; project has a class, the <strong>LessCssHierarchicalParser</strong>, which takes the output from the CSSParser (a <strong>CategorisedCharacterString</strong> set) and tranforms it into hierarhical data describing selectors, media queries, import statements, style property names and style property values. Selectors and media queries are containers that have child &quot;fragments&quot; (these could be style properties or they could be nested selectors). All mention of whitespace and comments are removed and just a representation of the raw style data remains.</p>
<pre><code>// Example
html
{
  h1
  {
    color: black;
    background: white url(&quot;background.jpg&quot;) no-repeat top left;
  }
  p.Intro { padding: 8px; }
}
</code></pre>
<p>becomes something like</p>
<pre><code>html
  h1
    color
      black
    background
      white
      url(&quot;background.jpg&quot;)
      no-repat
      top
      left
  p.Intro
    padding
      8px
</code></pre>
<p><em>(Above: &quot;html&quot; represent a <strong>Selector</strong> instance with a ChildFragments property containing <strong>Selector</strong> instances for the &quot;h1&quot; and &quot;p&quot;, each with ChildFragments data made up of <strong>StylePropertyValue</strong> and <strong>StylePropertyValue</strong> instances. These classes implement <strong>ICSSFragment</strong> as do the <strong>Import</strong> and <strong>MediaQuery</strong>, which aren't present in the example here).</em></p>
<p>To ensure that content is wrapped in scope-restricting html tags, what must be done is that the output from the <strong>LessCssHierarchicalParser</strong> (a set of <strong>ICSSFragment</strong> implementations) must be considered and it be asserted that they are either <strong>Import</strong> instances or <strong>Selector</strong> instances whose <strong>Selectors</strong> property indicates that the selector in the source content was only &quot;html&quot;. An implementation can be found in my <a href="https://bitbucket.org/DanRoberts/noncascadingcssrulesenforcer/">NonCascadingCSSRulesEnforcer</a> project on Bitbucket, specifically the file <a href="https://bitbucket.org/DanRoberts/noncascadingcssrulesenforcer/src/1c997d6a25d4cee7dcd64fc451eda4fa7c17ca80/NonCascadingCSSRulesEnforcer/Rules/HtmlTagScopingMustBeAppliedToNonResetsOrThemesSheets.cs">HtmlTagScopingMustBeAppliedToNonResetsOrThemesSheets.cs</a>.</p>
<p>Unfortunately, since this level of analysis requires that the entire content be considered before the structure can be described, this is not as lightweight a process as the CSSProcessor's parsing. However, it is much more powerful in enabling you to drill down into the structure of a stylesheet. The <a href="https://bitbucket.org/DanRoberts/noncascadingcssrulesenforcer/">NonCascadingCSSRulesEnforcer</a> has code to enforce nearly all of the rules in my original <a href="/noncascading-css-a-revolution">Non-cascading CSS Post</a>, along with an <strong>ITextFileLoader</strong> implementation which allows the rules validation to be integrated with my <a href="https://bitbucket.org/DanRoberts/cssminifier">CSSMinifier</a> project which I've been using to rebuild a real site (not just my blog) with these rules. It's been going really well and I intend to put up a concluding post to this &quot;Non-cascading CSS&quot; mini-series with any final insights and any evidence I can present for and against trying to apply them to all builds I'm involved with in the future.</p>
<p class="PostTime">Posted at 21:50</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/optimising-the-css-processor-ants-and-algorithms">Optimising the CSS Processor (ANTS and algorithms)</a></li><li><a href="/noncascading-css-the-followup">Non-cascading CSS: The follow-up</a></li><li><a href="/noncascading-css-a-revolution">Non-cascading CSS: A revolution!</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/CSS" title="9 Posts">CSS</a></li><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/parsing-css#disqus_thread" data-disqus-identifier="57">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">17 December 2012</p><h2><a id="the-full-text-indexer-post-roundup" href="/the-full-text-indexer-post-roundup">The Full Text Indexer Post Round-up</a></h2>
<p>This is a compilation of links to articles outlining some of the details of the Full Text Indexer project I put together, just so I could point a link to everything all in one place (like from the BitBucket ReadMe!)</p>
<p>I wrote about the basic building blocks of the Index Generator, went off on a few tangents about how using different key types could allow for searches over data with multi-lingual content (or support Product data that has different descriptions for different web sites, for example) and then came back round to illustrate how I've used the code for this blog's search functionality.</p>
<ul>
<li><a href="/the-full-text-indexer">The Full Text Indexer</a></li>
<li><a href="/the-full-text-indexer-adding-and-subtracting">The Full Text Indexer - Adding and Subtracting</a></li>
<li><a href="/the-full-text-indexer-going-international">The Full Text Indexer - Going International!</a></li>
<li><a href="/the-full-text-indexer-token-breaker-and-string-normaliser-variations">The Full Text Indexer - Token Breaker and String Normaliser variations (+AutoComplete)</a></li>
<li><a href="/the-full-text-indexer-automating-index-generation">The Full Text Indexer - Automating Index Generation</a></li>
<li><a href="/the-full-text-indexer-structured-queries">The Full Text Indexer - Structured Queries</a></li>
<li><a href="/the-full-text-indexer-source-locations">The Full Text Indexer: Source Locations</a></li>
<li><a href="/the-full-text-indexer-search-term-highlighting-with-source-locations">Search Term Highlighting with Source Locations</a></li>
<li><a href="/the-neocities-challenge-aka-the-full-text-indexer-goes-clientside">The Full Text Indexer goes Client-side!</a></li>
</ul>
<p>Along the journey, I got to learn a few new things, take advantage of other's research and have fun trying to improve the performance of some of the bottlenecks in the index generation process.</p>
<ul>
<li><a href="/the-net-dictionary-is-fast">The .Net Dictionary is FAST!</a></li>
<li><a href="/an-englishlanguage-pluralityhandling-string-normaliser">An English-language Plurality-handling String Normaliser</a></li>
<li><a href="/optimising-the-pluralityhandling-normaliser">Optimising the Plurality-Handling Normaliser</a></li>
<li><a href="/a-pluralityhandling-normaliser-correction">A Plurality-Handling Normaliser Correction</a></li>
<li><a href="/compiled-linq-expressions-dont-serialise">Compiled LINQ Expressions don't serialise :(</a></li>
<li><a href="/javascript-compression-putting-my-json-search-indexes-on-a-diet">JavaScript Compression (Putting my JSON Search Indexes on a diet)</a></li>
</ul>
<p>I also had a chance to revisit the basic immutable list structure that I used from the get-go in this project and improve its performance characteristics as well (again, taking a lot of inspiration from cleverer people who've tackled the same problems before me! :)</p>
<ul>
<li><a href="/persistent-immutable-lists">Persistent Immutable Lists</a></li>
<li><a href="/persistent-immutable-lists-extended">Persistent Immutable Lists - Extended</a></li>
</ul>
<p>The code can be found in the <a href="https://bitbucket.org/DanRoberts/full-text-indexer/">Full Text Indexer BitBucket Repository</a>. I've still got a few ideas I'm contemplating toying with - but I've also got other projects I want to investigate! So we'll just have to see what happens with this next..</p>
<p><strong>Update (5th March 2013):</strong> I just can't seem to let this lie! :) I've added another post <a href="/the-full-text-indexer-automating-index-generation">The Full Text Indexer - Automating Index Generation</a> which demonstrates some new code that will examine your source data type and generate an index for you, all on its own! Easy! (Added to the list above).</p>
<p><strong>Update (14th March 2013):</strong> And another! This time about support for structured querying, a way to combine terms with AND, OR, NOT operators. See <a href="/the-full-text-indexer-structured-queries">The Full Text Indexer - Structured Queries</a>.  (Added to the list above).</p>
<p><strong>Update (28th March 2013):</strong> Documenting an extension to the index data that allow for more performant consecutive term matching: <a href="/the-full-text-indexer-source-locations">The Full Text Indexer: Source Locations</a>. Followed by a way to utilise this information for <a href="/the-full-text-indexer-search-term-highlighting-with-source-locations">Search Term Highlighting with Source Locations</a>. (Added to the list above).</p>
<p><strong>Update (25th July 2013):</strong> Inspired by the &quot;<a href="http://10mbmanifesto.neocities.org">The 10 Megabyte Manifesto</a>&quot; and <a href="http://neocities.org">NeoCities</a>, I've developed a way to consume search index data with JavaScript to enable a copy of this blog to be hosted where the searching is done entirely client-side. Read about it at <a href="/the-neocities-challenge-aka-the-full-text-indexer-goes-clientside">The Full Text Indexer goes client-side!</a> and see it in action live at <a href="http://productiverage.neocities.org">productiverage.neocities.org</a>! (Added to the list above).</p>
<p><strong>Update (30th July 2013):</strong> A follow-up to the &quot;The Full Text Indexer goes client-side&quot; describing how the search index data can be compressed to take up less space on the host: <a href="/javascript-compression-putting-my-json-search-indexes-on-a-diet">JavaScript Compression (Putting my JSON Search Indexes on a diet)</a>. (Added to the list above).</p>
<p class="PostTime">Posted at 18:06</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/the-neocities-challenge-aka-the-full-text-indexer-goes-clientside">The NeoCities Challenge! aka The Full Text Indexer goes client-side!</a></li><li><a href="/the-full-text-indexer-token-breaker-and-string-normaliser-variations">The Full Text Indexer - Token Breaker and String Normaliser variations</a></li><li><a href="/the-full-text-indexer">The Full Text Indexer</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/FullTextIndexer" title="17 Posts">FullTextIndexer</a></li><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li><li><a href="/Archive/Tag/LINQ" title="13 Posts">LINQ</a></li><li><a href="/Archive/Tag/Optimisation" title="8 Posts">Optimisation</a></li></ul></div>
            <p class="Comments">
                <a href="/the-full-text-indexer-post-roundup#disqus_thread" data-disqus-identifier="40">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">6 December 2012</p><h2><a id="persistent-immutable-lists-extended" href="/persistent-immutable-lists-extended">Persistent Immutable Lists - Extended</a></h2>
<p>In my last post (<a href="/persistent-immutable-lists">Persistent Immutable Lists</a>) I offered some code as an alternate (and more performant) way to write an immutable list to that I suggested right back in my first post (<a href="/i-love-immutable-data">I love Immutable Data</a>). Well now I'd like to present a minor follow-up to the follow-up! I've incorporated the new list implementation into a few projects and have filled out a few more methods such as a &quot;Remove&quot; method (to remove a particular value, rather than removing from a given index with &quot;RemoveAt&quot; or &quot;RemoveRange&quot;), alternate &quot;Sort&quot; signatures and a &quot;To&quot; method that allows for derived types to be written that return their the derived type from the manipulation methods (see examples below):</p>
<pre><code>[Serializable]
public class ImmutableList&lt;T&gt; : IEnumerable&lt;T&gt;
{
    private readonly Node _tail;
    private readonly IValueValidator&lt;T&gt; _optionalValueValidator;
    private T[] _allValues;

    public ImmutableList() : this((IValueValidator&lt;T&gt;)null) { }
    public ImmutableList(IEnumerable&lt;T&gt; values) : this(values, null) { }
    public ImmutableList(IValueValidator&lt;T&gt; optionalValueValidator)
        : this((Node)null, optionalValueValidator) { }
    public ImmutableList(IEnumerable&lt;T&gt; values, IValueValidator&lt;T&gt; optionalValueValidator)
    {
        if (values == null)
            throw new ArgumentNullException(&quot;values&quot;);

        Node node = null;
        foreach (var value in values)
        {
            if (optionalValueValidator != null)
                optionalValueValidator.EnsureValid(value);
            if (node == null)
                node = new Node(value, null);
            else
                node = new Node(value, node);
        }
        _tail = node;
        _optionalValueValidator = optionalValueValidator;
        _allValues = null;
    }
    protected ImmutableList(Node tail, IValueValidator&lt;T&gt; optionalValueValidator)
    {
        _tail = tail;
        _optionalValueValidator = optionalValueValidator;
        _allValues = null;
    }

    public T this[int index]
    {
        get
        {
            if ((index &lt; 0) || (index &gt;= Count))
                throw new ArgumentOutOfRangeException(&quot;index&quot;);

            EnsureAllValuesDataIsPopulated();
            return _allValues[index];
        }
    }

    public int Count
    {
        get { return (_tail == null) ? 0 : _tail.Count; }
    }

    public bool Contains(T value)
    {
        return Contains(value, null);
    }

    public bool Contains(T value, IEqualityComparer&lt;T&gt; optionalComparer)
    {
        if (_tail == null)
            return false;

        EnsureAllValuesDataIsPopulated();
        for (var index = 0; index &lt; _allValues.Length; index++)
        {
            if (DoValuesMatch(_allValues[index], value, optionalComparer))
                return true;
        }
        return false;
    }

    public ImmutableList&lt;T&gt; Add(T value)
    {
        // Add is easy since we keep a reference to the tail node, we only need to wrap it
        // in a new node to create a new tail!
        if (_optionalValueValidator != null)
            _optionalValueValidator.EnsureValid(value);
        return new ImmutableList&lt;T&gt;(
            new Node(value, _tail),
            _optionalValueValidator
        );
    }

    public ImmutableList&lt;T&gt; AddRange(IEnumerable&lt;T&gt; values)
    {
        if (values == null)
            throw new ArgumentNullException(&quot;values&quot;);
        if (!values.Any())
            return this;

        // AddRange is easy for the same reason as Add
        var node = _tail;
        foreach (var value in values)
        {
            if (_optionalValueValidator != null)
                _optionalValueValidator.EnsureValid(value);
            node = new Node(value, node);
        }
        return new ImmutableList&lt;T&gt;(node, _optionalValueValidator);
    }

    public ImmutableList&lt;T&gt; Insert(IEnumerable&lt;T&gt; values, int insertAtIndex)
    {
        if (values == null)
            throw new ArgumentNullException(&quot;values&quot;);

        return Insert(values, default(T), insertAtIndex);
    }

    public ImmutableList&lt;T&gt; Insert(T value, int insertAtIndex)
    {
        return Insert(null, value, insertAtIndex);
    }

    private ImmutableList&lt;T&gt; Insert(
        IEnumerable&lt;T&gt; multipleValuesToAdd,
        T singleValueToAdd,
        int insertAtIndex)
    {
        if ((insertAtIndex &lt; 0) || (insertAtIndex &gt; Count))
            throw new ArgumentOutOfRangeException(&quot;insertAtIndex&quot;);
        if ((multipleValuesToAdd != null) &amp;&amp; !multipleValuesToAdd.Any())
            return this;

        // If the insertion is at the end of the list then we can use Add or AddRange which
        // may allow some optimisation
        if (insertAtIndex == Count)
        {
            if (multipleValuesToAdd == null)
                return Add(singleValueToAdd);
            return AddRange(multipleValuesToAdd);
        }

        // Starting with the tail, walk back to the insertion point, record the values we
        // pass over
        var node = _tail;
        var valuesBeforeInsertionPoint = new T[Count - insertAtIndex];
        for (var index = 0; index &lt; valuesBeforeInsertionPoint.Length; index++)
        {
            valuesBeforeInsertionPoint[index] = node.Value;
            node = node.Previous;
        }

        // Any existing node chain before the insertion point can be persisted and the new
        // value(s) appended
        if (multipleValuesToAdd == null)
        {
            if (_optionalValueValidator != null)
                _optionalValueValidator.EnsureValid(singleValueToAdd);
            node = new Node(singleValueToAdd, node);
        }
        else
        {
            foreach (var valueToAdd in multipleValuesToAdd)
            {
                if (_optionalValueValidator != null)
                    _optionalValueValidator.EnsureValid(valueToAdd);
                node = new Node(valueToAdd, node);
            }
        }

        // Finally, add back the values we walked through before to complete the chain
        for (var index = valuesBeforeInsertionPoint.Length - 1; index &gt;= 0; index--)
            node = new Node(valuesBeforeInsertionPoint[index], node);
        return new ImmutableList&lt;T&gt;(node, _optionalValueValidator);
    }

    /// &lt;summary&gt;
    /// Removes the first occurrence of a specific object from the list, if the item is
    /// not present then this instance will be returned
    /// &lt;/summary&gt;
    public ImmutableList&lt;T&gt; Remove(T value)
    {
        return Remove(value, null);
    }

    /// &lt;summary&gt;
    /// Removes the first occurrence of a specific object from the list, if the item is
    /// not present then this instance will be returned
    /// &lt;/summary&gt;
    public ImmutableList&lt;T&gt; Remove(T value, IEqualityComparer&lt;T&gt; optionalComparer)
    {
        // If there are no items in the list then the specified value can't be present,
        // so do nothing
        if (_tail == null)
            return this;

        // Try to find the last node that matches the value when walking backwards from
        // the tail; this will be the first in the list when considered from start to end
        var node = _tail;
        Node lastNodeThatMatched = null;
        int? lastNodeIndexThatMatched = null;
        var valuesBeforeRemoval = new T[Count];
        for (var index = 0; index &lt; Count; index++)
        {
            if (DoValuesMatch(value, node.Value, optionalComparer))
            {
                lastNodeThatMatched = node;
                lastNodeIndexThatMatched = index;
            }
            valuesBeforeRemoval[index] = node.Value;
            node = node.Previous;
        }
        if (lastNodeThatMatched == null)
            return this;

        // Now build a new chain by taking the content before the value-to-remove and
        // adding back the values that were stepped through
        node = lastNodeThatMatched.Previous;
        for (var index = lastNodeIndexThatMatched.Value - 1; index &gt;= 0; index--)
            node = new Node(valuesBeforeRemoval[index], node);
        return new ImmutableList&lt;T&gt;(node, _optionalValueValidator);
    }

    private bool DoValuesMatch(T x, T y, IEqualityComparer&lt;T&gt; optionalComparer)
    {
        if (optionalComparer != null)
            return optionalComparer.Equals(x, y);

        if ((x == null) &amp;&amp; (y == null))
            return true;
        else if ((x == null) || (y == null))
            return false;
        else
            return x.Equals(y);
    }

    public ImmutableList&lt;T&gt; RemoveAt(int removeAtIndex)
    {
        return RemoveRange(removeAtIndex, 1);
    }

    public ImmutableList&lt;T&gt; RemoveRange(int removeAtIndex, int count)
    {
        if (removeAtIndex &lt; 0)
            throw new ArgumentOutOfRangeException(
                &quot;removeAtIndex&quot;,
                &quot;must be greater than or equal zero&quot;
            );
        if (count &lt;= 0)
            throw new ArgumentOutOfRangeException(&quot;count&quot;, &quot;must be greater than zero&quot;);
        if ((removeAtIndex + count) &gt; Count)
            throw new ArgumentException(&quot;removeAtIndex + count must not exceed Count&quot;);

        // Starting with the tail, walk back to the end of the removal range, recording
        // the values we pass over
        var node = _tail;
        var valuesBeforeRemovalRange = new T[Count - (removeAtIndex + count)];
        for (var index = 0; index &lt; valuesBeforeRemovalRange.Length; index++)
        {
            valuesBeforeRemovalRange[index] = node.Value;
            node = node.Previous;
        }

        // Move past the values in the removal range
        for (var index = 0; index &lt; count; index++)
            node = node.Previous;

        // Now add back the values we walked through above to the part of the chain that
        // can be persisted
        for (var index = valuesBeforeRemovalRange.Length - 1; index &gt;= 0; index--)
            node = new Node(valuesBeforeRemovalRange[index], node);
        return new ImmutableList&lt;T&gt;(node, _optionalValueValidator);
    }

    public ImmutableList&lt;T&gt; Sort()
    {
        return Sort((IComparer&lt;T&gt;)null);
    }

    public ImmutableList&lt;T&gt; Sort(Comparison&lt;T&gt; optionalComparison)
    {
        if (optionalComparison == null)
            return Sort((IComparer&lt;T&gt;)null);
        return Sort(new SortComparisonWrapper(optionalComparison));
    }

    public ImmutableList&lt;T&gt; Sort(IComparer&lt;T&gt; optionalComparer)
    {
        EnsureAllValuesDataIsPopulated();
        return new ImmutableList&lt;T&gt;(
            (optionalComparer == null)
                ? _allValues.OrderBy(v =&gt; v)
                : _allValues.OrderBy(v =&gt; v, optionalComparer),
            _optionalValueValidator
        );
    }

    public IEnumerator&lt;T&gt; GetEnumerator()
    {
        // As documented at http://msdn.microsoft.com/en-us/library/system.array.aspx,
        // from .Net 2.0 onward, the Array class implements IEnumerable&lt;T&gt; but this is
        // only provided at runtime so we have to explicitly cast access its generic
        // GetEnumerator method
        EnsureAllValuesDataIsPopulated();
        return ((IEnumerable&lt;T&gt;)_allValues).GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    /// &lt;summary&gt;
    /// So that a derived class may override the public methods with implementations that
    /// return the derived type's class, this method exposes a manner to access the _tail
    /// reference of a return ImmutableList instance without having to make both it and the
    /// Node class public - eg. a derived class NonNullOrEmptyStringList may incorporate its
    /// own hard-coded validation and wish to have a NonNullOrEmptyStringList instance
    /// returned from its Add method. If it calls the ImmutableList's Add method it will
    /// receive a new ImmutableList instance which can be transformed into an instance of
    /// NonNullOrEmptyStringList if it has a constructor which take a Node argument by
    /// passing a lambda wrapping a call to that constructor into this method, along with
    /// the new ImmutableList reference that is to be wrapped. This introduce does have the
    /// overhead of an additional initialisation (of the NonNullOrEmptyStringList) but it
    /// allows for more strictly-typed return values from the NonNullOrEmptyStringList's
    /// methods.
    /// &lt;/summary&gt;
    protected static U To&lt;U&gt;(ImmutableList&lt;T&gt; list, Func&lt;Node, U&gt; generator)
    {
        if (list == null)
            throw new ArgumentNullException(&quot;list&quot;);
        if (generator == null)
            throw new ArgumentNullException(&quot;generator&quot;);

        return generator(list._tail);
    }

    /// &lt;summary&gt;
    /// For enumerating the values we need to walk through all of the nodes and then reverse
    /// the set (since we start with the tail and work backwards). This can be relatively
    /// expensive so the list is cached in the &quot;_allValues&quot; member array so that subsequent
    /// requests are fast (wouldn't be a big deal for a single enumeration of the contents
    /// but it could be for multiple calls to the indexed property).
    /// &lt;/summary&gt;
    private void EnsureAllValuesDataIsPopulated()
    {
        if (_allValues != null)
            return;

        // Since we start at the tail and work backwards, we need to reverse
        // the order of the items in values array that is populated here
        var numberOfValues = Count;
        var values = new T[numberOfValues];
        var node = _tail;
        for (var index = 0; index &lt; numberOfValues; index++)
        {
            values[(numberOfValues - 1) - index] = node.Value;
            node = node.Previous;
        }
        _allValues = values;
    }

    /// &lt;summary&gt;
    /// This is used by the Sort method if a Comparison&lt;T&gt; is specified
    /// &lt;/summary&gt;
    private class SortComparisonWrapper : IComparer&lt;T&gt;
    {
        private Comparison&lt;T&gt; _comparison;
        public SortComparisonWrapper(Comparison&lt;T&gt; comparison)
        {
            if (comparison == null)
                throw new ArgumentNullException(&quot;comparison&quot;);

            _comparison = comparison;
        }

        public int Compare(T x, T y)
        {
            return _comparison(x, y);
        }
    }

    protected class Node
    {
        public Node(T value, Node previous)
        {
            Value = value;
            Previous = previous;
            Count = (previous == null) ? 1 : (previous.Count + 1);
        }

        public T Value { get; private set; }

        /// &lt;summary&gt;
        /// This will be null if there is no previous node (ie. this is the start of the
        /// chain, the head)
        /// &lt;/summary&gt;
        public Node Previous { get; private set; }

        public int Count { get; private set; }
    }
}

public interface IValueValidator&lt;T&gt;
{
    /// &lt;summary&gt;
    /// This will throw an exception for a value that does pass validation requirements
    /// &lt;/summary&gt;
    void EnsureValid(T value);
}
</code></pre>
<p>To implement a NonNullImmutableList we want to inherit from the ImmutableList and introduce a compulsory IValueValidator that ensures that no item in the list is null. Each of the methods are then &quot;overridden&quot; using the &quot;new&quot; keyword so that if they are called on an instance of the NonNullImmutableList then an instance of the NonNullImmutableList will be returned but if it is used anywhere as an ImmutableList then the ImmutableList's methods will be called directly and an ImmutableList (rather than a NonNullImmutableList) reference will be returned. This approach does have a minor overhead as described in the comment on the &quot;To&quot; method seen above but it does offer a straight-forward way to write derived classes that maintain their type (and so their implicit validation rules and assurances) when manipulations are performed.</p>
<pre><code>[Serializable]
public class NonNullImmutableList&lt;T&gt; : ImmutableList&lt;T&gt; where T : class
{
    private readonly static Validator _defaultValidator = new Validator(null);
    private IValueValidator&lt;T&gt; _optionalValueValidator;

    public NonNullImmutableList() : this((IValueValidator&lt;T&gt;)null) { }
    public NonNullImmutableList(IEnumerable&lt;T&gt; values) : this(values, null) { }
    public NonNullImmutableList(IValueValidator&lt;T&gt; optionalValueValidator)
        : base((Node)null, GetValidator(optionalValueValidator))
    {
        _optionalValueValidator = optionalValueValidator;
    }
    public NonNullImmutableList(
        IEnumerable&lt;T&gt; values,
        IValueValidator&lt;T&gt; optionalValueValidator
    ) : base(values, GetValidator(optionalValueValidator))
    {
        _optionalValueValidator = optionalValueValidator;
    }
    private NonNullImmutableList(Node tail, IValueValidator&lt;T&gt; optionalValueValidator)
        : base(tail, GetValidator(optionalValueValidator))
    {
        _optionalValueValidator = optionalValueValidator;
    }

    private static IValueValidator&lt;T&gt; GetValidator(IValueValidator&lt;T&gt; optionalValueValidator)
    {
        if (optionalValueValidator == null)
            return _defaultValidator;
        return new Validator(optionalValueValidator);
    }

    public new NonNullImmutableList&lt;T&gt; Add(T value)
    {
        return ToNonNullOrEmptyStringList(base.Add(value));
    }
    public new NonNullImmutableList&lt;T&gt; AddRange(IEnumerable&lt;T&gt; values)
    {
        return ToNonNullOrEmptyStringList(base.AddRange(values));
    }
    public new NonNullImmutableList&lt;T&gt; Insert(T value, int insertAtIndex)
    {
        return ToNonNullOrEmptyStringList(base.Insert(value, insertAtIndex));
    }
    public new NonNullImmutableList&lt;T&gt; Insert(IEnumerable&lt;T&gt; values, int insertAtIndex)
    {
        return ToNonNullOrEmptyStringList(base.Insert(values, insertAtIndex));
    }
    public new NonNullImmutableList&lt;T&gt; Remove(T value)
    {
        return ToNonNullOrEmptyStringList(base.Remove(value));
    }
    public new NonNullImmutableList&lt;T&gt; Remove(T value, IEqualityComparer&lt;T&gt; optionalComparer)
    {
        return ToNonNullOrEmptyStringList(base.Remove(value, optionalComparer));
    }
    public new NonNullImmutableList&lt;T&gt; RemoveAt(int removeAtIndex)
    {
        return ToNonNullOrEmptyStringList(base.RemoveAt(removeAtIndex));
    }
    public new NonNullImmutableList&lt;T&gt; RemoveRange(int removeAtIndex, int count)
    {
        return ToNonNullOrEmptyStringList(base.RemoveRange(removeAtIndex, count));
    }
    public new NonNullImmutableList&lt;T&gt; Sort()
    {
        return ToNonNullOrEmptyStringList(base.Sort());
    }
    public new NonNullImmutableList&lt;T&gt; Sort(Comparison&lt;T&gt; optionalComparison)
    {
        return ToNonNullOrEmptyStringList(base.Sort(optionalComparison));
    }
    public new NonNullImmutableList&lt;T&gt; Sort(IComparer&lt;T&gt; optionalComparer)
    {
        return ToNonNullOrEmptyStringList(base.Sort(optionalComparer));
    }
    private NonNullImmutableList&lt;T&gt; ToNonNullOrEmptyStringList(ImmutableList&lt;T&gt; list)
    {
        if (list == null)
            throw new ArgumentNullException(&quot;list&quot;);

        return To&lt;NonNullImmutableList&lt;T&gt;&gt;(
            list,
            tail =&gt; new NonNullImmutableList&lt;T&gt;(tail, _optionalValueValidator)
        );
    }

    private class Validator : IValueValidator&lt;T&gt;
    {
        private IValueValidator&lt;T&gt; _optionalInnerValidator;
        public Validator(IValueValidator&lt;T&gt; optionalInnerValidator)
        {
            _optionalInnerValidator = optionalInnerValidator;
        }

        /// &lt;summary&gt;
        /// This will throw an exception for a value that does pass validation requirements
        /// &lt;/summary&gt;
        public void EnsureValid(T value)
        {
            if (value == null)
                throw new ArgumentNullException(&quot;value&quot;);
            if (_optionalInnerValidator != null)
                _optionalInnerValidator.EnsureValid(value);
        }
    }
}
</code></pre>
<p>A very similar approach could be taken to implement a &quot;NonNullOrEmptyStringList&quot; class (referred to in previous posts as a &quot;DefinedStringList&quot;) but dropping the type param and inheriting from ImmutableList&lt;string&gt; and swapping out the validator to check for null or blank strings.</p>
<p>The final piece of the puzzle I've used in my code is to throw in some extension methods:</p>
<pre><code>public static class IEnumerable_Extensions
{
    public static ImmutableList&lt;T&gt; ToImmutableList&lt;T&gt;(this IEnumerable&lt;T&gt; data)
    {
        return new ImmutableList&lt;T&gt;(data);
    }

    /// &lt;summary&gt;
    /// valueValidator is optional (may be null)
    /// &lt;/summary&gt;
    public static ImmutableList&lt;T&gt; ToImmutableList&lt;T&gt;(
        this IEnumerable&lt;T&gt; data,
        IValueValidator&lt;T&gt; valueValidator)
    {
        return new ImmutableList&lt;T&gt;(data, valueValidator);
    }

    /// &lt;summary&gt;
    /// This will throw an exception if any of the values are null
    /// &lt;/summary&gt;
    public static NonNullImmutableList&lt;T&gt; ToNonNullImmutableList&lt;T&gt;(
        this IEnumerable&lt;T&gt; data) where T : class
    {
        return new NonNullImmutableList&lt;T&gt;(data);
    }

    /// &lt;summary&gt;
    /// This will throw an exception if any of the values are null, valueValidator is
    /// optional (may be null)
    /// &lt;/summary&gt;
    public static NonNullImmutableList&lt;T&gt; ToNonNullImmutableList&lt;T&gt;(
        this IEnumerable&lt;T&gt; data,
        IValueValidator&lt;T&gt; valueValidator) where T : class
    {
        return new NonNullImmutableList&lt;T&gt;(data, valueValidator);
    }
}
</code></pre>
<p>And that's it! I'm happy with these updated lists for now and, as I already mentioned, have been using them in a few projects and consider them ready for use!</p>
<p class="PostTime">Posted at 20:02</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired &quot;with&quot; updates for immutable classes in C#</a></li><li><a href="/persistent-immutable-lists">Persistent Immutable Lists</a></li><li><a href="/i-love-immutable-data">I love Immutable Data</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/persistent-immutable-lists-extended#disqus_thread" data-disqus-identifier="39">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">26 November 2012</p><h2><a id="persistent-immutable-lists" href="/persistent-immutable-lists">Persistent Immutable Lists</a></h2>
<p>I've written before about immutable data structures (I'm all for them; see <a href="/i-love-immutable-data">I love Immutable Data</a> and <a href="/problems-in-immutabilityland">Problems in Immutability-land</a>) but watching a talk recently by Clojure-creator Rich Hickey made me think about one particular area again recently. In that first post I put up some example cost for an Immutable List that wrapped the .Net List&lt;T&gt; class - this was very simple to implement and understand, and in many cases I was using the immutable class as a return type or a method argument which meant that the instance would be built once and futher manipulations would be limited. This meant that I wasn't too concerned with internally creating a new list instance each time a new immutable instance was required and copying the references over.</p>
<p>However, in this talk it was reiterated that all of the core data structures in Clojure were intended to be immutable and that considerable work was done to ensure that the performance of these structures was sufficient that it could compete with Java and C#. A persistent linked list structure was used so that operations could be performed without having to recreate the entire dataset.</p>
<p>This is something that I didn't know a huge amount about but sounded like it could be an interesting avenue to explore!</p>
<h3>A basic introduction into the singly-linked list</h3>
<p>The singly-linked list is a fairly basic structure built around nodes; each node has a value and a link to the next node, if there is one. We know we're at the end of the list when the current node has a null &quot;next&quot; node reference.</p>
<p>An empty list would have a null &quot;head&quot; node.</p>
<p>An int list with a single item would have a head node of the form</p>
<pre><code>{ 1, null }
</code></pre>
<p>where the value of the item is 1 and there is no next node.</p>
<p>An int list with two items could be illustrated as</p>
<pre><code>{ 1, { 2, null } }
</code></pre>
<p>And one with four values as</p>
<pre><code>{ 1, { 2, { 3, { 4, null } } } }
</code></pre>
<p>Well, you get the idea!</p>
<p>The interesting thing comes when we look at how the structure changes as items are added. Starting off with an empty list and adding items one at a time to the front of the list, the structure grows in this manner:</p>
<pre><code>{ 1, null }

{ 2, { 1, null } }

{ 3, { 2, { 1, null } } }

{ 4, { 3, { 2, { 1, null } } } }
</code></pre>
<p>Each time we take a list L0 and create a new instance L1 by adding a single item, the head node of L1 can be taken to be a new node that contains the new value and whose &quot;next&quot; reference points to the head node of L0. This is where the &quot;persistent&quot; part comes into play. (This is only possible if the nodes themselves are immutable as otherwise one instance of the list could affect the data in another instance if they shared node chain references where the nodes were <em>not</em> immutable).</p>
<p>This means that creating a new list with a new item is a very simple and fast action! This operation is considerably faster than the doing the same on the original immutable list approach I was using, especially as the size of the list grows.</p>
<p>Enumerating the list is also straight-forward; we start at the head node (if non-null) and then walk down the &quot;next&quot; references until we hit a null, indicating the end of the list.</p>
<p>A basic implementation of this could be:</p>
<pre><code>public class SimplePersistentImmutableList&lt;T&gt; : IEnumerable&lt;T&gt;
{
    private readonly Node _head;
    public SimplePersistentImmutableList() : this(null) { }
    private SimplePersistentImmutableList(Node head)
    {
        _head = head;
    }

    public SimplePersistentImmutableList&lt;T&gt; InsertAtStart(T value)
    {
        return new SimplePersistentImmutableList&lt;T&gt;(
            new Node(value, _head)
        );
    }

    public IEnumerator&lt;T&gt; GetEnumerator()
    {
        return new SetEnumerator(_head);
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    private class Node
    {
        public Node(T value, Node next)
        {
            Value = value;
            Next = next;
        }

        public T Value { get; private set; }

        /// &lt;summary&gt;
        /// This will be null if there is no next node
        /// &lt;/summary&gt;
        public Node Next { get; private set; }
    }

    private class SetEnumerator : IEnumerator&lt;T&gt;
    {
        private readonly Node _topNode;
        private Node _currentNode;
        public SetEnumerator(Node topNode)
        {
            // The way that the enumeration operates is that it will call MoveNext before
            // trying to retrieve the first value when processing a foreach loop to ensure
            // that data is present. In order to deal with this, we need to wrap the Top
            // Node in another node so that the first MoveNext call moves us to the start
            // of the data.
            _topNode = new Node(default(T), topNode);
            _currentNode = _topNode;
        }

        public void Dispose() { }

        public T Current
        {
            get
            {
                if (_currentNode == null)
                    throw new InvalidOperationException(&quot;No Current value&quot;);
                return _currentNode.Value;
            }
        }

        object IEnumerator.Current
        {
            get { return Current; }
        }

        public bool MoveNext()
        {
            if ((_currentNode == null) || (_currentNode.Next == null))
                return false;
            _currentNode = _currentNode.Next;
            return true;
        }

        public void Reset()
        {
            _currentNode = _topNode;
        }
    }
}
</code></pre>
<p>And most of that code is the implementation of IEnumerable!</p>
<h3>Limitations</h3>
<p>This example <em>only</em> exposes an InsertAtStart method as a manner in which to alter the list. An obvious counterpart would be to add a RemoveFromStart method, since all that need do is create a new list whose head node is the &quot;next&quot; node of the head node of the current list (if the head node of the intial list was null then there are no items, and so RemoveFromStart would be invalid).</p>
<pre><code>public SimplePersistentImmutableList&lt;T&gt; RemoveFirstItem()
{
    if (_head == null)
        throw new InvalidOperationException(&quot;The list is empty&quot;);

    return new SimplePersistentImmutableList&lt;T&gt;(
        _head.Next
    );
}
</code></pre>
<p>At this point, we could very easily take this code and create an immutable stack by renaming &quot;InsertAtStart&quot; to &quot;Push&quot;, &quot;RemoveFromStart&quot; to &quot;Pop&quot; and adding in a way to retrieve the current value, if any:</p>
<pre><code>public T Peek()
{
    if (_head == null)
        throw new InvalidOperationException(&quot;The list is empty&quot;);

    return _head.Value;
}

public bool IsEmpty
{
    get
    {
        return (_head == null);
    }
}
</code></pre>
<p>However, to support the other actions that are expected from a list such as inserting-into and removing-from arbitrary locations we need to consider how to find the appropriate place in the node chain from which to snip out values or insert new ones. Unless these operations are to remove the first item(s) from a list or to add some to the start of the list, only <em>some</em> of the existing chain may be shared between the current and new instances.</p>
<p>For example, to add the value 99 into index 2 of the list that is described by the following node chain</p>
<pre><code>{ 3, { 2, { 1, { 0, null } } } }
</code></pre>
<p>then we'd need to end up with the chain</p>
<pre><code>{ 3, { 2, { 99, { 1, { 0, null } } } } }
</code></pre>
<p>managing to re-use only the last two nodes of the existing chain.</p>
<p>This brings me onto the issue that I have with the above implementation; it's my gut feeling that the majority of operations that I might perform on a list are generating an immutable list from a mutable set, adding items to the end of an existing list and enumerating through the values. Keeping a reference to the head node means that every time a new value is added to the end of the list, none of the chain may be persisted. So to optimise for this operation we can store a reference to the <em>tail</em> of the chain. Now the same logic from the InsertAtStart method becomes the Add method:</p>
<pre><code>public SimplePersistentImmutableList&lt;T&gt; Add(T value)
{
    return new SimplePersistentImmutableList&lt;T&gt;(
        new Node(value, _tail)
    );
}
</code></pre>
<p>so long as the Node class is also altered to reflect this reversed nature:</p>
<pre><code>private class Node
{
    public Node(T value, Node previous)
    {
        Value = value;
        Previous = previous;
    }

    public T Value { get; private set; }

    /// &lt;summary&gt;
    /// This will be null if there is no previous node
    /// &lt;/summary&gt;
    public Node Previous { get; private set; }
}
</code></pre>
<p>This does raise one thorny issue, though; we have to re-think enumeration of the list since we can only step <em>backwards</em> through the list as the &quot;master&quot; node reference we store is the tail. A simple approach would be as follows:</p>
<pre><code>public IEnumerator&lt;T&gt; GetEnumerator()
{
    var values = new List&lt;T&gt;();
    var node = _tail;
    while (_tail != null)
    {
        values.Insert(0, node.Value);
        node = node.Previous;
    }
    return values.GetEnumerator();
}
</code></pre>
<p>This makes enumeration potentially an expensive operation, especially if there are a large number of items in the set since a new List is built and populated for each enumeration. And if there are a lot of items to deal with then the list may have to resize its internal array multiple times (with a copy operation from one array to the next) since we don't know up front how large the list needs to be.</p>
<p>To address this, I'm going to make two changes. Firstly, the Node class will be given a Count property which is always the Count of the previous Node plus one, unless the previous Node is null in which case the Count is one.</p>
<pre><code>private class Node
{
    public Node(T value, Node previous)
    {
        Value = value;
        Previous = previous;
        Count = (previous == null) ? 1 : (previous.Count + 1);
    }

    public T Value { get; private set; }

    /// &lt;summary&gt;
    /// This will be null if there is no previous node
    /// the head)
    /// &lt;/summary&gt;
    public Node Previous { get; private set; }

    public int Count { get; private set; }
}
</code></pre>
<p>Secondly, I'm going to introduce a class member array &quot;_allValues&quot; which is only populated the first time that an enumeration is requested and that effectively caches the value set in an easily-enumerable format. This is only populated &quot;on demand&quot; to avoid any overhead where it is generated for a list that will never be enumerated over (if an instance L0 has a value added to it, resulting in L1, which then has a further value added to it, resulting in L2, we don't want to waste time generating the &quot;_allValues&quot; array for L1 if the reference to L1 is dropped when L2 is created).</p>
<pre><code>/// &lt;summary&gt;
/// For enumerating the values we need to walk through all of the nodes and then reverse the
/// set (since we start with the tail and work backwards). This can be relatively expensive
/// so the list is cached in the &quot;_allValues&quot; member array so that subsequent requests are
/// fast (mightn't be a big deal for a single enumeration of the contents but it could
/// be for multiple calls to the indexed property, for example).
/// &lt;/summary&gt;
private void EnsureAllValuesDataIsPopulated()
{
    if (_allValues != null)
        return;

    // Since we start at the tail and work backwards, we need to reverse the order of the
    // items in values array that is populated here
    var numberOfValues = Count;
    var values = new T[numberOfValues];
    var node = _tail;
    for (var index = 0; index &lt; numberOfValues; index++)
    {
        values[(numberOfValues - 1) - index] = node.Value;
        node = node.Previous;
    }
    _allValues = values;
}
</code></pre>
<p>The Count property of the node allows an array to be initialised of the required size since now we <em>know</em> the required size. The &quot;_allValues&quot; array is set to null in the constructor and this EnsureAllValuesDataIsPopulated method must be called before anything references it (eg. the GetEnumerator method).</p>
<p>There's something potentially a bit hairy in this, though, as the internals of the class are no longer immutable and so could we be open to crazy things happening in multi-threaded scenarios? <a href="http://www.albahari.com/threading/part4.aspx">Joseph Albahari's Advanced Threading article</a> shows a scary first example and Jon Skeet's <a href="http://csharpindepth.com/Articles/General/Singleton.aspx">Implementing the Singleton Pattern in C#</a> has an example with code that looks very similar to what we're doing here, and that's clearly marked as not thread-safe. The first example illustrates how issues may arise as the <em>&quot;compiler, CLR or CPU may <em>reorder</em> your program's instructions to improve efficiency&quot;</em> but <em>&quot;C# and the runtime are very careful to ensure that such optimizations dont break ordinary single-threaded code&quot;</em> so in this case we needn't worry as there is only one &quot;_allValues&quot; reference being compared to null and then set and no significant rearrangement could be made that wouldn't affect single-threaded processing. In the Singleton example, the issue is that the work could potentially be performed multiple times if multiple threads checked for null before any thread had completed the work and set the &quot;_allValues&quot; reference. For the lock-free reading that be possible result when &quot;_allValues&quot; <em>has</em> been set, I'm happy with the trade-off in this case. (If multiple threads have to do the work of generating the array while they're all clamouring for the &quot;_allValues&quot; data at the same time that's fine since once they finish, subsequent requests will be able to access the pre-generated array with no locking or other complications). If I wasn't happy with it then I'd probably use the .Net 4.0 Lazy&lt;T&gt; construct I've talked about before (see <a href="/check-check-it-out">Check, check it out</a>) but this could potentially add some overhead for each new instance of the immutable list, which I wanted to avoid for instances that will never be enumerated over.</p>
<pre><code>public class PersistentImmutableList&lt;T&gt; : IEnumerable&lt;T&gt;
{
    private readonly Node _tail;
    private T[] _allValues;

    public PersistentImmutableList() : this((Node)null) { }
    public PersistentImmutableList(IEnumerable&lt;T&gt; values)
    {
        if (values == null)
            throw new ArgumentNullException(&quot;values&quot;);

        Node node = null;
        foreach (var value in values)
        {
            if (node == null)
                node = new Node(value, null);
            else
                node = new Node(value, node);
        }
        _tail = node;
    }
    private PersistentImmutableList(Node tail)
    {
        _tail = tail;
    }

    public int Count
    {
        get { return (_tail == null) ? 0 : _tail.Count; }
    }

    public PersistentImmutableList&lt;T&gt; Add(T value)
    {
        return AddRange(new[] { value });
    }

    public PersistentImmutableList&lt;T&gt; AddRange(IEnumerable&lt;T&gt; values)
    {
        if (values == null)
            throw new ArgumentNullException(&quot;values&quot;);

        var node = _tail;
        foreach (var value in values)
            node = new Node(value, _tail);
        return new PersistentImmutableList&lt;T&gt;(node);
    }

    public IEnumerator&lt;T&gt; GetEnumerator()
    {
        // As documented at http://msdn.microsoft.com/en-us/library/system.array.aspx, from
        // .Net 2.0 onward, the Array class implements IEnumerable&lt;T&gt; but this is only
        // provided at runtime so we have to explicitly cast access its generic
        // GetEnumerator method
        EnsureAllValuesDataIsPopulated();
        return ((IEnumerable&lt;T&gt;)_allValues).GetEnumerator();
    }
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    /// &lt;summary&gt;
    /// For enumerating the values we need to walk through all of the nodes and then reverse
    /// the set (since we start with the tail and work backwards). This can be relatively
    /// expensive so the list is cached in the &quot;_allValues&quot; member array so that subsequent
    /// requests are fast (mightn't be a big deal for a single enumeration of the contents
    /// but it could be for multiple calls to the indexed property).
    /// &lt;/summary&gt;
    private void EnsureAllValuesDataIsPopulated()
    {
        if (_allValues != null)
            return;

        // Since we start at the tail and work backwards, we need to reverse the order of
        // the items in values array that is populated here
        var numberOfValues = Count;
        var values = new T[numberOfValues];
        var node = _tail;
        for (var index = 0; index &lt; numberOfValues; index++)
        {
            values[(numberOfValues - 1) - index] = node.Value;
            node = node.Previous;
        }
        _allValues = values;
    }

    private class Node
    {
        public Node(T value, Node previous)
        {
            Value = value;
            Previous = previous;
            Count = (previous == null) ? 1 : (previous.Count + 1);
        }

        public T Value { get; private set; }

        /// &lt;summary&gt;
        /// This will be null if there is no previous node
        /// the head)
        /// &lt;/summary&gt;
        public Node Previous { get; private set; }

        public int Count { get; private set; }
    }
}
</code></pre>
<p>Having a Count property on the Node enables the immutable list to expose a Count property without having to recursively loop through the nodes.</p>
<h3>Rounding it out</h3>
<p>Since we have a &quot;_tail&quot; Node reference and each Node has a Previous property, this Count on the Node represents the number of items in the list up to and including the current Node. So the tail Node's Count is the number of items in the entire list, the Count property on the node before the tail (if any) would have a Count value of one less - indicating the number of Nodes there are one place before the tail Node. I mention this is because I hope it makes the following methods easier to follow!</p>
<pre><code>public PersistentImmutableList&lt;T&gt; InsertAt(T value, int insertAtIndex)
{
    return InsertAt(new[] { value }, insertAtIndex);
}

public PersistentImmutableList&lt;T&gt; InsertAt(IEnumerable&lt;T&gt; values, int insertAtIndex)
{
    if (values == null)
        throw new ArgumentNullException(&quot;values&quot;);
    if (!values.Any())
        return this;
    if ((insertAtIndex &lt; 0) || (insertAtIndex &gt; Count))
        throw new ArgumentOutOfRangeException(&quot;insertAtIndex&quot;);

    // If the insertion is at the end of the list then we can use AddRange and avoid any
    // messing about
    if (insertAtIndex == Count)
        return AddRange(values);

    // Starting with the tail, walk back to the insertion point, recording the values we
    // pass over
    var node = _tail;
    var valuesBeforeInsertionPoint = new T[Count - insertAtIndex];
    for (var index = 0; index &lt; valuesBeforeInsertionPoint.Length; index++)
    {
        valuesBeforeInsertionPoint[index] = node.Value;
        node = node.Previous;
    }

    // Any existing node chain before the insertion point can be persisted and the new
    // value(s) appended
    foreach (var value in values)
        node = new Node(value, node);

    // Finally, add back the values we walked through before to complete the chain
    for (var index = valuesBeforeInsertionPoint.Length - 1; index &gt;= 0; index--)
        node = new Node(valuesBeforeInsertionPoint[index], node);
    return new PersistentImmutableList&lt;T&gt;(node);
}
</code></pre>
<p>To insert into an arbitrary location in the list, we need to walk backwards from the tail to the insertion point and then insert the new value(s) by persisting the rest of the node chain (from the insertion point up to the head) and appending the new values and then the values which we have to walk through to get to the insertion point. The nodes from the tail to the insertion point can not be maintained as their &quot;Previous&quot; chain will not include the new values!</p>
<p>A very similar approach may be taken to removals:</p>
<pre><code>public PersistentImmutableList&lt;T&gt; RemoveAt(int removeAtIndex)
{
    return RemoveRange(removeAtIndex, 1);
}

public PersistentImmutableList&lt;T&gt; RemoveRange(int removeAtIndex, int count)
{
    if (removeAtIndex &lt; 0)
        throw new ArgumentOutOfRangeException(
            &quot;removeAtIndex&quot;,
            &quot;must be greater than or equal zero&quot;
        );
    if (count &lt;= 0)
        throw new ArgumentOutOfRangeException(&quot;count&quot;, &quot;must be greater than zero&quot;);
    if ((removeAtIndex + count) &gt; Count)
        throw new ArgumentException(&quot;removeAtIndex + count must not exceed Count&quot;);

    // Starting with the tail, walk back to the end of the removal range, recording the
    // values we passed over
    var node = _tail;
    var valuesBeforeRemovalRange = new T[Count - (removeAtIndex + count)];
    for (var index = 0; index &lt; valuesBeforeRemovalRange.Length; index++)
    {
        valuesBeforeRemovalRange[index] = node.Value;
        node = node.Previous;
    }

    // Move past the values in the removal range
    for (var index = 0; index &lt; count; index++)
        node = node.Previous;

    // Now add back the values we walked through above to the part of the chain that can be
    // persisted
    for (var index = valuesBeforeRemovalRange.Length - 1; index &gt;= 0; index--)
        node = new Node(valuesBeforeRemovalRange[index], node);
    return new PersistentImmutableList&lt;T&gt;(node);
}
</code></pre>
<p>And really, that's most of the complication out of the way! We can still flesh out a few more properties like an index property:</p>
<pre><code>public T this[int index]
{
    get
    {
        if ((index &lt; 0) || (index &gt;= Count))
            throw new ArgumentNullException(&quot;index&quot;);

        EnsureAllValuesDataIsPopulated();
        return _allValues[index];
    }
}
</code></pre>
<p>and a sort method:</p>
<pre><code>public PersistentImmutableList&lt;T&gt; Sort(IComparer&lt;T&gt; comparison)
{
    if (comparison == null)
        throw new ArgumentNullException(&quot;comparison&quot;);

    EnsureAllValuesDataIsPopulated();
    return new PersistentImmutableList&lt;T&gt;(
        _allValues.OrderBy(x =&gt; x, comparison)
    );
}
</code></pre>
<p>but we're getting down to icing-on-the-cake now.</p>
<h3>Conclusion</h3>
<p>I've enjoyed this little foray and intend to replace that old simple (effective but slow) immutable list I was using before with a version of this code! In existing code that used the previous implementation, there was a measurable performance hit in some loops where lists were being built up in a method before being returned - I rewrote these to use a mutable list internally and return an immutable representation when the work was complete (because of this performance hit). But now I think I could probably get away with using this new immutable list throughout method internals as well! I need to do some profiling of previously-seen trouble areas to be sure, but I get the sneaky feeling that in some of the larger data sets where performance was seen to be taking a hit, this new immutable list variation may work even better than the built-in <em>mutable</em> list. And that, I'm very happy with! :)</p>
<p class="PostTime">Posted at 20:33</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired &quot;with&quot; updates for immutable classes in C#</a></li><li><a href="/persistent-immutable-lists-extended">Persistent Immutable Lists - Extended</a></li><li><a href="/i-love-immutable-data">I love Immutable Data</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/persistent-immutable-lists#disqus_thread" data-disqus-identifier="38">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">22 March 2011</p><h2><a id="problems-in-immutabilityland" href="/problems-in-immutabilityland">Problems in Immutability-land</a></h2>
<p>Having sung the praises of immutability last time, there <em>are</em> a couple of flies in the ointment. The first is a bit of a non-issue I think, but bears mentioning; if I have a class with half a dozen properties it feels like a <em>lot</em> of monotonous typing hammering out those private properties, those arguments-not-whitespace-or-null checks, those property assigments, those public properties, those comments about the class contract - it's boring! Now I know that developers should all be superfast, touch-typist maniacs (<a href="http://www.codinghorror.com/blog/2008/11/we-are-typists-first-programmers-second.html">http://www.codinghorror.com/blog/2008/11/we-are-typists-first-programmers-second.html</a>) - and I am, that's not the problem - but it still makes me grimace when I know I have to throw down a big chunk of boilerplate-looking code like the Name class I used in an example last time.</p>
<pre><code>public class Name
{
  public Name(string title, string firstName, string lastName)
  {
    if ((title ?? &quot;&quot;).Trim() == &quot;&quot;)
      throw new ArgumentException(&quot;Null/empty title specified&quot;);
    if ((firstName ?? &quot;&quot;).Trim() == &quot;&quot;)
      throw new ArgumentException(&quot;Null/empty firstName specified&quot;);
    if ((lastName ?? &quot;&quot;).Trim() == &quot;&quot;)
      throw new ArgumentException(&quot;Null/empty lastName specified&quot;);

    Title = title;
    FirstName = firstName;
    LastName = lastName;
  }

  /// &lt;summary&gt;
  /// This will never be null or empty
  /// &lt;/summary&gt;
  public string Title { get; private set; }

  /// &lt;summary&gt;
  /// This will never be null or empty
  /// &lt;/summary&gt;
  public string FirstName { get; private set; }

  /// &lt;summary&gt;
  /// This will never be null or empty
  /// &lt;/summary&gt;
  public string LastName { get; private set; }
}
</code></pre>
<p>Now, on the other hand, this means that callers can take on certain guarantees about the class and so contain less &quot;gotcha&quot; code (checking for null values and all that). So this is probably code that would have to be written in one way or another elsewhere. Possibly many times over. So I think it's definitely a win overall, which is why I said it's kind of a non-issue - but still it makes my fingers hurt a bit for that quick blaze of crazy typing. I'm concerned the key motions for ArgumentNullException are so ingrained in my muscle memory that my one day my hands will refuse to type anything else!</p>
<h3>The DeferredElementStore</h3>
<p>Another issue I've come across a few times was highlighted quite nicely by something I was writing the other day; we had some forms that we wanted to generate from xml config files so some of the elements could be added, removed, made optional, compulsory, etc, etc.. It was fairly straight-forward and each element was parsed from the file and described by a corresponding immutable class but there was a problem - some of the elements were related, or rather one might depend on another. A cascading dropdown scenario, basically. So each element needed a way to access the other elements in the form data to read their values and whatnot. But when initialising each element there didn't exist any single object that had awareness of all of the elements since we were still in the process of initialising them! Catch-22, bang!</p>
<p>To work around this I used an object that appear immutable to the element but which would not guarantee to be able to respond to requests for references to other element until the Init phase of the pagecycle (this was in ASP.Net and the process was to parse the config file, build a list of controls that the elements required and then add those controls to a Page all at once - so the Init event for each of those controls would be raised after all of the elements had been initialised and the controls created). This object would contain no data initially and be used just as a reference to pass to the elements during initialisation. When the initialisation of all of the elements was complete, a reference to the list of these elements was passed to this mystery object; our &quot;deferred element store&quot;. And then the elements' controls were added to the Page. So when the element classes requested access to other elements during or after the Init phase, the data was available!</p>
<p>Now, this clearly immutable data - it's more like some sort of single-setting, delayed-instantation object.. or something. I'm going to link to Eric Lippert again here since he's pretty much the guru on this sort of thing and since he describes this precise scenario in the following article:</p>
<p><a href="http://blogs.msdn.com/b/ericlippert/archive/2007/11/13/immutability-in-c-part-one-kinds-of-immutability.aspx">http://blogs.msdn.com/b/ericlippert/archive/2007/11/13/immutability-in-c-part-one-kinds-of-immutability.aspx</a></p>
<p>.. I'm not so sure about the phrase &quot;popsicle immutability&quot; but that's basically what I'm talking about! There's a slight variation that I've used here (which actually is talked about in the comments for that article) where the real &quot;element store&quot; class is not passed to the elements during initialisation, only a wrapper around it. This ensures that the element classes couldn't mess with the state, only the form parser could:</p>
<pre><code>public interface IDeferredElementStore
{
  AbstractFormElement TryToGetElement(string id);
}

public class DeferredElementStore : IDeferredElementStore
{
  private NonNullImmutableList&lt;AbstractFormElement&gt; _elements;
  public DeferredElementStore()
  {
    _elements = new NonNullImmutableList&lt;AbstractFormElement&gt;();
  }
  public void StoreElementData(NonNullImmutableList&lt;AbstractFormElement&gt; elements)
  {
    if (elements == null)
      throw new ArgumentNullException(&quot;elements&quot;);
    _elements = elements;
  }
  public AbstractFormElement TryToGetElement(string id)
  {
    var element = _elements.FirstOrDefault(e.Id = id);
    if (element == null)
      throw new ArgumentException(&quot;Invalid Id&quot;);
    return element;
  }
}

public class ReadOnlyDeferredElementStore : IDeferredElementStore
{
  private IDeferredElementStore _elementStore;
  public ReadOnlyDeferredElementStore(IDeferredElementStore elementStore)
  {
    if (elementStore == null)
      throw new ArgumentNullException(&quot;elementStore&quot;);
    _elementStore = elementStore;
  }
  public AbstractFormElement TryToGetElement(string id)
  {
    return _elementStore.TryToGetElement(id);
  }
}
</code></pre>
<p>.. and the element generation code could look something like:</p>
<pre><code>var elements = new List&lt;AbstractFormElement&gt;();
var elementStore = new DeferredElementStore();
var elementStoreReadOnly = new ReadOnlyDeferredElementStore(elementStore);
elements.Add(new FreeTextElement(.., elementStoreReadOnly, ..));
elements.Add(new DropDownElement(.., elementStoreReadOnly, ..));
elementStore.StoreElementData(new NonNullImmutableList&lt;AbstractFormElement&gt;(elements));
foreach (var element in elements)
{
  foreach (var control in element.Controls)
    this.Controls.Add(control);
}
</code></pre>
<p>This could just as well be used if there are circular references between classes. I suppose then you'd have to have a container to handle both objects being instantiated and pass a read-only wrapper of this container to both classes, then push references to those instances into the container.</p>
<p>This isn't quite the same as the &quot;obervational immutability&quot; described in that article, but I feel I've got an article about dynamic factory classes coming on which will touch on that!</p>
<h3>Still loving it</h3>
<p>All in all, I'm still definitely a big fan of this immutability lark and am still convinced it makes the code easier to deal with overall. I was reading something earlier that I know can't find so I'll have to paraphrase - they were saying that when you're trying to get to grips with existing code, the less you have to keep in your head about what's going on at any time, the easier it is. This is hardly news but it was used in the context of the advantages of immutable data; that if you have references that just <em>are</em> and aren't going to undergo all sorts of states changes, there's much fewer potential interactions you have to deal with mentally. And that means it should be easier to deal with!</p>
<p class="PostTime">Posted at 19:00</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/using-roslyn-to-identify-unused-and-undeclared-variables-in-vbscript-wsc-components">Using Roslyn to identify unused and undeclared variables in VBScript WSC components</a></li><li><a href="/writing-a-brackets-extension-in-typescript-in-brackets">Writing a Brackets extension in TypeScript, in Brackets</a></li><li><a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired &quot;with&quot; updates for immutable classes in C#</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/problems-in-immutabilityland#disqus_thread" data-disqus-identifier="2">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">14 March 2011</p><h2><a id="i-love-immutable-data" href="/i-love-immutable-data">I love Immutable Data</a></h2>
<p>I love immutable data. There, I said it. I think over the last couple of years a few major factors have had the most influence in leading me to this point -</p>
<ul>
<li>I've been driven mad by dealing with code full of complicated object models with no indication which properties are required, which are optional, which go together, which are mutually exclusive, etc..</li>
<li>I was working on a store of data that would be read from and written to by multiple threads and the initial implementation had a naive lock-on-every-interaction approach when it seemed like we should be able to make the reads work without locking (especially since reads were massively more common than writes)</li>
<li>I've been working largely on Tourism websites (and all the related backend services) for a few years now and most of the data feels like it's read-only, though having thought about it I'm not sure if I'd change my mind if I was doing CRUD day-in, day-out instead</li>
</ul>
<p>The first point could really be addressed in all sorts of ways - the code's all a bit wishy-washy and poorly defined and nobody seems to know which fields are for what in the example I'm thinking of. But when I think of immutable types I instinctively think of classes whose values are set once through a constructor (though there are other variations that can be used) and then that instance is &quot;locked&quot; such that we know its state will never change - and that constructor will have ensured that this state is valid. If the classes in point were all written in this way then never again (hopefully!) would there be concerns regarding the validity of the states of the objects, they must have been valid in order to be instantiated and immutability means they can't have changed since!</p>
<p>While we're doing some sort of validation on the constructor arguments I think it also encourages you to think about the various states that can exist - eg.</p>
<pre><code>public class Employee
{
  public string Title { get; set; }
  public string FirstName { get; set; }
  public string LastName { get; set; }
  public string[] Roles { get; set; }
}
</code></pre>
<p>This is the sort of thing that's found all over the place - especially across webservice interfaces. Assume that we have the requirements that Title, FirstName and LastName <em>all</em> have values and that all Employees have zero or more Roles. I think describing the requirements in constructor validation and then some liberal commenting ends up in nicer code:</p>
<pre><code>public class Employee
{
  public Employee(Name name, DefinedStringList roles)
  {
    if (name == null)
      throw new ArgumentNullException(&quot;name&quot;);
    if (roles == null)
      throw new ArgumentNullException(&quot;roles&quot;);

    Name = name;
    Roles = roles;
  }

  /// &lt;summary&gt;
  /// This will never be null
  /// &lt;/summary&gt;
  public Name Name { get; private set; }

  /// &lt;summary&gt;
  /// This will never be null
  /// &lt;/summary&gt;
  public DefinedStringList Roles { get; private set; }
}

public class Name
{
  public Name(string title, string firstName, string lastName)
  {
    if ((title ?? &quot;&quot;).Trim() == &quot;&quot;)
      throw new ArgumentException(&quot;Null/empty title specified&quot;);
    if ((firstName ?? &quot;&quot;).Trim() == &quot;&quot;)
      throw new ArgumentException(&quot;Null/empty firstName specified&quot;);
    if ((lastName ?? &quot;&quot;).Trim() == &quot;&quot;)
      throw new ArgumentException(&quot;Null/empty lastName specified&quot;);

    Title = title;
    FirstName = firstName;
    LastName = lastName;
  }

  /// &lt;summary&gt;
  /// This will never be null or empty
  /// &lt;/summary&gt;
  public string Title { get; private set; }

  /// &lt;summary&gt;
  /// This will never be null or empty
  /// &lt;/summary&gt;
  public string FirstName { get; private set; }

  /// &lt;summary&gt;
  /// This will never be null or empty
  /// &lt;/summary&gt;
  public string LastName { get; private set; }
}
</code></pre>
<p>Except - wow! - the amount of code seems to have ballooned and I've not even included the &quot;DefinedStringList&quot; class! (Well, not here at least - it's down the bottom of the post).</p>
<p>But what we <em>do</em> have now will be instances of Employee that are always in a known good state and we can safely retrieve employee.Name.FirstName without first ensuring that Name is not null. We also know that Employees that have not been assigned roles will have a Roles instance that declares a Count of zero rather than wondering if it will be that or whether there will be a null Roles instance. So the upshot should be that there will actually be <em>less</em> code in places where Employee instances are accessed.</p>
<h3>Multithreaded access</h3>
<p>Now, to recreate a really trivial version of the multithreaded datastore I mentioned earlier, imagine we have a local store of Employees that is being written to and read from - eg.</p>
<pre><code>public class EmployeeStore
{
  private List&lt;Employee&gt; _data = new List&lt;Employee&gt;();

  public IEnumerable&lt;Employee&gt; GetAll()
  {
    lock (_data)
    {
      return _data.AsReadOnly();
    }
  }

  public void Add(Employee employeeToAdd)
  {
    if (employeeToAdd == null)
      throw new ArgumentNullException(&quot;employeeToAdd&quot;);

    lock (_data)
    {
      _data.Add(employeeToAdd);
    }
  }
}
</code></pre>
<p>We'll ignore any concept or deleting or updating for now. Since we don't know how many threads are at work in this scenario, or who's doing what, we lock the internal data at each read or write. We're also returning the data as an IEnumerable and using List's .AsReadOnly method in an optimistic attempt to keep the internal data from being manipulated externally after we return it. In fact, in the example I had, the data was actually (deep-)cloned before returning to ensure that no caller could manipulate any data inside the data store.</p>
<p>If we're working with immutable data types and have access to an immutable list then we can change this without much effort to require no locks for reading and we can implicitly forget any AsReadOnly or cloning malarkey if we have an immutable list to work with as well. An immutable list works by returning new instances when methods that would otherwise effect its contents are called - so if a list has 3 items and we call Add then the existing list is unchanged and the Add method returns a <em>new</em> list with all 4 items. Example code is at the end of this post, along with a DefinedStringList implementation, as mentioned earlier.</p>
<pre><code>public class EmployeeStoreWithoutReadLocking
{
  private object _writeLock = new object();
  private ImmutableList&lt;Employee&gt; _data = new ImmutableList&lt;Employee&gt;();

  public ImmutableList&lt;Employee&gt; GetAll()
  {
    return _data;
  }

  public void Add(Employee employeeToAdd)
  {
    if (employeeToAdd == null)
      throw new ArgumentNullException(&quot;employeeToAdd&quot;);

    lock (_writeLock)
    {
      _data = _data.Add(employeeToAdd);
    }
  }
}
</code></pre>
<p>Easy! Of course this relies upon the Employee class being immutable (which must cover all of its properties' types as well). Now we're not just reaping the benefits in state validity but we've got more performant threaded code (again, my example was heavy on reads and light). In a lot of cases immutability such as this can make areas of multi-threaded code much easier to write and maintain.</p>
<p>I think in this case I extended the ImmutableList to a NonNullImmutableList which had validation to ensure it would never contain any null references. Similar to how the DefinedStringList will ensure it has no null or empty values. Another layer of comforting behaviour guarantee so that callers don't have to worry about nulls. It makes me feel warm and fuzzy.</p>
<h3>Undo!</h3>
<p>In most scenarios it seems I've been working with recently, classes such as Employee <em>would</em> be instantiated just the once and then not changed unless another query was executed that returned a new set of Employee data. But feasibly we may want to alter the Employee class such that it is &quot;editable&quot; in the same way that the DefinedStringList that we're talking about is - you can call methods that return a new instance of the class with the alteration made, leaving the original reference unaltered.</p>
<pre><code>public class Employee
{
  public Employee(Name name, DefinedStringList roles)
  {
    if (name == null)
      throw new ArgumentNullException(&quot;name&quot;);
    if (roles == null)
      throw new ArgumentNullException(&quot;roles&quot;);

    Name = name;
    Roles = roles;
  }

  /// &lt;summary&gt;
  /// This will never be null
  /// &lt;/summary&gt;
  public Name Name { get; private set; }

  /// &lt;summary&gt;
  /// This will never be null
  /// &lt;/summary&gt;
  public DefinedStringList Roles { get; private set; }

  public Employee UpdateName(Name name)
  {
    // This will throw an exception for a null name reference
    return new Employee(name, _roles);
  }

  public Employee AddRole(string role)
  {
    // This will throw an exception for a null or empty role value
    return new Employee(_name, _roles.Add(role));
  }

  public Employee RemoveRole(string role)
  {
    return new Employee(_name, _roles.Remove(role));
  }
}
</code></pre>
<p>Here the name can be overwritten and roles can be added or removed. What's interesting about this approach is that returning new instances each time means you could persists a chain of changes - an undo history or sorts! I must admit that I've never taken advantage of this in any way, but it's often struck me that it could be useful in some situations..</p>
<h3>Some more views</h3>
<p>While writing this post, I did a bit of research to try and make sure I wasn't say anything either too done-to-death or too stupid and the following links are articles I like, largely because they agree with me! :)</p>
<blockquote>
<p>Immutable data structures are the way of the future in C#</p>
</blockquote>
<p><a href="http://blogs.msdn.com/b/ericlippert/archive/2007/10/04/path-finding-using-a-in-c-3-0-part-two.aspx">http://blogs.msdn.com/b/ericlippert/archive/2007/10/04/path-finding-using-a-in-c-3-0-part-two.aspx</a></p>
<blockquote>
<p>One of reasons why immutable types can be faster is that they are optimized due to having dealt with memory management in years past</p>
</blockquote>
<p><a href="http://en.csharp-online.net/CSharp_Coding_Solutions%E2%80%94Immutable_Types_Are_Scalable_Types">http://en.csharp-online.net/CSharp_Coding_Solutions-Immutable_Types_Are_Scalable_Types</a></p>
<p>However there's also this one:</p>
<blockquote>
<p>The &quot;verbose constructor&quot; is itself a good candidate for an anti-pattern for the following reasons:</p>
</blockquote>
<p><a href="http://blog.dezfowler.com/2009/05/always-valid-entity-anti-pattern.html">http://blog.dezfowler.com/2009/05/always-valid-entity-anti-pattern.html</a></p>
<p>I've worked with Derek before so although I read that article two or three times and couldn't agree with it, I didn't give up 'cos I know he's a bright guy. And it finally broke for me what I think he meant when I read the comments on that piece - there's only four and it's the last one that made it stick for me. Partly because someone I work with <em>now</em> has a similar view, I think. The way I see things working together is that the validation in these &quot;verbose constructors&quot; is a last line of defense to ensure that the object's state is ensured to be valid and is <em>not</em> business logic where the intention is to throw a load of possibly-valid values at it and see what sticks. There should be a nice validation layer between the UI and these constructors that only allows through allowable state and handles the aggregation of errors where required. The exceptions in the constructor should still be just that; exceptions, not the norm for invalid UI input.</p>
<p>But in summary, I'm still all for these &quot;verbose constructors&quot; - as this final defense that allows us not to worry about instances of these immutable classes - if they exist, then they're valid. And I like that.</p>
<h3>An immutable list (and the DefinedStringList class)</h3>
<p>Since this code is a bit long to jam in the middle of the article, here it is in all its glory:</p>
<pre><code>public class ImmutableList&lt;T&gt; : IEnumerable&lt;T&gt;
{
  private List&lt;T&gt; values;
  private IValueValidator&lt;T&gt; validator;
  public ImmutableList(IEnumerable&lt;T&gt; values, IValueValidator&lt;T&gt; validator)
  {
    if (values == null)
      throw new ArgumentNullException(&quot;values&quot;);

    var valuesList = new List&lt;T&gt;();
    foreach (var value in values)
    {
      if (validator != null)
      {
        try { validator.EnsureValid(value); }
        catch (Exception e)
        {
          throw new ArgumentException(&quot;Invalid reference encountered in values&quot;, e);
        }
      }
      valuesList.Add(value);
    }
    this.values = valuesList;
    this.validator = validator;
  }
  public ImmutableList(IEnumerable&lt;T&gt; values) : this(values, null) { }
  public ImmutableList(IValueValidator&lt;T&gt; validator, params T[] values)
    : this((IEnumerable&lt;T&gt;)values, validator) { }
  public ImmutableList(params T[] values) : this(null, values) { }

  public T this[int index]
  {
    get
    {
      if ((index &lt; 0) || (index &gt;= this.values.Count))
        throw new ArgumentOutOfRangeException(&quot;index&quot;);
      return this.values[index];
    }
  }

  public int Count
  {
    get { return this.values.Count; }
  }

  public bool Contains(T value)
  {
    return this.values.Contains(value);
  }

  public ImmutableList&lt;T&gt; Add(T value)
  {
    if (this.validator != null)
    {
      try { this.validator.EnsureValid(value); }
      catch (Exception e)
      {
        throw new ArgumentException(&quot;Invalid value&quot;, e);
      }
    }
    var valuesNew = new List&lt;T&gt;();
    valuesNew.AddRange(this.values);
    valuesNew.Add(value);
    return new ImmutableList&lt;T&gt;()
    {
      values = valuesNew,
      validator = this.validator
    };
  }

  /// &lt;summary&gt;
  /// Removes the first occurrence of a specific object
  /// &lt;/summary&gt;
  public ImmutableList&lt;T&gt; Remove(T value)
  {
    var valuesNew = new List&lt;T&gt;();
    valuesNew.AddRange(this.values);
    valuesNew.Remove(value);
    return new ImmutableList&lt;T&gt;()
    {
      values = valuesNew,
      validator = this.validator
    };
  }

  /// &lt;summary&gt;
  /// This is just a convenience method so that derived types can call Add, Remove, etc.. and return
  /// instances of themselves without having to pass that data back through a constructor which will
  /// check each value against the validator even though we already know they're valid! Note: This
  /// can only be used by derived classes that don't have any new requirements of any type - we're
  /// setting only the values and validator references here!
  /// &lt;/summary&gt;
  protected static U toDerivedClass&lt;U&gt;(ImmutableList&lt;T&gt; list) where U : ImmutableList&lt;T&gt;, new()
  {
    if (list == null)
      throw new ArgumentNullException(&quot;list&quot;);

    // Use same trick as above methods to cheat - we're changing the state of the object after
    // instantiation, but after returning from
    // this method it can be considered immutable
    return new U()
    {
      values = list.values,
      validator = list.validator
    };
  }

  public IEnumerator&lt;T&gt; GetEnumerator()
  {
    return this.values.GetEnumerator();
  }

  IEnumerator IEnumerable.GetEnumerator()
  {
    return GetEnumerator();
  }
}

public interface IValueValidator&lt;T&gt;
{
  /// &lt;summary&gt;
  /// This will throw an exception for a value that does pass validation requirements
  /// &lt;/summary&gt;
  void EnsureValid(T value);
}
</code></pre>
<p>That's all the setup to enable a DefinedStringList class, which we can with:</p>
<pre><code>public class DefinedStringList : ImmutableList&lt;string&gt;
{
  public DefinedStringList(IEnumerable&lt;string&gt; values)
    : base(values, new NonNullOrEmptyWrappingValueValidator()) { }
  public DefinedStringList(params string[] values) : this((IEnumerable&lt;string&gt;)values) { }
  public DefinedStringList() : this(new string[0]) { }

  public new DefinedStringList Add(string value)
  {
    return toDerivedClass&lt;DefinedStringList&gt;(base.Add(value));
  }
  public new DefinedStringList Remove(string value)
  {
    return toDerivedClass&lt;DefinedStringList&gt;(base.Remove(value));
  }

  private class NonNullOrEmptyWrappingValueValidator : IValueValidator&lt;string&gt;
  {
    public void EnsureValid(string value)
    {
      if ((value ?? &quot;&quot;).Trim() == null)
        throw new ArgumentException(&quot;Null/empty value specified&quot;);
    }
  }
}
</code></pre>
<p>These are actually cut-down versions of classes I've got in one of my projects that also includes AddRange, Insert, RemoveAt, Contains(T value, IEqualityComparer<t> comparer), etc.. but this is more than enough to get the gist. At some point I may look into that GitHub thing..</t></p>
<h3>Immutability purity</h3>
<p>A final side note(*) - you might notice that internally the ImmutableList <em>does</em> actually participate in some mutability! When calling the Add method, we validate the new value (if required) and then create a new instance of the class with no data and <em>then</em> assign its internal &quot;values&quot; and &quot;validator&quot; references, meaning we sidestep the looping of all the data in the constructor which is unnecessary since we know the values are all valid, that's part of the point of the class! BTW, it feels like a bit of a trick updating these private references after creating the new instances and it's only possible because we've just created the instance ourself and the new object is an instance of the class that is performing the work. I don't know if there's a phrase to describe this method and I was a bit surprised to discover it could be done since it has a feeling of breaking the &quot;private&quot; member contract!</p>
<p>* I don't want to go into <em>too</em> much detail since I want to talk about this further another time!</p>
<p><strong>Update (26th November 2012):</strong> A re-visit of this principle can be seen in the post <a href="/persistent-immutable-lists">Persistent Immutable Lists</a> which has an alternate implementation of the immutable list with improved performance but all of the immutability-based safety!</p>
<p class="PostTime">Posted at 20:14</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired &quot;with&quot; updates for immutable classes in C#</a></li><li><a href="/persistent-immutable-lists-extended">Persistent Immutable Lists - Extended</a></li><li><a href="/persistent-immutable-lists">Persistent Immutable Lists</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/i-love-immutable-data#disqus_thread" data-disqus-identifier="1">Comments</a>
            </p>
    </div>

        <script type="text/javascript">
            (function () {
                var s = document.createElement("script");
                s.type = "text/javascript";
                s.async = true;
                s.src = "https://" + disqus_shortname + ".disqus.com/count.js";
                (document.getElementsByTagName("HEAD")[0] || document.getElementsByTagName("BODY")[0]).appendChild(s);
            }());
        </script>

				<div class="Footer">
					 Productive Rage 2011 - 2022
				</div>
			</div>

			<div class="SideBar">
				<div class="About">
					<h2>About</h2>
					<p>Dan is a big geek who likes making stuff with computers! He can be quite outspoken so clearly needs a blog :)</p>
					<p>In the last few minutes he seems to have taken to referring to himself in the third person. He's quite enjoying it.</p>
					<p><a href="mailto:dangger36@gmail.com" class="Email">dangger36@gmail.com</a></p>
				</div>
				<div class="Search">
<form action="/Search" autocomplete="off" class="Search" method="get">						<div>
							<label class="SearchField">
								<span class="text">Site Search</span>
								<input type="text" class="SiteSearch" name="term" value="" />
							</label>
							<input type="submit" class="SiteSearchSubmit" value="Search" />
						</div>
</form>				</div>
				<div class="Recent"><h2>Recent Posts</h2><ul><li><a href="/so-what-is-machine-learning-nocodeintro">So.. what is machine learning? (#NoCodeIntro)</a></li><li><a href="/parallelising-linq-work-in-c-sharp">Parallelising (LINQ) work in C#</a></li><li><a href="/automating-suggested-related-posts-links-for-my-blog-posts-part-2">Automating &quot;suggested / related posts&quot; links for my blog posts - Part 2</a></li><li><a href="/automating-suggested-related-posts-links-for-my-blog-posts">Automating &quot;suggested / related posts&quot; links for my blog posts</a></li><li><a href="/language-detection-and-wordsinsentence-classification-in-c-sharp">Language detection and words-in-sentence classification in C#</a></li></ul><div class="RSSFeedLink"><a href="https://www.productiverage.com/feed">RSS Feed</a></div></div>
				<div class="Featured"><h2>Highlights</h2><ul><li><a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face (finding faces in photos using C# and Accord.NET)</a></li><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/translating-vbscript-into-c-sharp">Translating VBScript into C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div>
				<div class="History"><h2>Archives</h2><ul><li><a href="/Archive/2/2022">February 2022 (1)</a></li><li><a href="/Archive/8/2021">August 2021 (1)</a></li><li><a href="/Archive/4/2021">April 2021 (2)</a></li><li><a href="/Archive/3/2021">March 2021 (1)</a></li><li><a href="/Archive/8/2020">August 2020 (3)</a></li><li><a href="/Archive/7/2019">July 2019 (2)</a></li><li><a href="/Archive/9/2018">September 2018 (1)</a></li><li><a href="/Archive/4/2018">April 2018 (1)</a></li><li><a href="/Archive/3/2018">March 2018 (1)</a></li><li><a href="/Archive/7/2017">July 2017 (1)</a></li><li><a href="/Archive/6/2017">June 2017 (1)</a></li><li><a href="/Archive/2/2017">February 2017 (1)</a></li><li><a href="/Archive/11/2016">November 2016 (1)</a></li><li><a href="/Archive/9/2016">September 2016 (2)</a></li><li><a href="/Archive/8/2016">August 2016 (1)</a></li><li><a href="/Archive/7/2016">July 2016 (1)</a></li><li><a href="/Archive/6/2016">June 2016 (1)</a></li><li><a href="/Archive/5/2016">May 2016 (3)</a></li><li><a href="/Archive/3/2016">March 2016 (3)</a></li><li><a href="/Archive/2/2016">February 2016 (2)</a></li><li><a href="/Archive/12/2015">December 2015 (1)</a></li><li><a href="/Archive/11/2015">November 2015 (2)</a></li><li><a href="/Archive/8/2015">August 2015 (3)</a></li><li><a href="/Archive/7/2015">July 2015 (1)</a></li><li><a href="/Archive/6/2015">June 2015 (1)</a></li><li><a href="/Archive/5/2015">May 2015 (2)</a></li><li><a href="/Archive/4/2015">April 2015 (1)</a></li><li><a href="/Archive/3/2015">March 2015 (1)</a></li><li><a href="/Archive/1/2015">January 2015 (2)</a></li><li><a href="/Archive/12/2014">December 2014 (1)</a></li><li><a href="/Archive/11/2014">November 2014 (1)</a></li><li><a href="/Archive/10/2014">October 2014 (2)</a></li><li><a href="/Archive/9/2014">September 2014 (2)</a></li><li><a href="/Archive/8/2014">August 2014 (1)</a></li><li><a href="/Archive/7/2014">July 2014 (1)</a></li><li><a href="/Archive/6/2014">June 2014 (1)</a></li><li><a href="/Archive/5/2014">May 2014 (2)</a></li><li><a href="/Archive/2/2014">February 2014 (1)</a></li><li><a href="/Archive/1/2014">January 2014 (1)</a></li><li><a href="/Archive/12/2013">December 2013 (1)</a></li><li><a href="/Archive/11/2013">November 2013 (1)</a></li><li><a href="/Archive/10/2013">October 2013 (1)</a></li><li><a href="/Archive/8/2013">August 2013 (3)</a></li><li><a href="/Archive/7/2013">July 2013 (3)</a></li><li><a href="/Archive/6/2013">June 2013 (1)</a></li><li><a href="/Archive/5/2013">May 2013 (2)</a></li><li><a href="/Archive/4/2013">April 2013 (1)</a></li><li><a href="/Archive/3/2013">March 2013 (8)</a></li><li><a href="/Archive/2/2013">February 2013 (2)</a></li><li><a href="/Archive/1/2013">January 2013 (2)</a></li><li><a href="/Archive/12/2012">December 2012 (3)</a></li><li><a href="/Archive/11/2012">November 2012 (4)</a></li><li><a href="/Archive/9/2012">September 2012 (1)</a></li><li><a href="/Archive/8/2012">August 2012 (1)</a></li><li><a href="/Archive/7/2012">July 2012 (3)</a></li><li><a href="/Archive/6/2012">June 2012 (3)</a></li><li><a href="/Archive/5/2012">May 2012 (2)</a></li><li><a href="/Archive/2/2012">February 2012 (3)</a></li><li><a href="/Archive/1/2012">January 2012 (4)</a></li><li><a href="/Archive/12/2011">December 2011 (7)</a></li><li><a href="/Archive/8/2011">August 2011 (2)</a></li><li><a href="/Archive/7/2011">July 2011 (1)</a></li><li><a href="/Archive/5/2011">May 2011 (1)</a></li><li><a href="/Archive/4/2011">April 2011 (2)</a></li><li><a href="/Archive/3/2011">March 2011 (3)</a></li></ul><div class="EveryTitle"><a href="/Archive/All">Every Post Title</a></div></div>
			</div>

		</div>
	</div>

	<script type="text/javascript" src="/Scripts/autocomplete.js"></script>
	<script type="text/javascript" src="/Scripts/prettify.js"></script>
	<script type="text/javascript" src="/Scripts/Site.js"></script>
	<script type="text/javascript" src="/Scripts/IndexSearchGenerator.js"></script>
	<script type="text/javascript" src="/Scripts/SearchTermHighlighter.js"></script>
	<script type="text/javascript" src="/Scripts/SearchPage.js"></script>
	<script type="text/javascript" src="/Scripts/LZString.js"></script>

</body>
</html>
