<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Productive Rage - Bridge</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta name="theme-color" content="#393939" />
	<link rel="stylesheet" type="text/css" media="all" href="/Content/Styles.css" />
	<link rel="stylesheet" type="text/css" media="print" href="/Content/PrintOverrides.css" />
	<meta name="robots" content="noindex, follow" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.productiverage.com/feed" />
	<script type="text/javascript">
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

		ga('create', "UA-32312857-1", { 'storage': 'none' });
		ga('send', 'pageview');
	</script>
    <meta name="description" content="Archive for tag: Bridge" />
</head>

<body>

	<div class="Header">
		<div class="HeaderContent">
			<h1>
				<a href="/">Productive Rage</a>
			</h1>
			<span class="Tagline">Dan's techie ramblings</span>
		</div>
	</div>

	<div class="WrapperOuter">
		<div class="Wrapper">
			<div class="Main HasSideBar">
				

        <script type="text/javascript">
            var disqus_shortname = "productiverage";
            document.addEventListener(
                "DOMContentLoaded",
                function () {
                    var commentsLinks = document.querySelectorAll("div.Content p.Comments");
                    for (var i = 0; i < commentsLinks.length; i++) {
                        commentsLinks[i].style.display = "block";
                    }
                }
            );
        </script>

    <div class="Content ArchiveByTag">
        <p class="PostDate">4 August 2020</p><h2><a id="removing-all-assembly-names-in-jsonnet-typenamehandling-output" href="/removing-all-assembly-names-in-jsonnet-typenamehandling-output">Removing ALL assembly names in Json.NET TypeNameHandling output</a></h2>
<p>In some cases, it may be desirable to include type name information in <a href="https://www.newtonsoft.com/json">Json.NET</a> output but for those type names to not include assembly names.</p>
<p>In my case it's because I have a <a href="https://dev.to/rionmonster/sharing-is-caring-using-shared-projects-in-aspnet-e17">Shared Project</a> that contains classes that I want to appear in my .NET Core C# server code and in my <a href="https://bridge.net/">Bridge.NET</a> client code and this results in the class names existing in assemblies with different names (but there are also other people with their own cases, such as <a href="https://stackoverflow.com/questions/8039910/how-do-i-omit-the-assembly-name-from-the-type-name-while-serializing-and-deseria">How do I omit the assembly name from the type name while serializing and deserializing in JSON.Net?</a>.</p>
<p>Json.NET has support for customising how the type names are emitted and there is an answer in the Stack Overflow question that I linked just above that points to an <a href="http://james.newtonking.com/archive/2011/11/19/json-net-4-0-release-4-bug-fixes">article</a> written by the Json.NET author illustrating how to do it. Essentially, you create a custom serialization binder that looks a bit like this:</p>
<pre><code>public sealed class TypeNameAssemblyExcludingSerializationBinder : ISerializationBinder
{
    public static TypeNameAssemblyExcludingSerializationBinder Instance { get; }
        = new TypeNameAssemblyExcludingSerializationBinder();

    private TypeNameAssemblyExcludingSerializationBinder() { }

    public void BindToName(Type serializedType, out string assemblyName, out string typeName)
    {
        assemblyName = null;
        typeName = serializedType.FullName;
    }

    public Type BindToType(string assemblyName, string typeName)
    {
        // Note: Some additional work may be required here if the assembly name has been removed
        // and you are not loading a type from the current assembly or one of the core libraries
        return Type.GetType(typeName);
    }
}
</code></pre>
<p>Then you serialise your content something like this:</p>
<pre><code>var json = JsonConvert.SerializeObject(
    new ExampleClass(123, &quot;Test&quot;),
    new JsonSerializerSettings
    {
        Formatting = Formatting.Indented,
        TypeNameHandling = TypeNameHandling.All,
        SerializationBinder = TypeNameAssemblyExcludingSerializationBinder.Instance
    }
);
</code></pre>
<p>If the <strong>ExampleClass</strong> looked like this:</p>
<pre><code>public sealed class ExampleClass
{
    public ExampleClass(int key, string name)
    {
        Key = key;
        Name = name;
    }
    public int Key { get; }
    public string Name { get; }
}
</code></pre>
<p>.. and was in a namespace called &quot;Tester&quot; then the resulting JSON would look like this:</p>
<pre><code>{
  &quot;$type&quot;: &quot;Tester.ExampleClass&quot;,
  &quot;Key&quot;: 123,
  &quot;Name&quot;: &quot;Test&quot;
}
</code></pre>
<p>To make the difference clear, if the custom serialisation binder had not been used (and if the containing assembly was also called &quot;Tester&quot;) then the JSON would have looked like this:</p>
<pre><code>{
  &quot;$type&quot;: &quot;Tester.ExampleClass, Tester&quot;,
  &quot;Key&quot;: 123,
  &quot;Name&quot;: &quot;Test&quot;
}
</code></pre>
<p>So.. problem solved!</p>
<p>Yes?</p>
<p>No.</p>
<h3>ISerializationBinder is not applied to generic type parameters</h3>
<p>While everything was hunkydory in the example above, there are cases where it isn't. For example, if we wanted to serialise a <em>list</em> of <strong>ExampleClass</strong> instances then we'd have code like this:</p>
<pre><code>var json = JsonConvert.SerializeObject(
    new List&lt;ExampleClass&gt; { new ExampleClass(123, &quot;Test&quot;) },
    new JsonSerializerSettings
    {
        Formatting = Formatting.Indented,
        TypeNameHandling = TypeNameHandling.All,
        SerializationBinder = TypeNameAssemblyExcludingSerializationBinder.Instance
    }
);
</code></pre>
<p>.. and the resulting JSON would look like this:</p>
<pre><code>{
  &quot;$type&quot;: &quot;System.Collections.Generic.List`1[[Tester.ExampleClass, Tester]]&quot;,
  &quot;$values&quot;: [
    {
      &quot;$type&quot;: &quot;Tester.ExampleClass&quot;,
      &quot;Key&quot;: 123,
      &quot;Name&quot;: &quot;Test&quot;
    }
  ]
}
</code></pre>
<p>Without the custom serialisation binder, it would have looked like this:</p>
<pre><code>{
  &quot;$type&quot;: &quot;System.Collections.Generic.List`1[[Tester.ExampleClass, Tester]], System.Private.CoreLib&quot;,
  &quot;$values&quot;: [
    {
      &quot;$type&quot;: &quot;Tester.ExampleClass, Tester&quot;,
      &quot;Key&quot;: 123,
      &quot;Name&quot;: &quot;Test&quot;
    }
  ]
}
</code></pre>
<p>.. and so we've successfully removed <em>some</em> of the assembly names as there is no mention of &quot;System.Private.CoreLib&quot; in the List's type and the $type string for the <strong>ExampleClass</strong> instance no longer mentions the &quot;Tester&quot; assembly name but the generic type of the List <em>does</em> mention the &quot;Tester&quot; assembly name and we were trying to prevent assembly names from appearing in the type data!</p>
<p>I've had a good Google around this and there doesn't seem to be a definitive answer anywhere and I had a need for one, so I've put together a solution that does what I need. There is an answer to a similar(ish) stack overflow question <a href="https://stackoverflow.com/a/19927484/3813189">here</a> but it ends with a disclaimer that the regex provided would need tweaking to support nested types and <strong>a)</strong> I definitely wanted to support nested generic type parameters (eg. a Dictionary that maps string keys to List-of-int values) and <strong>b)</strong> regexes and me are not the best of friends - hence my going about it my own way!</p>
<pre><code>public sealed class TypeNameAssemblyExcludingSerializationBinder : ISerializationBinder
{
    public static TypeNameAssemblyExcludingSerializationBinder Instance { get; }
        = new TypeNameAssemblyExcludingSerializationBinder();
    private TypeNameAssemblyExcludingSerializationBinder() { }

    public void BindToName(Type serializedType, out string assemblyName, out string typeName)
    {
        // Note: Setting the assemblyName to null here will only remove it from the main type itself -
        // it won't remove it from any types specified as generic type parameters (that's what the
        // RemoveAssemblyNames method is needed for)
        assemblyName = null;
        typeName = RemoveAssemblyNames(serializedType.FullName);
    }

    public Type BindToType(string assemblyName, string typeName)
    {
        // Note: Some additional work may be required here if the assembly name has been removed
        // and you are not loading a type from the current assembly or one of the core libraries
        return Type.GetType(typeName);
    }

    private static string RemoveAssemblyNames(string typeName)
    {
        var index = 0;
        var content = new StringBuilder();
        RecusivelyRemoveAssemblyNames();
        return content.ToString();

        void RecusivelyRemoveAssemblyNames()
        {
            // If we started inside a type name - eg.
            //
            //   &quot;System.Int32, System.Private.CoreLib&quot;
            //
            // .. then we want to look for the comma that separates the type name from the assembly
            // information and ignore that content. If we started inside nested generic type content
            // - eg.
            //
            //  &quot;[System.Int32, System.Private.CoreLib], [System.String, System.Private.CoreLib]&quot;
            //
            // .. then we do NOT want to start ignoring content after any commas encountered. So
            // it's important to know here which case we're in.
            var insideTypeName = typeName[index] != '[';

            var ignoreContent = false;
            while (index &lt; typeName.Length)
            {
                var c = typeName[index];
                index++;

                if (insideTypeName &amp;&amp; (c == ','))
                {
                    ignoreContent = true;
                    continue;
                }

                if (!ignoreContent)
                    content.Append(c);

                if (c == '[')
                    RecusivelyRemoveAssemblyNames();
                else if (c == ']')
                {
                    if (ignoreContent)
                    {
                        // If we encountered a comma that indicated that we were about to start
                        // an assembly name then we'll have stopped adding content to the string
                        // builder but we don't want to lose this closing brace, so explicitly
                        // add it in if that's the case
                        content.Append(c);
                    }
                    break;
                }
            }
        }
    }
}
</code></pre>
<h3>A note about resolving types from type names (without assemblies)</h3>
<p>In .NET, the &quot;Type.GetType&quot; method will return null if it is given a type name that does not correspond to a type that exists in either the current assembly or in one of the core .NET libraries. In Bridge.NET, it doesn't appear that they maintained that requirement and I believe that all types are available, even if an assembly name is not specified - but whether it is or isn't, a similar approach could be used in both cases where you use reflection to look at all loaded assemblies and all of their available types and try to map assembly-name-less type names onto one of those. Getting into this would be completely out of the scope of this post and I'm hoping that you already have an idea in mind if you had got to the point where you wanted to remove all assembly names from your type metadata!</p>
<p class="PostTime">Posted at 17:25</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/using-roslyn-code-fixes-to-make-the-frictionless-immutable-objects-in-bridge-even-easier">Using Roslyn code fixes to make the &quot;Friction-less immutable objects in Bridge&quot; even easier</a></li><li><a href="/writing-a-brackets-extension-in-typescript-in-brackets">Writing a Brackets extension in TypeScript, in Brackets</a></li><li><a href="/if-you-can-keep-your-head-when-all-about-you-are-losing-theirs-and-blaming-it-on-vbscript">If you can keep your head when all about you are losing theirs and blaming it on VBScript</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li></ul></div>
            <p class="Comments">
                <a href="/removing-all-assembly-names-in-jsonnet-typenamehandling-output#disqus_thread" data-disqus-identifier="116">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">2 July 2019</p><h2><a id="type-aliases-in-bridgenet-c-sharp" href="/type-aliases-in-bridgenet-c-sharp">Type aliases in Bridge.NET (C#)</a></h2>
<p>Back in 2016, I wrote <a href="/writing-react-apps-using-bridgenet-the-dan-way-part-three">Writing React apps using Bridge.NET - The Dan Way (Part Three)</a> and I talked about trying to tighten up the representation of values in the type system. One of my pet peeves that I talked about was how &quot;no value&quot; is represented in reference types and, in particular, with strings.</p>
<p>As a reminder, I was having a rant about how I hate the uncertainty of wondering &quot;should I expect to get null passed in here / returned from here&quot; and I decided to draw a hard line and say that <strong>no</strong>, in <em>my</em> code I would <em>never</em> expect a reference type to have a null value - instead I would always use the <strong>Optional&lt;T&gt;</strong> struct that I included in my NuGet package <a href="https://github.com/ProductiveRage/Bridge.Immutable">ProductiveRage.Immutable</a>. This allows me to make it clear when a method may return a null value (because its return type would be something like <strong>Optional&lt;PersonDetails&gt;</strong>) and it would allow me to make it clear when a method will and won't accept null arguments (it <em>will</em> if the parameter type is <strong>Optional&lt;T&gt;</strong> and it <em>won't</em> if it's <em>not</em>).</p>
<p>Strings, however, have <em>another</em> &quot;no value&quot; state - when they are blank. If I want to have a method argument whose type indicates &quot;this argument must be a string that is not null AND that is not blank&quot; then we can't communicate that. To address that, my blog post introduced <em>another</em> type; the <strong>NonBlankTrimmedString</strong> -</p>
<pre><code>public class NonBlankTrimmedString
{
    public NonBlankTrimmedString(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException(&quot;Null, blank or whitespace-only value specified&quot;);
        Value = value.Trim();
    }

    /// &lt;summary&gt;
    /// This will never be null, blank or have any leading or trailing whitespace
    /// &lt;/summary&gt;
    public string Value { get; }

    /// &lt;summary&gt;
    /// It's convenient to be able to pass a NonBlankTrimmedString instance as any argument
    /// that requires a string
    /// &lt;/summary&gt;
    public static implicit operator string(NonBlankTrimmedString value)
    {
        if (value == null)
            throw new ArgumentNullException(&quot;value&quot;);
        return value.Value;
    }
}
</code></pre>
<p>This would allow me to have a method that clearly indicates that it needs a string <em>with a real value</em> - eg.</p>
<pre><code>void DoSomething(NonBlankTrimmedString value);
</code></pre>
<p>.. and it could be combined with <strong>Optional&lt;T&gt;</strong> to define a method whose type signature indicates that it will take a string with a real value OR it will accept a &quot;no value&quot; - eg.</p>
<pre><code>void DoSomething(Optional&lt;NonBlankTrimmedString&gt; value);
</code></pre>
<p>This method will <em>not</em> accept a blank string because that's just another state that is not necessary; either you give me a real (non-blank) value or you don't. There is no half-way house of &quot;non-null but still with no value&quot;.</p>
<p>As another example, I might want to write a <a href="https://github.com/ProductiveRage/Bridge.React">Bridge.React</a> component whose <strong>Props</strong> type can optionally take an additional class name to render as part of the component - in which case, I might write the class a bit like this:</p>
<pre><code>public sealed class Props
{
    public Props(
        /* .. other property values, */
        Optional&lt;NonBlankTrimmedString&gt; className = new Optional&lt;NonBlankTrimmedString&gt;())
    {
        // .. other properties set here
        ClassName = className;
    }

    // .. other public properties exposed here

    public Optional&lt;NonBlankTrimmedString&gt; ClassName { get; }
}
</code></pre>
<p>This is all fine and dandy and, pretty much, it just works. If I want to expand this richer type system so that it's used in API requests / responses as well then I can have <strong>Optional&lt;T&gt;</strong> and <strong>NonBlankTrimmedString</strong> types defined in the .NET code that runs on the server as well as in my Bridge project. And if I want to avoid code duplication then I can define the types in a <a href="https://dev.to/rionmonster/sharing-is-caring-using-shared-projects-in-aspnet-e17">Shared Project</a> that is referenced by both the Bridge project and the server API project.</p>
<p>One downside to this approach, though, is that JSON payloads from API calls are going to be larger if I wrap all of my strings in <strong>NonBlankTrimmedString</strong> instances. And there will be more work for <a href="https://github.com/bridgedotnet/Bridge.Newtonsoft.Json">Bridge's version of Newtonsoft Json.NET</a> to do because it has to parse more data and it has to deserialise more instances of types; for every string, instead of just deserialising a value into a string, it needs to deserialise that string value <em>and then</em> create an instance of a <strong>NonBlankTrimmedString</strong> to wrap it. If you have any API calls that return 100s or 1000s of strings then this can become a non-negligible cost.</p>
<p>The full .NET version of Newtonsoft Json.NET has some flexibility with how types are serialised to/from JSON. For example, if I wanted to tell the serialiser that <strong>NonBlankTrimmedString</strong> instances should appear in the JSON as plain strings then I could do so using a <strong>JsonConverter</strong> (there is sample code in the Newtonsoft website that demonstrates how to do it for the <strong>Version</strong> type and the principle would be exactly the same for <strong>NonBlankTrimmedString</strong> - see <a href="https://www.newtonsoft.com/json/help/html/CustomJsonConverterGeneric.htm">Custom JsonConverter&lt;T&gt;</a>).</p>
<p>The Bridge version of the library has no support for custom JsonConverters, though, so we may appear to be a bit stuck.. if it weren't for the fact that Bridge has some low-level tricks that we can use to our advantage.</p>
<p>In order to allow C# code to be written that interacts with JavaScript libraries, Bridge has a few escape hatches for the type system that we can use in a careful manner. For example, I could rewrite the Bridge version of <strong>NonBlankTrimmedString</strong> to look like this:</p>
<pre><code>public class NonBlankTrimmedString
{
    protected NonBlankTrimmedString() { }

    /// &lt;summary&gt;
    /// This will never be null, blank or have any leading or trailing whitespace
    /// &lt;/summary&gt;
    public extern string Value { [Template(&quot;{this}&quot;)] get; }

    /// &lt;summary&gt;
    /// Create a NonBlankTrimmedString instance by explicitly casting a string
    /// &lt;/summary&gt;
    public static explicit operator NonBlankTrimmedString(string value)
    {
        if (value == null)
            return null;
        value = value.Trim();
        if (value == &quot;&quot;)
            throw new ArgumentException(&quot;Can not cast from a blank or whitespace-only string&quot;);
        return Script.Write&lt;NonBlankTrimmedString&gt;(&quot;value&quot;);
    }

    /// &lt;summary&gt;
    /// It's convenient to be able to pass a NonBlankTrimmedString instance as any argument
    /// that requires a string
    /// &lt;/summary&gt;
    [Template(&quot;{value}&quot;)]
    public extern static implicit operator string(NonBlankTrimmedString value);
}
</code></pre>
<p>This changes things up a bit. Now there is no public constructor and the only way to get a <strong>NonBlankTrimmedString</strong> instance from a plain string is to explicitly cast to it - eg.</p>
<pre><code>var x = (NonBlankTrimmedString)&quot;hi!&quot;;
</code></pre>
<p>If the source string is blank or whitespace-only then attempting to cast it to a <strong>NonBlankTrimmedString</strong> will result in an exception being thrown.</p>
<p>What's interesting about this class is that it exists only to provide type information to the C# compiler - there will never be an instance of <strong>NonBlankTrimmedString</strong> alive runtime in JavaScript. The reason for this is that the explicit cast performs some validation but then, at runtime, returns the string instance directly back; it <em>doesn't</em> wrap it in an instance of a <strong>NonBlankTrimmedString</strong> class. Similarly, when the &quot;Value&quot; property is requested in C# code, this is translated into JS as a direct reference to &quot;this&quot; (which we know is a plain string). This is sounding complicated as I write this, so let me try to make it clear with an example!</p>
<p>The following C# code:</p>
<pre><code>// Start with a plain string
var source = &quot;Hi!&quot;;

// Create a NonBlankTrimmed by explicitly casting the string
var x = (NonBlankTrimmedString)source;

// Write the value of the NonBlankTrimmedString to the console
Console.WriteLine(x.Value);
</code></pre>
<p>.. is translated into this JS:</p>
<pre><code>// Start with a plain string
var source = &quot;Hi!&quot;;

// Create a NonBlankTrimmed by explicitly casting the string
var x = Demo.NonBlankTrimmedString.op_Explicit(source);

// Write the value of the NonBlankTrimmedString to the console
System.Console.WriteLine(x);
</code></pre>
<p>The reference &quot;x&quot; in the JS runtime is actually just a string (and so the C# &quot;x.Value&quot; is translated into simply &quot;x&quot;) and the explicit operator (the method call &quot;Demo.NonBlankTrimmedString.op_Explicit&quot;) performs some validation but then (if the validation passes) returns the string right back but claims (for the benefit of the C# compiler and type system) that it is now a <strong>NonBlankTrimmedString</strong>.</p>
<p>This has a couple of benefits - now, plain string values that appear in JSON can be deserialised into <strong>NonBlankTrimmedString</strong> instances by Bridge (while the Bridge version of Json.NET doesn't support type converters, it <em>does</em> support deserialising types using implicit or explicit operators - so, here, it would see a string in the JSON and see that the target type was a <strong>NonBlankTrimmedString</strong> and it would use <strong>NonBlankTrimmedString</strong>'s explicit operator to instantiate the target type), so the JSON returned from the server can be cleaner. <em>And</em> it means that the JS runtime doesn't have to actually create instances of <strong>NonBlankTrimmedString</strong> to wrap those strings up in, which makes the life of the garbage collector easier (again, may be important if you have API responses that need to return 1000s of <strong>NonBlankTrimmedString</strong>).</p>
<p>This is an interesting concept that I'm referring to as a &quot;type alias&quot; - a type that exists only for the compiler and that doesn't affect the runtime. The phrase &quot;type alias&quot; exists in TypeScript and in F# (and in other languages, I'm sure) but I think that it means something slightly different there.. which may mean that I've chosen a confusing name for this C# / Bridge.NET concept! In TypeScript and F#, I don't believe that they allow the level of compiler validation that I'm talking about - certainly in TypeScript, type aliases are more of a convenience that allow you say something like:</p>
<pre><code>type Vector = number[];
type Vectors = Vector[];
</code></pre>
<p>.. so that you can then write a method signature that looks like this:</p>
<pre><code>function process(data: Vectors) {
    // ..
}
</code></pre>
<p>.. instead of:</p>
<pre><code>function process(data: number[][]) {
    // ..
}
</code></pre>
<p>.. but the two are identical. TypeScript &quot;type aliases&quot; make things more flexible, <em>not</em> more constrained. To make that clearer, if you wrote:</p>
<pre><code>type CustomerID = number;

function process(id: CustomerID) {
    // ..
}
</code></pre>
<p>.. then you could still call:</p>
<pre><code>process(1); // Passing a plain number into a method whose signature specifies type CustomerID
</code></pre>
<p>In other words, the TypeScript alias means &quot;anywhere that you see CustomerID, you can pass in a 'number'&quot;. This is the opposite of what I want, I want to be able to have methods that specify that they want a <strong>NonBlankTrimmedString</strong> and <em>not</em> just any old string.</p>
<p>I go into this in a little more detail in the section &quot;Type aliases in other languages&quot; at the end of this blog post. My point here was that maybe &quot;type alias&quot; is not the best phrase to use and maybe I'll revisit this in the future.</p>
<p>For now, though, let's get back to the <strong>NonBlankTrimmedString</strong> definition that I've proposed because it has some downsides, as well. As the type <em>only</em> exists at compile time and <em>not</em> at runtine, if I try to query the type of a <strong>NonBlankTrimmedString</strong> instance at runtime then it will report that it is a &quot;System.String&quot; - this is to be expected, since part of the benefit of this approach is that no additional instances are required other than the plain string itself - but if you were wanted to do some crazy reflection for some reason then it might catch you off guard.</p>
<p>Another downside is that if I wanted to create specialised versions of <strong>NonBlankTrimmedString</strong> then I have to duplicate some code. For example, I might want to <a href="https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/">strongly type</a> my entity IDs and define them as classes derived from <strong>NonBlankTrimmedString</strong>. With the version of <strong>NonBlankTrimmedString</strong> from my 2016 blog post, this would be as simple as this:</p>
<pre><code>// If NonBlankTrimmedString is a regular class then creating derived types is easy as this
public class OrderID : NonBlankTrimmedString
{
    public OrderID(string value) : base(value) { }
}
</code></pre>
<p>.. but with this &quot;type alias&quot; approach, it becomes more verbose -</p>
<pre><code>// The explicit operator needs to be reimplemented for each derived type with the type alias
// alias approach shown earlier :(
public class ClassName : NonBlankTrimmedString
{
    protected ClassName() { }

    public static explicit operator ClassName(string value)
    {
        if (value == null)
            return null;
        value = value.Trim();
        if (value == &quot;&quot;)
            throw new ArgumentException(&quot;Can not cast from a blank or whitespace-only string&quot;);
        return Script.Write&lt;ClassName&gt;(&quot;value&quot;);
    }
}
</code></pre>
<p>However, we could make this a little simpler by changing the <strong>NonBlankTrimmedString</strong> type definition to this:</p>
<pre><code>public class NonBlankTrimmedString
{
    protected NonBlankTrimmedString() { }

    /// &lt;summary&gt;
    /// This will never be null, blank or have any leading or trailing whitespace
    /// &lt;/summary&gt;
    public extern string Value { [Template(&quot;{this}&quot;)] get; }

    /// &lt;summary&gt;
    /// Create a NonBlankTrimmedString instance by explicitly casting a string
    /// &lt;/summary&gt;
    public static explicit operator NonBlankTrimmedString(string value)
        =&gt; Wrap&lt;NonBlankTrimmedString&gt;(value);

    /// &lt;summary&gt;
    /// It's convenient to be able to pass a NonBlankTrimmedString instance as any argument
    /// that requires a string
    /// &lt;/summary&gt;
    [Template(&quot;{value}&quot;)]
    public extern static implicit operator string(NonBlankTrimmedString value);

    protected static T Wrap&lt;T&gt;(string value) where T : NonBlankTrimmedString
    {
        if (value == null)
            return null;
        value = value.Trim();
        if (value == &quot;&quot;)
            throw new ArgumentException(&quot;Can not cast from a blank or whitespace-only string&quot;);
        return Script.Write&lt;T&gt;(&quot;value&quot;);
    }
}
</code></pre>
<p>.. and then derived types would look like this:</p>
<pre><code>public class OrderID : NonBlankTrimmedString
{
    protected OrderID() { }
    public static explicit operator OrderID(string value) =&gt; Wrap&lt;OrderID&gt;(value);
}
</code></pre>
<h3>(Sort-of-)immutability for &quot;free&quot; through type aliases</h3>
<p>Another use case where this sort of approach seemed interesting was when I was writing some client-side code that received data in the form of arrays and then did some clever calculations and drew some pretty graphs. The API response data was 10s of 1000s of arrays, where each array was 100 floating point numbers. The calculation logic took those arrays and passed them through a bunch of methods to come up with the results but I got myself in a bit of a muddle when there were one or two places that had to manipulate a subset of the data and I realised that I was confusing myself as to whether the data should be altered in place or whether local copies of those parts of the data should be taken and then changed. To make the code easier to follow, I wanted those methods to take local copies to make the changes, rather than mutating them in-place and risking messing up calculations performed on the data later in the pipeline.</p>
<p>What I really wanted was for those methods to have type signatures that would either take an immutable data type or a readonly data type. Immutable is the ideal because it means that not only can the receiving methods not change the data but <em>nothing</em> can change the data. Having readonly types on the method signatures means that the methods can't change the data but it's still technically possible for the caller to change the data. To try to illustrate this, I'll use the <strong>ReadOnlyCollection&lt;T&gt;</strong> type from .NET in an example:</p>
<pre><code>public static void Main()
{
    var items = new List&lt;int&gt; { 0, 1, 2, 3 };
    var readOnlyItems = items.AsReadOnly();
    DoSomething(
        readOnlyItems,
        halfwayPointCallback: () =&gt; items.RemoveAt(0)
    );
}

static void DoSomething(ReadOnlyCollection&lt;int&gt; readOnlyItems, Action halfwayPointCallback)
{
    Console.WriteLine(&quot;Number of readonlyItems: &quot; + readOnlyItems.Count);
    halfwayPointCallback();
    Console.WriteLine(&quot;Number of readonlyItems: &quot; + readOnlyItems.Count);
}
</code></pre>
<p>Here, the &quot;Main&quot; method declares a mutable list and then it create a readonly wrapper around it. The readonly wrapper is passed into the &quot;DoSomething&quot; method and this means &quot;DoSomething&quot; can <em>not</em> directly alter that list. However, it's still possible for the &quot;Main&quot; method to change the underlying list while &quot;DoSomething&quot; is running.</p>
<p>In practice, this is not something that I find commonly happens. As such, while I would <em>prefer</em> immutable structures at all times (because then &quot;Main&quot; <em>couldn't</em> change the contents of the list while &quot;DoSomething&quot; is working on it), being able to wrap the data in a readonly structure is still a significant improvement.</p>
<p>So, some of the more obvious options available to me were:</p>
<ol>
<li>Stick with using arrays and be careful not to write code that performs any alteration &quot;in place&quot; (<strong>I don't like this situation - C#'s type system has great potential and I want it to help me and save me from myself where possible!</strong>)</li>
<li>Pass the arrays into the methods as <strong>IEnumerable&lt;float&gt;</strong> (<strong>this isn't a terrible idea in general - it quite clearly communicates that the provided data should be considered read only - but the calculations that I was doing wanted to get the length of the array and to read particular indexed values from the array in unpredictable orders and this isn't very efficient with enumerable types</strong>)</li>
<li>Create an &quot;immutable list&quot; class that takes an array into the constructor, copies the data and then allows access to the copy only through tightly-controlled members; ie. Length and an indexed property (<strong>This is the most type-safe way but it felt expensive doing this for the 10s of 1000s of arrays that I had</strong>)</li>
<li>Convert each array into a <strong>List&lt;float&gt;</strong> and then call &quot;.AsReadOnly()&quot; on them (<strong>this is very little code but it also felt expensive with the amount of data that I had</strong>)</li>
<li>Create a &quot;ReadOnlyArray&lt;T&gt;&quot; type that would be very similar in nature to the <strong>ReadOnlyCollection&lt;T&gt;</strong> in that it would take an array into its constructor and then provide a read only interface for it, <em>without</em> copying the array (<strong>This is a reasonable option and I might have gone this way were it not for liking the idea of option six</strong>)</li>
<li>Create a &quot;ReadOnlyArray&lt;T&gt;&quot; type <em>alias</em> that I could use to instruct the type system that the data should not be altered but without having to introduce <em>any</em> new types or instances at runtime</li>
</ol>
<p>I went with the last one because I was all excited about experimenting with &quot;Bridge.NET type aliases&quot; and I wanted to see how well they could work! (In reality, the fifth option was also a good one and some of the others would also be perfectly fine for smaller data sets.. to be honest, there is a chance that they wouldn't have made <em>too</em> much difference even with the data that I was looking at but, again, sometimes you need to make opportunity to experiment! :)</p>
<pre><code>public sealed class ReadOnlyArray&lt;T&gt; : IEnumerable&lt;T&gt;
{
    [Template(&quot;{data}&quot;)]
    public extern ReadOnlyArray(T[] data);

    [External] // Required due to https://github.com/bridgedotnet/Bridge/issues/4015
    public extern T this[int index] { [Template(&quot;{this}[{index}]&quot;)] get; }

    public extern int Length { [Template(&quot;length&quot;)] get; }

    [External]
    public extern IEnumerator&lt;T&gt; GetEnumerator();

    [External]
    extern IEnumerator IEnumerable.GetEnumerator();

    [Template(&quot;{value}&quot;)]
    public extern static implicit operator ReadOnlyArray&lt;T&gt;(T[] value);
}
</code></pre>
<p>The structure of this class is similar in some ways to that of the <strong>NonBlankTrimmedString</strong>. Unlike that class, there is no validation that is required - I <em>only</em> want to provide access to an array in a limited manner and so it's fine to expose a public constructor (as opposed to the <strong>NonBlankTrimmedString</strong>, where it's important to check that the value is neither null nor blank nor whitespace-only and the [Template] attribute on the constructor doesn't easily allow for any validation).</p>
<p>Even though the constructor may be used on this class, there is still an operator to change an array into a <strong>ReadOnlyArray</strong> so that the deserialisation process is able to read an array of items into a <strong>ReadOnlyArray</strong> instance. I've chosen to use an implicit operator (rather than en explicit operator) here because there is no validation to perform - the <strong>NonBlankTrimmedString</strong> has an explicit operator because that<em>does</em> perform some validation and so it's a casting action that could fail and so I want it to be explicit in code.</p>
<p>As with the <strong>NonBlankTrimmedString</strong>, this type will exist only at compile time and the compiled JavaScript will always be operating directly against the original array. As far as the JS code is aware, there <em>is no</em> wrapper class involved at all. The following C# -</p>
<pre><code>var values = new[] { 1, 2, 3 };
Console.WriteLine(values.Length);

var readOnlyValuesCtor = new ReadOnlyArray&lt;int&gt;(values);
Console.WriteLine(readOnlyValuesCtor.Length);

ReadOnlyArray&lt;int&gt; readOnlyValuesCast = values;
Console.WriteLine(readOnlyValuesCast.Length);
</code></pre>
<p>.. is translated into this JS:</p>
<pre><code>var values = System.Array.init([1, 2, 3], System.Int32);
System.Console.WriteLine(values.length);

var readOnlyValuesCtor = values;
System.Console.WriteLine(readOnlyValuesCtor.length);

var readOnlyValuesCast = values;
System.Console.WriteLine(readOnlyValuesCast.length);
</code></pre>
<p>Whether the <strong>ReadOnlyArray&lt;int&gt;</strong> is created by calling its constructor or by an implicit cast in the C# code, the JS is unaware of any change required of the reference and continues to operate on the original array. This is the &quot;free&quot; part of this approach - there is no runtime cost in terms of type conversions or additional references.</p>
<p>The other members of the class need a little more explanation, though. The indexer <em>should</em> be implemented just like the &quot;Length&quot; property, by having an extern property that has a getter with a [Template] attribute on it. However, there is a bug in the Bridge compiler that necessitate an additional [External] attribute be added to the property. Not the end of the world and I'm sure that the Bridge Team will fix it in a future version of the compiler.</p>
<p>The &quot;GetEnumerator&quot; methods require a tiny bit more explanation. In order for the class to implement <strong>IEnumerable&lt;T&gt;</strong>, these methods must be present. But we don't actually have to implement them ourselves. Whenever Bridge encouters a &quot;foreach&quot; in the source C# code, it translates it into JS that calls &quot;GetEnumerator&quot; and then steps through each value. For example, this C# code:</p>
<pre><code>foreach (var value in readOnlyValuesCtor)
    Console.WriteLine(value);
</code></pre>
<p>.. becomes this JS:</p>
<pre><code>$t = Bridge.getEnumerator(readOnlyValuesCtor);
try {
    while ($t.moveNext()) {
        var value = $t.Current;
        System.Console.WriteLine(value);
    }
} finally {
    if (Bridge.is($t, System.IDisposable)) {
        $t.System$IDisposable$Dispose();
    }
}
</code></pre>
<p>Because Bridge needs to support enumerating over arrays, the function &quot;Bridge.getEnumerator&quot; knows what to do if it is given an array reference. And since a <strong>ReadOnlyArray</strong> <em>is</em> an array reference at runtime, we don't have to do anything special - we don't have to provide a GetEnumerator implementation.</p>
<p>And there we go! As I explained above, I originally encountered this problem when passing an array into a complicated calculation process but this type could <em>also</em> be used for deserialising JSON into a richer type model, just like the <strong>NonBlankTrimmedString</strong> earlier - again, without any overhead in doing so (no instances of wrapper types will be present runtime and there will be no additional references for the garbage collector to track).</p>
<h3><em>Only</em> possible in Bridge.NET?</h3>
<p>I was wracking my brains about whether it would be possible to do something similar with C# running in a .NET environment and I couldn't think of anything. People sometimes think <em>&quot;structs!&quot;</em> when trying to concoct ways to avoid adding references that the garbage collector needs to track but structs are only immune to this if they don't contain any object references within their fields and properties (and there are other edge cases besides this but they're not important right now).</p>
<p>At the end of the day, this &quot;type alias&quot; concept might be a bit of a niche technique and it <em>might</em> even be a case of me playing around, more than it being something that you might use in production.. but I thought that it was interesting nonetheless. And it has made me wish, again, that C# had support for something like this - I've written code before that defines all variety of strongly typed IDs (strings) and Keys (integers) to avoid passing the wrong type of value into the wrong place but it's always felt cumbersome (it's felt worth the effort but that didn't stop wishing me that it was <em>less</em> effort).</p>
<h3>Type aliases in other languages</h3>
<p>I've linked above to an article <a href="https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/">Using strongly-typed entity IDs to avoid primitive obsession</a>, which is excellent and eloquently expresses some of my thoughts, but I thought that I'd add a summary in here as well (which also gives me an opportunity to go into more detail about the options in TypeScript and F#).</p>
<p>I'll start with an anecdote to set the scene. In a company that I used to work at, we had systems that would retrieve and render different data for different language options. Sometimes data would vary only by language (&quot;English&quot;, &quot;French&quot;, etc..) but sometimes it would be more specific and vary by language <em>culture</em> (eg. &quot;English - United Kingdom&quot;, &quot;English - United States&quot;, etc..). An older version of the system would pass around int values for the language or language culture keys. So there might be a method such as:</p>
<pre><code>private string GetTranslatedName(int languageKey)
</code></pre>
<p>A problem that occurred over and over again is that language keys and language culture keys would get mixed up in the code base - in other words, it was quite common for someone to accidentally pass a language key into a method where a language <em>culture</em> key was expected (this situation was not helped by the fact that much of the developer testing was done in English and the language key and language culture key values in many of the databases were both 1 for English / English UK). Something that I was very keen to get into a new version of the system was to introduce &quot;strongly typed keys&quot; so that this sort of accident could no longer occur. The method's signature would be changed to something like this:</p>
<pre><code>private string GetTranslatedName(LanguageKey languageKey)
</code></pre>
<p>.. and we would not describe language or language culture keys as ints in the code base. They would always be either an instance of <strong>LanguageKey</strong> or <strong>LanguageCultureKey</strong> - this way, if you attempted to pass a key of the wrong type into a method then you would get a compile error.</p>
<p>The downside is that each key type had to be defined as its own struct, with the following (quite verbose) structure:</p>
<pre><code>public struct LanguageKey : IEquatable&lt;LanguageKey&gt;
{
    public LanguageKey(int value) =&gt; Value = value;

    public int Value { get; }

    public bool Equals(LanguageKey other) =&gt; Value.Equals(other.Value);
    public override bool Equals(object obj) =&gt; (obj is LanguageKey key) &amp;&amp; (key.Value == Value);
    public override int GetHashCode() =&gt; Value;

    public static bool operator ==(LanguageKey x, LanguageKey y) =&gt; x.Value == y.Value;
    public static bool operator !=(LanguageKey x, LanguageKey y) =&gt; !(x == y);

    public static explicit operator LanguageKey(int value) =&gt; new LanguageKey(value);
}
</code></pre>
<p>Really, though, that is the <em>only</em> downside. As the strongly typed keys are structs without any reference properties or fields, there is no additional work for the garbage collector and there is no memory overhead vs tracking a simple int. But it <em>does</em> still feel a little arduous to have to have these definitions in the code base, particularly when the equivalent F# code looks like this:</p>
<pre><code>[&lt;Struct&gt;] type LanguageKey = LanguageKey of int
</code></pre>
<p>It's worth noting that this is not actually referred to as a &quot;type alias&quot; in F#; this is a &quot;single case union type&quot;. There <em>is</em> a concept called a &quot;type alias&quot; in F# that looks like this:</p>
<pre><code>type LanguageKey = int
</code></pre>
<p>.. but that code simply says &quot;allow me to use the word 'LanguageKey' anywhere in place of int&quot; - eg. if I have the LanguageKey type alias specified as a method argument type in F# method, like this:</p>
<pre><code>let getTranslatedName (language: LanguageKey) =
    // (Real work to retrieve translated name would go here but we'll
    //  just return the string &quot;Whatever&quot; for the sake of this example)
    &quot;Whatever&quot;
</code></pre>
<p>.. then the compiler would allow me to pass an int into that method -</p>
<pre><code>// A LanguageKey type alias lets me pass any old int into the method - rubbish!
let name = getTranslatedName 123
</code></pre>
<p>.. and that's exactly what I wanted to avoid!</p>
<p>On the other hand, if the type <strong>LanguageKey</strong> was a &quot;single case union type&quot; then the code above would not compile:</p>
<pre><code>// error FS0001: This expression was expected to have type 'LanguageKey' but here has type 'int'
let name = getTranslatedName 123

// This DOES compile because the types match
let key = LanguageKey 123
let name = getTranslatedName 123
</code></pre>
<p>.. and that's exactly what I <em>did</em> want!</p>
<p>(TypeScript's type aliases are like F#'s type aliases - they are more of a convenience and do not add the sort of type checking that I want)</p>
<p>Things get a bit more awkward if we want to deal with reference types, such as strings, becase we could create a C# class similar to <strong>LanguageKey</strong> (or we could create an F# single case union type) but that would introduce a new instance of a type that must be tracked by the garbage collector - every strongly typed ID involves <em>two</em> references; the underlying string value and the strongly typed wrapper. Much of the time, that's no problem - I've had the odd issue with the .NET GC in the past but, on the whole, it's an amazing and reliable tool.. but because I <em>have</em> had these problems before, it makes me more aware of the trade-off when I introduce wrappers like this.</p>
<p>I'm convinced that using strongly typed IDs is the right thing to do in 99% of cases because it improves code quality and can eradicate a class of real-world mistake. But the concept became even more interesting to me as it appeared possible to introduce a form of type alias into Bridge.NET code that enables those compile time checks but with zero runtime cost. Granted, the type erasure that occurs means that <em>runtime</em> type checking is not possible (the Bridge code can not differentiate between a <strong>string</strong> or a <strong>NonBlankTrimmedString</strong> or a type that is <em>derived</em> from <strong>NonBlankTrimmedString</strong>) but the main driver for me was to improve compile time checking and so that wasn't a problem for me. Maybe it would be a problem in other scenarios, in which case these Bridge.NET &quot;type aliases&quot; might not be appropriate.</p>
<p class="PostTime">Posted at 21:59</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/stronglytyped-react-with-bridgenet">Strongly-typed React (with Bridge.net)</a></li><li><a href="/a-followup-to-implementing-f-sharp-inspired-with-updates-in-c-sharp">A follow-up to &quot;Implementing F#-inspired &#x27;with&#x27; updates in C#&quot;</a></li><li><a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired &quot;with&quot; updates for immutable classes in C#</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li></ul></div>
            <p class="Comments">
                <a href="/type-aliases-in-bridgenet-c-sharp#disqus_thread" data-disqus-identifier="114">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">6 September 2016</p><h2><a id="performance-tuning-a-bridgenet-react-app" href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></h2>
<p>On the whole, React is fast. And, on the whole, writing a web application's code in C# using <a href="http://bridge.net/">Bridge.NET</a> has little overhead compared to writing it directly in JavaScript since Bridge generates sensible JavaScript.</p>
<p>However, I recently wanted to convince myself that performance would not be an issue with the sort of projects that we'll be writing at work. We have some applications that are key to the business and yet have unfortunately been left to wither into a barely-maintinable state. The plan is to, over time, rewrite sections of the application using Bridge and React so that the application continues to work at all times but the old code is pruned away. This means that we need to be sure that any crazy forms that existed in the old codebase will work fine in the new architecture. In particular, there is a configuration page that allows a user to select options from a list of almost 1,000 checkboxes. Is this good UI? Most probably not. Do we need to be able to support such configurations in the future? Unfortunately, most probably yes. With a classic server-based MVC application, this would involve 1,000 checkboxes being rendered on the page and then a ginormous form post to send the changes back when the user clicks Save. In a React app, this sort of form will require virtual re-renders each time that a checkbox is clicked on.</p>
<p>I thought I'd actually go with something slightly more demanding - 5,000 rows on a form where each row has two text boxes and a checkbox. If this can be handled easily then the worst case scenario that we have in mind for our rewrites (1,000 checkboxes) will be a walk in the park.</p>
<p>So I whipped up a sample app and started using the Chrome profiler.. and the news was not good.</p>
<p>The total time recorded by the profiler was 838ms to deal with the changing of a single checkbox. It's said that <a href="https://www.nngroup.com/articles/response-times-3-important-limits/">100ms is &quot;the limit for having the user feel that the system is reacting instantaneously&quot;</a> and 838ms is just not in the same ballpark. What's even worse is that this delay is experienced not only when a checkbox state is changed but also when any change is applied to one of the text boxes. Waiting almost a second for a checkbox to change is bad but waiting that long for each key press to be registered while typing is unbearable.</p>
<h3>Examining the test app</h3>
<p>The test app is fairly simple (and will contain no surprises if you've read my <a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">Writing React apps using Bridge.NET - The Dan Way</a> three part mini-series). However, the performance improvements that I'm going to cover will be in versions of libraries that I haven't yet released - namely, <a href="https://github.com/ProductiveRage/Bridge.React">Bridge.React</a>, <a href="https://github.com/ProductiveRage/Bridge.Immutable">ProductiveRage.Immutable</a> and <a href="https://github.com/ProductiveRage/Bridge.Immutable.Extensions">ProductiveRage.Immutable.Extensions</a>. The ProductiveRage.Immutable.Extensions library includes types that I commonly use when writing Bridge / React apps (such as <strong>RequestId</strong> and <strong>NonBlankTrimmedString</strong>). So you won't yet be able to try out the changes that I'm going to discuss but (hopefully!) the process of identifying what changes to make will be useful.</p>
<p><em>(I'm planning to release the updates to these libraries around the time that Bridge 15.0 comes out, which should hopefully be this month - this will include the change to using Roslyn for parsing the C#, rather than NRefactory, and so C# 6 syntax will finally be supported, which is wonderful news).</em></p>
<p>One of the types that will be available in ProductiveRage.Immutable.Extensions is <strong>CommonProps&lt;T&gt;</strong>. It's extremely common for component classes to require the same sort of information - what the initial state is, how to record requests to change that state, what class name to apply to the component, whether it should be in a disabled state or not and what key the component has (for cases where it appears as part of a set of dynamic child components).</p>
<pre><code>public sealed class CommonProps&lt;T&gt; : IAmImmutable
{
    public CommonProps(
        T state,
        Action&lt;T&gt; onChange,
        Optional&lt;ClassName&gt; className,
        bool disabled,
        Optional&lt;Any&lt;string, int&gt;&gt; key)
    {
        this.CtorSet(_ =&gt; _.State, state);
        this.CtorSet(_ =&gt; _.OnChange, onChange);
        this.CtorSet(_ =&gt; _.ClassName, className);
        this.CtorSet(_ =&gt; _.Disabled, disabled);
        this.CtorSet(_ =&gt; _.Key, key);
    }

    public T State { get; private set; }
    public Action&lt;T&gt; OnChange { get; private set; }
    public Optional&lt;ClassName&gt; ClassName { get; private set; }
    public bool Disabled { get; private set; }
    public Optional&lt;Any&lt;string, int&gt;&gt; Key { get; private set; }
}
</code></pre>
<p>If you have a custom text box component then you want to be able to set the initial text value and to be informed when the user is performing an action that changes the text value. If you have a row in a table that shows a message (such as in the application built up in the three part series) then each row needs to have state describing what to show in the &quot;Content&quot; text box and what to show in the &quot;Author&quot; text box. When the user tries to change of those values, the row needs to have a way to say that the current message state is changing. As a final example, if there is a Message table component then the initial state will be a set of messages to render and the &quot;OnChange&quot; delegate will be used whenever a user wants to change a value in an existing row or when they want to remove a row or when they want to add a row. So it's a very common pattern and having a generic class to describe it means that there's less code to write for each component, since they can use this common class rather than each component having their <em>own</em> props class.</p>
<p>There are some static factory methods to make initialising <strong>CommonProps&lt;T&gt;</strong> instances easier:</p>
<pre><code>public static class CommonProps
{
    public static CommonProps&lt;T&gt; For&lt;T&gt;(
        T state,
        Action&lt;T&gt; onChange,
        Optional&lt;ClassName&gt; className,
        bool disabled)
    {
        return new CommonProps&lt;T&gt;(
            state,
            onChange,
            className,
            disabled,
            Optional&lt;Any&lt;string, int&gt;&gt;.Missing
        );
    }

    public static CommonProps&lt;T&gt; For&lt;T&gt;(
        T state,
        Action&lt;T&gt; onChange,
        Optional&lt;ClassName&gt; className,
        bool disabled)
        Any&lt;string, int&gt; key)
    {
        return new CommonProps&lt;T&gt;(state, onChange, className, disabled, key);
    }
}
</code></pre>
<p>With that in mind, the code below should be easy to understand. For simplicity, state changes are handled directly by the container component (there is no Dispatcher) and all that the app does is render 5,000 rows and allow the user to change either text box in each row or the checkbox that each row has. It might seem like a lot of code but that's partly due to the way that the lines are wrapped to fit in the blog post and it's partly because I've included <em>all</em> of the non-shared-library code from the app, which is important so that we can talk about what is and isn't worth altering.</p>
<pre><code>public static class App
{
    [Ready]
    public static void Main()
    {
        React.Render(
            new AppContainer(),
            Document.GetElementById(&quot;main&quot;)
        );
    }
}

public sealed class AppContainer : Component&lt;object, AppContainer.State&gt;
{
    public AppContainer() : base(null) { }

    protected override State GetInitialState()
    {
        return new State(
            Enumerable.Range(1, 5000)
                .Select(i =&gt; Saved.For(
                    i.ToString(),
                    new MessageEditState(&quot;Title&quot; + i, &quot;Content&quot; + i, isAwesome: false)))
                .ToSet()
        );
    }

    public override ReactElement Render()
    {
        return DOM.Div(
            new Attributes { ClassName = &quot;wrapper&quot; },
            new MessageTable(
                state.Messages,
                updatedMessages =&gt; SetState(new State(updatedMessages)),
                className: new ClassName(&quot;messages&quot;),
                disabled: false
            )
        );
    }

    public sealed class State : IAmImmutable
    {
        public State(NonNullList&lt;Saved&lt;MessageEditState&gt;&gt; messages)
        {
            this.CtorSet(_ =&gt; _.Messages, messages);
        }

        public NonNullList&lt;Saved&lt;MessageEditState&gt;&gt; Messages { get; private set; }
    }
}

public sealed class Saved&lt;T&gt; : IAmImmutable
{
    public Saved(string id, T value)
    {
        this.CtorSet(_ =&gt; _.Id, id);
        this.CtorSet(_ =&gt; _.Value, value);
    }

    public string Id { get; private set; }
    public T Value { get; private set; }
}

public static class Saved
{
    public static Saved&lt;T&gt; For&lt;T&gt;(string id, T value)
    {
        return new Saved&lt;T&gt;(id, value);
    }
}

public sealed class MessageEditState : IAmImmutable
{
    public MessageEditState(string title, string content, bool isAwesome)
    {
        this.CtorSet(_ =&gt; _.Title, title);
        this.CtorSet(_ =&gt; _.Content, content);
        this.CtorSet(_ =&gt; _.IsAwesome, isAwesome);
    }

    public string Title { get; private set; }
    public string Content { get; private set; }
    public bool IsAwesome { get; private set; }
}

public sealed class MessageTable : PureComponent&lt;CommonProps&lt;NonNullList&lt;Saved&lt;MessageEditState&gt;&gt;&gt;&gt;
{
    public MessageTable(
        NonNullList&lt;Saved&lt;MessageEditState&gt;&gt; state,
        Action&lt;NonNullList&lt;Saved&lt;MessageEditState&gt;&gt;&gt; onChange,
        Optional&lt;ClassName&gt; className,
        bool disabled)
            : base(CommonProps.For(state, onChange, className, disabled)) { }

    public override ReactElement Render()
    {
        return DOM.Div(
            new Attributes { ClassName = props.ClassName.ToNullableString() },
            props.State.Select((savedMessage, index) =&gt; new MessageRow(
                savedMessage.Value,
                updatedMessage =&gt; props.OnChange(
                    props.State.SetValue(index, props.State[index].With(_ =&gt; _.Value, updatedMessage))
                ),
                className: null,
                disabled: false,
                key: savedMessage.Id
            ))
        );
    }
}

public sealed class MessageRow : PureComponent&lt;CommonProps&lt;MessageEditState&gt;&gt;
{
    public MessageRow(
        MessageEditState state,
        Action&lt;MessageEditState&gt; onChange,
        Optional&lt;ClassName&gt; className,
        bool disabled,
        Any&lt;string, int&gt; key)
            : base(CommonProps.For(state, onChange, className, disabled, key)) { }

    public override ReactElement Render()
    {
        return DOM.Div(new Attributes { ClassName = props.ClassName.ToNullableString() },
            props.TextBoxFor(_ =&gt; _.Title, &quot;title&quot;),
            props.TextBoxFor(_ =&gt; _.Content, &quot;content&quot;),
            props.CheckboxFor(_ =&gt; _.IsAwesome, &quot;is-awesome&quot;)
        );
    }
}

public static class CommonPropsRenderer
{
    public static ReactElement TextBoxFor&lt;T&gt;(
        this CommonProps&lt;T&gt; props,
        [PropertyIdentifier]Func&lt;T, string&gt; propertyIdentifier,
        string className)
            where T : IAmImmutable
    {
        if (props == null)
            throw new ArgumentNullException(&quot;props&quot;);
        if (propertyIdentifier == null)
            throw new ArgumentNullException(&quot;propertyIdentifier&quot;);

        return DOM.Input(new InputAttributes
        {
            ClassName = className,
            Value = propertyIdentifier(props.State),
            OnChange = e =&gt; props.OnChange(props.State.With(propertyIdentifier, e.CurrentTarget.Value))
        });
    }

    public static ReactElement CheckboxFor&lt;T&gt;(
        this CommonProps&lt;T&gt; props,
        [PropertyIdentifier]Func&lt;T, bool&gt; propertyIdentifier,
        string className)
            where T : IAmImmutable
    {
        if (props == null)
            throw new ArgumentNullException(&quot;props&quot;);
        if (propertyIdentifier == null)
            throw new ArgumentNullException(&quot;propertyIdentifier&quot;);

        return DOM.Input(new InputAttributes
        {
            Type = InputType.Checkbox,
            ClassName = className,
            Checked = propertyIdentifier(props.State),
            OnChange = e =&gt; props.OnChange(props.State.With(propertyIdentifier, e.CurrentTarget.Checked))
        });
    }
}
</code></pre>
<p>Except for the top-level <strong>AppContainer</strong>, every component is derived from <strong>PureComponent&lt;T&gt;</strong> which means that they automatically get implementations for React's &quot;<a href="https://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate">shouldComponentUpdate</a>&quot; component life cycle method. This means that if a component needs to be re-rendered by the virtual DOM and if the new props settings are the same as its current props settings then the component will tell React &quot;I'm not going to change, you do not need to re-render me (nor any of my child components)&quot;. I had originally hoped that this would mean that everything would be blazing fast without any additional work. However, as I've already said, this was not to be the case.</p>
<p>Before I get stuck in, it's worth bearing in mind that this really is a <em>worst case</em> scenario. If there was a page that required 5,000 entry rows spread over ten different tables then changing any single row would only require the containing table to re-render, the other nine would not need to (the <strong>PureComponent&lt;T&gt;</strong>'s &quot;shouldComponentUpdate&quot; logic would take take of that). The difficulty here is that all 5,000 rows are in a <em>single</em> table and so changing any value in any row requires that the table potentially re-render all of its rows. I can't imagine very many UIs where presenting a user with so many rows simultaneously would be a particularly pleasant experience. Perhaps a spreadsheet of some sort? If you needed to present an interface with tens of thousands of inputs, there are ways to make it faster such as &quot;chunking up&quot; groups of rows (so that a change to any single row only requires the other rows in the group potentially to re-render and not any other group). A more complicated (but highly efficient) approach would be to work out what data is currently visible in the browser window and to only update that.</p>
<p>Rather than considering these alternatives at this point, though, I want to see what we can do with the sample app as it's presented.</p>
<h3>Profiling</h3>
<img alt="Initial timings (not good)" src="/Content/Images/Posts/BridgeReactProfiling1.png" class="NoBorder HalfWidth" title="Initial timings (not good)" />
<p>The first thing to do was to start measuring and digging. I loaded the page in Chrome, opened the dev tools, went to the Profiles tab, clicked &quot;Start CPU profiling&quot;, clicked a checkbox and then &quot;Stop CPU profiling&quot;. The result is shown here. There is a natural split between two processes - the &quot;Render&quot; method of the <strong>MessageTable</strong> and the &quot;receiveComponent&quot; / &quot;updateComponent&quot; within React. I know that it's the <strong>MessageTable</strong>'s Render method because it calls &quot;select&quot; (the LINQ function) and that will be where the <strong>MessageTable</strong> creates each <strong>MessageRow</strong>. I'm going to concentrate there first since that's where most of the time is taken and it's also what I have the most direct control over.</p>
<p>Just one thing to check first, though - I'm using the development build of the React library at this point, which has some overhead compared to the production version (since it performs more checks and does more work in order to provide more helpful warnings, where required). Changing to the production build trims some time off; the <strong>MessageTable</strong> &quot;Render&quot; method still takes 609ms but &quot;receiveComponent&quot; takes about half as much time, now 128ms. Clearly, the production build is not going to magically solve all of my problems.</p>
<p>The Chrome dev tools allow you to zoom in on sections of the profiler results, so I tried to make sense of what I could see under the &quot;Render&quot; side. The problem was that it seemed like there were lots of nested calls where none were individually very expensive, it seemed like a cumulative problem with just how many components there were. There were a lot of calls to &quot;constructor&quot;, which suggested to me that there may be some overhead in creating Bridge classes. To try to test this theory, I added a new option to the React bindings to enable components to be created by providing a static function rather than creating a component class that is derived from <strong>Component&lt;TProps, TState&gt;</strong> or <strong>PureComponent&lt;TProps&gt;</strong>. This allows <strong>MessageRow</strong> to be rewritten as:</p>
<pre><code>public static class MessageRow
{
    [Name(&quot;MessageRow&quot;)]
    public static ReactElement Render(CommonProps&lt;MessageEditState&gt; props)
    {
        return DOM.Div(new Attributes { ClassName = props.ClassName.ToNullableString() },
            props.TextBoxFor(_ =&gt; _.Title, &quot;title&quot;),
            props.TextBoxFor(_ =&gt; _.Content, &quot;content&quot;),
            props.CheckboxFor(_ =&gt; _.IsAwesome, &quot;is-awesome&quot;)
        );
    }
}
</code></pre>
<p>which requires <strong>MessageTable</strong> to be changed to:</p>
<pre><code>public sealed class MessageTable : PureComponent&lt;CommonProps&lt;NonNullList&lt;Saved&lt;MessageEditState&gt;&gt;&gt;&gt;
{
    public MessageTable(
        NonNullList&lt;Saved&lt;MessageEditState&gt;&gt; state,
        Action&lt;NonNullList&lt;Saved&lt;MessageEditState&gt;&gt;&gt; onChange,
        Optional&lt;ClassName&gt; className,
        bool disabled)
            : base(CommonProps.For(state, onChange, className, disabled)) { }

    public override ReactElement Render()
    {
        return DOM.Div(
            new Attributes { ClassName = props.ClassName.ToNullableString() },
            props.State.Select((savedMessage, index) =&gt; StaticComponent.Pure(
                MessageRow.Render,
                CommonProps.For(
                    savedMessage.Value,
                    updatedMessage =&gt; props.OnChange(
                        props.State.SetValue(index, props.State[index].With(_ =&gt; _.Value, updatedMessage))
                    ),
                    className: null,
                    disabled: false,
                    key: savedMessage.Id
                )
            ))
        );
    }
}
</code></pre>
<p>This way, there are 5,000 <strong>MessageRow</strong> constructor calls saved each time that the <strong>MessageTable</strong> needs to re-render. (Under the hood, there is still an object created for each row but it's a very lightweight JavaScript object).</p>
<p>This reduced the &quot;Render&quot; time to 496ms (it didn't affect &quot;receiveComponent&quot;, but I didn't expect it to). This was a good start and made me want to look further into the cost of class instantiation in Bridge.</p>
<h3>Bridge generic classes are more expensive</h3>
<p>I whipped up a quick test to try creating lots of instances of a class, like this:</p>
<pre><code>public static class App
{
    [Ready]
    public static void Main()
    {
        var x = new MyClass[10000];
        var timer = Stopwatch.StartNew();
        for (var i = 0; i &lt; x.Length; i++)
            x[i] = new MyClass(&quot;test&quot;);
        timer.Stop();
        Console.WriteLine(timer.ElapsedMilliseconds + &quot;ms&quot;);
    }
}

public class MyClass
{
    public MyClass(string value)
    {
        Value = value;
    }
    public string Value { get; private set; }
}
</code></pre>
<p>That only reported 3ms, which didn't seem like it could be the source of the problem.</p>
<p>Next I tried going one step more complicated. The <strong>MessageRow</strong> class that I've replaced with a static function was derived from <strong>PureComponent&lt;T&gt;</strong>, which means that each <strong>MessageRow</strong> instantiation also involved an instantiation of a generic base class. Clearly <em>something</em> is still taking up a lot time.. since the <strong>CommonProps&lt;T&gt;</strong> class used for <strong>MessageRow</strong> props was a generic type, maybe it's something specifically to  do with generic types.</p>
<pre><code>public static class App
{
    [Ready]
    public static void Main()
    {
        var x = new MyClass&lt;string&gt;[10000];
        var timer = Stopwatch.StartNew();
        for (var i = 0; i &lt; x.Length; i++)
            x[i] = new MyClass&lt;string&gt;(&quot;test&quot;);
        timer.Stop();
        Console.WriteLine(timer.ElapsedMilliseconds + &quot;ms&quot;);
    }
}

public class MyClass&lt;T&gt;
{
    public MyClass(T value)
    {
        Value = value;
    }
    public T Value { get; private set; }
}
</code></pre>
<p>This time it reported 35ms. Still not an earth-shattering duration in isolation but a big step up from the non-generic class' 3ms.</p>
<p>One of the nice things about Bridge is that it allows you to tweak the way that the JavaScript is generated. By default, it will strike a good balance between creating reasonable JavaScript while also creating code that is faithful to the C# representation. For example, the <strong>MyClass&lt;T&gt;</strong> class will get the following JavaScript definition:</p>
<pre><code>Bridge.define('Demo.MyClass$1', function (T) { return {
    config: {
        properties: {
            Value: Bridge.getDefaultValue(T)
        }
    },
    constructor: function (value) {
        this.setValue(value);
    }
}; });
</code></pre>
<p>It's important that the type param &quot;T&quot; be available as a reference at runtime in case you ever need to access it (such as via a call to &quot;default(T)&quot; or when needing to instantiate another generic type whose type param will also be &quot;T&quot;). If the type &quot;T&quot; was not known to the runtime then it wouldn't be possible for the JavaScript code to do things like create a &quot;default(T)&quot; value appropriate to whatever &quot;T&quot; is; it should be null for a reference type, zero for a numeric type and false for a boolean.</p>
<p>However, this creation of a class that encapsulates the type parameters must incur some overhead. For comparison, the non-generic class is defined in JavaScript with the following (note the lack of the function that captures &quot;T&quot;) -</p>
<pre><code>Bridge.define('Demo.MyClass', {
    config: {
        properties: {
            Value: null
        }
    },
    constructor: function (value) {
        this.setValue(value);
    }
});
</code></pre>
<p>One of the options that Bridge has to affect what JavaScript is emitted is the [IgnoreGeneric] attribute. If this is applied to a class then it <em>won't</em> be given a JavaScript definition that includes the type parameter. This means that we can create a generic C# class (and continue to fully take advantage of the safety of the C# type system) but have Bridge generate a cheaper-to-instantiate JavaScript representation.</p>
<p>There is one problem with this, though. The C# code:</p>
<pre><code>[IgnoreGeneric]
public class MyClass&lt;T&gt;
{
    public MyClass(T value)
    {
        Value = value;
    }
    public T Value { get; private set; }
}
</code></pre>
<p>will result in the following JavaScript:</p>
<pre><code>Bridge.define('Demo.MyClass$1', {
    config: {
        properties: {
            Value: Bridge.getDefaultValue(T)
        }
    },
    constructor: function (value) {
        this.setValue(value);
    }
});
</code></pre>
<p>All properties are set to default values before any instances are created. This is important for cases where there are constructors where one or more properties are not explicitly set since they can't be left undefined. In C#, if you don't set a property on a class instance then it will be left as its default value (null for a reference type, zero for a number, etc..) and Bridge has to maintain this behaviour in JavaScript in order to be consistent. The problem here is that the type &quot;T&quot; is not available and so the &quot;Value&quot; property <em>can't</em> reliably be set to the correct default value.</p>
<p>Since I'm considering tweaking the <strong>CommonProps&lt;T&gt;</strong> class, this doesn't apply - every property will explicitly be set in the constructor and so I don't have to worry about the case of a property needing to be left with the default value for the type.</p>
<p>Thankfully, Bridge has <em>another</em> way to control the JavaScript that will be helpful. The [Template] attribute may be applied to property getters and setters and will change how these are represented. The default is for &quot;setValue(x)&quot; and &quot;getValue()&quot; methods to be created on the class (this may be seen in the above code, where &quot;this.setValue(value)&quot; is called in the constructor). If the getter is marked with [Template(&quot;value&quot;)] then anywhere that would previously have called &quot;getValue()&quot; will now simply access &quot;value&quot; and if the setter is marked with [Template(&quot;this.value&quot;)] then the property-setting (which only happens in the constructor for <strong>CommonProps&lt;T&gt;</strong>) will not be a call to &quot;setValue&quot;, it will simply set &quot;this.value&quot;.</p>
<p>To apply this to the <strong>MyClass&lt;T&gt;</strong> class, the following C#:</p>
<pre><code>[IgnoreGeneric]
public class MyClass&lt;T&gt;
{
    public MyClass(T value)
    {
        Value = value;
    }
    public T Value { [Template(&quot;value&quot;)]get; [Template(&quot;this.value&quot;)]private set; }
}
</code></pre>
<p>would result in the following JavaScript:</p>
<pre><code>Bridge.define('Demo.MyClass$1', {
    constructor: function (value) {
        this.value = value;
    }
});
</code></pre>
<p>Note that the set-properties-to-default-values code is no longer present in the JavaScript class definition.</p>
<p>Also, it's worth noting that this will affect anywhere that the property is accessed by code outside of the class. For example, if there is C# like this:</p>
<pre><code>var x = new MyClass&lt;string&gt;(&quot;test&quot;);
Console.WriteLine(x.Value);
</code></pre>
<p>.. then, instead of the property being accessed through a getter method -</p>
<pre><code>var x = new Demo.MyClass$1(&quot;test&quot;);
Bridge.Console.log(x.getValue());
</code></pre>
<p>.. it will be accessed directly -</p>
<pre><code>var x = new Demo.MyClass$1(&quot;test&quot;);
Bridge.Console.log(x.value);
</code></pre>
<p>This means that the JavaScript is a slightly less faithful representation of the C# code. However, the C# compiler is complete unaware of these changes and it will continue to enforce the type system in the same way that it always does. So (presuming you are writing all of your front end code in C#, using Bridge) you are not losing anything. In fact, there will be some more performance gains to be had by accessing properties directly like this - there is a small overhead to calling functions to return values (small, but not zero) as opposed to retrieving them directly.</p>
<p>If this is applied to <strong>CommonProps&lt;T&gt;</strong> then we get the following:</p>
<pre><code>[IgnoreGeneric]
public sealed class CommonProps&lt;T&gt;
{
    public CommonProps(
        T state,
        Action&lt;T&gt; onChange,
        Optional&lt;ClassName&gt; className,
        bool disabled,
        Optional&lt;Any&lt;string, int&gt;&gt; key)
    {
        if (state == null)
            throw new ArgumentNullException(&quot;state&quot;);
        if (onChange == null)
            throw new ArgumentNullException(&quot;onChange&quot;);

        State = state;
        OnChange = onChange;
        ClassName = className;
        Disabled = disabled;
        Key = key;
    }

    public T State
    {
        [Template(&quot;state&quot;)]get; [Template(&quot;this.state&quot;)]private set;
    }
    public Action&lt;T&gt; OnChange
    {
        [Template(&quot;onChange&quot;)]get; [Template(&quot;this.onChange&quot;)]private set;
    }
    public Optional&lt;ClassName&gt; ClassName
    {
        [Template(&quot;className&quot;)]get; [Template(&quot;this.className&quot;)]private set;
    }
    public bool Disabled
    {
        [Template(&quot;disabled&quot;)]get; [Template(&quot;this.disabled&quot;)]private set;
    }
    public Optional&lt;Any&lt;string, int&gt;&gt; Key
    {
        [Template(&quot;key&quot;)]get; [Template(&quot;this.key&quot;)]private set;
    }
}
</code></pre>
<p>In order to do this, <strong>CommonProps&lt;T&gt;</strong> could no longer be an <strong>IAmImmutable</strong> type since the &quot;CtorSet&quot; and &quot;With&quot; methods won't work with properties that rely upon any fancy shenanigans like [Template]. This isn't a huge deal with the props on components since they are always created fresh for every render, unlike the other data types that represent state. For example, when the title value of a single row is edited, a new <strong>MessageEditState</strong> instance is created using something like the following:</p>
<pre><code>newMessage = currentMessage.With(_ =&gt; _.Title, newTitle)
</code></pre>
<p>This is important for two reasons. Firstly, if &quot;newTitle&quot; is the same as the current title (which can happen if the user does something to a text box that doesn't actually change its value - such as when pasting a value into the box that is the same as the current value; React will identfy this as an input change even though the value hasn't actually been altered) then a new message instance is <em>not</em> created. When the <strong>MessageRow</strong> is re-rendered, because the <strong>MessageEditState</strong> reference won't have changed, the <strong>PureComponent</strong> logic will tell React that there is no need to re-render the row, which saves React some work. Secondly, it's very convenient to be able to get a new instance of a data type with a single property changed in this manner - otherwise you would have to deal with the has-this-value-really-changed logic and either define &quot;With{x}&quot; methods for each individual property or call the constructor with the value that has changed <em>and</em> all of the ones that haven't. Which gets old very quickly. (You <em>could</em> use mutable data types but then you wouldn't be able perform inexpensive reference equality checks when trying to determine whether a component needs to re-render and so you end up contemplating expensive deep equality checks or you give up on implementing &quot;shouldComponentUpdate&quot; and force React to do much more work).</p>
<p>One final note: the CtorSet method that <strong>IAmImmutable</strong> types can use ensures that no value is ever null (if you have a property that may or may not have a value then use the <strong>Optional&lt;T&gt;</strong> type - which can never be null itself since it's a struct). Since <strong>CommonProps&lt;T&gt;</strong> isn't using CtorSet any more, the constructor needs to include explicit checks for null &quot;state&quot; and &quot;onChange&quot; constructor arguments.</p>
<p>With this change to <strong>CommonProps&lt;T&gt;</strong>, the &quot;Render&quot; time is now 124ms in the React development build. Interestingly, in the React production, the &quot;Render&quot; time is reduced to 69ms and the &quot;receiveComponent&quot; drops to 98ms. A combined 167ms is much better than the original 838ms.</p>
<p>With these improvements, there is only a slightly perceptible delay felt when clicking a checkbox. Unfortunately, though, trying to type into a text box when there is a 167ms delay between key presses being recognised is not pleasant. So it's back to the profiler..</p>
<h3>Optional&lt;T&gt;</h3>
<p>Taking another snapshot with the profiler, I'm still going to concentrate on the &quot;Render&quot; method (for the same reasons as before; it's still the slower part of the work and it's still what I can most easily control). This time I see a lot of calls to a generic constructor resulting from &quot;op_Implicit&quot; calls.</p>
<img alt="Unnecessary Optional instantiation" src="/Content/Images/Posts/BridgeReactProfiling2.png" class="NoBorder FullWidth" title="Unnecessary Optional instantiation" />
<p>The &quot;op_Implicit&quot; methods are the JavaScript representations of implicit operator methods in C#. So, where the <strong>Optional&lt;T&gt;</strong> struct has an implicit operator from &quot;T&quot; -</p>
<pre><code>public static implicit operator Optional&lt;T&gt;(T value)
{
    return new Optional&lt;T&gt;(value);
}
</code></pre>
<p>the following JavaScript is generated:</p>
<pre><code>op_Implicit: function (value) {
    return new (ProductiveRage.Immutable.Optional$1(T)).$constructor1(value);
}
</code></pre>
<p>When a <strong>CommonProps</strong> instance is created with a null &quot;className&quot; argument (which is the case for every <strong>MessageRow</strong> in the sample app), each call to the <strong>CommonProps</strong> &quot;For&quot; method requires the null reference to be implicitly cast to an <strong>Optional&lt;ClassName&gt;</strong>.</p>
<pre><code>public static CommonProps&lt;T&gt; For&lt;T&gt;(
    T state,
    Action&lt;T&gt; onChange,
    Optional&lt;ClassName&gt; className,
    bool disabled,
    Any&lt;string, int&gt; key)
</code></pre>
<p>Each implicit cast requires a call to the implicit operator, which creates a new <strong>Optional&lt;ClassName&gt;</strong> instance. This feels like unnecessary work.</p>
<p>The <strong>Optional&lt;T&gt;</strong> has a public static &quot;Missing&quot; property, so one way to avoid the creation of unnecessary instances would be to use</p>
<pre><code>className: Optional&lt;ClassName&gt;.Missing
</code></pre>
<p>instead of</p>
<pre><code>className: null
</code></pre>
<p>But there were a few problems with this. Firstly, <strong>Optional&lt;T&gt;</strong> is part of the ProductiveRage.Immutable library and I would like it to be as easy to use as possible. I think that it would be quite difficult to justify a significant performance cost in passing null as an Optional rather than &quot;Missing&quot; when there is an implicit cast to perform the translation. Secondly, the &quot;Missing&quot; property was implemented as</p>
<pre><code>    public static Optional&lt;T&gt; Missing { get { new Optional&lt;T&gt;(default(T), false); } }
</code></pre>
<p>.. which means that a new instance is created each time it's called anyway, so actually the &quot;Missing&quot; property wouldn't magically solve anything.</p>
<p>It would make more sense for the &quot;Missing&quot; property to be set only once, something like:</p>
<pre><code>public static Optional&lt;T&gt; Missing { get { return _missing; } }
private static Optional&lt;T&gt; _missing = new Optional&lt;T&gt;(default(T), false);
</code></pre>
<p>When I first wrote the <strong>Optional&lt;T&gt;</strong> struct, that is how I did it. Unfortunately, there was a problem with Bridge 1.10 and I removed the private &quot;_missing&quot; field as a workaround. The Bridge Team have long since resolved that issue and so I can put the code back how I want it.</p>
<p>This also allows for a tweak to the implicit operator method -</p>
<pre><code>public static implicit operator Optional&lt;T&gt;(T value)
{
    if (value == null)
        return _missing;
    return new Optional&lt;T&gt;(value);
}
</code></pre>
<p>Now, one might presume, there would now be no unnecessary instantiations whether &quot;className: Optional&lt;ClassName&gt;.Missing&quot; <em>or</em> &quot;className: null&quot; was specified. Unfortunately, we're not quite there yet..</p>
<p>When structs are passed around in C#, they are copied. This is why they appear to be passed &quot;by value&quot; rather than &quot;by reference&quot; - if a mutable struct is instantiated in method F1 and passed to F2, any changes made to it in F2 are not visible in F1 since they both have different copies of the struct. To ensure consistency with .net, Bridge's JavaScript must do something similar - any time that a struct is passed around, it is copied. This means that a new instance <em>will</em> be created each time that &quot;Missing&quot; or &quot;_missing&quot; is accessed. This is wasteful with the <strong>Optional&lt;T&gt;</strong> struct since it's immutable; since nothing can alter its contents, there is no need to copy it when passing it around.</p>
<p>Bridge has another workaround for this, the [Immutable] attribute. When applied to the <strong>Optional&lt;T&gt;</strong> struct, the Bridge compiler will not copy instances when they are passed from one method to another. These changes reduce the &quot;Render&quot; time to 93ms in the React development build and 61ms in production.</p>
<p>While this is an improvement, I can still see what looks like a lot of time spent on generic type <em>stuff</em> in the profiler. Even though the op_Implicit calls for null values are sharing instances now, in order to get to the static op_Implicit method it is necessary to access the representation of the <strong>Optional&lt;T&gt;</strong> struct for the particular type. And, I suspect, this incurs a similar cost to instantiating a new instance.</p>
<p>To confirm this, I added [IgnoreGeneric] to <strong>Optional&lt;T&gt;</strong>. This was not something I really wanted to do since it would require a minor change to the struct's public interface. There are two properties; IsDefined and Value. Currently there are two states - a state where IsDefined is true and Value has a specified &quot;T&quot; value and a state where IsDefined is false and Value has the default value of &quot;T&quot; (null for a reference type, zero for a number). With the [IgnoreGeneric] attribute, it would not be possible to set the default value of &quot;T&quot; for the &quot;Missing&quot; value state since &quot;T&quot; would not be available at runtime. If I was to apply [IgnoreGeneric] to the struct then &quot;Value&quot; would have to be considered undefined if IsDefined was false. This isn't a huge deal since I think that that's how it should have been interpreted anyway, really (an alternative would have been to be more aggressive and throw an exception from the Value property getter if IsDefined is false) but it's still a change.</p>
<p>When I added [IgnoreGeneric] to the <strong>CommonProps&lt;T&gt;</strong> class, I had to apply some workarounds to deal with the type &quot;T&quot; not being available at runtime. I had to do similar with <strong>Optional&lt;T&gt;</strong>. The first change was that the following line clearly wouldn't work:</p>
<pre><code>private static Optional&lt;T&gt; _missing = new Optional&lt;T&gt;(default(T), false);
</code></pre>
<p>so it was replaced with this:</p>
<pre><code>private static Optional&lt;T&gt; _missing = new Optional&lt;T&gt;(Script.Write&lt;T&gt;(&quot;null&quot;), false);
</code></pre>
<p>The &quot;Script.Write&lt;T&gt;&quot; method in Bridge is a way to directly emit JavaScript (simply &quot;null&quot; in this case) and to tell the C# type system that a value of type &quot;T&quot; is being returned. So, here, the &quot;T&quot; is only used by the C# compiler and does not have any impact on runtime. The compromise is that &quot;null&quot; is being used for the Value property of the &quot;Missing&quot; instance regardless of the type of &quot;T&quot;. So Value will be null even if &quot;T&quot; is an int or a bool in cases where IsDefined is false.</p>
<p>The other change required completely removing the C# backing field for the Value property -</p>
<pre><code>private readonly T value;
</code></pre>
<p>The problem was that Bridge would generate a struct definition that would try to set &quot;value&quot; to default(T), which it would not be able to do since &quot;T&quot; would not be available at runtime.</p>
<p>Instead, the value would be written directly by more raw JavaScript. The constructor changed from:</p>
<pre><code>public Optional(T value) : this(value, value != null) { }
    this.isDefined = isDefined &amp;&amp; (value != null);
    this.value = value;
}
</code></pre>
<p>to:</p>
<pre><code>public Optional(T value) : this(value, value != null) { }
    this.isDefined = isDefined &amp;&amp; (value != null);
    Script.Write(&quot;this.value = {0}&quot;, value);
}
</code></pre>
<p>and the property getter changed from:</p>
<pre><code>public T Value { get { return this.value; } }
</code></pre>
<p>to:</p>
<pre><code>public T Value { get { return Script.Write&lt;T&gt;(&quot;this.value&quot;); } }
</code></pre>
<p>Finally, anywhere in the struct that the backing field was accessed was changed so that it went via the public &quot;Value&quot; property getter.</p>
<p>This meant that there were no potential runtime errors waiting to occur within the struct (none of the code relied on access to the type &quot;T&quot;), that there was type safety for any code instantiating or accessing the struct in C# <em>and</em> it meant that the struct could have [IgnoreGeneric] applied and hence (theoretically) allow the application to work more efficiently.</p>
<p>It worked. Using the development build of React, the &quot;Render&quot; time of the <strong>MessageTable</strong> was now 36ms and the &quot;receiveComponent&quot; time 141ms. With the production build, &quot;Render&quot; took &quot;9ms&quot; and &quot;receiveComponent&quot; 49ms.</p>
<p>That's sufficiently fast that there is no perceived delay while typing into the text boxes. And, to put things back into context, the original &quot;worst case scenario&quot; that I was planning for was to deal with up to 1,000 checkboxes. I've been measuring the time for 5,000 rows that include two text boxes <em>and</em> a checkbox. If the sample app was changed to render only 1,000 rows then the React production build handles changes to elements by spending 5ms in &quot;Render&quot; and 17ms in &quot;receiveComponent&quot;. This means that there is no chance of perceptible lag in typing and certainly no perceptible delay in checking or unchecking a checkbox.</p>
<h3>To summarise</h3>
<p>I think that it's fair to call this a success! There are several things that I've particuarly enjoyed in this investigation. Firstly, it's been a good reminder of just how powerful the dev tools are that come free with browsers these days. I was using Chrome but I believe that IE and Firefox have equivalent functionality. Secondly, the options that the Bridge Team have made available are really well thought out and very clever when you examine them - in isolation, each seems quite simple but it's the recognition that <em>sometimes</em> it might be beneficial to have more control over the generated JavaScript that helps make Bridge so powerful and to enable me to do what I've done here. Thirdly, almost all of the changes that I've talked about here were made to my &quot;Bridge.React&quot;, &quot;ProductiveRage.Immutable&quot;, &quot;ProductiveRage.Immutable.Extensions&quot; libraries. That means that, when I make these changes live, anyone using those libraries will automatically reap the benefit. The only change that I made to the sample app was to change the <strong>MessageRow</strong> implementation from being a component class to being a static function.</p>
<p><em>Note: I tried reverting <strong>MessageRow</strong> back to being a component class and the &quot;Render&quot; time was still only 20ms when editing one of 1,000 rows (compared to 5ms when <strong>MessageRow</strong> is implemented as a static function). The time spent by React in &quot;receiveComponent&quot; was unaffected. This means that simply updating the Bridge.React, ProductiveRage.Immutable and ProductiveRage.Immutable.Extensions packages could significantly improve the performance of complex applications with zero code changes.</em></p>
<p>This is one of the benefits of using libraries where the authors care about performance and strive to improve it over time. It reminds me of when the Bridge Team added compiler support for &quot;<a href="http://bridge.net/bridge-1-11-released/#Lifted_Anonymous_Functions">Lifted Anonyomous Functions</a>&quot; (something I suggested after going on a bit of a JavaScript performance research binge a few months ago - but something that the team there deserve much credit for making work) and it reminds me of articles that I've read about React which talk about how there are many optimisations yet to be made that their current API will make possible (see &quot;<a href="https://github.com/acdlite/react-fiber-architecture">React Fiber Architecture</a>&quot;); all that we'll have to do in the future is upgrade the version of the library being used and get more performance!</p>
<h3>Update: The Bridge Team ruin my fun</h3>
<p>I've been researching and writing this post over the space of a couple of weeks. Once I had observed that generic classes are slower to instantiate in Bridge than non-generic classes, and while I was looking into the workarounds required sometimes in order to use [IgnoreGeneric], I raised a bug on the <a href="http://forums.bridge.net/forum/bridge-net-pro/bugs">Bridge Forums</a> relating to properties that are initially to default(T) (which fails when &quot;T&quot; is not available at runtime).</p>
<p>While looking into the issue for me, they noted that they found a way to optimise the instantiation of generic types (looking at the <a href="https://github.com/bridgedotnet/Bridge/pull/1740/files">pull request</a> it seems like the work required to form a new specialisation of a class / struct for a given &quot;T&quot; is now cached rather than being repeated each time that a new <strong>Whatever&lt;T&gt;</strong> is created).</p>
<p>The good news is that this means that there will very soon be almost zero overhead to generic types in Bridge! The bad news is that many of the findings documented here are unnecessary.. However, that's the sort of bad news that I'm happy to accept! The compromise around <strong>Optional&lt;T&gt;</strong>'s &quot;Value&quot; property (for cases where &quot;IsDefined&quot; is false) will no longer be necessary. And I won't have to worry so much in the future; if I'm creating a library class, should I be avoiding generics (or using [IgnoreGeneric]) in case it's used in an expensive loop anywhere?</p>
<p>Despite being out of date even before being published, I'll leave this post here for posterity. I had a lot of fun digging into performance tuning my Bridge / React app. And, in a roundabout way, I feel like I contributed to the optimisation (which I imagine will makes its way into the next release of Bridge) that everyone using Bridge can benefit from! I'm going to call that a win.</p>
<p class="PostTime">Posted at 22:04</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/writing-react-apps-using-bridgenet-the-dan-way-part-three">Writing React apps using Bridge.NET - The Dan Way (Part Three)</a></li><li><a href="/easy-purecomponent-react-performance-boosts-for-bridgenet">Easy &quot;PureComponent&quot; React performance boosts for Bridge.Net</a></li><li><a href="/react-and-flux-with-bridgenet-redux">React (and Flux) with Bridge.net - Redux</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/Performance" title="2 Posts">Performance</a></li></ul></div>
            <p class="Comments">
                <a href="/performance-tuning-a-bridgenet-react-app#disqus_thread" data-disqus-identifier="105">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">4 May 2016</p><h2><a id="using-roslyn-code-fixes-to-make-the-frictionless-immutable-objects-in-bridge-even-easier" href="/using-roslyn-code-fixes-to-make-the-frictionless-immutable-objects-in-bridge-even-easier">Using Roslyn code fixes to make the &quot;Friction-less immutable objects in Bridge&quot; even easier</a></h2>
<p>This is going to be a short post about a Roslyn (or &quot;The .NET Compiler Platform&quot;, if you're from Microsoft) analyser and code fix that I've added to a library. I'm not going to try to take you through the steps required to create an analyser nor how the Roslyn object model describes the code that you've written in the IDE* but I want to talk about the analyser itself because it's going to be very useful if you're one of the few people using my <a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a> library. Also, I feel like the inclusion of analysers with libraries is something that's going to become increasingly common (and I want to be able to have something to refer back to if I get the chance to say &quot;told you!&quot; in the future).</p>
<p>* <em>(This is largely because I'm still struggling with it a bit myself; my current process is to start with <a href="https://msdn.microsoft.com/en-gb/magazine/dn879356.aspx">Use Roslyn to Write a Live Code Analyzer for Your API</a> and the &quot;Analyzer with Code Fix (NuGet + VSIX)&quot; Visual Studio template. I then tinker around a bit and try running what I've got so far, so that I can use the &quot;Syntax Visualizer&quot; in the Visual Studio instance that is being debugged. Then I tend to do a lot of Google searches when I feel like I'm getting close to something useful.. how do I tell if a <strong>FieldDeclarationSyntax</strong> is for a readonly field or not? Oh, good, someone else has already written some code doing something like what  I want to do - I look at the &quot;Modifiers&quot; property on the <strong>FieldDeclarationSyntax</strong> instance).</em></p>
<p>As new .net libraries get written, some of them will have guidelines and rules that can't easily be described through the type system. In the past, the only option for such rules would be to try to ensure that the documentation (whether this be the project README and / or more in-depth online docs and / or the xml summary comment documentation for the types, methods, properties and fields that intellisense can bring to your attention in the IDE). The support that Visual Studio 2015 introduced for customs analysers* allows these rules to be communicated in a different manner.</p>
<p>* <em>(I'm being English and stubborn, hence my use of &quot;analysers&quot; rather than &quot;analyzers&quot;)</em></p>
<p>In short, they allow these library-specific guidelines and rules to be higlighted in the Visual Studio Error List, just like any error or warning raised by Visual Studio itself (even refusing to allow the project to be built, if an error-level message is recorded).</p>
<p>An excellent example that I've seen recently was encountered when I was writing some of my own analyser code. To do this, you can start with the &quot;Analyzer with Code Fix (NuGet + VSIX)&quot; template, which pulls in a range of NuGet packages and includes some template code of its own. You then need to write a class that is derived from <strong>DiagnosticAnalyzer</strong>. Your class will declare one of more <strong>DiagnosticDescriptor</strong> instances - each will be a particular rule that is checked. You then override an &quot;Initialize&quot; method, which allows your code to register for syntax changes and to raise any rules that have been broken. You must also override a &quot;SupportedDiagnostics&quot; property and return the set of <strong>DiagnosticDescriptor</strong> instances (ie. rules) that your analyser will cover. If the code that the &quot;Initialize&quot; method hooks up tries to raise a rule that &quot;SupportedDiagnostics&quot; did not declare, the rule will be ignored by the analysis engine. This would be a kind of (silent) runtime failure and it's something that is documented - but it's still a very easy mistake to make; you might create a new <strong>DiagnosticDescriptor</strong> instance and raise it from your &quot;Initialize&quot; method but forget to add it to the &quot;SupportedDiagnostics&quot; set.. whoops. In the past, you may not realise until runtime that you'd made a mistake and, as a silent failure, you might end up getting very frustrated and be stuck wondering what had gone wrong. But, mercifully (and I say this as I made this very mistake), there is an analyser in the &quot;Microsoft.CodeAnalysis.CSharp&quot; NuGet package that brings this error immediately to your attention with the message:</p>
<blockquote>
<p>RS1005 ReportDiagnostic invoked with an unsupported DiagnosticDescriptor</p>
</blockquote>
<p>The entry in the Error List links straight to the code that called &quot;context.ReportDiagnostic&quot; with the unexpected rule. This is fantastic - instead of suffering a runtime failure, you are informed at compile time precisely what the problem is. Compile time is <em>always</em> better than run time (for many reasons - it's more immediate, so you don't have to <em>wait</em> until runtime, and it's more thorough; a runtime failure may only happen if a particular code path is followed, but static analysis such as this is like having <em>every possible</em> code path tested).</p>
<h3>The analysers already in ProductiveRage.Immutable</h3>
<p>The ProductiveRage uber-fans (who, surely exist.. yes? ..no? :D) may be thinking &quot;doesn't the ProductiveRage.Immutable library already have some analysers built into it?&quot;</p>
<p>And they would be correct, for some time now it has included a few analysers that try to prevent some simple mistakes. As a quick reminder, the premise of the library is that it will make creating immutable types in <a href="http://www.bridge.net">Bridge.NET</a> easier.</p>
<p>Instead of writing something like this:</p>
<pre><code>public sealed class EmployeeDetails
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
    if (id == null)
      throw new ArgumentNullException(&quot;id&quot;);
    if (name == null)
      throw new ArgumentNullException(&quot;name&quot;);

    Id = id;
    Name = name;
  }

  /// &lt;summary&gt;
  /// This will never be null
  /// &lt;/summary&gt;
  public PersonId Id { get; }

  /// &lt;summary&gt;
  /// This will never be null
  /// &lt;/summary&gt;
  public NameDetails Name { get; }

  public EmployeeDetails WithId(PersonId id)
  {
    return Id.Equals(id) ? this : return new EmployeeDetails(id, Name);
  }
  public EmployeeDetails WithName(NameDetails name)
  {
    return Name.Equals(name) ? this : return new EmployeeDetails(Id, name);
  }
}
</code></pre>
<p>.. you can express it just as:</p>
<pre><code>public sealed class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
    this.CtorSet(_ =&gt; _.Id, id);
    this.CtorSet(_ =&gt; _.Name, name);
  }
  public PersonId Id { get; }
  public NameDetails Name { get; }
}
</code></pre>
<p>The if-null-then-throw validation is encapsulated in the CtorSet call (since the library takes the view that no value should ever be null - it introduces an <strong>Optional</strong> struct so that you can identify properties that may be without a value). And it saves you from having to write &quot;With&quot; methods for the updates as <strong>IAmImmutable</strong> implementations may use the &quot;With&quot; extension method whenever you want to create a new instance with an altered property - eg.</p>
<pre><code>var updatedEmployee = employee.With(_ =&gt; _.Name, newName);
</code></pre>
<p>The library can only work if certain conditions are met. For example, every property must have a getter and a setter - otherwise, the &quot;CtorSet&quot; extension method won't know how to actually set the value &quot;under the hood&quot; when populating the initial instance (nor would the &quot;With&quot; method know how to set the value on the new instance that it would create).</p>
<p>If you forgot this and wrote the following (note the &quot;DisplayNameLength&quot; property that is now effectively a computed value and there would be no way for us to directly set it via a &quot;With&quot; call) -</p>
<pre><code>public sealed class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
    this.CtorSet(_ =&gt; _.Id, id);
    this.CtorSet(_ =&gt; _.Name, name);
  }
  public PersonId Id { get; }
  public NameDetails Name { get; }
  public int DisplayNameLength { get { return Name.DisplayName.Length; } }
}
</code></pre>
<p>.. then you would see the following errors reported by Visual Studio (presuming you are using 2015 or later) -</p>
<p><img src="/Content/Images/Posts/ProductiveRageImmutableAnalyserError1.png" alt="Example analyser errors raised by the ProductiveRage.Immutable library" title="Example analyser errors raised by the ProductiveRage.Immutable library" /></p>
<p>.. which is one of the &quot;common IAmImmutable mistakes&quot; analysers identifying the problem for you.</p>
<h3>Getting Visual Studio to write code for you, using code fixes</h3>
<p>I've been writing more code with this library and I'm still, largely, happy with it. Making the move to assuming never-allow-null (which is baked into the &quot;CtorSet&quot; and &quot;With&quot; calls) means that the classes that I'm writing are a lot shorter and that type signatures are more descriptive. (I wrote about all this in my post at the end of last year &quot;<a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a>&quot; if you're curious for more details).</p>
<p>However.. I <em>still</em> don't really like typing out as much code for each class as I have to. Each class has to repeat the property names four times - once in the constructor, twice in the &quot;CtorSet&quot; call and a fourth time in the public property. Similarly, the type name has to be repeated twice - once in the constructor and once in the property.</p>
<p>This is better than the obvious alternative, which is to not bother with immutable types. I will gladly take the extra lines of code (and the effort required to write them) to get the additional confidence that a &quot;stronger&quot; type system offers - I wrote about this recently in my &quot;<a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">Writing React with Bridge.NET - The Dan Way</a>&quot; posts; I think that it's really worthwhile to bake assumptions into the type system where possible. For example, the Props types of React components are assumed, by the React library, to be immutable - so having them defined as immutable types represents this requirement in the type system. If the Props types are <em>mutable</em> then it would be possible to write code that tries to change that data and then bad things could happen (you're doing something that library expects not to happen). If the Props types are <em>immutable</em> then it's not even possible to write this particular kind of bad-things-might-happen code, which is a positive thing.</p>
<p>But <em>still</em> I get a niggling feeling that things could be better. And now they are! With Roslyn, you can not only identify particular patterns but you can also offer automatic fixes for them. So, if you were to start writing the <strong>EmployeeDetails</strong> class from scratch and got this far:</p>
<pre><code>public sealed class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
  }
}
</code></pre>
<p>.. then an analyser could identify that you were writing an <strong>IAmImmutable</strong> implementation and that you have an empty constructor - it could then offer to fix that for you by filling in the rest of the class.</p>
<p>The latest version of the ProductiveRage.Immutable library (1.7.0) does just that. The empty constructor will not only be identified with a warning but a light bulb will also appear alongside the code. Clicking this (or pressing [Ctrl]-[.] while within the empty constructor, for fellow keyboard junkies) will present an option to &quot;Populate class from constructor&quot; -</p>
<p><img src="/Content/Images/Posts/ProductiveRageImmutableAnalyserCodeFix1.png" alt="Screenshot showing the analyser identifying an empty constructor on an IAmImmutable implementation" title="Screenshot showing the analyser identifying an empty constructor on an IAmImmutable implementation" /></p>
<p>Selecting the &quot;Populate class from constructor&quot; option -</p>
<p><img src="/Content/Images/Posts/ProductiveRageImmutableAnalyserCodeFix2.png" alt="Screenshot showing the code fix that may auto-populate the incomplete IAmImmutable implementation" title="Screenshot showing the code fix that may auto-populate the incomplete IAmImmutable implementation" /></p>
<p>.. will take the constructor arguments and generate the &quot;CtorSet&quot; calls and the public properties automatically. Now you can have all of the safety of the immutable type with no more typing effort than the mutable version!</p>
<pre><code>// This is what you have to type of the immutable version,
// then the code fix will expand it for you
public sealed class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(PersonId id, NameDetails name)
  {
  }
}

// This is what you would have typed if you were feeling
// lazy and creating mutable types because you couldn't
// be bothered with the typing overhead of immutability
public sealed class EmployeeDetails
{
  public PersonId Id;
  public NameDetails name;
}
</code></pre>
<h3>To summarise</h3>
<p>If you're already using the library, then all you need to do to start taking advantage of this code fix is update your NuGet reference* (presuming that you're using VS 2015 - analysers weren't supported in previous versions of Visual Studio).</p>
<p>* <em>(Sometimes you have to restart Visual Studio after updating, you will know that this is the case if you get a warning in the Error List about Visual Studio not being able to load the Productive.Immutable analyser)</em></p>
<p>If you're writing your own library that has any guidelines or common gotchas that you have to describe in documentation somewhere (that the users of your library may well not read unless they have a problem - at which point they may even abandon the library, if they're only having an investigative play around with it) then I highly recommend that you consider using analysers to surface some of these assumptions and best practices. While I'm aware that I've not offered much concrete advice on <em>how</em> to write these analysers, the reason is that I'm still very much a beginner at it - but that puts me in a good position to be able to say that it really is fairly easy if you read a few articles about it (such as <a href="https://msdn.microsoft.com/en-gb/magazine/dn879356.aspx">Use Roslyn to Write a Live Code Analyzer for Your API</a>) and then just get stuck in. With some judicious Google'ing, you'll be making progress in no time!</p>
<p>I guess that only time will tell whether library-specific analysers become as prevalent as I imagine. It's very possible that I'm biased because I'm such a believer in static analysis. Let's wait and see*!</p>
<p>* <em>Unless YOU are a library writer that this might apply to - in which case, make it happen rather than just sitting back to see what MIGHT happen! :)</em></p>
<p class="PostTime">Posted at 22:33</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/using-roslyn-to-identify-unused-and-undeclared-variables-in-vbscript-wsc-components">Using Roslyn to identify unused and undeclared variables in VBScript WSC components</a></li><li><a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/using-roslyn-code-fixes-to-make-the-frictionless-immutable-objects-in-bridge-even-easier#disqus_thread" data-disqus-identifier="99">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">30 March 2016</p><h2><a id="writing-react-apps-using-bridgenet-the-dan-way-part-three" href="/writing-react-apps-using-bridgenet-the-dan-way-part-three">Writing React apps using Bridge.NET - The Dan Way (Part Three)</a></h2>
<p>In parts <a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">One</a> and <a href="/writing-react-apps-using-bridgenet-the-dan-way-part-two">Two</a>, I described how to create a simple application using React and a Flux-like architecture, written in <a href="http://bridge.net/">Bridge.NET</a> - it covered where and how to deal with validation, how to integrate with a persistence layer, how to deal with asynchronous interactions (and how they don't need to be scary) and how the approach made the code easy to test and easy to reason about.</p>
<p>The components created using the <a href="https://www.nuget.org/packages/Bridge.React">React / Bridge bindings</a> have their requirements / dependencies described in a strongly-typed manner since each component's &quot;props&quot; reference is a nested class with properties for each value or reference that will be needed in order for it to render.</p>
<p>This combination of technologies has the potential to be really powerful for writing client-side / browser-based applications, particularly with the ability to leverage C#'s proven strength in allowing the writing of large and reliable systems. However, I'm not happy with the example application yet. Although the way that it's written makes a lot of it easy to understand and, hopefully, makes the <em>intent</em> of the code clear, it still could be <em>even easier</em> to understand and the intent and the requirements <em>even clearer</em>.</p>
<p>People often like to talk as if a language is dynamically-typed (or &quot;non-typed&quot; or &quot;uni-typed&quot;, depending upon the language, their vocabulary and their knowledge and opinion of the language) or statically-typed; as if it is a binary choice. Really, it is a sliding scale. C# definitely sits on the &quot;statically-typed <em>side</em>&quot;, but the way that you write C# dictates how far along the scale that <em>your C#</em> is.</p>
<p><em>(C# can also be written to act as a dynamically-typed language, particularly if you use the &quot;<a href="https://msdn.microsoft.com/en-us/library/dd264741.aspx">dynamic</a>&quot; keyword - but it's principally a statically-typed language).</em></p>
<p>I'm going to describe some ways to improve the example application and, in doing so, extrapolate some rules as to how to make the code clearer (and, <em>again</em>, easier to reason about, write and maintain - since these are extremely important qualities of code to me, that I strive for when developing and that appealed to me when I first encountered React). These will be my opinions (based upon my experiences) and you might disagree with them - but this is where we really get into &quot;The Dan Way&quot; of working with Bridge and React. If you <em>do</em> choose to disagree, then hopefully parts <a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">One</a> and <a href="/writing-react-apps-using-bridgenet-the-dan-way-part-two">Two</a> will continue to be useful (but I'm afraid we can never be friends*).</p>
<p>* <em>(Only joking**)</em></p>
<p>** <em>(I'm not)</em></p>
<h3>Clarification through a richer type system</h3>
<p>Let's jump straight in with a simple example. We have a <strong>TextInput</strong> component that renders a text input element and passes up any requests by the user that the input's content be changed. The main primary purpose of this class is to provide a simple interface. Many of the html attributes that <em>may</em> be applied to a text input are not relevant (this exposes only the basics, such as &quot;ClassName&quot;). Similarly, the &quot;OnChange&quot; that a text input raises has a relatively complicated event reference (it allows you to identify the element that changed and then get the requested &quot;new value&quot; from it, but I want a <strong>TextInput</strong>'s &quot;OnChange&quot; event to simply provide the new string and nothing else).</p>
<pre><code>using System;
using Bridge.Html5;
using Bridge.React;

namespace BridgeReactTutorial.Components
{
  public class TextInput : StatelessComponent&lt;TextInput.Props&gt;
  {
    public TextInput(Props props) : base(props) { }

    public override ReactElement Render()
    {
      return DOM.Input(new InputAttributes
      {
        Type = InputType.Text,
        ClassName = props.ClassName,
        Disabled = props.Disabled,
        Value = props.Content,
        OnChange = e =&gt; props.OnChange(e.CurrentTarget.Value)
      });
    }

    public class Props
    {
      public string ClassName;
      public bool Disabled;
      public string Content;
      public Action&lt;string&gt; OnChange;
    }
  }
}
</code></pre>
<p>In the context of this small class, looking at the code, I would say that it's fairly clear what each line of code does and what each of the properties of the <strong>Props</strong> class is required for and how it will be used. However, even within such a small class, there are several implicit assumptions that are being made - eg.</p>
<ol>
<li>ClassName is optional, it may be null.. or it may be blank - React will actually treat these two cases differently, do we really want that? If it's null then no &quot;class&quot; attribute will be present on the input element, but if it's blank then a &quot;class&quot; attribute <em>will</em> be added (but with no value).</li>
<li>Content is treated in the same way but probably shouldn't be - does it really make sense for Content to potentially be null? Blank, yes; if there's no user-entered content. But null? Probably not.</li>
<li>OnChange is <em>not</em> optional - if it's null then a null reference exception is going to be thrown when the user attempts to change the value in the input box (because &quot;props.OnChange&quot; will be called like a function, which will fail if it's null).</li>
</ol>
<p>First off, I don't like the should-or-shouldn't-be-allowed-to-be-null confusion around the &quot;ClassName&quot; and &quot;Content&quot; values. Secondly, I don't like the fact that, as it stands, you need to read (or already be familiar with) the code inside the <strong>TextInput</strong> component. One way to try to address these issues would be to consider using summary comments on the <strong>Props</strong> class - eg.</p>
<pre><code>public class Props
{
  /// &lt;summary&gt;
  /// This is optional and so may be null (if non-null, then it should be a valid class
  /// name - ie. non-blank)
  /// &lt;/summary&gt;
  public string ClassName;

  public bool Disabled;

  /// &lt;summary&gt;
  /// An input may not always have a value and so this may be blank (but it should never
  /// be null)
  /// &lt;/summary&gt;
  public string Content;

  /// &lt;summary&gt;
  /// This is mandatory and may never be null
  /// &lt;/summary&gt;
  public Action&lt;string&gt; OnChange;
}
</code></pre>
<p>The problem with this approach is that, if the comments are ignored, runtime problems will occur at some point and it may not be very easy to trace them back to where they originated. If the &quot;OnChange&quot; value is null, for example, then the problem won't be noticed until the user interacts with the input box - and the code that raises the exception (the &quot;props.OnChange&quot; call with <strong>TextInput</strong>'s &quot;Render&quot; method) will be completely removed from the code that incorrectly set the null value (the code that instantiated and populated <strong>Props</strong> instance).</p>
<p>So another alternative would be to combine these comments with some validation - eg.</p>
<pre><code>public class Props
{
  private string _className, _content;
  private Action&lt;string&gt; _onChange;

  /// &lt;summary&gt;
  /// This is optional and so may be null (if non-null, then it should be a valid class
  /// name - ie. non-blank)
  /// &lt;/summary&gt;
  public string ClassName
  {
    get { return _className; }
    set
    {
      if (value == &quot;&quot;)
        throw new ArgumentException(&quot;ClassName should not be set to a blank string&quot;);
      _className = value;
    }
  }

  public bool Disabled { get; set; }

  /// &lt;summary&gt;
  /// An input may not always have a value and so this may be blank (but it should never
  /// be null)
  /// &lt;/summary&gt;
  public string Content
  {
    get { return _content; }
    set
    {
      if (value == null)
        throw new ArgumentNullException(&quot;Content should not be set to null&quot;);
      _content = value;
    }
  }

  /// &lt;summary&gt;
  /// This is mandatory and may never be null
  /// &lt;/summary&gt;
  public Action&lt;string&gt; OnChange
  {
    get { return _onChange; }
    set
    {
      if (value == null)
        throw new ArgumentNullException(&quot;OnChange should not be set to null&quot;);
      _onChange = value;
    }
  }
}
</code></pre>
<p>This way, it would not be possible to explicitly set &quot;OnChange&quot; to null - if this was attempted then an exception would be thrown immediately, right at the point in the code that was attempting to assign this invalid value. This is much better than it failing later on, at some point that depends upon how the user does or doesn't interact with the UI component. This is potentially the sort of mistake that goes unnoticed for some time. For cases that are clearly a &quot;programmer error&quot; bug like this, I much prefer to &quot;fail fast&quot;.</p>
<p>There's still a problem, though, because the initial state of the <strong>Props</strong> class is invalid, since &quot;OnChange&quot; will start as null. If the initialisation code explicitly tries to set it to null then it will fail fast, but if it doesn't set it at all then it remain null and we'll be back to where we started in terms of where and when the exception is raised compared to where the programming mistake was made.</p>
<p>Attempt three could be to set appropriate defaults - eg.</p>
<pre><code>public class Props
{
  private string _className = null;
  private string _content = &quot;&quot;;
  private Action&lt;string&gt; _onChange = newValue =&gt; { };

  /// &lt;summary&gt;
  /// This is optional and so may be null (if non-null, then it should be a valid class
  /// name - ie. non-blank)
  /// &lt;/summary&gt;
  public string ClassName
  {
    get { return _className; }
    set
    {
      if (value == &quot;&quot;)
        throw new ArgumentException(&quot;ClassName should not be set to a blank string&quot;);
      _className = value;
    }
  }

  public bool Disabled { get; set; }

  /// &lt;summary&gt;
  /// An input may not always have a value and so this may be blank (but it should never
  /// be null)
  /// &lt;/summary&gt;
  public string Content
  {
    get { return _content; }
    set
    {
      if (value == null)
        throw new ArgumentNullException(&quot;Content should not be set to null&quot;);
      _content = value;
    }
  }

  /// &lt;summary&gt;
  /// This is mandatory and may never be null
  /// &lt;/summary&gt;
  public Action&lt;string&gt; OnChange
  {
    get { return _onChange; }
    set
    {
      if (value == null)
        throw new ArgumentNullException(&quot;OnChange should not be set to null&quot;);
      _onChange = value;
    }
  }
}
</code></pre>
<p>Now it's <em>not</em> possible for &quot;OnChange&quot; to be null, so a null reference exception can <em>not</em> be thrown when the user tries to interact with the component.</p>
<p>This still isn't fantastic, though. Is it really likely that there's ever a time where no &quot;OnChange&quot; value should have been set? Changes are that, in that case, there is still a programmer error (a <strong>TextInput</strong> is useless without an &quot;OnChange&quot; callback and so one <em>should</em> be set).. but now the error is being silently swallowed.</p>
<p>So, maybe most properties should <em>have</em> to be specified in order to get a new <strong>Props</strong> instance. Since values have to be provided at the point of initialisation, they may as well be validated at that point. This is a very good argument for making the <strong>Props</strong> class immutable - eg.</p>
<pre><code>public class Props
{
  public Props(string className, string content, bool disabled, Action&lt;string&gt; onChange)
  {
    if (className == &quot;&quot;)
      throw new ArgumentException(&quot;className should not be set to a blank string&quot;);
    if (content == null)
      throw new ArgumentNullException(&quot;content&quot;);
    if (onChange == null)
      throw new ArgumentNullException(&quot;onChange&quot;);

    ClassName = className;
    Content = content;
    Disabled = disabled;
    OnChange = onChange;
  }

  /// &lt;summary&gt;
  /// This is optional and so may be null (if non-null, then it will never be blank)
  /// &lt;/summary&gt;
  public string ClassName { get; }

  public bool Disabled { get; }

  /// &lt;summary&gt;
  /// An input may not always have a value and so this may be blank (but it should never
  /// be null)
  /// &lt;/summary&gt;
  public string Content { get; }

  /// &lt;summary&gt;
  /// This is mandatory and will never be null
  /// &lt;/summary&gt;
  public Action&lt;string&gt; OnChange { get; }
}
</code></pre>
<p>Two nice benefits arise from this. Firstly, the comments may be tighted up - so &quot;OnChange&quot; is no longer described as</p>
<blockquote>
<p>This is mandatory and should never be null</p>
</blockquote>
<p>now it is</p>
<blockquote>
<p>This is mandatory and will never be null</p>
</blockquote>
<p>It's a seemingly small change, but I'm looking for confidence in the code and this is a positive step from &quot;hopefully this won't happen&quot; to &quot;this can not happen (because an ArgumentNullException would have been instantly thrown if an attempt was made to create a <strong>Props</strong> instance in this manner)&quot;.</p>
<p>The second benefit is that the <strong>Props</strong> class now communicates one of the React guidelines - the React documentation states that props data should be considered immutable; once a component has a props reference, it should not try to change its data, nor should it expect any other code to be able to change it. Now, that commandment is baked into the code - this is a great example of what I mean when I talk about using a &quot;richer type system&quot;, there's more information that may be encoded than just &quot;this class has a property that is of type string&quot;.</p>
<p>One final tweak to this sort of approach is to enable optional values to truly be optional. In this example, I'm talking about &quot;className&quot;. The constructor may be changed from:</p>
<pre><code>public Props(string className, string content, bool disabled, Action&lt;string&gt; onChange)
{
  if (className == &quot;&quot;)
    throw new ArgumentException(&quot;className should not be set to a blank string&quot;);
  if (content == null)
    throw new ArgumentNullException(&quot;content&quot;);
  if (onChange == null)
    throw new ArgumentNullException(&quot;onChange&quot;);

  ClassName = className;
  Content = content;
  Disabled = disabled;
  OnChange = onChange;
}
</code></pre>
<p>to:</p>
<pre><code>public Props(string content, bool disabled, Action&lt;string&gt; onChange, string className = &quot;&quot;)
{
  if (content == null)
    throw new ArgumentNullException(&quot;content&quot;);
  if (onChange == null)
    throw new ArgumentNullException(&quot;onChange&quot;);
  if (className == &quot;&quot;)
    throw new ArgumentException(&quot;className should not be set to a blank string&quot;);

  Content = content;
  Disabled = disabled;
  OnChange = onChange;
  ClassName = className;
}
</code></pre>
<p>This means that an instance of <strong>TextInput.Props</strong> may be created, if no class name is required, like this:</p>
<pre><code>new TextInput.Props(title, isSaveInProgress, onTitleChange)
</code></pre>
<p>Or, if a class name <em>is</em> required:</p>
<pre><code>new TextInput.Props(title, isSaveInProgress, onTitleChange, &quot;title&quot;)
</code></pre>
<p>Personally, I like to use named constructor arguments when creating <strong>Props</strong> instances, so I would probably write:</p>
<pre><code>new TextInput.Props(
  className: &quot;title&quot;,
  value: title,
  disabled: isSaveInProgress,
  onChange: onTitleChange
)
</code></pre>
<p>I think that this makes the code easier to read (I don't need to resort to looking at the <strong>Props</strong> constructor to see that &quot;title&quot; is a class name and not an ID or any other use for a string) <em>and</em> means that it doesn't matter that the &quot;className&quot; argument moved from the start of the constructor argument list to the end, since the position of arguments doesn't matter when their names are used. (As an added benefit, this makes the code slightly more similar to the React component initialisation code that you might see in non-Bridge/C# projects, where JSON objects are used to set properties - but, here, we have the added benefit that's it all typed).</p>
<p>This is a big step forward in terms of including additional information in the type system (and in terms of catching errors quickly - and as close to the root cause of the error as possible), meaning that I can more reliably use a component without having to know everything about how it works (which, in a lot of ways, is like the idea of coding against an interface - you want to know about how to communicate with an interface to get the desired result without having to know all of the details of its implementation).</p>
<p>I'm not completely happy with the code at this point, though. It feels like the <strong>Props</strong> class has ballooned considerably from:</p>
<pre><code>public class Props
{
  public string ClassName;
  public bool Disabled;
  public string Content;
  public Action&lt;string&gt; OnChange;
}
</code></pre>
<p>to:</p>
<pre><code>public class Props
{
  public Props(
    string content,
    bool disabled,
    Action&lt;string&gt; onChange,
    string className = &quot;&quot;)
  {
    if (content == null)
      throw new ArgumentNullException(&quot;content&quot;);
    if (onChange == null)
      throw new ArgumentNullException(&quot;onChange&quot;);
    if (className == &quot;&quot;)
      throw new ArgumentException(&quot;className should not be set to a blank string&quot;);

    Content = content;
    Disabled = disabled;
    OnChange = onChange;
    ClassName = className;
  }

  /// &lt;summary&gt;
  /// This is optional and so may be null (if non-null, then it will never be blank)
  /// &lt;/summary&gt;
  public string ClassName { get; }

  public bool Disabled { get; }

  /// &lt;summary&gt;
  /// An input may not always have a value and so this may be blank (but it should never
  /// be null)
  /// &lt;/summary&gt;
  public string Content { get; }

  /// &lt;summary&gt;
  /// This is mandatory and will never be null
  /// &lt;/summary&gt;
  public Action&lt;string&gt; OnChange { get; }
}
</code></pre>
<p>While I am willing to make a certain trade-off between the cost of writing the code to begin with against the long term benefits of it being easier to quickly understand and then reason about*, I don't want to have to write any more of this monotonous form of code than absolutely necessary - in particular, I think I would get bored of writing &quot;This is mandatory and will never be null&quot; over and over again on different properties on different classes**.</p>
<p>* <em>(Since &quot;<a href="https://blogs.msdn.microsoft.com/oldnewthing/20070406-00/?p=27343">Code is read much more often than it is written, so plan accordingly</a>&quot;, I strongly believe that a little extra writing effort is worth it to reduce the more-often-incurred reading effort).</em></p>
<p>** <em>(I have personally written a lot of code that uses immutable, always-valid types and that was littered with these sorts of comments - while I definitely think it was worth it, I definitely HAVE gotten bored with writing &quot;This will never be null&quot; time after time after time).</em></p>
<p>But what alternative is there?</p>
<h3>Working on the basis that null is <em>never</em> allowed</h3>
<p>Since this whole series is about &quot;The Dan Way&quot;, I think that it is entirely reasonable to introduce a library that I've written at this point. It's a NuGet package for Bridge that makes it easier to write immutable types, such as the <strong>Props</strong> class above: &quot;<a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a>&quot;.</p>
<p>If a class implements an empty interface <strong>IAmImmutable</strong> then it may access extension methods that make the constructor easier to write. Something along the lines of:</p>
<pre><code>public class Props : IAmImmutable
{
  public Props(string content, bool disabled, Action&lt;string&gt; onChange, string className = &quot;&quot;)
  {
    this.CtorSet(_ =&gt; _.Content, content);
    this.CtorSet(_ =&gt; _.Disabled, disabled);
    this.CtorSet(_ =&gt; _.OnChange, onChange);
    this.CtorSet(_ =&gt; _.ClassName, className);
  }
  public string ClassName { get; }
  public bool Disabled { get; }
  public string Content { get; }
  public Action&lt;string&gt; OnChange { get; }
}
</code></pre>
<p>The extension method is &quot;CtorSet&quot; and it takes a lambda that specifies a property on the class and it takes a new value for that property. The type of the property and the type of the new value must be consistent - so, although there's apparently a little magic involved, we're not sacrificing any type safety.</p>
<p>One interesting feature of &quot;CtorSet&quot; is that it will never allow a null value. This means the comments from the <strong>Props</strong> class along the lines of &quot;This will never be null&quot; are unnecessary because an <strong>IAmImmutable</strong>-implementing class that sets all of its properties in its constructor will never have any null property values.</p>
<p>This actually doesn't work for the <strong>Props</strong> class we're looking at here since we want &quot;ClassName&quot; to be allowed to be null. To enable that, the library comes with a new struct - <strong>Optional&lt;T&gt;</strong>. Any time that you want to have a constructor argument be null, you have to wrap its type in this struct - ie.</p>
<pre><code>public class Props : IAmImmutable
{
  public Props(
    string content,
    bool disabled,
    Action&lt;string&gt; onChange,
    Optional&lt;string&gt; className = new Optional&lt;string&gt;())
  {
    this.CtorSet(_ =&gt; _.Content, content);
    this.CtorSet(_ =&gt; _.Disabled, disabled);
    this.CtorSet(_ =&gt; _.OnChange, onChange);
    this.CtorSet(_ =&gt; _.ClassName, className);
  }
  public Optional&lt;string&gt; ClassName { get; }
  public bool Disabled { get; }
  public string Content { get; }
  public Action&lt;string&gt; OnChange { get; }
}
</code></pre>
<p>Once again, we've made a step forward to encoding additional information in the class itself. In terms of being able to more easily reason about the code, this is a great win - classes such as these will never have null values to worry about; any property that may or may not have a value will be of type <strong>Optional&lt;T&gt;</strong>, which has properties &quot;IsDefined&quot; (a boolean indicating whether or not it has a value) and &quot;Value&quot; (which is the value itself, so long as &quot;IsDefined&quot; is true).</p>
<p>If you were in an argumentative mood, then you might say that <strong>Optional&lt;T&gt;</strong> can't save you from nulls in all cases since any code that deals with them could choose not to check &quot;IsDefined&quot; and to just try to access &quot;className.Value&quot; in all cases. This is true, but this faulty style of calling code had to be explicitly written to &quot;work around&quot; the <strong>Optional&lt;T&gt;</strong> wrapper. If the person who wrote it had sufficiently little interest to try to understand why <strong>Optional&lt;T&gt;</strong> was used then they may need some help in getting back on to the right path in their programming. This wrapper type acts as a sign post at each point where a null may be encountered, if the sign posts are ignored then that's unfortunate (but the benefit remains that there <em>is</em> a sign post for every potentially-null value whereas, in normal C# code, you need to be wary that nulls may leap out at you at any point, without warning).</p>
<p>This change doesn't affect how you call the constructor if you used the named arguments approach from above, so the following works fine:</p>
<pre><code>new TextInput.Props(
  className: &quot;title&quot;,
  value: title,
  disabled: isSaveInProgress,
  onChange: onTitleChange
)
</code></pre>
<p>as does:</p>
<pre><code>new TextInput.Props(
  value: title,
  disabled: isSaveInProgress,
  onChange: onTitleChange
)
</code></pre>
<p>If you wanted to really deliberately indicate that a <strong>TextInput</strong> should have no title then you could use any of the following three -</p>
<pre><code>// The explicit way
new TextInput.Props(
  className: Optional&lt;string&gt;.Missing,
  value: title,
  disabled: isSaveInProgress,
  onChange: onTitleChange
)

// The implicit way (there is an implicit cast from T to Optional&lt;T&gt;, which is why passing
// the string &quot;title&quot; in the earlier example works, because the &quot;title&quot; string is implicitly
// cast to an Optional&lt;string&gt; with value &quot;title&quot; - similarly null is implicitly cast to
// an Optional&lt;string&gt; with value null, which is the same as Optional&lt;string&gt;.Missing)
new TextInput.Props(
  className: null,
  value: title,
  disabled: isSaveInProgress,
  onChange: onTitleChange
)

// Using the struct's constructor - the most verbose and least-prefered way. Note that this
// is the only way that a &quot;Missing&quot; value may be specified as a constructor argument's
// default value, as may be seen in the Props constructor above (this is because default
// argument values must be compile time constants, which a new instance of a struct is but
// the static &quot;Missing&quot; property is not. Null can't be used as a constructor argument's
// default value for an Optional as the implicit cast is a runtime operation and so is
// not available at compile time).
new TextInput.Props(
  className: new Optional&lt;string&gt;(),
  value: title,
  disabled: isSaveInProgress,
  onChange: onTitleChange
)
</code></pre>
<p>I'm <em>still</em> not happy with this, though. I talked earlier about the ambiguity between null and blank string - for the &quot;Value&quot; property, this is solved since it can never be null now. It's valid for it to be a blank string (if there is no content in the input box) but it's not valid for it to be null (an <strong>ArgumentNullException</strong> will be raised in the constructor for a null &quot;value&quot;). Problem solved. However, the &quot;ClassName&quot; property can be &quot;<strong>Optional&lt;string&gt;</strong>.Missing&quot; (which is similar to null) or it can be a value that is a blank string. It would be much better to say that &quot;ClassName&quot; is &quot;Missing&quot; (meaning that it has no value and that the DOM element should have a &quot;class&quot; attribute at all) <em>or</em> that it has a value that is not blank.</p>
<p>One way to try to address this would be with <em>another</em> type -</p>
<pre><code>using System;

namespace BridgeReactTutorial.API
{
  public class NonBlankTrimmedString
  {
    public NonBlankTrimmedString(string value)
    {
      if (string.IsNullOrWhiteSpace(value))
        throw new ArgumentException(&quot;Null, blank or whitespace-only value specified&quot;);
      Value = value.Trim();
    }

    /// &lt;summary&gt;
    /// This will never be null, blank or have any leading or trailing whitespace
    /// &lt;/summary&gt;
    public string Value { get; }

    /// &lt;summary&gt;
    /// It's convenient to be able to pass a NonBlankTrimmedString instance as any argument
    /// that requires a string
    /// &lt;/summary&gt;
    public static implicit operator string(NonBlankTrimmedString value)
    {
      if (value == null)
        throw new ArgumentNullException(&quot;value&quot;);
      return value.Value;
    }
  }
}
</code></pre>
<p>I said that I wasn't keen on writing out more of this type of &quot;This will never be null..&quot; summary comment if I could avoid it, but the idea with this class it that it will be applicable in multiple places. So I have had to type &quot;This will never be null, blank or have any leading or trailing whitespace&quot; <em>once again</em> but I will take advantage of this one comment over and over again throughout my code.</p>
<p><em>Now</em> the <strong>TextInput.Props</strong> class becomes:</p>
<pre><code>public class Props : IAmImmutable
{
  public Props(
    string content,
    bool disabled,
    Action&lt;string&gt; onChange,
    Optional&lt;NonBlankTrimmedString&gt; className = new Optional&lt;NonBlankTrimmedString&gt;())
  {
    this.CtorSet(_ =&gt; _.Content, content);
    this.CtorSet(_ =&gt; _.Disabled, disabled);
    this.CtorSet(_ =&gt; _.OnChange, onChange);
    this.CtorSet(_ =&gt; _.ClassName, className);
  }
  public Optional&lt;NonBlankTrimmedString&gt; ClassName { get; }
  public bool Disabled { get; }
  public string Content { get; }
  public Action&lt;string&gt; OnChange { get; }
}
</code></pre>
<p>If you wanted to instantiate one then you would need to change the calling code slightly - eg.</p>
<pre><code>new TextInput.Props(
  className: new NonBlankTrimmedString(&quot;title&quot;),
  value: title,
  disabled: isSaveInProgress,
  onChange: onTitleChange
)
</code></pre>
<p>This <em>does</em> make this code a little more verbose. But we have the benefit that the <strong>Props</strong> class contains more information about what is and isn't acceptable for its property values. Also, making the calling code more explicit like this forces the writer to consider whether an appropriate value will always be passed to it - they should be careful to pass null or &quot;<strong>Optional&lt;NonBlankTrimmedString&gt;</strong>.Missing&quot; if they don't want to set a class name and to provide a populated, non-blank string if they <em>do</em> want a class name.</p>
<p>At this point, I'm finally satisifed with the <strong>TextInput.Props</strong> class!</p>
<p>Note: This is probably the most controversial part of my recommended approach - if you're happy to consider making your classes immutable like this, for the reasons I outlined above (which, by the way, can be applied to <em>all</em> classes in your code, not just props types for React components) and you're willing to consider the benefits and trade-offs of building up a more detailed type system (such as using <strong>Optional&lt;NonBlankOrTrimmedString&gt;</strong> instead of just &quot;string&quot; and only using &quot;string&quot; to mean &quot;non-nullable string&quot;) then I think that you'll enjoy the rest of what I've got to say.</p>
<p>I want to extend this ostracising of nulls to the <strong>TextInput</strong> class itself, though. At the end of <a href="/writing-react-apps-using-bridgenet-the-dan-way-part-two">Part Two</a>, the component looked like this:</p>
<pre><code>using System;
using Bridge.Html5;
using Bridge.React;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Components
{
  public class TextInput : StatelessComponent&lt;TextInput.Props&gt;
  {
    public TextInput(Props props) : base(props) { }

    public override ReactElement Render()
    {
      return DOM.Input(new InputAttributes
      {
        Type = InputType.Text,
        ClassName = props.ClassName,
        Disabled = props.Disabled,
        Value = props.Content,
        OnChange = e =&gt; props.OnChange(e.CurrentTarget.Value)
      });
    }

    public class Props : IAmImmutable
    {
      public string ClassName;
      public bool Disabled;
      public string Content;
      public Action&lt;string&gt; OnChange;
    }
  }
}
</code></pre>
<p>My problem with this is that it's possible to call the constructor with a null &quot;props&quot; value - but, if you do so, then the &quot;Render&quot; method will throw a null reference exception. Unfortunately, it's not possible to check for a null &quot;props&quot; value in the component's constructor due to the way that the Bridge / React bindings work with the React library; the constructor is never actually executed and so a null-check in there would never run. What I suggest is that the <strong>Props</strong> constructor arguments be repeated in the component's constructor -</p>
<pre><code>using System;
using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.API;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Components
{
  public class TextInput : StatelessComponent&lt;TextInput.Props&gt;
  {
    public TextInput(
      string content,
      bool disabled,
      Action&lt;string&gt; onChange,
      Optional&lt;NonBlankTrimmedString&gt; className = new Optional&lt;NonBlankTrimmedString&gt;())
      : base(new Props(content, disabled, onChange, className)) { }

    public override ReactElement Render()
    {
      return DOM.Input(new InputAttributes
      {
        Type = InputType.Text,
        ClassName = props.ClassName.IsDefined ? props.ClassName.Value : null,
        Disabled = props.Disabled,
        Value = props.Content,
        OnChange = e =&gt; props.OnChange(e.CurrentTarget.Value)
      });
    }

    public class Props : IAmImmutable
    {
      public Props(
        string content,
        bool disabled,
        Action&lt;string&gt; onChange,
        Optional&lt;NonBlankTrimmedString&gt; className)
      {
        this.CtorSet(_ =&gt; _.Content, content);
        this.CtorSet(_ =&gt; _.Disabled, disabled);
        this.CtorSet(_ =&gt; _.OnChange, onChange);
        this.CtorSet(_ =&gt; _.ClassName, className);
      }
      public Optional&lt;NonBlankTrimmedString&gt; ClassName { get; }
      public bool Disabled { get; }
      public string Content { get; }
      public Action&lt;string&gt; OnChange { get; }
    }
  }
}
</code></pre>
<p>Again, this <em>has</em> expanded the amount of code that is required within the component class. But the real effect is magnified by the line-wrapping that I use on my blog post code samples - in Visual Studio, I would likely have the constructor arguments all on one line.</p>
<p>If we can get past the cost of additional code within the component then we get two benefits. The first is that it's no longer possible for the <strong>TextInput</strong> to ever have a null &quot;props&quot; reference as a <strong>Props</strong> reference is no longer passed in, but is created in the call to the base constructor by using the individual arguments passed to the <strong>TextInput</strong> constructor. The second benefit is more marginal, but still nice (especially since it partially offsets the additional code added above) - the way that a new <strong>TextInput</strong> was declared previously required duplication of the word &quot;<strong>TextInput</strong>&quot; (with &quot;new <strong>TextInput</strong>&quot; and &quot;new <strong>TextInput.Props</strong>&quot;) -</p>
<pre><code>new TextInput(new TextInput.Props
{
  ClassName = &quot;title&quot;
  Disabled = props.Disabled,
  Content = props.Content,
  OnChange = props.OnChange
})
</code></pre>
<p>With the updated <strong>TextInput</strong> implementation, this duplication is avoided -</p>
<pre><code>new TextInput(
  className: new NonBlankTrimmedString(&quot;title&quot;),
  disabled: props.Disabled,
  content: props.Content,
  onChange: props.OnChange
)
</code></pre>
<p>Even without this (admittedly minor) second benefit, I would still be much happier with the new version of <strong>TextInput</strong>. The additional code (the final version is definitely somewhat longer than the previous version) pays for itself in what it communicates to someone who wishes to consume that component. However, one of the themes that I've been pushing in this series is that components should be dumb and that the real logic of the application should be outside of any UI classes; in the application code that will deal with the complications of the business logic and how to deal with user interactions.. if there is a way to move some of the syntactic noise around component creation away from the complicated library code and into the dumb components, then that seems a sensible trade-off. And that's what has been done here!</p>
<p>There's actually a <em>third</em> benefit to using this &quot;<strong>IAmImmutable</strong> style&quot; for writing these data types, when it comes to passing events from the simple components all the way up to the top of the component tree, where each &quot;OnChange&quot; (or whatever) adds increasing detail on the way up - but I'll come to that later on, first I want to address a burning question:</p>
<h3>If it's so effective to work on the basis that null should not be allowed anywhere in components and their Props, why not use this approach elsewhere in the application?</h3>
<p>Trick question! I am convinced that it <em>does</em> make sense to use <strong>IAmImmutable</strong> for data types <em>throughout</em> the application and to make null arguments and properties unacceptable in <em>all</em> places.</p>
<p>One obvious example is in the &quot;SaveMessage&quot; method in the <strong>MessageApi</strong> class. Currently, it starts like this:</p>
<pre><code>private RequestId SaveMessage(MessageDetails message, Action optionalSaveCompletedCallback)
{
  if (message == null)
    throw new ArgumentNullException(&quot;message&quot;);
  if (string.IsNullOrWhiteSpace(message.Title))
    throw new ArgumentException(&quot;A title value must be provided&quot;);
  if (string.IsNullOrWhiteSpace(message.Content))
    throw new ArgumentException(&quot;A content value must be provided&quot;);
</code></pre>
<p>Not accepting a null <strong>MessageDetails</strong> instance is good - if someone tried to call this method with a null &quot;message&quot; argument then it should be rejected immediately. However, it feels wrong that it's necesary to then check the &quot;Title&quot; and &quot;Content&quot; properties - should there ever be a case where a <strong>MessageDetails</strong> instance exists <em>without</em> these values being populated? In this application, the answer is no - the <strong>MessageEditor</strong> component only allows a new message to be saved if both its Title and Content have values.</p>
<p>This is another opportunity to encode this additional information into the type system. Instead of <strong>MessageDetails</strong> being implemented like this:</p>
<pre><code>namespace BridgeReactTutorial.ViewModels
{
  public class MessageDetails
  {
    public string Title;
    public string Content;
  }
}
</code></pre>
<p>It should be rewritten thusly:</p>
<pre><code>using BridgeReactTutorial.API;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.ViewModels
{
  public class MessageDetails : IAmImmutable
  {
    public MessageDetails(NonBlankTrimmedString title, NonBlankTrimmedString content)
    {
      this.CtorSet(_ =&gt; _.Title, title);
      this.CtorSet(_ =&gt; _.Content, content);
    }
    public NonBlankTrimmedString Title { get; }
    public NonBlankTrimmedString Content { get; }
  }
}
</code></pre>
<p>Now, the &quot;SaveMessage&quot; validation is much simpler - all that is required is:</p>
<pre><code>private RequestId SaveMessage(MessageDetails message, Action optionalSaveCompletedCallback)
{
  if (message == null)
    throw new ArgumentNullException(&quot;message&quot;);
</code></pre>
<p>Since a <strong>MessageDetails</strong> instance may no longer exist with missing Title or Content values, the property validation in &quot;SaveMessage&quot; is unnecessary. This has the benefit that there is less code at the point at which data is retrieved from a <strong>MessageDetails</strong> instance, which goes some way to offsetting the additional code required in defining the type. The real benefit, though, to removing that code is not just reducing line count but in removing potential duplication (the property validation code may have appeared elsewhere in the application if there were other methods that processed <strong>MessageDetails</strong> instances) <em>and</em> baking assumptions into the type system, rather than leaving them be implicit. Before, it was probably safe to assume that Title and Content would always have values since the code that would create a <strong>MessageDetails</strong> instance would always give them values - however, that was <em>only</em> an assumption and you would have had to have read all of the code that created <strong>MessageDetails</strong> instances to be confident. With this arrangement, you <em>know</em> that a <strong>MessageDetails</strong> has both Title and Content values at all times, since it's not possible for an instance to be created that doesn't!</p>
<p>When I talk about code being easy to reason about, it's not usually in terms of the dozen or so lines of code that are directly in front of you, it's how the objects and methods that you're dealing with may interact with the rest of the system and what assumptions are being made. Knowing that a <strong>MessageDetails</strong> instance will always be valid is extremely helpful. Knowing that any code that attempts to create a <strong>MessageDetails</strong> with invalid data will fail immeditely, rather than cause an error later on (when the instance is presumed to be valid but turns out not to be) is extremely helpful. Knowing that a type is immutable and that it won't be changed &quot;behind the scenes&quot; when you pass it off to another method is extremely helpful - when types are mutable and you pass an instance to another method to read, you can't be sure whether the method will <em>only</em> read it or whether it will manipulate it; there's no way to tell from the method signature. Making mutations explicit by making types immutable is another big win for being able to reason about code.</p>
<p>Speaking of dealing with mutation brings me smoothly onto the third benefit of <strong>IAmImmutable</strong> that I hinted at earlier. Currently, the <strong>MessageEditor</strong> component in our example app looks like this:</p>
<pre><code>using System;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class MessageEditor : StatelessComponent&lt;MessageEditor.Props&gt;
  {
    public MessageEditor(Props props) : base(props) { }

    public override ReactElement Render()
    {
      var formIsInvalid =
        !string.IsNullOrWhiteSpace(props.Message.Title.ValidationError) ||
        !string.IsNullOrWhiteSpace(props.Message.Content.ValidationError);

      return DOM.FieldSet(new FieldSetAttributes { ClassName = props.ClassName },
        DOM.Legend(null, props.Message.Caption),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Title&quot;),
        new ValidatedTextInput(new ValidatedTextInput.Props
        {
          ClassName = &quot;title&quot;,
          Disabled = props.Message.IsSaveInProgress,
          Content = props.Message.Title.Text,
          OnChange = newTitle =&gt; props.OnChange(new MessageEditState
          {
            Title = new TextEditState { Text = newTitle },
            Content = props.Message.Content
          }),
          ValidationMessage = props.Message.Title.ValidationError
        }),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Content&quot;),
        new ValidatedTextInput(new ValidatedTextInput.Props
        {
          ClassName = &quot;content&quot;,
          Disabled = props.Message.IsSaveInProgress,
          Content = props.Message.Content.Text,
          OnChange = newContent =&gt; props.OnChange(new MessageEditState
          {
            Title = props.Message.Title,
            Content = new TextEditState { Text = newContent },
          }),
          ValidationMessage = props.Message.Content.ValidationError
        }),
        DOM.Button(
        new ButtonAttributes
        {
          Disabled = formIsInvalid || props.Message.IsSaveInProgress,
          OnClick = e =&gt; props.OnSave()
        },
        &quot;Save&quot;
        )
      );
    }

    public class Props
    {
      public string ClassName;
      public MessageEditState Message;
      public Action&lt;MessageEditState&gt; OnChange;
      public Action OnSave;
    }
  }
}
</code></pre>
<p>The first thing I'm going to do is change the <strong>Props</strong> type and the component's constructor in the same way as I did for the <strong>TextInput</strong> -</p>
<pre><code>using System;
using Bridge.React;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Components
{
  public class MessageEditor : StatelessComponent&lt;MessageEditor.Props&gt;
  {
    public MessageEditor(
      MessageEditState message,
      Action&lt;MessageEditState&gt; onChange,
      Action onSave,
      Optional&lt;NonBlankTrimmedString&gt; className = new Optional&lt;NonBlankTrimmedString&gt;())
      : base(new Props(className, message, onChange, onSave)) { }

    public override ReactElement Render()
    {
      var formIsInvalid =
        !string.IsNullOrWhiteSpace(props.Message.Title.ValidationError) ||
        !string.IsNullOrWhiteSpace(props.Message.Content.ValidationError);

      return DOM.FieldSet(
        new FieldSetAttributes {
          ClassName = props.ClassName.IsDefined ? props.ClassName.Value : null
        },
        DOM.Legend(null, props.Message.Caption),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Title&quot;),
        new ValidatedTextInput(new ValidatedTextInput.Props
        {
          ClassName = &quot;title&quot;,
          Disabled = props.Message.IsSaveInProgress,
          Content = props.Message.Title.Text,
          OnChange = newTitle =&gt; props.OnChange(new MessageEditState
          {
            Title = new TextEditState { Text = newTitle },
            Content = props.Message.Content
          }),
          ValidationMessage = props.Message.Title.ValidationError
        }),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Content&quot;),
        new ValidatedTextInput(new ValidatedTextInput.Props
        {
          ClassName = &quot;content&quot;,
          Disabled = props.Message.IsSaveInProgress,
          Content = props.Message.Content.Text,
          OnChange = newContent =&gt; props.OnChange(new MessageEditState
          {
            Title = props.Message.Title,
            Content = new TextEditState { Text = newContent },
          }),
          ValidationMessage = props.Message.Content.ValidationError
        }),
        DOM.Button(
        new ButtonAttributes
        {
          Disabled = formIsInvalid || props.Message.IsSaveInProgress,
          OnClick = e =&gt; props.OnSave()
        },
        &quot;Save&quot;
        )
      );
    }

    public class Props : IAmImmutable
    {
      public Props(
        Optional&lt;NonBlankTrimmedString&gt; className,
        MessageEditState message,
        Action&lt;MessageEditState&gt; onChange,
        Action onSave)
      {
        this.CtorSet(_ =&gt; _.ClassName, className);
        this.CtorSet(_ =&gt; _.Message, message);
        this.CtorSet(_ =&gt; _.OnChange, onChange);
        this.CtorSet(_ =&gt; _.OnSave, onSave);
      }
      public Optional&lt;NonBlankTrimmedString&gt; ClassName { get; }
      public MessageEditState Message { get; }
      public Action&lt;MessageEditState&gt; OnChange { get; }
      public Action OnSave { get; }
    }
  }
}
</code></pre>
<p>This means that the    <strong>MessageEditor</strong> instantiation code changes slightly from:</p>
<pre><code>new MessageEditor(new MessageEditor.Props
{
  ClassName = &quot;message&quot;,
  Message = state.Message,
  OnChange = newState =&gt; props.Dispatcher.Dispatch(
    UserEditRequested.For(newState)
  ),
  OnSave = () =&gt; props.Dispatcher.Dispatch(
    SaveRequested.For(
      new MessageDetails(
        new NonBlankTrimmedString(state.Message.Title.Text),
        new NonBlankTrimmedString(state.Message.Content.Text)
      )
    )
  )
}),
</code></pre>
<p>to:</p>
<pre><code>new MessageEditor(
  className: new NonBlankTrimmedString(&quot;message&quot;),
  message:  state.Message,
  onChange: newState =&gt; props.Dispatcher.Dispatch(
    UserEditRequested.For(newState)
  ),
  onSave: () =&gt; props.Dispatcher.Dispatch(
    SaveRequested.For(
      new MessageDetails(
        new NonBlankTrimmedString(state.Message.Title.Text),
        new NonBlankTrimmedString(state.Message.Content.Text)
      )
    )
  )
),
</code></pre>
<p>There are several steps that need following now until I can reveal my point,  so bear with me. I'm going to change the <strong>MessageEditState</strong> data type, in the same way as I did the <strong>MessageDetails</strong> - from:</p>
<pre><code>namespace BridgeReactTutorial.ViewModels
{
  public class MessageEditState
  {
    public string Caption;
    public TextEditState Title;
    public TextEditState Content;
    public bool IsSaveInProgress;
  }
}
</code></pre>
<p>to:</p>
<pre><code>using BridgeReactTutorial.API;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.ViewModels
{
  public class MessageEditState : IAmImmutable
  {
    public MessageEditState(
      NonBlankTrimmedString caption,
      TextEditState title,
      TextEditState content,
      bool isSaveInProgress)
    {
      this.CtorSet(_ =&gt; _.Caption, caption);
      this.CtorSet(_ =&gt; _.Title, title);
      this.CtorSet(_ =&gt; _.Content, content);
      this.CtorSet(_ =&gt; _.IsSaveInProgress, isSaveInProgress);
    }
    public NonBlankTrimmedString Caption { get; }
    public TextEditState Title { get; }
    public TextEditState Content { get; }
    public bool IsSaveInProgress { get; }
  }
}
</code></pre>
<p>And do the same with <strong>TextEditState</strong>, from -</p>
<pre><code>namespace BridgeReactTutorial.ViewModels
{
    public class TextEditState
    {
        public string Text;
        public string ValidationError;
    }
}
</code></pre>
<p>to:</p>
<pre><code>using BridgeReactTutorial.API;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.ViewModels
{
  public class TextEditState : IAmImmutable
  {
    public TextEditState(
      string text,
      Optional&lt;NonBlankTrimmedString&gt; validationError = new Optional&lt;NonBlankTrimmedString&gt;())
    {
      this.CtorSet(_ =&gt; _.Text, text);
      this.CtorSet(_ =&gt; _.ValidationError, validationError);
    }
    public string Text { get; }
    public Optional&lt;NonBlankTrimmedString&gt; ValidationError { get; }
  }
}
</code></pre>
<p>I'm going to change the <strong>ValidatedTextInput</strong> to</p>
<pre><code>using System;
using Bridge.React;
using BridgeReactTutorial.API;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Components
{
  public class ValidatedTextInput : StatelessComponent&lt;ValidatedTextInput.Props&gt;
  {
    public ValidatedTextInput(
      bool disabled,
      string content,
      Action&lt;string&gt; onChange,
      Optional&lt;NonBlankTrimmedString&gt; validationMessage,
      Optional&lt;NonBlankTrimmedString&gt; className = new Optional&lt;NonBlankTrimmedString&gt;())
      : base(new Props(className, disabled, content, onChange, validationMessage)) { }

    public override ReactElement Render()
    {
      var className = props.ClassName;
      if (props.ValidationMessage.IsDefined)
        className = className.Add(&quot; &quot;, new NonBlankTrimmedString(&quot;invalid&quot;));
      return DOM.Span(new Attributes { ClassName = className.ToStringIfDefined() },
        new TextInput(
          className: props.ClassName,
          disabled: props.Disabled,
          content: props.Content,
          onChange: props.OnChange
        ),
        props.ValidationMessage.IsDefined
        ? DOM.Span(
          new Attributes { ClassName = &quot;validation-message&quot; },
          props.ValidationMessage.ToStringIfDefined()
        )
        : null
      );
    }

    public class Props : IAmImmutable
    {
      public Props(
        Optional&lt;NonBlankTrimmedString&gt; className,
        bool disabled,
        string content,
        Action&lt;string&gt; onChange,
        Optional&lt;NonBlankTrimmedString&gt; validationMessage)
      {
        this.CtorSet(_ =&gt; _.ClassName, className);
        this.CtorSet(_ =&gt; _.Disabled, disabled);
        this.CtorSet(_ =&gt; _.Content, content);
        this.CtorSet(_ =&gt; _.OnChange, onChange);
        this.CtorSet(_ =&gt; _.ValidationMessage, validationMessage);
      }
      public Optional&lt;NonBlankTrimmedString&gt; ClassName { get; }
      public bool Disabled { get; }
      public string Content { get; }
      public Action&lt;string&gt; OnChange { get; }
      public Optional&lt;NonBlankTrimmedString&gt; ValidationMessage { get; }
    }
  }
}
</code></pre>
<p>.. which requires a new class be added to the &quot;API&quot; folder with some extension methods to make dealing with <strong>Optional&lt;NonBlankTrimmedString&gt;</strong> a little nicer -</p>
<pre><code>using System;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.API
{
  public static class OptionalNonBlankTrimmedStringExtensions
  {
    /// &lt;summary&gt;
    /// If the Optional NonBlankTrimmedString has a value then it will be unwrapped directly
    /// into a string - if not, the null will be returned (this is one of the few places
    /// where null will be an acceptable value in the app and it should be only used when
    /// integrating with code that expects nulls - such as when setting attributes via
    /// React html element factories)
    /// &lt;/summary&gt;
    public static string ToStringIfDefined(this Optional&lt;NonBlankTrimmedString&gt; source)
    {
      return source.IsDefined ? source.Value : null;
    }

    /// &lt;summary&gt;
    /// This will join two Optional NonBlankTrimmedString with a specified delimiter if
    /// they both have values. If only one of them has a value then this will be returned
    /// unaltered. If neither of them have a value then a Missing value will be returned.
    /// &lt;/summary&gt;
    public static Optional&lt;NonBlankTrimmedString&gt; Add(
      this Optional&lt;NonBlankTrimmedString&gt; source,
      string delimiter,
      Optional&lt;NonBlankTrimmedString&gt; other)
    {
      if (delimiter == null)
        throw new ArgumentNullException(&quot;delimiter&quot;);

      if (!source.IsDefined &amp;&amp; !other.IsDefined)
        return Optional&lt;NonBlankTrimmedString&gt;.Missing;
      else if (!source.IsDefined)
        return other;
      else if (!other.IsDefined)
        return source;

      return new NonBlankTrimmedString(source.Value.Value + delimiter + other.Value.Value);
    }
  }
}
</code></pre>
<p>and a further implicit operator adding to the <strong>NonBlankTrimmedString</strong> -</p>
<pre><code>    /// &lt;summary&gt;
    /// It's convenient to be able to pass a NonBlankTrimmedString instance as any argument
    /// that requires a ReactElement-or-string, such as for the children array of the React
    /// DOM component factories
    /// &lt;/summary&gt;
    public static implicit operator Union&lt;ReactElement, string&gt;(NonBlankTrimmedString value)
    {
        if (value == null)
            throw new ArgumentNullException(&quot;value&quot;);
        return value.Value;
    }
</code></pre>
<p>Ok, now I'm finally able to demonstrate this mysterious third benefit. The &quot;OnChange&quot; lambdas which were provided as <strong>ValidatedTextInput.Props</strong> values by the <strong>MessageEditor</strong>'s &quot;Render&quot; method were previously specified like this:</p>
<pre><code>OnChange = newTitle =&gt; props.OnChange(new MessageEditState
{
  Title = new TextEditState { Text = newTitle },
  Content = props.Message.Content
})

OnChange = newContent =&gt; props.OnChange(new MessageEditState
{
  Title = props.Message.Title,
  Content = new TextEditState { Text = newContent },
})
</code></pre>
<p>Within each &quot;OnChange&quot;, we want to create a new <strong>MessageEditState</strong> instance with one of the properties changed. However, it get arduous having to repeat <em>all</em> of the property names each time that you want to change a single property - here it's not <em>that</em> bad because there are only two properties (&quot;Title&quot; and &quot;Content&quot;), but on classes with more properties this is annoying and, worse, error-prone.</p>
<p>Now that <strong>MessageEditState</strong> implements <strong>IAmImmutable</strong>, we can take advantage of another extension method available; &quot;With&quot;. This takes an argument that specifies the property to change and it takes an argument for the new property value. This means that</p>
<pre><code>OnChange = newTitle =&gt; props.OnChange(new MessageEditState
{
  Title = new TextEditState { Text = newTitle },
  Content = props.Message.Content
})
</code></pre>
<p>is replaced with</p>
<pre><code>OnChange = newTitle =&gt; props.OnChange(
   props.Message.With(_ =&gt; _.Title, new TextEditState(newTitle))
)
</code></pre>
<p>and</p>
<pre><code>OnChange = newContent =&gt; props.OnChange(new MessageEditState
{
  Title = props.Message.Title,
  Content = new TextEditState { Text = newContent }
})
</code></pre>
<p>is replaced with</p>
<pre><code>OnChange = newContent =&gt; props.OnChange(
  props.Message.With(_ =&gt; _.Content, new TextEditState(newContent))
)
</code></pre>
<p><em>(Again, I'm only wrapping these lines for the sake of the formatting on my blog - if I was writing this code in Visual Studio then I would make those a single line each).</em></p>
<p>The &quot;With&quot; function takes an instance of an <strong>IAmImmutable</strong>-implementing class, clones it but changes the specified property value - unless the new value is the same as the old value, in which case it returns the original instance unaltered.</p>
<p>All of these changes combined mean that the <strong>MessageEditor</strong> component now becomes:</p>
<pre><code>using System;
using Bridge.React;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Components
{
  public class MessageEditor : StatelessComponent&lt;MessageEditor.Props&gt;
  {
    public MessageEditor(
      MessageEditState message,
      Action&lt;MessageEditState&gt; onChange,
      Action onSave,
      Optional&lt;NonBlankTrimmedString&gt; className = new Optional&lt;NonBlankTrimmedString&gt;())
      : base(new Props(className, message, onChange, onSave)) { }

    public override ReactElement Render()
    {
      var formIsInvalid =
        props.Message.Title.ValidationError.IsDefined ||
        props.Message.Content.ValidationError.IsDefined;

      return DOM.FieldSet(
        new FieldSetAttributes { ClassName = props.ClassName.ToStringIfDefined() },
        DOM.Legend(null, props.Message.Caption),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Title&quot;),
        new ValidatedTextInput(
          className: new NonBlankTrimmedString(&quot;title&quot;),
          disabled: props.Message.IsSaveInProgress,
          content: props.Message.Title.Text,
          onChange: newTitle =&gt; props.OnChange(
            props.Message.With(_ =&gt; _.Title, new TextEditState(newTitle))
          ),
          validationMessage: props.Message.Title.ValidationError
        ),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Content&quot;),
        new ValidatedTextInput(
          className: new NonBlankTrimmedString(&quot;content&quot;),
          disabled: props.Message.IsSaveInProgress,
          content: props.Message.Content.Text,
          onChange: newContent =&gt; props.OnChange(
            props.Message.With(_ =&gt; _.Content, new TextEditState(newContent))
          ),
          validationMessage: props.Message.Content.ValidationError
        ),
        DOM.Button(
        new ButtonAttributes
        {
          Disabled = formIsInvalid || props.Message.IsSaveInProgress,
          OnClick = e =&gt; props.OnSave()
        },
        &quot;Save&quot;
        )
      );
    }

    public class Props : IAmImmutable
    {
      public Props(
        Optional&lt;NonBlankTrimmedString&gt; className,
        MessageEditState message,
        Action&lt;MessageEditState&gt; onChange,
        Action onSave)
      {
        this.CtorSet(_ =&gt; _.ClassName, className);
        this.CtorSet(_ =&gt; _.Message, message);
        this.CtorSet(_ =&gt; _.OnChange, onChange);
        this.CtorSet(_ =&gt; _.OnSave, onSave);
      }
      public Optional&lt;NonBlankTrimmedString&gt; ClassName { get; }
      public MessageEditState Message { get; }
      public Action&lt;MessageEditState&gt; OnChange { get; }
      public Action OnSave { get; }
    }
  }
}
</code></pre>
<h3>One more example</h3>
<p>Before moving on, I want to apply these changes to one more component to really drive the point home.</p>
<p>This is the <strong>MessageHistory</strong> component as it currently stands:</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class MessageHistory : StatelessComponent&lt;MessageHistory.Props&gt;
  {
    public MessageHistory(Props props) : base(props) { }

    public override ReactElement Render()
    {
      var className = props.ClassName;
      if (!props.Messages.Any())
        className = (className + &quot; zero-messages&quot;).Trim();

      // Any time a set of child components is dynamically-created (meaning that the
      // numbers of items may vary from one render to another), each must have a unique
      // &quot;Key&quot; property set (this may be a int or a string). Here, this is simple as
      // each message tuple is a unique ID and the contents of that message.
      var messageElements = props.Messages
        .Select(idAndMessage =&gt; DOM.Div(new Attributes { Key = idAndMessage.Item1 },
        DOM.Span(new Attributes { ClassName = &quot;title&quot; }, idAndMessage.Item2.Title),
        DOM.Span(new Attributes { ClassName = &quot;content&quot; }, idAndMessage.Item2.Content)
      ));

      // When child components are specified (as they are through the second argument of
      // DOM.Div), the argument is of type Union&lt;ReactElement, string&gt;[] (meaning that each
      // element may be another component or it may be a simple text value)
      // - The React bindings have an extension method that transforms an IEnumerable set
      //   of components (such as &quot;messageElements&quot;) into an Union&lt;ReactElement, string&gt;[]
      return DOM.FieldSet(new FieldSetAttributes { ClassName = className },
        DOM.Legend(null, &quot;Message History&quot;),
        DOM.Div(null, messageElements)
      );
    }

    public class Props
    {
      public string ClassName;
      public IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt; Messages;
    }
  }
}
</code></pre>
<p>Despite this appearing very simple at first glance, there are various implicit assumptions that you should be aware of. Firstly, it is assumed that &quot;props&quot; will never be null (&quot;Render&quot; will throw an exception if this is not the case). It is also assumed that &quot;props.ClassName&quot; <em>may</em> be null (and, technically, it may also be a blank string, though this is not desirable) while &quot;props.Messages&quot; should <em>not</em> null. Nor should &quot;props.Messages&quot; contain any tuples with a null <strong>MessageDetails</strong> instance. But these assumptions are neither documented nor enforced.</p>
<p>By this point, we've seen several examples of how to prevent &quot;props&quot; being null (ie. require that the props constructor arguments be passed as the component's constructor arguments) and we've seen how to better represent <strong>Props</strong> to allow &quot;ClassName&quot; to be optional but for &quot;Messages&quot; to not be (&quot;ClassName&quot; should be an <strong>Optional&lt;NonBlankTrimmedString&gt;</strong>). But there are two further tricks we can use for the <strong>MessageHistory.Props</strong>.</p>
<p>Firstly, <strong>IEnumerable</strong> is too loose for my liking - technically, there are no guarantees that an <strong>IEnumerable</strong> will report the same information if enumerated multiple times and there are definitely no guarantees that it won't contain any null references. I want consistency and I want a life free from null. The <a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a> library contains another handy class for this sort of thing; <strong>NonNullList&lt;T&gt;</strong>. This is essentially an ordered list of items of type &quot;T&quot; that is immutable and that will never contain any null values. If you want a set of items that may or may not have values of type &quot;T&quot; then you need the list type to be <strong>NonNullList&lt;Optional&lt;T&gt;&gt;</strong>.</p>
<p>The second tweak that I want to make is to replace the <strong>Tuple&lt;int, MessageDetails&gt;</strong> - in part, again, because there is no guarantee that the second item in the pair will not be null but also because I don't like the &quot;Item1&quot; and &quot;Item2&quot; property names. I think it's just one more thing to mentally translate (&quot;Oh yes, Item1 means Key and Item2 means Message&quot;). So I'm going to extend the type system again.</p>
<p>When considering a simple API, the common actions are &quot;Create&quot;, &quot;Read&quot;, &quot;Update&quot;, &quot;Delete&quot;. When creating a new item (like when we save a new message in our example application), we don't have a unique key for the new message - that will be generated by the persistence layer as part of the save process. When we read values (to display existing messages in the <strong>MessageHistory</strong>, for example), we <em>will</em> have access to unique keys - the persistence layer will be reading data from wherever the data is stored and it will be able to draw the keys out along with the data. When updating an existing record, we should know what its key is, since we will have performed a read action in order to get the currently-persisted state for the record. Similarly, when requesting a delete, we will have the key from a previous read action, in order to know what record to remove.</p>
<p>I've seen object models before which try to have a single data type to use in all of the Create, Read and Update cases. This would be like our <strong>MessageDetails</strong> having a &quot;Key&quot;, &quot;Title&quot; and &quot;Content&quot;. However, sometimes the &quot;Key&quot; would be null because it would be unknown (when generating a brand new <strong>MessageDetails</strong> instance to pass to &quot;SaveMessage&quot;, for example). I don't like this. The sometimes-Key-is-null-and-sometimes-it-isn't is an unnecessary complication and it means that there are places where we require a Key but can't guarantee (through the type system) that the reference that we have will have a non-null Key value. I think it's much better to have <em>two</em> data types; one for a record that has been persisted at some point (and thus has a non-null Key) and another type for a record that may or may not have been persisted. Currently, our <strong>MessageDetails</strong> class (which has only &quot;Title&quot; and &quot;Content&quot; properties) represents a message that may or may not have been persisted - when a new one is passed to &quot;SaveMessage&quot; when the user attempts to save a new message then we know that it hasn't been persisted yet, but it's not difficult to imagine that there could be other code that we add to the application in the future that wants to deal with some message data, but that doesn't care whether it's been persisted or not yet; it only wants access to its &quot;Title&quot; and / or &quot;Content&quot; values, it doesn't need the &quot;Key&quot; for anything.</p>
<p>So, instead of the <strong>MessageHistory</strong> using the generic <strong>Tuple</strong> class to represent a <strong>MessageDetails</strong>-plus-persisted-Key, I'm going to introduce something new. Create a new file under the &quot;API&quot; folder, &quot;Saved.cs&quot; -</p>
<pre><code>using ProductiveRage.Immutable;

namespace BridgeReactTutorial.API
{
  public class Saved&lt;TKey, TValue&gt; : IAmImmutable
  {
    public Saved(TKey key, TValue value)
    {
      this.CtorSet(_ =&gt; _.Key, key);
      this.CtorSet(_ =&gt; _.Value, value);
    }
    public TKey Key { get; }
    public TValue Value { get; }
  }

  public static class Saved
  {
    /// &lt;summary&gt;
    /// This generic method makes code that creates generic Saved instances more succinct
    /// by relying upon type inference (based upon the key and value argument types), so
    /// that the calling code does not have to explicitly declare TKey and TValue
    /// &lt;/summary&gt;
    public static Saved&lt;TKey, TValue&gt; For&lt;TKey, TValue&gt;(TKey key, TValue value)
    {
      return new Saved&lt;TKey, TValue&gt;(key, value);
    }
  }
}
</code></pre>
<p>The <strong>Saved</strong> class makes differentiating between record-that-has-a-persistence-id and record-that-may-or-may-not-have-a-persistence-id simple. If the message has been persisted, then it may be represented as a <strong>Saved&lt;int, MessageDetails&gt;</strong>. If it's <em>just</em> the message data, with no persisted-or-not-persisted state associated with it then it will be simply a <strong>MessageDetails</strong>.</p>
<p>I'm <em>still</em> not happy, though. I think that <strong>Saved&lt;int, MessageDetails&gt;</strong> could still be more descriptive. This value represents a message with a unique persistence key for that message. Even if the underlying data store is a database which uses an integer column (in our example app, it's a simple in-browser-memory store, but a database on a server is likely much more common) that doesn't mean that we have to use such a vague term as &quot;an integer&quot; in our application's object model. I recommend strongly-typed ID representations. We need to add a new file &quot;MessageId.cs&quot; to the &quot;API&quot; folder:</p>
<pre><code>namespace BridgeReactTutorial.API
{
  public struct MessageId
  {
    public int Value { get; private set; }

    public static explicit operator MessageId(int value)
    {
      return new MessageId { Value = value };
    }

    public static implicit operator int(MessageId id)
    {
      return id.Value;
    }
  }
}
</code></pre>
<p>This is the final step in the move away from <strong>IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt;</strong>, we will now represent this data with the type <strong>NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt;</strong>. This list will never contain any null &quot;Saved&quot; instances and a &quot;Saved&quot; instance will never contain a null message. This list of messages will never vary, which is another way that React's &quot;consider props to be immutable&quot; guidelines is described and enforced in the type system.</p>
<p>Not only do I believe that having strongly-typed IDs makes the code clearer in cases like this but it can also avoid silly mistakes that have a nasty tendency to crop up from time to time - if you're writing code and having a bad day, then it's easy to accidentally pass the wrong ID around. For example, if I have a function:</p>
<pre><code>void RecordMessageAsHavingBeenReadBy(int messageId, int userId)
</code></pre>
<p>then it's possible in the calling code to mix up the IDs if you're having a bad day (this isn't <em>too</em> contrived an example, I <em>have</em> done something like this in the past!) - eg.</p>
<pre><code>RecordMessageAsHavingBeenReadBy(user.Id, message.id); // Whoops!
</code></pre>
<p>If the IDs were strongly-typed, meaning that the method signature would be..</p>
<pre><code>void RecordMessageAsHavingBeenReadBy(MessageId messageId, UserId userId)
</code></pre>
<p>.. then that mishap would result in a compile error, rather than runtime confusion that may not get noticed immediately.</p>
<p><em>(Note: These changes to how messages are represented will require changes to the <strong>MesageApi</strong>, which I'll cover shortly - nothing very complicated, though).</em></p>
<p>These changes lead the <strong>MessageHistory</strong> component's code to now look like this:</p>
<pre><code>using System.Linq;
using Bridge.React;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Components
{
  public class MessageHistory : StatelessComponent&lt;MessageHistory.Props&gt;
  {
    public MessageHistory(
      NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt; messages,
      Optional&lt;NonBlankTrimmedString&gt; className = new Optional&lt;NonBlankTrimmedString&gt;())
      : base(new Props(className, messages)) { }

    public override ReactElement Render()
    {
      var className = props.ClassName;
      if (!props.Messages.Any())
        className = className.Add(&quot; &quot;, new NonBlankTrimmedString(&quot;zero-messages&quot;));

      // Any time a set of child components is dynamically-created (meaning that the
      // numbers of items may vary from one render to another), each must have a unique
      // &quot;Key&quot; property set (this may be a int or a string)
      var messageElements = props.Messages
        .Select(savedMessage =&gt; DOM.Div(new Attributes { Key = (int)savedMessage.Key },
        DOM.Span(new Attributes { ClassName = &quot;title&quot; }, savedMessage.Value.Title),
        DOM.Span(new Attributes { ClassName = &quot;content&quot; }, savedMessage.Value.Content)
        ));

      // When child components are specified (as they are through the second argument of
      // DOM.Div), the argument is of type Union&lt;ReactElement, string&gt;[] (meaning that each
      // element may be another component or it may be a simple text value)
      // - The React bindings have an extension method that transforms an IEnumerable set
      //   of components (such as &quot;messageElements&quot;) into an Union&lt;ReactElement, string&gt;[]
      return DOM.FieldSet(
        new FieldSetAttributes { ClassName = className.ToStringIfDefined() },
        DOM.Legend(null, &quot;Message History&quot;),
        DOM.Div(null, messageElements)
      );
    }

    public class Props : IAmImmutable
    {
      public Props(
        Optional&lt;NonBlankTrimmedString&gt; className,
        NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt; messages)
      {
        this.CtorSet(_ =&gt; _.ClassName, className);
        this.CtorSet(_ =&gt; _.Messages, messages);
      }
      public Optional&lt;NonBlankTrimmedString&gt; ClassName { get; }
      public NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt; Messages { get; }
    }
  }
}
</code></pre>
<p>All of those implicit assumptions are now explicitly described in the type system. This makes me feel much better.</p>
<h3>So, EVERYWHERE?</h3>
<p>I introduced the use of <strong>IAmImmutable</strong> in terms of a component's <strong>Props</strong> class. But I subsequently used it to tighten up the <strong>MessageDetails</strong> class and then again when the <strong>Saved</strong> class was added.</p>
<p>One option in incorporating <strong>IAmImmutable</strong> and this no-value-or-property-may-be-null behaviour into applications would be to say that any class that implements <strong>IAmImmutable</strong> will not allow null anywhere. As I've already hinted, I strongly suggest going further than that, however, and writing <em>all</em> code like this. Frankly, I can see no good reason why any public data type should be mutable. I can imagine that, in some special cases, it may be desirable to have some private mutable data structures for convenience, or <em>maybe</em> performance (in some <em>very</em> specialised cases) but where the data is shared with other classes, data types being immutable makes the code much easier to reason about. Transformations are explicit and do not occur &quot;in place&quot; for any references. Meaning that a reference that describes some data when a function starts will always describe the same data when the function ends.</p>
<p>It's actually worth remembering that JavaScript in the browser is single-threaded. A lot of the time that people talk about the benefits of immutability, they talk about the safety of being able to share references between multiple threads and not having to worry about corruption because one thread can't manipulate data in a way that another thread doesn't expect, with unfortunate (and often non-deterministic) results. Here, we are not concerned about multi-threading, I recommend the use of immutable structures solely because they make the code that accesses them and passes them around easier to reason about.</p>
<p>The largest downside in my eyes, as may have struck you after reading all of the above, is that changing code that doesn't use <strong>IAmImmutable</strong> into code that <em>does</em> use it requires changes not only to that particular class but, in many cases, to code that accesses or initialises that class and then to code that accesses or initialises <em>that</em> code (the changes to the <strong>MessageEditor</strong> and <strong>MessageHistory</strong> components required changes to the <strong>MessageDetails</strong> and <strong>MessageEditState</strong> classes and still require more changes to the <strong>AppContainer</strong>, the <strong>MessageWriterStore</strong> and the <strong>MessageApi</strong>). It's much better to bake this in from the start. The big benefit is that, if you do so, you'll rarely have to worry about &quot;could this value be null&quot;* and &quot;could this data be changed if I pass it into another function&quot;.</p>
<p>* <em>(There will still be some places where you have to be alert about potential nulls, but these should largely arise from interacting with other libraries - the &quot;ToStringIfDefined&quot; extension method we saw earlier is an example of a place where nulls may be returned, but it is clearly documented as such and the return value is only intended to be passed to a React element factory method).</em></p>
<h3>Filling in more gaps</h3>
<p>If you've been following along and creating your own project with the code in this series, you will be all too aware that it doesn't build at the moment. Let's go through and fix everything up. Much of the required alterations will be similar to what is presented above, but there are a few other tips and tricks to consider along the way.</p>
<p>Let's start with the <strong>AppContainer</strong>. Last we saw it, it looked like this:</p>
<pre><code>using System;
using System.Collections.Generic;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.ViewModels;
using BridgeReactTutorial.Stores;
using BridgeReactTutorial.API;

namespace BridgeReactTutorial.Components
{
  public class AppContainer : Component&lt;AppContainer.Props, AppContainer.State&gt;
  {
    public AppContainer(AppContainer.Props props) : base(props) { }

    protected override void ComponentDidMount()
    {
      props.Store.Change += StoreChanged;
    }
    protected override void ComponentWillUnmount()
    {
      props.Store.Change -= StoreChanged;
    }
    private void StoreChanged()
    {
      SetState(new State
      {
        Message = props.Store.Message,
        MessageHistory = props.Store.MessageHistory
      });
    }

    public override ReactElement Render()
    {
      if (state == null)
        return null;

      return DOM.Div(null,
        new MessageEditor(
          className: new NonBlankTrimmedString(&quot;message&quot;),
          message:  state.Message,
          onChange: newState =&gt; props.Dispatcher.Dispatch(
            UserEditRequested.For(newState)
          ),
          onSave: () =&gt; props.Dispatcher.Dispatch(
            SaveRequested.For(
              new MessageDetails(
                new NonBlankTrimmedString(state.Message.Title.Text),
                new NonBlankTrimmedString(state.Message.Content.Text)
              )
            )
          )
        ),
        new MessageHistory(new MessageHistory.Props
        {
          ClassName = &quot;history&quot;,
          Messages = state.MessageHistory
        })
      );
    }

    public class Props
    {
      public AppDispatcher Dispatcher;
      public MessageWriterStore Store;
    }

    public class State
    {
      public MessageEditState Message;
      public IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt; MessageHistory;
    }
  }
}
</code></pre>
<p>It's nice and simple since we moved nearly all of the logic that it contained in <a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">Part One</a> into the <strong>MessageWriterStore</strong> in <a href="/writing-react-apps-using-bridgenet-the-dan-way-part-two">Part Two</a>.</p>
<p>The obvious thing to do, based on what I've been talking about today, is to change its <strong>Props</strong> and <strong>State</strong> classes to implement <strong>IAmImmutable</strong>.</p>
<p>After that, there is one difference between this component and the other components we've already looked at - this is stateful and they were state-<em>less</em>. That means that they only had &quot;props&quot; to think about, while the <strong>AppContainer</strong> has both &quot;props&quot; and &quot;state&quot;. As with the stateless components, it is presumed that the &quot;props&quot; reference may never be null. This can be enforced by using the same trick as we did for the others - mirror the <strong>Props</strong> constructor arguments in the <strong>AppContainer</strong>'s constructor arguments and generate a <strong>Props</strong> instance from them. However, the &quot;state&quot; reference <em>may</em> be null some times, as can be seen at the very start of the &quot;Render&quot; method. This means that the &quot;state&quot; type should be <strong>Optional&lt;State&gt;</strong>, rather than just <strong>State</strong>.</p>
<p>These changes result in this:</p>
<pre><code>using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.API;
using BridgeReactTutorial.Stores;
using BridgeReactTutorial.ViewModels;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Components
{
  public class AppContainer : Component&lt;AppContainer.Props, Optional&lt;AppContainer.State&gt;&gt;
  {
    public AppContainer(AppDispatcher dispatcher, MessageWriterStore store)
      : base(new Props(dispatcher, store)) { }

    protected override void ComponentDidMount()
    {
      props.Store.Change += StoreChanged;
    }
    protected override void ComponentWillUnmount()
    {
      props.Store.Change -= StoreChanged;
    }
    private void StoreChanged()
    {
      SetState(new State(
        message: props.Store.Message,
        messageHistory: props.Store.MessageHistory
      ));
    }

    public override ReactElement Render()
    {
      if (!state.IsDefined)
        return null;

      return DOM.Div(null,
        new MessageEditor(
          className: new NonBlankTrimmedString(&quot;message&quot;),
          message:  state.Value.Message,
          onChange: newState =&gt; props.Dispatcher.Dispatch(
            UserEditRequested.For(newState)
          ),
          onSave: () =&gt; props.Dispatcher.Dispatch(
            SaveRequested.For(
              new MessageDetails(
                new NonBlankTrimmedString(state.Value.Message.Title.Text),
                new NonBlankTrimmedString(state.Value.Message.Content.Text)
              )
            )
          )
        ),
        new MessageHistory(
          className: new NonBlankTrimmedString(&quot;history&quot;),
          messages: state.Value.MessageHistory
        )
      );
    }

    public class Props : IAmImmutable
    {
      public Props(AppDispatcher dispatcher, MessageWriterStore store)
      {
        this.CtorSet(_ =&gt; _.Dispatcher, dispatcher);
        this.CtorSet(_ =&gt; _.Store, store);
      }
      public AppDispatcher Dispatcher { get; }
      public MessageWriterStore Store { get; }
    }

    public class State : IAmImmutable
    {
      public State(
        MessageEditState message,
        NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt; messageHistory)
      {
        this.CtorSet(_ =&gt; _.Message, message);
        this.CtorSet(_ =&gt; _.MessageHistory, messageHistory);
      }
      public MessageEditState Message { get; }
      public NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt; MessageHistory { get; }
    }
  }
}
</code></pre>
<p>That transformation should have felt quite run-of-the-mill and predictable by this point - seen one component-tightening-up, seen them all. Let's move on to the <strong>MessageWriterStore</strong>. This is what deals with the events from the application, both from user-initiated events from DOM elements and from new-messages-data-available events from the <strong>MessageApi</strong>.</p>
<p>At the bare minimum, it will need some changes since it was written when the <strong>MessageEditState</strong> type was mutable and so the &quot;ValidateMessage&quot; method was able to mutate it (such as setting or clearing validation warning messages) in-place. I've moved away from that so that mutations are <em>always</em> explicit - there will no longer be a method that may or may not mutate a reference, if a method needs to set values on something then it will take the initial reference as an input and return a new one as its return value. But there are more of those sneaky &quot;implicit assumptions&quot; tucked away in the store that we should address. In the last post, we left it implemented like this:</p>
<pre><code>using System;
using System.Collections.Generic;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Stores
{
  public class MessageWriterStore
  {
    private RequestId _saveActionRequestId, _lastDataUpdatedRequestId;
    public MessageWriterStore(IReadAndWriteMessages messageApi, AppDispatcher dispatcher)
    {
      if (messageApi == null)
        throw new ArgumentNullException(&quot;messageApi&quot;);
      if (dispatcher == null)
        throw new ArgumentNullException(&quot;dispatcher&quot;);

      Message = GetInitialMessageEditState();
      MessageHistory = new Tuple&lt;int, MessageDetails&gt;[0];

      dispatcher.Receive(a =&gt; a
        .If&lt;StoreInitialised&gt;(
          condition: action =&gt; (action.Store == this),
          work: action =&gt; { }
        )
        .Else&lt;MessageEditStateChanged&gt;(action =&gt;
        {
          Message = action.NewState;
          ValidateMessage(Message);
        })
        .Else&lt;MessageSaveRequested&gt;(action =&gt;
        {
          _saveActionRequestId = messageApi.SaveMessage(action.Message);
          Message.IsSaveInProgress = true;
        })
        .Else&lt;MessageSaveSucceeded&gt;(
          condition: action =&gt; (action.RequestId == _saveActionRequestId),
          work: action =&gt;
          {
            _saveActionRequestId = null;
            Message = GetInitialMessageEditState();
            _lastDataUpdatedRequestId = messageApi.GetMessages();
          }
        )
        .Else&lt;MessageHistoryUpdated&gt;(
          condition: action =&gt;
            action.RequestId.IsEqualToOrComesAfter(_lastDataUpdatedRequestId),
          work: action =&gt;
          {
            _lastDataUpdatedRequestId = action.RequestId;
            MessageHistory = action.Messages;
          }
        )
        .IfAnyMatched(OnChange);
      );
    }

    public event Action Change;
    public MessageEditState Message;
    public IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt; MessageHistory;

    private MessageEditState GetInitialMessageEditState()
    {
      // Note: By using the ValidateMessage here, we don't need to duplicate the &quot;Untitled&quot;
      // string that should be used for the Caption value when the UI is first rendered
      // or when the user has entered some Title content but then deleted it again.
      // Similarly, we avoid having to repeat the validation messages that should be
      // displayed when the form is empty, since they will be set by ValidateMessage.
      var blankMessage = new MessageEditState
      {
        Caption = &quot;&quot;,
        Title = new TextEditState { Text = &quot;&quot; },
        Content = new TextEditState { Text = &quot;&quot; },
        IsSaveInProgress = false
      };
      ValidateMessage(blankMessage);
      return blankMessage;
    }

    private void ValidateMessage(MessageEditState message)
    {
      if (message == null)
        throw new ArgumentNullException(&quot;message&quot;);

      message.Caption = string.IsNullOrWhiteSpace(message.Title.Text)
        ? &quot;Untitled&quot;
        : message.Title.Text.Trim();
      message.Title.ValidationError = string.IsNullOrWhiteSpace(message.Title.Text)
        ? &quot;Must enter a title&quot;
        : null;
      message.Content.ValidationError = string.IsNullOrWhiteSpace(message.Content.Text)
        ? &quot;Must enter message content&quot;
        : null;
    }

    private void OnChange()
    {
      if (Change != null)
        Change();
    }
  }
}
</code></pre>
<p>Three things jump out at me here. Firstly, the &quot;_saveActionRequestId&quot; and &quot;_lastDataUpdatedRequestId&quot; references may not always be populated. If there is no save action in progress that we're waiting to complete, for example, then &quot;_saveActionRequestId&quot; won't have a value. Let's explicitly describe this in the type system by changing the type of these two values from <strong>RequestId</strong> to <strong>Optional&lt;RequestId&gt;</strong> (even though these values aren't part of a public API of the store class, there's still a benefit to indicating what may and may not have a value, for the sake of code clarity).</p>
<p>The second thing is that the &quot;Message&quot; and &quot;MessageHistory&quot; properties are only intended to be written to internally. They are available for reading by other classes (like the <strong>AppContainer</strong> component), but not for updating by other classes. It makes sense to change these from being public fields to being properties with public getters and private setters. This wasn't done originally because I wanted to start from the simplest possible implementations and only stray from that when there was a clear benefit. Today, we're dealing with the clear benefit of increased code clarity through the reduction of implicit assumptions. Moving to private-setter properties allows the compiler to enforce what was only <em>presumed</em> to be true before (instead of working on the assumption that no-one would try to update these references, now we can sleep safe that no-one other than the <strong>MessageWriteStore</strong> itself <em>can</em> change the references).</p>
<p>The third thing is that &quot;Change&quot; is an event and so may be null if no-one has subscribed to it. That's just the way that events work in C#. We could either come up with a new way to represent events or we could accept that a null check is required (and that we can't use an <strong>Optional</strong> type to represent it). I think that the pragmatic thing to do is to just accept it - this is basically how events have worked in C# from day one and I don't think that there would be any improvement to code clarity by trying to shy away from this accepted practice.</p>
<p>What is really going to be the most interesting part in updating the <strong>MessageWriterStore</strong> is, I think, how we change the validation / <strong>MessageEditState</strong>-mutating code -</p>
<pre><code>private void ValidateMessage(MessageEditState message)
{
  if (message == null)
    throw new ArgumentNullException(&quot;message&quot;);

  message.Caption = string.IsNullOrWhiteSpace(message.Title.Text)
    ? &quot;Untitled&quot;
    : message.Title.Text.Trim();
  message.Title.ValidationError = string.IsNullOrWhiteSpace(message.Title.Text)
    ? &quot;Must enter a title&quot;
    : null;
  message.Content.ValidationError = string.IsNullOrWhiteSpace(message.Content.Text)
    ? &quot;Must enter message content&quot;
    : null;
}
</code></pre>
<p>Probably the absolute simplest thing that we could do would be to rewrite it like this:</p>
<pre><code>private MessageEditState ValidateMessage(MessageEditState message)
{
  if (message == null)
    throw new ArgumentNullException(&quot;message&quot;);

  if (string.IsNullOrWhiteSpace(message.Title.Text))
    message = message.With(_ =&gt; _.Caption, new NonBlankTrimmedString(&quot;Untitled&quot;));
  else
    message = message.With(_ =&gt; _.Caption, new NonBlankTrimmedString(message.Title.Text));

  if (string.IsNullOrWhiteSpace(message.Title.Text))
    message = message.With(_ =&gt; _.Title, SetValidationMessage(message.Title, new NonBlankTrimmedString(&quot;Must enter a title&quot;)));
  else
    message = message.With(_ =&gt; _.Title, SetValidationMessage(message.Title, null));

  if (string.IsNullOrWhiteSpace(message.Content.Text))
    message = message.With(_ =&gt; _.Content, SetValidationMessage(message.Content, new NonBlankTrimmedString(&quot;Must enter message content&quot;)));
  else
    message = message.With(_ =&gt; _.Content, SetValidationMessage(message.Content, null));

  return message;
}

private TextEditState SetValidationMessage(
  TextEditState textEditState,
  Optional&lt;NonBlankTrimmedString&gt; message)
{
  if (textEditState == null)
    throw new ArgumentNullException(&quot;textEditState&quot;);

  return textEditState.With(_ =&gt; _.ValidationError, message);
}
</code></pre>
<p>That is.. more verbose, I think would be a polite way to describe it. I would normally have wrapped some of the lines in order to fit the horizontal scrolling budget I allow on code samples on my blog but I wanted to give this arrangement the best change at looking succint that it could. And it's still not looking very good.</p>
<p>What's much worse, though, is that I don't think that this code is very easy to read. I think that there's quite a lot of noise that masks the actual intent. It's not complicated, by a long shot, but I think that the actual logic that it's trying to apply is drowning a little bit in all the code that's required. The verbosity itself, is not the biggest problem for me - I will take code that is slightly longer if it's clearer (I'm not just talking about descriptive variable and method names and I'm don't mean avoiding compact &quot;clever&quot; code, I mean like the changes from mutable classes to <strong>IAmImmutable</strong> implementations; they are more verbose but they are much more expressive).</p>
<p>One alternative would be:</p>
<pre><code>private MessageEditState ValidateMessage(MessageEditState message)
{
  if (message == null)
    throw new ArgumentNullException(&quot;message&quot;);

  var caption = string.IsNullOrWhiteSpace(message.Title.Text)
    ? new NonBlankTrimmedString(&quot;Untitled&quot;)
    : new NonBlankTrimmedString(message.Title.Text);
  var titleEditState = string.IsNullOrWhiteSpace(message.Title.Text)
    ? SetValidationMessage(message.Title, new NonBlankTrimmedString(&quot;Must enter a title&quot;))
    : null;
  var contentEditState = string.IsNullOrWhiteSpace(message.Content.Text)
    ? SetValidationMessage(message.Content, new NonBlankTrimmedString(&quot;Must enter message content&quot;))
    : null;

  return message
    .With(_ =&gt; _.Caption, caption)
    .With(_ =&gt; _.Title, titleEditState)
    .With(_ =&gt; _.Content, contentEditState);
}
</code></pre>
<p>This is much improved. The code <em>looks</em> cleaner at a glance and, crucially, it's much clearer in its intent.</p>
<p>However.. the way that we've reduced the syntactic noise is by separating the &quot;what should the new values be&quot; from the &quot;set these new values&quot;. This isn't too bad with only three properties, but if the object being validated was more complex then the new-value-determining code would drift further from the new-value-setting code, which would be a pity since they are intrinsicially linked concepts (and it would be nice - meaning that the code should be easier to understand at a glance - if the two types of code were linked again for each property, with each new-value-determiner being present alongside the new-value-setter).</p>
<p>Instead of splitting the code up for clarity, we can try to make it clearer by using abstractions.</p>
<p>Let's start by introducing a method to abstract the setting-or-removing of validation messages from <strong>TextEditState</strong> instances -</p>
<pre><code>private TextEditState Validate(
  TextEditState textEditState,
  Predicate&lt;TextEditState&gt; validIf,
  NonBlankTrimmedString messageIfInvalid)
{
  if (textEditState == null)
    throw new ArgumentNullException(&quot;textEditState&quot;);
  if (validIf == null)
    throw new ArgumentNullException(&quot;validIf&quot;);
  if (messageIfInvalid == null)
    throw new ArgumentNullException(&quot;messageIfInvalid&quot;);

  return textEditState.With(_ =&gt; _.ValidationError, validIf(textEditState)
    ? null
    : messageIfInvalid);
}
</code></pre>
<p>This will take a <strong>TextEditState</strong>, a rule that determines whether or not its &quot;Text&quot; value should be considered valid and a message to set if the value is <em>not</em> valid (if it <em>is</em> valid then the message will be cleared).</p>
<p>This would allow us to set (or remove) the validation message on the &quot;Title&quot; property with code such as:</p>
<pre><code>message = message.With(
  _ =&gt; _.Title,
  Validate(
    message.Title,
    textEditState =&gt; string.IsNullOrWhiteSpace(textEditState.Text),
    new NonBlankTrimmedString(&quot;Must enter a title&quot;)
  )
);
</code></pre>
<p>Since the validation logic for both &quot;Title&quot; and &quot;Content&quot; is the same and &quot;textEditState =&gt; string.IsNullOrWhiteSpace(textEditState.Text)&quot; is quite long and going to be responsible for a lot of the &quot;syntactic noise&quot; that I want to avoid, this could also be abstracted by defining another method -</p>
<pre><code>private bool MustHaveValue(TextEditState textEditState)
{
  if (textEditState == null)
    throw new ArgumentNullException(&quot;textEditState&quot;);

  return !string.IsNullOrWhiteSpace(textEditState.Text);
}
</code></pre>
<p>If we also move the constant messages (the two validation warnings and the &quot;Untitled&quot; caption string) into static class members -</p>
<pre><code>private readonly static NonBlankTrimmedString _defaultCaption
  = new NonBlankTrimmedString(&quot;Untitled&quot;);

private readonly static NonBlankTrimmedString _noTitleWarning
  = new NonBlankTrimmedString(&quot;Must enter a title&quot;);

private readonly static NonBlankTrimmedString _noContentWarning
  = new NonBlankTrimmedString(&quot;Must enter message content&quot;);
</code></pre>
<p>.. then we can make the &quot;Title&quot; validation-message-setting/unsetting much clearer:</p>
<pre><code>message = message
  .With(_ =&gt; _.Title, Validate(message.Title, MustHaveValue, _noTitleWarning));
</code></pre>
<p>If we add a final helper method to make the setting of the &quot;Caption&quot; property simpler -</p>
<pre><code>private NonBlankTrimmedString ToNonBlankTrimmedString(
  TextEditState textEditState,
  NonBlankTrimmedString fallback)
{
  if (textEditState == null)
    throw new ArgumentNullException(&quot;textEditState&quot;);
  if (fallback == null)
    throw new ArgumentNullException(&quot;fallback&quot;);

  return (textEditState.Text.Trim() == &quot;&quot;)
    ? fallback
    : new NonBlankTrimmedString(textEditState.Text);
}
</code></pre>
<p>.. then the &quot;ValidateMessage&quot; can be reduced to the following:</p>
<pre><code>private MessageEditState ValidateMessage(MessageEditState message)
{
  if (message == null)
    throw new ArgumentNullException(&quot;message&quot;);

  return message
    .With(_ =&gt; _.Caption, ToNonBlankTrimmedString(message.Title, fallback: _defaultCaption))
    .With(_ =&gt; _.Title, Validate(message.Title, MustHaveValue, _noTitleWarning))
    .With(_ =&gt; _.Content, Validate(message.Content, MustHaveValue, _noContentWarning));
}
</code></pre>
<p>Now I really think that we have the best of every world. The actual code in &quot;ValidateMessage&quot; is short and to the point. While there are more lines of code in total (when you also consider the &quot;ToNonBlankTrimmedString&quot;, &quot;Validate&quot; and &quot;MustHaveValue&quot; methods), each method is more focused and very easy to fully comprehend at a glance. This is the crux of the matter for me - these changes are all about (say it with, because I'm sure that you know what's coming by this point): making code easier to reason about and hence easier to read, maintain and extend.</p>
<h3>Sidebar: Pure functions</h3>
<p>In the past, I've had a tendency to interchange the words &quot;method&quot; and &quot;function&quot;. For the last year or so (and definitely in this series of posts, I hope!) I've been more careful not to use &quot;function&quot; when I mean &quot;method&quot;. Having read around, it seems like the accepted difference between the two is (to quote an excellent example from a <a href="http://stackoverflow.com/a/155655">StackOverflow answer</a>) -</p>
<blockquote>
<p>A function is a piece of code that is called by name. It can be passed data to operate on (ie. the parameters) and can optionally return data (the return value).</p>
<p>All data that is passed to a function is explicitly passed.</p>
<p>A method is a piece of code that is called by name that is associated with an object. In most respects it is identical to a function except for two key differences.</p>
<p>It is implicitly passed the object on which it was called.<br />
It is able to operate on data that is contained within the class (remembering that an object is an instance of a class - the class is the definition, the object is an instance of that data).</p>
</blockquote>
<p>That means that C# only has methods since every method is associated with an object. Even static methods are, technically, since they have access to anything else that is static within the type that declares the static method.</p>
<p>A function will <em>only</em> consider data passed explicitly in arguments, which is not a concept that is possible to represent with C#.</p>
<p>The key difference, then, being that a function is absolutely guaranteed to always retun the same value given the same argument(s). Parallels are often drawn to mathematical functions. If you think about the need to &quot;calculate the square root of x&quot;, this is a good example of a function as it will always return the same result for any value of &quot;x&quot;. &quot;x&quot; is the <em>only</em> thing that matters.</p>
<p>With C#, you can get no such guarantees. Just to really drive the point home, here are three example - first, an instance method:</p>
<pre><code>public class Adder
{
  private readonly int _amountToIncrement;
  public Adder(int amountToIncrement)
  {
    _amountToIncrement = amountToIncrement;
  }

  public int AddTo(int value)
  {
    return value + _amountToIncrement;
  }
}
</code></pre>
<p>Obviously, the return value from &quot;AddTo&quot; depends on more than the argument passed in - it also depends upon the &quot;_amountToIncrement&quot; that the <strong>Adder</strong> instance has.</p>
<p>And a couple of static examples:</p>
<pre><code>public static class Adder
{
  private static int _amountToIncrement = 0;

  public static int AddTo(int value)
  {
    _amountToIncrement++;
    return value + _amountToIncrement;
  }
}

public static class DayNameRetriever
{
  public static string GetDayNameForDateThisMonth(int date)
  {
    var today = DateTime.Now;
    var firstDayOfMonth = today.AddDays(-today.Day).AddDays(date);
    return firstDayOfMonth.ToString(&quot;dddd&quot;);
  }
}
</code></pre>
<p>Granted, theses examples are clearly contrived to illustrate a point and are not genuinely useful code. But they are also not totally unlike code that exists in the real world. The point is that, because C# only has methods, the mental burden in fully comprehending any method is increased because you have to be aware of anything else that the method might have access to.</p>
<p>Which is a pity, because the &quot;ToNonBlankTrimmedString&quot;, &quot;Validate&quot; and &quot;MustHaveValue&quot; methods are perfect examples of genuine <em>functions</em> - they <em>only</em> operate on their arguments. The &quot;ValidateMessage&quot; only strays outside of its arguments to access the &quot;default caption&quot;, &quot;missing-title validation message&quot; and &quot;missing-content validation message&quot; values, but since there are effectively constants (since they are static readonly instances of immutable types) then &quot;ValidateMessage&quot; could also be considered to be a true function (in particular, we know that it will always return the same data given the same arguments).</p>
<p><em>Note: Interestingly, there is a <a href="https://msdn.microsoft.com/en-us/library/system.diagnostics.contracts.pureattribute(v=vs.110).aspx">[Pure]</a> attribute in the .net framework, which is intended to indicate that a method is a &quot;pure function&quot; (where the phrase &quot;pure function&quot; is effectively consistent with the description of a &quot;function&quot; that I gave above). This seems like a nice idea, but it's not actually enforced by the compiler and so it's more of a suggestion, which greatly reduces my enthusiasm. The reason that I want to use immutable types to represent data that should not change (like React components' props types) is that it encodes the &quot;this data is immutable&quot; information into the type system and results in any code that tries to break this requirement (by trying to set a value on an immutable type, for example) as being identified as an error by the compiler. The [Pure] attribute will, alas, not result in any compiler warnings or errors.</em></p>
<p>The closest that we can get to indicating that a method should be considered a &quot;function&quot;  is by making it static. As I showed above, this does <em>not</em> mean that the method is truly &quot;pure&quot; (at least, there is no provision for the compiler to confirm that this is so) but making a function static does, at least, mean that it can not access any instance fields, properties or methods and so there is still less to consider when reading one of these methods. If you know that a method is static, then there is less mental burden in reading it since you know that there is less code that you need to consider that may possibly affect the current method.</p>
<p>What I'm trying to get at is that the &quot;ValidateMessage&quot;, &quot;ToNonBlankTrimmedString&quot;, &quot;Validate&quot; and &quot;MustHaveValue&quot; methods should all be made static and, to go further, it's worth writing <em>all</em> methods as static unless you have a compelling reason not to. For a lot of methods, it's obvious that they have to be instance methods - the &quot;Render&quot; methods on the React component classes have to be instance methods, obviously, because they depend upon the &quot;props&quot; data for that component instance. But, in the final <strong>MessageWriterStore</strong> implementation (see below), if we pull the &quot;OnChange&quot; method into a lambda then there is no need for <em>any</em> of the methods to not be static.</p>
<p>It seems, in general, that people write methods as instance methods by default and then make them static if they encounter a good reason to do so. I suggest that methods be written as static by default and only made into instance methods if there is a good reason to do so.</p>
<p><em>(To be honest, this is still something that I'm trying to consistently apply to my own work - it's very easy to unconsciously write instance methods by default by omitting the &quot;static&quot; keyword; old habits die hard!)</em></p>
<pre><code>using System;
using System.Collections.Generic;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Stores
{
  public class MessageWriterStore
  {
    private Optional&lt;RequestId&gt; _saveActionRequestId, _lastDataUpdatedRequestId;
    public MessageWriterStore(IReadAndWriteMessages messageApi, AppDispatcher dispatcher)
    {
      if (messageApi == null)
        throw new ArgumentNullException(&quot;messageApi&quot;);
      if (dispatcher == null)
        throw new ArgumentNullException(&quot;dispatcher&quot;);

      Message = GetInitialMessageEditState();
      MessageHistory = NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt;.Empty;

      dispatcher.Receive(a =&gt; a
        .If&lt;StoreInitialised&gt;(
          condition: action =&gt; (action.Store == this),
          work: action =&gt; { }
        )
        .Else&lt;UserEditRequested&lt;MessageEditState&gt;&gt;(action =&gt;
          Message = ValidateMessage(action.NewState)
        )
        .Else&lt;SaveRequested&lt;MessageDetails&gt;&gt;(action =&gt;
        {
          _saveActionRequestId = messageApi.SaveMessage(action.Data);
          Message = Message.With(_ =&gt; _.IsSaveInProgress, true);
        })
        .Else&lt;SaveSucceeded&gt;(
          condition: action =&gt; (action.RequestId == _saveActionRequestId),
          work: action =&gt;
          {
            _saveActionRequestId = null;
            Message = GetInitialMessageEditState();
            _lastDataUpdatedRequestId = messageApi.GetMessages();
          }
        )
        .Else&lt;DataUpdated&lt;NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt;&gt;&gt;(
          condition:
            action =&gt; action.RequestId.IsEqualToOrComesAfter(_lastDataUpdatedRequestId),
          work: action =&gt;
          {
            _lastDataUpdatedRequestId = action.RequestId;
            MessageHistory = action.Data;
          }
        )
        .IfAnyMatched(() =&gt; { if (Change != null) Change(); })
      );
    }

    public event Action Change;
    public MessageEditState Message { get; private set; }
    public NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt; MessageHistory { get; private set; }

    private readonly static NonBlankTrimmedString _defaultCaption
      = new NonBlankTrimmedString(&quot;Untitled&quot;);
    private readonly static NonBlankTrimmedString _noTitleWarning
      = new NonBlankTrimmedString(&quot;Must enter a title&quot;);
    private readonly static NonBlankTrimmedString _noContentWarning
      = new NonBlankTrimmedString(&quot;Must enter message content&quot;);

    private static MessageEditState GetInitialMessageEditState()
    {
      return new MessageEditState(
        caption: _defaultCaption,
        title: new TextEditState(&quot;&quot;, _noTitleWarning),
        content: new TextEditState(&quot;&quot;, _noContentWarning),
        isSaveInProgress: false
      );
    }

    private static MessageEditState ValidateMessage(MessageEditState message)
    {
      if (message == null)
        throw new ArgumentNullException(&quot;message&quot;);

      return message
        .With(_ =&gt; _.Caption, ToNonBlankTrimmedString(message.Title, _defaultCaption))
        .With(_ =&gt; _.Title, Validate(message.Title, MustHaveValue, _noTitleWarning))
        .With(_ =&gt; _.Content, Validate(message.Content, MustHaveValue, _noContentWarning));
    }

    private static NonBlankTrimmedString ToNonBlankTrimmedString(
      TextEditState textEditState,
      NonBlankTrimmedString fallback)
    {
      if (textEditState == null)
        throw new ArgumentNullException(&quot;textEditState&quot;);
      if (fallback == null)
        throw new ArgumentNullException(&quot;fallback&quot;);

      return (textEditState.Text.Trim() == &quot;&quot;)
        ? fallback
        : new NonBlankTrimmedString(textEditState.Text);
    }

    private static TextEditState Validate(
      TextEditState textEditState,
      Predicate&lt;TextEditState&gt; validIf,
      NonBlankTrimmedString messageIfInvalid)
    {
      if (textEditState == null)
        throw new ArgumentNullException(&quot;textEditState&quot;);
      if (validIf == null)
        throw new ArgumentNullException(&quot;validIf&quot;);
      if (messageIfInvalid == null)
        throw new ArgumentNullException(&quot;messageIfInvalid&quot;);

      return textEditState.With(_ =&gt; _.ValidationError, validIf(textEditState)
        ? null
        : messageIfInvalid);
    }

    private static bool MustHaveValue(TextEditState textEditState)
    {
      if (textEditState == null)
        throw new ArgumentNullException(&quot;textEditState&quot;);

      return !string.IsNullOrWhiteSpace(textEditState.Text);
    }
  }
}
</code></pre>
<p>Note that, since the <strong>RequestId</strong> values are now <strong>Optional&lt;RequestId&gt;</strong> instances, we need to change the &quot;IsEqualToOrComesAfter&quot; extension method -</p>
<pre><code>using System;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.API
{
  public static class RequestIdExtensions
  {
    public static bool IsEqualToOrComesAfter(
      this RequestId source,
      Optional&lt;RequestId&gt; other)
    {
      if (source == null)
        throw new ArgumentNullException(&quot;source&quot;);

      // If the &quot;other&quot; reference is no-RequestId then the &quot;source&quot; may be considered to
      // come after it
      if (!other.IsDefined)
        return true;

      return (source == other.Value) || source.ComesAfter(other.Value);
    }
  }
}
</code></pre>
<h3>The rest of the gaps</h3>
<p>There's been a lot of theory covered so far. To really put it into practice, though, we need to fix the rest of the compile errors in the example application.</p>
<p>Changing the <strong>MessageEditor</strong>, <strong>MessageHistory</strong>, <strong>AppContainer</strong> and <strong>MessageWriteStore</strong> to use the new immutable types (the now-immutable <strong>MessageDetails</strong> and the <strong>NonNullList</strong> type from <a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a>) require further changes to the <strong>MessageApi</strong> and the <strong>App</strong> file that initialises the application.</p>
<p>And, while we're making everything immutable, let's change the action classes. Currently, we have actions such as:</p>
<pre><code>using Bridge.React;
using BridgeReactTutorial.API;

namespace BridgeReactTutorial.Actions
{
  public class DataUpdated&lt;T&gt; : IDispatcherAction
  {
    public RequestId RequestId;
    public T Data;
  }
  public static class DataUpdated
  {
    public static DataUpdated&lt;T&gt; For&lt;T&gt;(RequestId requestId, T data)
    {
      return new DataUpdated&lt;T&gt; { RequestId = requestId, Data = data };
    }
  }
}
</code></pre>
<p>This should be:</p>
<pre><code>using Bridge.React;
using BridgeReactTutorial.API;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Actions
{
  public class DataUpdated&lt;T&gt; : IDispatcherAction, IAmImmutable
  {
    public DataUpdated(RequestId requestId, T data)
    {
      this.CtorSet(_ =&gt; _.RequestId, requestId);
      this.CtorSet(_ =&gt; _.Data, data);
    }
    public RequestId RequestId { get; }
    public T Data { get; }
  }
  public static class DataUpdated
  {
    public static DataUpdated&lt;T&gt; For&lt;T&gt;(RequestId requestId, T data)
    {
      return new DataUpdated&lt;T&gt;(requestId, data);
    }
  }
}
</code></pre>
<p>The others require similar changes -</p>
<pre><code>using Bridge.React;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Actions
{
  public class SaveRequested&lt;T&gt; : IDispatcherAction, IAmImmutable
  {
    public SaveRequested(T data)
    {
      this.CtorSet(_ =&gt; _.Data, data);
    }
    public T Data { get; }
  }
  public static class SaveRequested
  {
    public static SaveRequested&lt;T&gt; For&lt;T&gt;(T data)
    {
      return new SaveRequested&lt;T&gt;(data);
    }
  }
}

using Bridge.React;
using BridgeReactTutorial.API;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Actions
{
  public class SaveSucceeded : IDispatcherAction, IAmImmutable
  {
    public SaveSucceeded(RequestId requestId)
    {
      this.CtorSet(_ =&gt; _.RequestId, requestId);
    }
    public RequestId RequestId { get; }
  }
}

using Bridge.React;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Actions
{
  public class StoreInitialised : IDispatcherAction, IAmImmutable
  {
    public StoreInitialised(object store)
    {
      this.CtorSet(_ =&gt; _.Store, store);
    }
    public object Store { get; }
  }
}

using Bridge.React;
using BridgeReactTutorial.ViewModels;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Actions
{
  public class UserEditRequested&lt;T&gt; : IDispatcherAction, IAmImmutable
  {
    public UserEditRequested(T newState)
    {
      this.CtorSet(_ =&gt; _.NewState, newState);
    }
    public T NewState { get; }
  }
  public static class UserEditRequested
  {
    public static UserEditRequested&lt;T&gt; For&lt;T&gt;(T newState)
    {
      return new UserEditRequested&lt;T&gt;(newState);
    }
  }
}
</code></pre>
<p>The <strong>App</strong> class requires only minor tweaks, from:</p>
<pre><code>using System.Linq;
using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.API;
using BridgeReactTutorial.Components;
using BridgeReactTutorial.Stores;

namespace BridgeReactTutorial
{
  public class App
  {
    [Ready]
    public static void Go()
    {
      var container = Document.GetElementById(&quot;main&quot;);
      container.ClassName = string.Join(
        &quot; &quot;,
        container.ClassName.Split().Where(c =&gt; c != &quot;loading&quot;)
      );

      var dispatcher = new AppDispatcher();
      var messageApi = new MessageApi(dispatcher);
      var store = new MessageWriterStore(messageApi, dispatcher);
      React.Render(
        new AppContainer(new AppContainer.Props
        {
          Dispatcher = dispatcher,
          Store = store
        }),
        container
      );
      dispatcher.Dispatch(new StoreInitialised { Store = store });
    }
  }
}
</code></pre>
<p>to:</p>
<pre><code>using System.Linq;
using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.API;
using BridgeReactTutorial.Components;
using BridgeReactTutorial.Stores;

namespace BridgeReactTutorial
{
  public class App
  {
    [Ready]
    public static void Go()
    {
      var container = Document.GetElementById(&quot;main&quot;);
      container.ClassName = string.Join(
        &quot; &quot;,
        container.ClassName.Split().Where(c =&gt; c != &quot;loading&quot;)
      );

      var dispatcher = new AppDispatcher();
      var messageApi = new MessageApi(dispatcher);
      var store = new MessageWriterStore(messageApi, dispatcher);
      React.Render(
        new AppContainer(dispatcher, store),
        container
      );
      dispatcher.Dispatch(new StoreInitialised(store));
    }
  }
}
</code></pre>
<p>Finally, the <strong>MessageApi</strong> needs various alterations to deal with the fact that all data types (such as the <strong>MessageDetails</strong>, the message history and the action classes) are immutable -</p>
<pre><code>using System;
using Bridge;
using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.ViewModels;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.API
{
  public class MessageApi : IReadAndWriteMessages
  {
    private readonly AppDispatcher _dispatcher;
    private NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt; _messages;
    public MessageApi(AppDispatcher dispatcher)
    {
      if (dispatcher == null)
        throw new ArgumentException(&quot;dispatcher&quot;);

      _dispatcher = dispatcher;
      _messages = NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt;.Empty;

      // To further mimic a server-based API (where other people may be recording messages
      // of their own), after a 10s delay a periodic task will be executed to retrieve a
      // new message
      Window.SetTimeout(
        () =&gt; Window.SetInterval(GetChuckNorrisFact, 5000),
        10000
      );
    }

    public RequestId SaveMessage(MessageDetails message)
    {
      return SaveMessage(message, optionalSaveCompletedCallback: null);
    }

    private RequestId SaveMessage(
      MessageDetails message,
      Action optionalSaveCompletedCallback)
    {
      if (message == null)
        throw new ArgumentNullException(&quot;message&quot;);

      var requestId = new RequestId();
      Window.SetTimeout(
        () =&gt;
        {
          _messages = _messages.Add(Saved.For(
            (MessageId)(int)_messages.Count,
            message
          ));
          _dispatcher.Dispatch(new SaveSucceeded(requestId));
          if (optionalSaveCompletedCallback != null)
            optionalSaveCompletedCallback();
        },
        1000 // Simulate a roundtrip to the server
      );
      return requestId;
    }

    public RequestId GetMessages()
    {
      var requestId = new RequestId();
      Window.SetTimeout(
        () =&gt; _dispatcher.Dispatch(DataUpdated.For(requestId, _messages)),
        1000 // Simulate a roundtrip to the server
      );
      return requestId;
    }

    private void GetChuckNorrisFact()
    {
      var request = new XMLHttpRequest();
      request.ResponseType = XMLHttpRequestResponseType.Json;
      request.OnReadyStateChange = () =&gt;
      {
        if (request.ReadyState != AjaxReadyState.Done)
          return;

        if ((request.Status == 200) || (request.Status == 304))
        {
          try
          {
            var apiResponse = (ChuckNorrisFactApiResponse)request.Response;
            if ((apiResponse.Type == &quot;success&quot;)
            &amp;&amp; (apiResponse.Value != null)
            &amp;&amp; !string.IsNullOrWhiteSpace(apiResponse.Value.Joke))
            {
              // The Chuck Norris Facts API (http://www.icndb.com/api/) returns strings
              // html-encoded, so they need decoding before be wrapped up in a
              // MessageDetails instance
              // - Note: After the save has been processed, GetMessages is called so
              //   that a MessageHistoryUpdate action is dispatched
              SaveMessage(
                new MessageDetails(
                  title: new NonBlankTrimmedString(&quot;Fact&quot;),
                  content: new NonBlankTrimmedString(HtmlDecode(apiResponse.Value.Joke))
                ),
                () =&gt; GetMessages()
              );
              return;
            }
          }
          catch
          {
            // Ignore any error and drop through to the fallback message-generator below
          }
        }
        SaveMessage(new MessageDetails(
          title: new NonBlankTrimmedString(&quot;Fact&quot;),
          content: new NonBlankTrimmedString(&quot;API call failed when polling for content :(&quot;)
        ));
      };
      request.Open(&quot;GET&quot;, &quot;http://api.icndb.com/jokes/random&quot;);
      request.Send();
    }

    private string HtmlDecode(string value)
    {
      if (value == null)
        throw new ArgumentNullException(&quot;value&quot;);

      var wrapper = Document.CreateElement(&quot;div&quot;);
      wrapper.InnerHTML = value;
      return wrapper.TextContent;
    }

    [IgnoreCast]
    private class ChuckNorrisFactApiResponse
    {
      public extern string Type { [Template(&quot;type&quot;)] get; }
      public extern FactDetails Value { [Template(&quot;value&quot;)] get; }

      [IgnoreCast]
      public class FactDetails
      {
        public extern int Id { [Template(&quot;id&quot;)] get; }
        public extern string Joke { [Template(&quot;joke&quot;)]get; }
      }
    }
  }
}
</code></pre>
<p>One pleasant change was the removal of code that was previously in the <strong>MessageApi</strong> with the following comment:</p>
<pre><code>// ToArray is used to return a clone of the message set - otherwise, the caller would
// end up with a list that is updated when the internal reference within this class
// is updated (which sounds convenient but it's not the behaviour that would be
// exhibited if this was really persisting messages to a server somewhere)
</code></pre>
<p>Since the message list is described by an immutable structure, there is no way that a particular reference's data could change. There is no way that a component could have a reference to this data type and then find that the data in that reference had changed by the time that an event bubbled up to that component from one of its child components. Similarly, when the <strong>MessageApi</strong> passes its message history data out, there is no action that may be performed by any code that receives the message history reference that could &quot;pollute&quot; the data that the <strong>MessageApi</strong> stores internally.</p>
<p>Previously, when the <strong>MessageApi</strong> wanted to share its message history data, we had two options - we could hope that the mutable list of mutable <strong>MessageDetails</strong> would never be manipulated when it was passed out from the <strong>MessageApi</strong> or we could try to make it impossible for other code to pollute the <strong>MessageApi</strong>'s copy of the data, which is what the &quot;ToArray&quot; call went some way towards (note that this wouldn't have saved us from code that received the mutable message history and then changed one of the fields on any of the individual mutable <strong>MessageDetails</strong> instances - this <em>would</em> have polluted to <strong>MessageApi</strong>'s internal data).</p>
<p>This is a nice example of how immutable structures can actually aid performance <em>as well</em> as aiding code clarity. Before, we were using a defensive &quot;ToArray&quot; call to try to avoid any silly mistakes polluting the <strong>MessageApi</strong>'s internal data. This was only a partial solution anyway, since, to really protect ourselves, we would have needed to clone the entire list - cloning each individual <strong>MessageDetails</strong> instance, as well as the list itself. Now that the data is immutable, such cloning (which can be very expensive in some case) is not necessary. I maintain, though, that the biggest benefit is to code clarity rather than performance - it is now <em>impossible</em> to make the &quot;silly mistake&quot; of mutating shared data, because the previously-implicit behaviour guideline of &quot;do not try to mutate this data, please&quot; is now encapsulated in the type sytem.</p>
<p>It's not uncommon to hear people claim that using immutable types incur a performance cost. I believe that this is only really true at a highly localised level. For example, if you have an array and you want to change the element at index 5, that is an incredibly cheap operation and it is not possible to have an &quot;immutable array&quot; that has a method that will give you a new immutable array instance with a different value at index 5 as cheaply. At this level, mutable structures can perform operations more quickly. However, immutable structures can allow techniques that provide performance benefits at a higher level, such as described above, where expensive cloning operations may be avoided entirely (general-case cloning operations can be expensive in CPU <em>and</em> in memory, since a clone will duplicate the entire data structure, whereas mature immutable-type libraries leverage clever &quot;persistent structures&quot; to reuse data between instances).</p>
<p><em>(It has become less common to hear this argument against immutable data structures since they are being much more widely used these days - React is an excellent example in that it leverages immutability to allow for fantastic performance, rather than immutability being a cost that the React library has to pay).</em></p>
<p>While performance is not my number one goal (which is not to say that I don't think it's an <em>important</em> target, I'm just saying that I value code clarity more highly), this topic of conversation leads me nicely on to the next topic.</p>
<h3>Pure Components</h3>
<p>If a &quot;pure function&quot; is one that returns a value based solely upon its arguments, then a &quot;pure component&quot; is a parallel concept - it generates content based solely upon its &quot;props&quot; data.</p>
<p>To recall what our example application looks like -</p>
<img alt="Message Editor and Message History" src="/Content/Images/Posts/ReactTutorial1.png" class="NoBorder AlwaysFullWidth" title="Message Editor and Message History" />
<p>There are basically two parts to it; the Message Editor and the Message History. The Message Editor part changes after one of any of the following occurs -</p>
<ol>
<li>While the entry form is enabled, the user changes the content in one of the text inputs</li>
<li>While the entry form is enabled and both text inputs have values, the user clicks Save</li>
<li>A save request is completed and the form changes back from disabled to enabled</li>
</ol>
<p>The Message History part changes only when the <strong>MessageApi</strong> sends a message to say that there is new message data to display.</p>
<p>What happens in our application is that <em>every</em> change results in a full React re-render. React is very efficient and its Virtual DOM minimises (and can batch) changes to the slow browser DOM, so this is rarely something to worry about. However, it might lead you to think -</p>
<blockquote>
<p>If I know that a particular event will only result in changes to the Message Editor, isn't it wasteful to React to re-render the entire Message History content in its Virtual DOM - <em>particularly</em> if it does this only to discover that no changes to the browser DOM need to be applied?</p>
</blockquote>
<p>This is an entirely reasonable question. If there are a hundred messages in the Message History, does that component <em>really</em> have to re-render them all in the Virtual DOM every time that the user presses a button to change the value in the &quot;Title&quot; text input in the Message Editor? What if there 1000 messages in the history? Or what if this was a much more complicated application with many, many editable inputs and lists of results all over the page - do I really want the entirety of this complicated UI to be re-rendered by the Virtual DOM every time that the user edits a single field?</p>
<p>If we were using mutable structures to represent the data that the React component hierarchy has to render, we would have a few options. One would be to change the component structure such that there were more stateful components in order to try to only update branches of the hierarchy that need to change according to particular changes. In our example, the <strong>MessageEditor</strong> could be made stateful in a bid to limit changes to the text inputs from resulting in re-renders of the <strong>MessageHistory</strong> (which would also have to become a stateful component, so that it could update itself when the message history data changes). This would require the <strong>MessageWriteStore</strong> to be changed as well. On the surface of it, this doesn't necessarily sound like a terrible idea, but stateful components will <em>always</em> require more thought and planning than stateless components and so this would be a move back towards more complicated component models. This would be an unfortunate step back from where we are now, where the complications are minimised and most components are stateless. We would no longer have a render-down and pass-events-up model, we would have a sort of branched version of it.</p>
<p>Another option would be to try to have components make use of React's &quot;<a href="https://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate">shouldComponentUpdate</a>&quot; method. This is a method that may optionally be implemented on components, that is called before a component's &quot;Render&quot; method is called, so long as that component has been rendered at least once before. It will be given two &quot;props&quot; values - one is the props data from the last render and the second is the new props data that has been specified for the re-render. If this method returns true then the component is re-rendered (to the Virtual DOM) as normal. If it returns false then the component's &quot;Render&quot; method is <em>not</em> called. This would mean that none of its child components would be re-rendered either, since those re-renders are only triggered by code in their parent's component's &quot;Render&quot; method. If it was possible for the <strong>MessageHistory</strong> to look at its last props and its next props and see that they describe the same data, then the entire re-render work could be avoided. The problem comes in working that out, though - for the cases where the old and new messages data <em>was</em> the same and when we had an <strong>IEnumerable</strong> set of mutable <strong>MessageDetails</strong> instances, we would have had to have enumerated through every value in the set and compared the &quot;Title&quot; and &quot;Content&quot; values on each message. If they all matched then the old and new data would have been proven to have been the same and the re-render would not be required. But was all that comparison work really much cheaper than just letting the Virtual DOM do its magic?</p>
<p>One of the good thing about immutable structures is that data can safely be shared and reused. Now that the <strong>MessageHistory</strong> component takes an immutable <strong>NonNullList</strong> of immutable <strong>MessageDetails</strong> instances, if the data hasn't changed then the same <strong>NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt;</strong> reference will be passed to the <strong>MessageHistory.Props</strong> instance - but if the data <em>has</em> changed then, by necessity, a new <strong>NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt;</strong> reference will be provided. This would make a &quot;shouldComponentUpdate&quot; implementation very simple - just look at each property on the old and new props references and use reference equality comparisons to see if anything's changed.</p>
<p>The bad news is that the <strong>StatelessComponent</strong> base class in the Bridge / React bindings doesn't support &quot;shouldComponentUpdate&quot;. So you can't try to take advantage of it to reduce the work that the Virtual DOM does - only the <strong>Component</strong> (which is the full stateful component) base class supports it. The good news is that you don't need to implement it manually. If you're creating stateless components whose props classes have properties that are all primitive values (such as bool, int, string, etc..) and / or immutable types and / or functions* and if the components genuinely render <em>entirely</em> according to the props data (no accessing DateTime.Now, for example) then you can derive from the <strong>PureComponent</strong> base class instead. This automatically implements &quot;shouldComponentUpdate&quot; behind the scenes.</p>
<p>* <em>(There are some cases where &quot;props&quot; properties that are callbacks - like &quot;OnChange&quot; on the <strong>TextInput</strong> - can't be compared by the <strong>PureComponent</strong>'s magic, but most of the time they can be and the details of when they can and can't are outside the scope of this article - so let's just assume that function / <strong>Action&lt;T&gt;</strong> / callback property types CAN always be handled).</em></p>
<p>To illustrate, add the following line to the start of the <strong>MessageHistory</strong> &quot;Render&quot; method -</p>
<pre><code>Console.WriteLine(&quot;MessageHistory.Render&quot;);
</code></pre>
<p>Now, run the application in the browser and bring up the browser console in the dev tools. <em>Every</em> time that the app re-renders in the Virtual DOM, &quot;MessageHistory.Render&quot; will be written to the console. Every time that a key is pressed to change one of the text input elements, the entire UI will be re-rendered and &quot;MessageHistory.Render&quot; will be displayed in the console.</p>
<p>Now, change the base class of the <strong>MessageHistory</strong> from <strong>StatelessComponent&lt;MessageHistory.Props&gt;</strong> to <strong>PureComponent&lt;MessageHistory.Props&gt;</strong>. It will look like this:</p>
<pre><code>using System;
using System.Linq;
using Bridge.React;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Components
{
  public class MessageHistory : StatelessComponent&lt;MessageHistory.Props&gt;
  {
    public MessageHistory(
      NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt; messages,
      Optional&lt;NonBlankTrimmedString&gt; className = new Optional&lt;NonBlankTrimmedString&gt;())
      : base(new Props(className, messages)) { }

    public override ReactElement Render()
    {
      Console.WriteLine(&quot;MessageHistory.Render&quot;);

      var className = props.ClassName;
      if (!props.Messages.Any())
        className = className.Add(&quot; &quot;, new NonBlankTrimmedString(&quot;zero-messages&quot;));

      // Any time a set of child components is dynamically-created (meaning that the
      // numbers of items may vary from one render to another), each must have a unique
      // &quot;Key&quot; property set (this may be a int or a string). Here, this is simple as
      // each message tuple is a unique ID and the contents of that message.
      var messageElements = props.Messages
        .Select(savedMessage =&gt; DOM.Div(new Attributes { Key = (int)savedMessage.Key },
        DOM.Span(new Attributes { ClassName = &quot;title&quot; }, savedMessage.Value.Title),
        DOM.Span(new Attributes { ClassName = &quot;content&quot; }, savedMessage.Value.Content)
        ));

      // When child components are specified (as they are through the second argument of
      // DOM.Div), the argument is of type Union&lt;ReactElement, string&gt;[] (meaning that each
      // element may be another component or it may be a simple text value)
      // - The React  bindings have an extension method that transforms an IEnumerable set
      //   of components (such as &quot;messageElements&quot;) into an Union&lt;ReactElement, string&gt;[]
      return DOM.FieldSet(
        new FieldSetAttributes { ClassName = className.ToStringIfDefined() },
        DOM.Legend(null, &quot;Message History&quot;),
        DOM.Div(null, messageElements)
      );
    }

    public class Props : IAmImmutable
    {
      public Props(
        Optional&lt;NonBlankTrimmedString&gt; className,
        NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt; messages)
      {
        this.CtorSet(_ =&gt; _.ClassName, className);
        this.CtorSet(_ =&gt; _.Messages, messages);
      }
      public Optional&lt;NonBlankTrimmedString&gt; ClassName { get; }
      public NonNullList&lt;Saved&lt;MessageId, MessageDetails&gt;&gt; Messages { get; }
    }
  }
}
</code></pre>
<p>Re-build the application and refresh it in the browser. Now change the text input values while keeping an eye on the console. The &quot;MessageHistory.Render&quot; message will initially only appear in the console when the <strong>MessageHistory</strong> component is first rendered, the changes to the text inputs no longer require the <strong>MessageHistory</strong> component be redrawn by the Virtual DOM. When the message data actually changes (whether due to you saving a new message or due to a new Chuck Norris fact arriving), the <strong>MessageHistory</strong> component <em>will</em> update - indicated by another &quot;MessageHistory.Render&quot; message being displayed in the console.</p>
<p>This is an excellent example of how using immutable structures can result in cleaner <em>and</em> more efficient code. In a complicated UI (or if your application is very performance-sensitive - if you're trying to achieve 60fps on mobile, for example) then being able to save the Virtual DOM the work of determining whether entire branches of the component hierarchy should be re-rendered is invaluable. And getting this optimisation &quot;for free&quot; makes it even better - if you're following my recommendations and the vast majority of your React components are stateless and al of your data types are immutable then you might as well use the <strong>PureComponent</strong> base class and reap the performance benefits.</p>
<h3>PureComponent details</h3>
<p>I want to go into some of the finer point of the <strong>PureComponent</strong>'s optimisation rules. There's nothing particularly complicated or surprising, but there are some nuances that it's worth being aware of.</p>
<p>When the <strong>PureComponent</strong> implements &quot;shouldComponentUpdate&quot; behind the scenes, the React library provides it with two separate instances to compare of the <strong>Props</strong> class for the current component. The first thing that the <strong>PureComponent</strong> does is ensure that the two props instances are of the same type (while it would be strange, it would not be illegal to create types derived from the component's <strong>Props</strong> class - but if different derived types were provided for the old and new props then it doesn't seem safe to try to compare them, who knows <em>why</em> they are different or what significance there could be in the differences). If the old and new props references <em>are</em> of the precise same type, then it enumerates the properties on the type and compares the values on the old and new props instances. Each pair of property values must match - this means that they are either both null or they are both the same value of a primitive type or they are the same reference <em>or</em> they are both non-null <em>and</em> the first value has an &quot;Equals&quot; method that returns true when the second value is passed into it.</p>
<p>On the whole, this means that things largely work completely intuitively. <em>Particularly</em> due to the way that the &quot;With&quot; extension methods works for <strong>IAmImmutable</strong>-implementing class. If &quot;With&quot; is called with a property value update where the new value is the same as the old value, then &quot;With&quot; returns the original instance unaltered. This is most easily explained with an example:</p>
<pre><code>var title = new TextEditState(text: &quot;hello&quot;, validationError: null);
var title2 = title.With(_ =&gt; _.Text, &quot;hello&quot;);
var title3 = title.With(_ =&gt; _.Text, &quot;hell&quot;);
</code></pre>
<p>The &quot;title2&quot; instance will be the same as the &quot;title&quot; reference - the text value was asked to changed from &quot;hello&quot; to &quot;hello&quot;, which is no change at all. Since the <strong>TextEditState</strong> type is immutable, there is no pointing copying &quot;title&quot; to create a new &quot;title2&quot; reference with all of the same data. &quot;title3&quot; <em>will</em> be a new instance, since the text value needs to change from &quot;hello&quot; to &quot;hell&quot;.</p>
<p>Having &quot;With&quot; return the same reference when no change is required is beneficial for garbage collection - the fewer references that are created means the less work that it has to do. But it's also very important for the <strong>PureComponent</strong> since that prefers to use referential equality to determine whether a property value has changed. If a <strong>Props</strong> class has a <strong>TextEditState</strong> property on it, when the values on the old and new props are compared then we want the <strong>TextEditState</strong> references to be the same if the data that they represent hasn't changed.</p>
<p>I think that another example is called for. In the example application from this series, the Message Editor form is given information in its props that describes the current state of the form - the &quot;Caption&quot;, the &quot;Title&quot; text-input-value-and-any-validation-message, the &quot;Content&quot; text-input-value-and-any-validation-message (and information about whether the form should be disabled because a save is in progress). This data is all contained within a <strong>MessageEditState</strong> instance. The <strong>MessageEditor</strong> component renders each text input by generating child <strong>ValidatedTextInput</strong> components. These child <strong>ValidatedTextInput</strong> components raise an &quot;OnChange&quot; event when the user wants to alter the content in the text input element, the event includes a string argument for the new text value. When this happens, the <strong>MessageEditor</strong> takes this new text value and uses it to create a new <strong>MessageEditState</strong> instance, using the &quot;With&quot; extension method - this new instance is then passed up on the <strong>MessageEditor</strong>'s &quot;OnChange&quot; event. This event will result in the UI being re-rendered to display the new data.</p>
<p>However, React raises change events from text inputs for user interactions <em>even if they don't actually result in a change</em>. If, for instance, there is a text input with the value &quot;Hello&quot; in it and you highlight that text and copy it to the clipboard and then paste it into that same text input then the value obviously hasn't changed, but React still raises a change event from the text input due to the paste action. What we want to happen in this case is for the &quot;new&quot; <strong>MessageEditState</strong> instance that the <strong>MessageEditor</strong> creates when it raises its &quot;OnChange&quot; event to be the exact same reference as the <strong>MessageEditState</strong> given to the <strong>MessageEditor</strong> when it last rendered. This way, when the <strong>MessageEditor</strong> is asked to re-render then it will find that the &quot;new&quot; props data is exactly the same as the old props data and the <strong>PureComponent</strong> logic will tell React that it needn't bother re-rendering the component at all.</p>
<p>Maybe it's worth examining the <strong>MessageEditor</strong> code again to try to make this seem less abstract:</p>
<pre><code>using System;
using Bridge.React;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;
using ProductiveRage.Immutable;

namespace BridgeReactTutorial.Components
{
  public class MessageEditor : StatelessComponent&lt;MessageEditor.Props&gt;
  {
    public MessageEditor(
      MessageEditState message,
      Action&lt;MessageEditState&gt; onChange,
      Action onSave,
      Optional&lt;NonBlankTrimmedString&gt; className = new Optional&lt;NonBlankTrimmedString&gt;())
      : base(new Props(className, message, onChange, onSave)) { }

    public override ReactElement Render()
    {
      var formIsInvalid =
        props.Message.Title.ValidationError.IsDefined ||
        props.Message.Content.ValidationError.IsDefined;

      return DOM.FieldSet(
        new FieldSetAttributes { ClassName = props.ClassName.ToStringIfDefined() },
        DOM.Legend(null, props.Message.Caption),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Title&quot;),
        new ValidatedTextInput(
          className: new NonBlankTrimmedString(&quot;title&quot;),
          disabled: props.Message.IsSaveInProgress,
          content: props.Message.Title.Text,
          onChange: newTitle =&gt; props.OnChange(
            props.Message.With(_ =&gt; _.Title, new TextEditState(newTitle))
          ),
          validationMessage: props.Message.Title.ValidationError
        ),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Content&quot;),
        new ValidatedTextInput(
          className: new NonBlankTrimmedString(&quot;content&quot;),
          disabled: props.Message.IsSaveInProgress,
          content: props.Message.Content.Text,
          onChange: newContent =&gt; props.OnChange(
            props.Message.With(_ =&gt; _.Content, new TextEditState(newContent))
          ),
          validationMessage: props.Message.Content.ValidationError
        ),
        DOM.Button(
        new ButtonAttributes
        {
          Disabled = formIsInvalid || props.Message.IsSaveInProgress,
          OnClick = e =&gt; props.OnSave()
        },
        &quot;Save&quot;
        )
      );
    }

    public class Props : IAmImmutable
    {
      public Props(
        Optional&lt;NonBlankTrimmedString&gt; className,
        MessageEditState message,
        Action&lt;MessageEditState&gt; onChange,
        Action onSave)
      {
        this.CtorSet(_ =&gt; _.ClassName, className);
        this.CtorSet(_ =&gt; _.Message, message);
        this.CtorSet(_ =&gt; _.OnChange, onChange);
        this.CtorSet(_ =&gt; _.OnSave, onSave);
      }
      public Optional&lt;NonBlankTrimmedString&gt; ClassName { get; }
      public MessageEditState Message { get; }
      public Action&lt;MessageEditState&gt; OnChange { get; }
      public Action OnSave { get; }
    }
  }
}
</code></pre>
<p>If the user attempted this copy-paste-same-value thing in the &quot;Title&quot; input, then the &quot;onChange&quot; event from the <strong>ValidatedTextInput</strong> that renders the Title value would be raised -</p>
<pre><code>onChange: newTitle =&gt; props.OnChange(
  props.Message.With(_ =&gt; _.Title, new TextEditState(newTitle))
)
</code></pre>
<p>This will result in the <strong>MessageEditor</strong>'s &quot;OnChange&quot; event being raised, with a new <strong>MessageEditState</strong> instance. The key thing is that we want the new <strong>MessageEditState</strong> instance to be the same as the current <strong>MessageEditState</strong> instance if the new &quot;Title&quot; string is exactly the same as the current &quot;Title&quot; string.</p>
<p>One way to do this would be to not worry about how &quot;With&quot; does or doesn't work and to add a condition into the lambda - eg.</p>
<pre><code>onChange: newTitle =&gt;
{
  if (newTitle != props.Message.Title.text)
    props.OnChange(props.Message.With(_ =&gt; _.Title, new TextEditState(newTitle)));
}
</code></pre>
<p>However, this means that more logic has to go in the components (which I want to avoid). Worse, it's boring and repetitive logic, which is the kind that I find is most likely to be done incorrectly by accident because you almost feel like you can write it on auto-pilot. It would be best if this could be handled automatically.</p>
<p>Well, it <em>can</em> be if we always use &quot;With&quot; to update values. In the code above, I've actually been a bit naughty. A <strong>TextEditState</strong> includes two values - &quot;Text&quot; and &quot;ValidationMessage&quot;. The &quot;ValidationMessage&quot; will get set according to the &quot;Text&quot; value when validation is applied (which happens in the <strong>MessageWriterStore</strong> in this application). The code above creates a <em>new</em> <strong>TextEditState</strong> with the &quot;newTitle&quot; string, erasing any &quot;ValidationMessage&quot; value. This is not really correct, since only the validation logic should change the &quot;ValidationMessage&quot; value. In this example, a validation message should only be displayed if the text value is empty - but the components should have no knowledge of this since we want them to be as dumb as possible. So, any time that a component creates a new <strong>TextEditState</strong> to include in an &quot;OnChange&quot; event, the &quot;ValidationMessage&quot; property should be untouched - again, it is the responsibility of the store (and <em>not</em> the component) to worry about ensuring that the &quot;ValidationMessage&quot; value is correct for the &quot;Text&quot; value before a re-render is triggered.</p>
<p>So, this code:</p>
<pre><code>onChange: newTitle =&gt; props.OnChange(
  props.Message.With(_ =&gt; _.Title, new TextEditState(newTitle))
)
</code></pre>
<p>should really be this:</p>
<pre><code>onChange: newTitle =&gt; props.OnChange(
  props.Message.With(_ =&gt; _.Title, props.Message.Title.With(_ =&gt; _.Text, newContent))
)
</code></pre>
<p>This <em>only</em> changes the &quot;Text&quot; property on the &quot;Title&quot; <strong>TextEditState</strong> - which means that, in our copy-paste-same-value case, no new <strong>TextEditState</strong> instance will be created. This still means that the <strong>MessageEditor</strong>'s &quot;OnChange&quot; event will be raised (which will result in an action being sent through the Dispatcher and received by the <strong>MessageWriterStore</strong>, which will raise a &quot;Change&quot; event and cause the <strong>AppContainer</strong> to re-render the UI), but when the <strong>MessageEditor</strong> is asked to re-render then it will realise that the new data is the same as its current data and it will tell React not to bother re-rendering it. The code still had to do one full pass of the raise-event-up-to-top-level-component-and-send-change-message-through-Dispatcher-to-the-Store, even though the data hadn't changed, but that sort of work is very cheap (certainly much cheaper than any DOM or even Virtual DOM interactions).</p>
<p>All of the above came &quot;for free&quot; by using <strong>IAmImmutable</strong>-implementing classes and <strong>PureComponent</strong> and by applying updates using the &quot;With&quot; extension method. There are <em>some</em> cases where you need to do a little work to help the system out, though. If you recall the &quot;ValidateMessage&quot; function that we wrote earlier -</p>
<pre><code>private static MessageEditState ValidateMessage(MessageEditState message)
{
  if (message == null)
    throw new ArgumentNullException(&quot;message&quot;);

  return message
    .With(_ =&gt; _.Caption, ToNonBlankTrimmedString(message.Title, fallback: _defaultCaption))
    .With(_ =&gt; _.Title, Validate(message.Title, MustHaveValue, _noTitleWarning))
    .With(_ =&gt; _.Content, Validate(message.Content, MustHaveValue, _noContentWarning));
}
</code></pre>
<p>This always set the &quot;Caption&quot; based upon the &quot;Title&quot; value. If there is a &quot;Title&quot; value in the text input of the message editor form of &quot;My New Message&quot; then the &quot;Caption&quot; value will also be &quot;My New Message&quot;. The &quot;ToNonBlankTrimmedString&quot; method is implemented as:</p>
<pre><code>private static NonBlankTrimmedString ToNonBlankTrimmedString(
  TextEditState textEditState,
  NonBlankTrimmedString fallback)
{
  if (textEditState == null)
    throw new ArgumentNullException(&quot;textEditState&quot;);
  if (fallback == null)
    throw new ArgumentNullException(&quot;fallback&quot;);

  return (textEditState.Text.Trim() == &quot;&quot;)
    ? fallback
    : new NonBlankTrimmedString(textEditState.Text);
}
</code></pre>
<p>Every time that &quot;ValidateMessage&quot; is called and there is a non-blank &quot;Title&quot; value then a new <strong>NonBlankTrimmedString</strong> instance will be created for the &quot;Caption&quot;. The problem is that if the &quot;Title&quot; input isn't changing (if the user is currently changing the &quot;Content&quot; text input box, for example) then we will be creating new <strong>NonBlankTrimmedString</strong> instances for the same &quot;Title&quot; value - and the <strong>PureComponent</strong> will see each new <strong>NonBlankTrimmedString</strong> reference as a new and distinct value.</p>
<p>We could try to prevent this by changing &quot;ValidateMessage&quot; such that it tries to avoid creating new <strong>NonBlankTrimmedString</strong> instances for the Caption -</p>
<pre><code>private static MessageEditState ValidateMessage(MessageEditState message)
{
  if (message == null)
    throw new ArgumentNullException(&quot;message&quot;);

  if (message.Title.Text.Trim() == &quot;&quot;)
    message = message.With(_ =&gt; _.Caption, _defaultCaption);
  else if (message.Title.Text.Trim() != message.Caption)
    message = message.With(_ =&gt; _.Caption, new NonBlankTrimmedString(message.Title.Text));

  return message
    .With(_ =&gt; _.Title, Validate(message.Title, MustHaveValue, _noTitleWarning))
    .With(_ =&gt; _.Content, Validate(message.Content, MustHaveValue, _noContentWarning));
}
</code></pre>
<p>.. but this brings us back round to &quot;ValidateMessage&quot; being very noisy. This will have a tendency to make it prone to error and it definitely moves away from the goal of code clarity that I'm aiming for.</p>
<p>An alternative is to implement an &quot;Equals&quot; override for the <strong>NonBlankTrimmedString</strong> class. The &quot;With&quot; extension method, like the <strong>PureComponent</strong>'s &quot;shouldComponentUpdate&quot; logic&quot;, will consider an &quot;Equals&quot; method if referential equality fails. This means that if we call</p>
<pre><code>.With(_ =&gt; _.Caption, ToNonBlankTrimmedString(message.Title, fallback: _defaultCaption))
</code></pre>
<p>.. and if the return value from &quot;ToNonBlankTrimmedString&quot; is a <strong>NonBlankTrimmedString</strong> instance that is equivalent to the current &quot;Caption&quot; value (according to the <strong>NonBlankTrimmedString</strong> &quot;Equals&quot; implementation below), then &quot;With&quot; will return the same reference.</p>
<pre><code>using System;
using Bridge;
using Bridge.React;

namespace BridgeReactTutorial.API
{
  public sealed class NonBlankTrimmedString
  {
    public NonBlankTrimmedString(string value)
    {
      if (string.IsNullOrWhiteSpace(value))
        throw new ArgumentException(&quot;Null, blank or whitespace-only value specified&quot;);

      Value = value.Trim();
    }

    /// &lt;summary&gt;
    /// This will never be null, blank or have any leading or trailing whitespace
    /// &lt;/summary&gt;
    public string Value { get; }

    /// &lt;summary&gt;
    /// It's convenient to be able to pass a NonBlankTrimmedString instance as any argument
    /// that requires a string
    /// &lt;/summary&gt;
    public static implicit operator string(NonBlankTrimmedString value)
    {
      if (value == null)
        throw new ArgumentNullException(&quot;value&quot;);
      return value.Value;
    }

    /// &lt;summary&gt;
    /// It's convenient to be able to pass a NonBlankTrimmedString instance as any argument
    /// that requires a ReactElement-or-string, such as for the children array of the React
    /// DOM component factories
    /// &lt;/summary&gt;
    public static implicit operator Union&lt;ReactElement, string&gt;(NonBlankTrimmedString value)
    {
      if (value == null)
        throw new ArgumentNullException(&quot;value&quot;);
      return value.Value;
    }

    public override bool Equals(object o)
    {
      var otherNonBlankTrimmedString = o as NonBlankTrimmedString;
      return
        (otherNonBlankTrimmedString != null) &amp;&amp;
        (otherNonBlankTrimmedString.Value == Value);
    }

    public override int GetHashCode()
    {
      return Value.GetHashCode();
    }
  }
}
</code></pre>
<p>Having an &quot;Equals&quot; implementation on types such as <strong>NonBlankTrimmedString</strong> makes a lot of sense because we essentially want them to be treated as &quot;value types&quot; - if two references describe the same data then they should be treated as the same value. Note that a custom &quot;Equals&quot; implementation was not necessary for <strong>MessageId</strong>, since that is a struct - in C#, structs <a href="http://csharp.2000things.com/2011/09/14/411-overriding-the-equals-method-for-a-value-type/">automatically get an &quot;Equals&quot; implementation created for them</a> that considers two struct instances to be equivalent if all of their properties have the same values and the JavaScript generated by Bridge does the same in order to maintain compatibility.</p>
<p>One thing that I snuck into the new <strong>NonBlankTrimmedString</strong> above is that the class is now sealed. If it is possible to inherit from a given class, it becomes much more difficult to implement a reliable &quot;Equals&quot; method. For the sake of argument, imagine a class &quot;X&quot; that is not sealed and that has a single string &quot;Value&quot; property and that implements its own &quot;Equals&quot; method, exactly the same as the <strong>NonBlankTrimmedString</strong> &quot;Equals&quot; method above. Then imagine that a class &quot;Y&quot; is derived from &quot;X&quot; and adds a second property, a &quot;Count&quot; int. If &quot;Y&quot; does not override the &quot;Equals&quot; implementation on &quot;X&quot; then it seems likely that the &quot;Equals&quot; implementation that &quot;Y&quot; inherits from &quot;X&quot; will be inaccurate - if an instance of &quot;Y&quot; with a &quot;Value&quot; of &quot;Hello&quot; and &quot;Count&quot; of 1 was compared to another instance of &quot;Y&quot; with a &quot;Value&quot; of &quot;Hello&quot; but a &quot;Count&quot; of 2 then they would be considered to be equivalent, which would almost certainly not be the expected behaviour. There is an implicit assumption that if &quot;X&quot; is derived from and the derived type adds properties then that derived type should have its own &quot;Equals&quot; method. A failure to respect this implicit assumption will not result in any compiler warnings, it will likely result only in unexpected runtime behaviour at some point. I don't like implicit assumptions, as I'm sure that you've been able to tell from the themes in this post. An easy way to avoid this problem is to prevent &quot;X&quot; from being inherited from, by making it sealed. This is precisely what I've done with the <strong>NonBlankTrimmedString</strong>.</p>
<p>This leads me on to another guideline - I believe that 99% of all classes should be abstract or sealed. Any class that may be inherited from requires planning, to try to make it as easy as possible for any derived types to work in non-suprising manners. This is complicated, if not impossible (as the &quot;Equals&quot; conundrum above hopefully illustrates for an extremely simple case). However, if you really think that it should be possible for a class to be inherited from, then I think that you should document any implicit assumptions on that base class and you should carefully think about how it should and shouldn't be used. I have found that the most common cases for which a base class are suitable are those where some shared functionality is required that can't easily be provided via composition (which I will talk about in a moment), but where that base class is not fully-functional itself and so must be inherited from in order to be useful. The <strong>Component</strong>, <strong>StatelessComponent</strong> and <strong>PureComponent</strong> base classes in the Bridge / React bindings are excellent examples; they are required in order to define components that the React library can work with, but the classes are not functional on their own - they must be inherited from in order to be useful, therefore they are defined as abstract classes.</p>
<p>Historically, I think that there have been beliefs that many object models lend themselves well to inheritance hierarchies. In Web Forms (if I remember correctly - it's been a long time), a <strong>Button</strong> inherited from a <strong>WebControl</strong> and that inherited from a <strong>Control</strong> or a <strong>Component</strong>.. or something. The idea was that every component as you went up the hierarchy was a specialisation of the one below it. Which arguably made sense. But I find that the waters often get very murky when these &quot;is-a&quot; hierachies are constructed and it's very easy to confuse a &quot;has-a&quot; characteristic for being an &quot;is-a&quot;. For example, the <strong>MessageWriterStore</strong> needs to register for events from the Dispatcher, so perhaps it is a specialisation of a &quot;DispatcherMessageReceiver&quot;. But it's also responsible for saving messages, so perhaps it's also specialisation of a &quot;MessageRecorder&quot;. Not only is it more complicated to design classes that are intended to be inherited from, but C# only allows one class to inherit from a single base class - so if <strong>MessageWriterStore</strong> needs to be a specialisation of both a &quot;DispatcherMessageReceiver&quot; <em>and</em> a &quot;MessageRecorder&quot; then we have a problem; possibly only solved by creating a specialisation of the &quot;DispatcherMessageReceiver&quot; that <em>also</em> deals with recording messages, so that the <strong>MessageWriterStore</strong> can inherit from <em>that</em>.</p>
<p>Perhaps that example is a little fatuous, but similar sorts of issues <em>do</em> genuinely occur when inheritance trees are viewed as &quot;the best way&quot; to build classes. The alternative is to use composition, which is where classes are designed in a &quot;has-a&quot; manner. The current <strong>MessageWriterStore</strong> is designed in this way as its constructor declares that it requires an <strong>AppDispatcher</strong> and a <strong>IReadAndWriteMessages</strong> implementation. Not only does composition avoid the multiple inheritance problem (also known as the &quot;<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">deadly diamond of death</a>&quot;) but it makes code easier to fully comprehend. With inheritance, each class is a sum of its behaviour and all of the behaviour of its base class (which is likewise a sum of <em>its</em> behaviour and all of the behaviour of <em>its</em> base class, repeated for as many levels as the inheritance tree is deep). With composition, each piece is fully self-contained and communication between one part and another is throughly tightly constrained interfaces.</p>
<p><em>(A couple of months ago, I read &quot;<a href="https://tech.scrunch.com/blog/5-reasons-your-team-will-love-you-for-composition/">5 reasons your team will love you for composition</a>&quot;, which I think offers a good take on some of the practical benefits positives of preferring composition to inheritance - it's well worth a quick read).</em></p>
<p>In summary, I strongly believe that almost all relations between classes may be described better by using composition than inheritance (where &quot;better&quot; means that the code is easier to reason about and, also, easier to test) and so almost no classes should need to be inherited from. In the few cases where inheritance <em>is</em> necessary, the base classes must be carefully designed for inheritance and the use cases that necessitate inheritance will almost always be ones where the base classes are non-functional in isolation, where they <em>require</em> a derived type in order to work.</p>
<p>Therefore, 99% of classes should be written to be abstract or to be sealed. This goes for <em>all</em> classes that I've shown code for in this series - the <strong>MessageEditor</strong> component class should be sealed, its <strong>Props</strong> class should be sealed, the <strong>MessageWriterStore</strong> should be sealed, the <strong>MessageDetails</strong> should be sealed, the <strong>Saved</strong> class should be sealed and the <strong>NonBlankTrimmedString</strong> should be sealed. They should <em>all</em> be sealed.</p>
<p>Now, if we wanted to play devil's advocate then we could say that any &quot;ClassName&quot; property on a component class shouldn't be <strong>Optional&lt;NonBlankTrimmedString&gt;</strong> since I've said that everything should be really specific, since richer types have a lot of value in expressing intent. We could say that there should be a more specific <strong>ClassName</strong> class, which only allows characters that are valid in an html class name (React deals with encoding string &quot;ClassName&quot; properties, so this isn't really a big concern - but I'm trying to prove another point, so bear with me). We could also say that this <strong>ClassName</strong> class really <em>is</em> a specialisation of <strong>NonBlankTrimmedString</strong> and so surely we should allow <strong>NonBlankTrimmedString</strong> to be inherited from so that <strong>ClassName</strong> could be derived from it. On the surface, this doesn't seem too unreasonable. However, the only actual benefit of having <strong>ClassName</strong> inherit from <strong>NonBlankTrimmedString</strong> (other than it just <em>feeling</em> like something that may possibly be a good idea) would be if there was a point at which you had a method that took an argument of type <strong>NonBlankTrimmedString</strong> that you wanted to give a <strong>ClassName</strong> instance - because it seems like any valid <strong>ClassName</strong> will also be a valid <strong>NonBlankTrimmedString</strong>. I think that the benefit is just too small to outweight the cost. Inheritance brings with it too much potential complication (and associated mental burden) that any small benefit like this is not enough to bring inheritance into play. On top of which, if you really did want to be able to use a <strong>ClassName</strong> instance anywhere that a <strong>NonBlankTrimmedString</strong> is required, you could do this by implementing an implicit operator method on <strong>ClassName</strong> that allows it be implicitly cast to a <strong>NonBlankTrimmedString</strong> - then you would have the marginal benefit of being able to use a <strong>ClassName</strong> anywhere that you need a <strong>NonBlankTrimmedString</strong> but still be able to keep <strong>NonBlankTrimmedString</strong> sealed and less prone to error.</p>
<p>Writing classes that are sealed by default is another practice that I am still trying to instill into myself. Much like writing methods to be static by default, I think that it makes a huge amount of sense but it's also a concept that I've only cemented in the last year or so and I'm still trying to consistently apply it!</p>
<h3>In summary</h3>
<p>This has turned out to be a pretty huge post. But I didn't want to try to split it up because all of the principles are related, really.</p>
<p>If you'd stopped reading after <a href="/writing-react-apps-using-bridgenet-the-dan-way-part-two">Part Two</a> then I think that you would have the tools to construct client-side applications that will scale from something simple up to something massively complex. The combination of C# (which is time-proven as a language that not only enables large applications to be built and maintained over long periods of time, it is a language where it is not exceptional for this to be the case*) and React is very powerful.</p>
<p>* <em>(Languages such as PHP and JavaScript CAN be used to build and maintain large code bases, but I think that it's telling that the companies that take this work seriously rely on, and develop, additional tooling to make it manageable, like <a href="http://hacklang.org/">Hack</a> and <a href="http://flowtype.org/">Flow</a>).</em></p>
<p>However, the principles behind React that I found most appealing when I first encountered it - that it primarily exists to make complicated interactions in an application simpler and scalable - are what I want to apply to my C#. In the concepts that I'm advocating here for writing C# React applications <em>and</em> in React itself, performance is not the number one priority; it is not something for which code clarity must be sacrificed in order to attain. Performance is, however, still important - but it is achieved through high-level design decisions and not through micro-optimisations (I still think that the best example of this is how performing particular operations on an immutable structure will almost always be slower than on the corresponding mutable structure, but the algorithms that may be written based upon the safe sharing of immutable types mean that actual application performance will be greater - whether this is in the avoidance of deep-cloning references for safety or in the way that the <strong>PureComponent</strong> can avoid re-rendering of entire branches of the UI by the Virtual DOM).</p>
<p>To summarise, I believe that if the guidelines presented here are followed then you will be able to go beyond the C# React applications that you would have written with Part-Two Knowledge and be able to write code that is easier to understand (whether by other Developers or by yourself, when you come back to a piece of code after six months), easier to maintain and extend <em>and</em> that is more efficient.</p>
<p>To recap, the guidelines are as follows:</p>
<ol>
<li>Immutable data types are fantastic for code clarity (the classes themselves will require more lines of code than if they were mutable but this is a trade-off that is well worth making, plus you will often require less code in places that makes use of these classes - which is relevant if lines of code is the most important metric to you)</li>
<li>Anything that can't be immutable should have accessibility that is as restricted as possible (Store classes are not immutable, but their public properties are all read-only)</li>
<li>Implicit assumptions are &quot;silly mistakes&quot; waiting to happen, encoding as much in the type system as possible communicates intent to other Developers and moves various types of error from runtime to compile time (immutable types and strongly-typed IDs are both examples of this)</li>
<li>Write static methods by default, only make them instance / non-static methods if and when they need to be</li>
<li>Write sealed classes by default, if they really need to be inheritable then they likely should be abstract (classes should almost never be neither sealed nor abstract)</li>
<li>Using simple composable abstractions can greatly improve code clarity (as we saw with the &quot;ValidateMessage&quot; method rewrite)</li>
<li>Code clarity is king!</li>
</ol>
<p>I'm not sure that there's anything earth-shatteringly original about any one of these suggestions. Combining them can, in my ever-so-humble opinion, result in significantly higher quality code than <em>not</em> following them. While these posts have been about writing React applications using <a href="http://bridge.net/">Bridge.NET</a>, these rules may be applied just as well to any C# code. The <a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a> NuGet package only works with Bridge projects, though - but if anyone asked them I would happily consider recreating it for vanilla C#! :)</p>
<h3>Is this really the end??</h3>
<p>There are some other things to consider when writing complete Bridge / React applications. I keep saying that it's important for code to be testable, but I haven't offered any way to write the actual unit tests. I've also not had to offer any URL-routing capabilities, since the example application is so simple. But routing <em>is</em> something that is almost certainly going to be required in any real browser-based application.</p>
<p>These are both technologies that I would like to cover in future posts, but probably as shorter follow-up pieces. In terms of <em>how</em> to write React applications in C#, I am happy with what I've covered in these three posts - I wanted to get the example code to where it is now but without jumping straight to the final architecture; I wanted to illustrate <em>why</em> one-way data binding is so beneficial and then why a Flux-like structure is so helpful and then <em>why</em> immutable types are such a good idea. Hopefully, by starting from the basics and introducing new concepts and approaches only when there was a way to illustrate the improvements that they yield, you all agree with me that this is the way to do things!</p>
<p>Of course, if you disagree in general, or on any particular points, or you have any tweaks to what I've suggested then I would be very interested to hear. That's what the comments section is for!</p>
<p class="PostTime">Posted at 21:32</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/writing-react-apps-using-bridgenet-the-dan-way-part-two">Writing React apps using Bridge.NET - The Dan Way (Part Two)</a></li><li><a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">Writing React apps using Bridge.NET - The Dan Way (from first principles)</a></li><li><a href="/easy-purecomponent-react-performance-boosts-for-bridgenet">Easy &quot;PureComponent&quot; React performance boosts for Bridge.Net</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/React" title="11 Posts">React</a></li></ul></div>
            <p class="Comments">
                <a href="/writing-react-apps-using-bridgenet-the-dan-way-part-three#disqus_thread" data-disqus-identifier="98">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">16 March 2016</p><h2><a id="writing-react-apps-using-bridgenet-the-dan-way-part-two" href="/writing-react-apps-using-bridgenet-the-dan-way-part-two">Writing React apps using Bridge.NET - The Dan Way (Part Two)</a></h2>
<p>To summarise where we got to in <a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">Part One</a>: we've got an entry form where, after you enter Title and Content values, you may save a message. During the message-saving process, the form and save button are disabled. Once the saving has completed, the form will be cleared and it will be re-enabled. Validation logic in the <strong>MessageEditor</strong> prevents the form from being saved while one or both of the required inputs are without value. After the save has succeeded, a read action will begin in the background - once the read operation has completed, a <strong>MessageHistory</strong> component will display all of the saved messages. All interactions with the <strong>MessageApi</strong> are handled by the top-level <strong>AppContainer</strong> component. Similarly, all user interaction events are passed up to this top-level component, from where re-renders of the UI state are triggered.</p>
<p>I see this arrangement as a top-to-bottom tree in terms of rendering - the top-level component is in control of what to display in the component hierarchy beneath it, and all of the information required to display those child components is contained within the top-level component's state data.</p>
<p>In terms of event-handling, events may occur deep down within the tree and are then passed back up to the top-level component. As an event passes up from the html element that it originates in, up to the top level, it will gather more and more information - for example, when a user requests a change to the &quot;Title&quot; text input (such as by pressing a key while the input has focus), then an event is raised by the <strong>TextInput</strong> component saying that a string value should be changed. This <strong>TextInput</strong> is a child component of the <strong>MessageEditor</strong>, which acknowledges this string-changed event and raises it own event; a <strong>MessageDetails</strong>-changed event. The &quot;Content&quot; value of this new message will be unchanged, but the &quot;Title&quot; value will have a new value - the new value that the <strong>TextInput</strong> should take. This event is received by the <strong>AppContainer</strong> and it uses it to update its internal representation of the application, changing its &quot;state&quot; reference by calling &quot;SetState&quot; and so triggering a re-render.</p>
<p>The path may be traced downward when considering rendering and may be traced upward when considering events.</p>
<p>This one-way passing of data is very powerful in terms of modelling interactions that are easy to follow. As a reminder, a common way to deal with interactions like this in days gone by (ie. before React popularised &quot;one-way bindings&quot;) was for changes to elements to be reflected immediately in-place and for any interested parties to subscribe to events that those elements raise after they change. So, for the message entry form -</p>
<img alt="The proposed example app" src="/Content/Images/Posts/ReactTutorial2.png" class="NoBorder AlwaysFullWidth" title="The proposed example app" />
<p>With the old method, the &quot;Title&quot; and the &quot;Content&quot; inputs would accept changes that the user makes immediately - and the fieldset legend and the save button components would need to listen out to some of these changes. The legend changes to match what is entered in the &quot;Title&quot; input (unless it's blank, in which case the legend shows &quot;Untitled&quot;). The save button needs to be enabled if both &quot;Title&quot; and &quot;Content&quot; have values and <em>disabled</em> if one or both of them are without.</p>
<p>I mentally envisage this as star-shaped event handling - a change to one element may fan out to many others. In some cases, these changes would then cascade on to other elements, and then on again and again (hopefully not &quot;again and again and..&quot;, but it was difficult to keep a handle on these things with this sort of approach - because it was difficult to get a simple view as to what could affect what).</p>
<p>With one-way data binding, events go up to the top, are processed and then the re-render distributes this new information all the way down. When the <strong>MessageEditor</strong> is rendered, it knows what the current &quot;Title&quot; value is and so it knows what to put in that &quot;Title&quot; <strong>TextInput</strong> <em>and</em> it knows what the fieldset legend should be <em>and</em> it knows whether the save button should be enabled or not.</p>
<p>This arrangement can take you a long way, I think. But there are a couple of things that I take issue with -</p>
<ol>
<li>I want to be able to easily unit test logic in my application and, while the React library goes a long way to taming the DOM, testing UI components will never be as easy as testing &quot;pure&quot; JavaScript (well, pure C# with Bridge, that will <em>become</em> pure JavaScript) - consequently, I want to be able to extract as much logic out of the UI components as possible</li>
<li>If any more event sources are added to the application, then dealing with these events becomes awkward - another &quot;event source&quot; may, for example, be something in the persistence layer that polls for new data from other users (which might not be uncommon since we're creating web applications and these are commonly expected to be multi-user, so it's beneficial to be able to reflect changes made by other users)</li>
</ol>
<p>We can refine this arrangement a little by introducing an intermediary for events to pass through and by pulling out the logic that exists within components (such as the validation within the <strong>MessageEditor</strong> and the when-a-save-happens-then-.. logic in the <strong>AppContainer</strong>).</p>
<h3>From up-and-down to round-and-round</h3>
<p>Rather than talk about how some applications could theoretically benefit from a change to the architecture, I want to do it with a demonstration.</p>
<p>I'm going to change the <strong>MessageApi</strong> so that, after a short delay, new messages start appearing in its internal list. The &quot;SaveMessage&quot; and &quot;GetMessages&quot; methods are unchanged, it's just that there's a background process going on as well. To keep things interesting, I'm going to source these message from the <a href="http://www.icndb.com/api/">The Internet Chuck Norris Database API</a> -</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Bridge;
using Bridge.Html5;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.API
{
  public class MessageApi : IReadAndWriteMessages
  {
    private readonly List&lt;Tuple&lt;int, MessageDetails&gt;&gt; _messages;
    public MessageApi()
    {
      _messages = new List&lt;Tuple&lt;int, MessageDetails&gt;&gt;();

      // To further mimic a server-based API (where other people may be recording messages
      // of their own), after a 10s delay a periodic task will be executed to retrieve a
      // new message
      Window.SetTimeout(
        () =&gt; Window.SetInterval(GetChuckNorrisFact, 5000),
        10000
      );
    }

    public Task SaveMessage(MessageDetails message)
    {
      if (message == null)
        throw new ArgumentNullException(&quot;message&quot;);
      if (string.IsNullOrWhiteSpace(message.Title))
        throw new ArgumentException(&quot;A title value must be provided&quot;);
      if (string.IsNullOrWhiteSpace(message.Content))
        throw new ArgumentException(&quot;A content value must be provided&quot;);

      var task = new Task&lt;object&gt;(null);
      Window.SetTimeout(
        () =&gt;
        {
          _messages.Add(Tuple.Create(_messages.Count, message));
          task.Complete();
        },
        1000 // Simulate a roundtrip to the server
      );
      return task;
    }

    public Task&lt;IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt;&gt; GetMessages()
    {
      // ToArray is used to return a clone of the message set - otherwise, the caller would
      // end up with a list that is updated when the internal reference within this class
      // is updated (which sounds convenient but it's not the behaviour that would be
      // exhibited if this was really persisting messages to a server somewhere)
      var task = new Task&lt;IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt;&gt;(null);
      Window.SetTimeout(
        () =&gt; task.Complete(_messages.ToArray()),
        1000 // Simulate a roundtrip to the server
      );
      return task;
    }

    private void GetChuckNorrisFact()
    {
      var request = new XMLHttpRequest();
      request.ResponseType = XMLHttpRequestResponseType.Json;
      request.OnReadyStateChange = () =&gt;
      {
        if (request.ReadyState != AjaxReadyState.Done)
          return;

        if ((request.Status == 200) || (request.Status == 304))
        {
          try
          {
            var apiResponse = (ChuckNorrisFactApiResponse)request.Response;
            if ((apiResponse.Type == &quot;success&quot;)
            &amp;&amp; (apiResponse.Value != null)
            &amp;&amp; !string.IsNullOrWhiteSpace(apiResponse.Value.Joke))
            {
              // The Chuck Norris Facts API (http://www.icndb.com/api/) returns strings
              // html-encoded, so they need decoding before be wrapped up in a
              // MessageDetails instance
              SaveMessage(new MessageDetails
              {
                Title = &quot;Fact&quot;,
                Content = HtmlDecode(apiResponse.Value.Joke)
              });
              return;
            }
          }
          catch
          {
            // Ignore any error and drop through to the fallback message-generator below
          }
        }
        SaveMessage(new MessageDetails
        {
          Title = &quot;Fact&quot;,
          Content = &quot;API call failed when polling for server content :(&quot;
        });
      };
      request.Open(&quot;GET&quot;, &quot;http://api.icndb.com/jokes/random&quot;);
      request.Send();
    }

    private string HtmlDecode(string value)
    {
      if (value == null)
        throw new ArgumentNullException(&quot;value&quot;);

      var wrapper = Document.CreateElement(&quot;div&quot;);
      wrapper.InnerHTML = value;
      return wrapper.TextContent;
    }

    [IgnoreCast]
    private class ChuckNorrisFactApiResponse
    {
      public extern string Type { [Template(&quot;type&quot;)] get; }
      public extern FactDetails Value { [Template(&quot;value&quot;)] get; }

      [IgnoreCast]
      public class FactDetails
      {
        public extern int Id { [Template(&quot;id&quot;)] get; }
        public extern string Joke { [Template(&quot;joke&quot;)]get; }
      }
    }
  }
}
</code></pre>
<p><em>The Chuck-Norris-fact-retrieval code could be made shortener by casting the &quot;apiResponse&quot; reference to <strong>dynamic</strong>, but I thought that it would a nice opportunity to show how you can call a JSON-returning API with Bridge and then access the data through a known object model (which is why I created a <strong>ChuckNorrisFactApiResponse</strong> class to use instead).</em></p>
<p>Without any other changes to the code we have so far, this works.. in a manner of speaking. Any time you save a message of your own, the read action that follows the save will pull back <em>all</em> of the messages from the <strong>MessageApi</strong>'s in-memory set. So, when a read is explicitly initiated, all of the most recent data will come back.</p>
<p>But it would be nice if the new messages could appear in the <strong>MessageHistory</strong> even without you, as the user, saving your own messages. They could appear in the history even as you are in the process of writing your own content.</p>
<p>One way to do this would be to have the <strong>MessageApi</strong> raise an event whenever its message history data changes. Then, the <strong>AppContainer</strong> would listen for events from its <strong>MessageApi</strong> reference (which it has in its props, since props on a stateful component are used to provide references to the &quot;external environment&quot;) as well as listening to events from the components that it renders.</p>
<p>On the one hand, this would actually make the save logic cleaner - the OnSave handler that the <strong>AppContainer</strong> passes to the <strong>MessageEditor</strong> in its props would only have to disable the form during the save and clear / re-enable it after the save, it <em>wouldn't</em> have to then request updated message data from the <strong>MessageApi</strong>, since it would know that the <strong>MessageApi</strong> would raise its own event when it had accepted the newly-saved message.</p>
<p>But, on the other hand, dealing with more event sources means that more logic is required in the <strong>AppContainer</strong> (which I want to move away from) and we no longer have the simple rendering-goes-down-the-tree and events-come-up-the-tree, now we have rendering-goes-down-the-tree and events-come-up-the-tree <em>and</em> events-come-from-some-other-places-too.</p>
<p>So I'm going to look at an alternative..</p>
<h4>Extracting UI logic</h4>
<p>Instead of the <strong>AppContainer</strong> potentially having to deal with multiple event sources and working out how events may or may not change its state, I'm going to pull that handling of UI state into another class entirely; somewhere to <em>store</em> this state, that will act as a single (and very simple) event source for <strong>AppContainer</strong>. This store will have a single event that the <strong>AppContainer</strong> will subscribe to; an argument-less &quot;OnChange&quot; event. When the <strong>AppContainer</strong> receives an &quot;OnChange&quot; event from the store, it will access data that the store makes available in order to update its own state reference and thus trigger a re-render.</p>
<p>Since events will be handled by this store, whenever an event from the component tree is passed up to the <strong>AppContainer</strong>, the <strong>AppContainer</strong> needs to pass it along to the store (instead of trying to process the event itself). So the <strong>AppContainer</strong> could act like an event source for this new store class. And, since the store class will be dealing with processing events (such as &quot;user has requested a new message be saved&quot;), it will also have to deal with the <strong>MessageApi</strong> being an event source.</p>
<p>This is a good illustration of separation of concerns - the <strong>AppContainer</strong> used to be responsible for rendering the component tree <em>and</em> dealing with handling events (which is where the real complexity of an application lies). With this new plan, the <strong>AppContainer</strong> will only deal with re-rendering and the event processing is dealt with by &quot;pure&quot; (ie. non-UI-related) C# code. However, we could <em>still</em> make the &quot;multiple event source&quot; issue a little cleaner. The store in this example will only have two event sources (the <strong>AppContainer</strong> - from user interactions - and the <strong>MessageApi</strong> - from new Chuck Norris facts arriving), but a more complex application could result in many event sources being required.</p>
<p>And, sometimes, a particular store might not even want access to the full event source reference; if our store was <em>only</em> going to be used for dealing with data for a form that edits an existing message (and doesn't want to show a message history anywhere), then it wouldn't need a full <strong>MessageApi</strong> reference - it just needs to be able to read one message in particular to edit, be able to request a change to that message be saved and then know when that save request had been processed. For this store to say that it requires a full <strong>MessageApi</strong> would be an exaggeration - it would be claiming that it had a greater dependency than it really does.</p>
<p>It makes sense to have one &quot;UI store&quot; per page of your application, so if we were to extend this example such that the main page allowed you to record new messages and see the message history and we added a way to edit a particular message on a different screen, then we might have two stores and two top-level components and a router to handle navigation from one to the other. I don't want to jump too far ahead here, I just mean to point out that different stores may rely upon different event sources and rely on different abilities of those event sources.</p>
<h4>The message bus</h4>
<p>So the next change that I'm going to propose is to decouple event sources from the store by having all events broadcast as messages. These are sent to some sort of message bus, which then passes them on to any interested parties. This would mean that the <strong>AppContainer</strong> would send a message to the bus whenever the user has interacted with the UI (whether this be an edit to a field or a request to save). When &quot;SaveMessage&quot; is called on the <strong>MessageApi</strong> then it will no longer return a <strong>Task</strong>, instead a message will be passed to the bus when the save has completed. When a new Chuck Norris fact is received by the <strong>MessageApi</strong>, it will send a message to the bus to say that new message data is available.</p>
<p>This would mean that the store class will only have a single &quot;event source&quot;, which is this message bus. It will subscribe to this bus, and whenever a message is dispatched that the store is interested in then it will deal with it accordingly. If a store were to receive a message that it <em>wasn't</em> interested in, then it would just ignore it.</p>
<p>Introducing a message bus like this is a common technique to decouple areas of a system and it is another approach that makes unit testing easier later on - since the store class(es) are where the complicated event-handling logic lives, this is the code that needs the most testing. With this proposed arrangement, to test a store's logic you need only to new one up, pass it a message bus reference used solely within the current unit test, push particular messages through the bus and then verify that the store raises its OnChange event after messages when you expect it to and that the data that the store makes public is what you expect at these times. This allows all of the complicated logic to be tested with zero UI components involved and reduces the times when mocks are required since so much of the communication with the store is done via messages. (In order to test the &quot;Save&quot; functionality in our example app, a mock <strong>IReadAndWriteMessages</strong> <em>would</em> be required by our <strong>MessageWriterStore</strong>, however, so that it could call &quot;SaveMessage&quot; on something that doesn't actually persist data - and so that the unit test could confirm that &quot;SaveMessage&quot; was called with the expected data).</p>
<p>To summarise all of the above, we will move away slightly from the paths of communication being rendering-goes-down-the-tree and events-come-up-the-tree. Before, these paths were a continuous chain because events came up the tree and were processed and the re-render immediately went back down the tree again. Now we have rendering-goes-down-the-tree and events-come-up-the-tree but then nothing seems to happen immediately, instead the top-level component sends off a message and does nothing more.. until the store receives that message, processes it as an event (and applies any complicated logic) and then raises its OnChange event, which the top-level component receives and triggers a re-render.</p>
<p>I must admit, that sounds <em>more</em> complicated! But don't lose sight of the fact that we will side-step the complexities that multiple event sources can introduce <em>and</em> we will separate logic from UI, making the code more testable <em>and</em> making each part of it easier to reason about and thus easier to maintain and extend in the future.</p>
<p><em>(Note: This approach brings us much closer to treating everything as &quot;asynchronous by default&quot; - even UI changes now are implemented in a fire-and-forget manner; the top-level component sends out a message when the UI should be updated and then does nothing until it's informed by the store that it should update. While it initially feels strange to not expect to &quot;immediately&quot; update UI components in a synchronous manner, the advantage to async being the norm is that it's common for async code to be a bit scary in otherwise synchronous code - but here it's all the same, and not scary at all. It's also worth noting that we weren't truly updating in a synchronous manner before, since React's SetState method actually operates asynchronously - this allows React to batch updates if many occur in succession, potentially further reducing the number of times that the browser DOM actually needs to be interacted with; clever stuff!)</em></p>
<h3>The new architecture</h3>
<p>I must admit, at this point, that I can't take any credit for the above ideas. What I've outlined is referred to as the <a href="https://facebook.github.io/flux/docs/overview.html#content">Flux Architecture</a> (since different people have extracted their own variations on the concept, it might be safer to describe it as a Flux-like architecture, but let's not split hairs).</p>
<p>Below is the classic Flux diagram -</p>
<img alt="The proposed example app" src="/Content/Images/Posts/FluxDiagramSimple.png" class="AlwaysFullWidth" title="The proposed example app" />
<p>The message bus is referred to as the &quot;Dispatcher&quot;, messages are known as &quot;Actions&quot;. The &quot;View&quot; is the React component tree (the <strong>AppContainer</strong> listens for the &quot;OnChange&quot; event from the Store and re-renders when it receives it). Note that actions come not just from the View but also from outside the cycle; in our case we have messages coming from the <strong>MessageApi</strong> when new Chuck Norris facts arrive. In an application with routing, there would be actions from the router when the URL changes.</p>
<p>So... what's required to get from the current architecture that the example application has to a Flux-like one?</p>
<p>Let's start with the Dispatcher and the messages that flow through it. The first good news is that the Bridge React bindings include a Dispatcher implementation; the <strong>AppDispatcher</strong>. This has two methods:</p>
<pre><code>void Receive(Action&lt;IDispatcherAction&gt; callback);
void Dispatch(IDispatcherAction action);
</code></pre>
<p>The <strong>IDispatcherAction</strong> interface is empty and is only used as a marker to identify classes as being intended for use as a Dispatcher action.</p>
<p>When writing in JavaScript, actions tend to be simple objects with a &quot;type&quot; or &quot;actionType&quot; property that identifies what sort of action it is. It will then have further properties, depending upon what action it needs to describe. I've taken the below example from an article (that wasn't written by me); <a href="http://spapas.github.io/2015/09/08/more-complex-react-flux-example/">A (little more) complex react and flux example</a> -</p>
<pre><code>AppDispatcher.dispatch({
  actionType: BookConstants.MESSAGE_ADD,
  message: {
    color: 'green',
    text: msg
  }
});
</code></pre>
<p>However, we're writing in C# and we're going to take advantage of that! Our actions will be distinct types. When the store listens out messages, it won't compare an &quot;actionType&quot; string to work out what a particular action represents, instead we'll perform type comparisons and, when we find an action that we're interested in, we'll cast the current action to the matched type and then access its data in a type-safe manner.</p>
<p>Create a new folder in the project from <a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">Part One</a> called &quot;Actions&quot;. The simplest action to begin with is the action that would be raised by the <strong>AppContainer</strong> when the user has clicked the Save button -</p>
<pre><code>using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Actions
{
  public class MessageSaveRequested : IDispatcherAction
  {
    public MessageDetails Message;
  }
}
</code></pre>
<p>Previously, the <strong>AppContainer</strong>'s Render method contained logic about dealing with save requests -</p>
<pre><code>OnSave = async () =&gt;
{
  // Set SaveInProgress to true while the save operation is requested
  SetState(new State {
     Message = state.Message,
    IsSaveInProgress = true,
    MessageHistory = state.MessageHistory
  });
  await props.MessageApi.SaveMessage(state.Message);

  // After the save has completed, clear the message entry form and reset
  // SaveInProgress to false
  SetState(new State {
     Message = new MessageDetails { Title = &quot;&quot;, Content = &quot;&quot; },
    IsSaveInProgress = false,
    MessageHistory = state.MessageHistory
  });

  // Then re-load the message history state and re-render when that data arrives
  var allMessages = await props.MessageApi.GetMessages();
  SetState(new State {
    Message = state.Message,
    IsSaveInProgress = state.IsSaveInProgress,
    MessageHistory = allMessages
  });
}
</code></pre>
<p>But, if all that it needs to do when a save-request bubbles up to it is send an appropriate action through the Dispatcher, then it becomes much simpler -</p>
<pre><code>OnSave = () =&gt; props.Dispatcher.Dispatch(
   new MessageSaveRequested { Message = state.Message }
)
</code></pre>
<p>I've only shown the change to the &quot;OnSave&quot; property, rather than show the change within the context of the complete <strong>AppContainer</strong> class because there are other things I want to rearrange at this point. Firstly, the <strong>MessageEditor</strong> &quot;OnChange&quot; handler also needs to be altered - as I described above, when a user interaction is expected to require a re-render, this will <em>not</em> result in SetState being called immediately. Instead, an action will be sent to the Dispatcher. We need to define this action, so create another class in the &quot;Actions&quot; folder -</p>
<pre><code>using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Actions
{
  public class MessageEditStateChanged : IDispatcherAction
  {
    public MessageEditState NewState;
  }
}
</code></pre>
<p>The other change is in the format of the data that is passed to the <strong>MessageEditor</strong>. Before, separate &quot;Title&quot;, &quot;Content&quot; and &quot;Disabled&quot; values were passed to it and the component would do three things with that information -</p>
<ol>
<li>It would populate the &quot;Title&quot; and &quot;Content&quot; text inputs with the provided values</li>
<li>If the &quot;Title&quot; string was populated then this value would be used to set the fieldset legend text, otherwise the legend would show &quot;Untitled&quot;</li>
<li>Validation messages would be displayed for &quot;Title&quot; and &quot;Content&quot; if one or both of the values was blank</li>
</ol>
<p>These second and third things are precisely the sort of logic that should be extracted out into the store. Consequently, the <strong>MessageEditor</strong> will be changed so that it no longer takes these individual values and, instead, takes a <strong>MessageEditState</strong> that has a &quot;Caption&quot; string  (for the legend text), &quot;Title&quot; and &quot;Content&quot; strings and validation messages for these user-entered strings. The &quot;Disabled&quot; property will replaced with &quot;IsSaveInProgress&quot; - if this is true then none of the form elements (the text inputs or the save button) should be enabled. If a save is <em>not</em> in progress, then the text inputs should be enabled but the save button should only be enabled if neither validation message has any content. That is arguably more logic that could be extracted, but I think that this approach will strike a good balance - keeping the component &quot;dumb&quot; without having to spell out every little thing to the nth degree. Add two new files to the &quot;ViewModels&quot; folder to define the following classes -</p>
<pre><code>namespace BridgeReactTutorial.ViewModels
{
  public class MessageEditState
  {
    public string Caption;
    public TextEditState Title;
    public TextEditState Content;
    public bool IsSaveInProgress;
  }
}

namespace BridgeReactTutorial.ViewModels
{
  public class TextEditState
  {
    public string Text;
    public string ValidationError;
  }
}
</code></pre>
<p>Now the <strong>MessageEditor</strong> may be rewritten to the following (note that after this change, the project isn't going to compile any more - there are a bunch of other alterations that will be required until everything builds again, all of which will be covered below):</p>
<pre><code>using System;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class MessageEditor : StatelessComponent&lt;MessageEditor.Props&gt;
  {
    public MessageEditor(Props props) : base(props) { }

    public override ReactElement Render()
    {
      var formIsInvalid =
        !string.IsNullOrWhiteSpace(props.Message.Title.ValidationError) ||
        !string.IsNullOrWhiteSpace(props.Message.Content.ValidationError);

      return DOM.FieldSet(new FieldSetAttributes { ClassName = props.ClassName },
        DOM.Legend(null, props.Message.Caption),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Title&quot;),
        new ValidatedTextInput(new ValidatedTextInput.Props
        {
          ClassName = &quot;title&quot;,
          Disabled = props.Message.IsSaveInProgress,
          Content = props.Message.Title.Text,
          OnChange = newTitle =&gt; props.OnChange(new MessageEditState
          {
            Title = new TextEditState { Text = newTitle },
            Content = props.Message.Content
          }),
          ValidationMessage = props.Message.Title.ValidationError
        }),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Content&quot;),
        new ValidatedTextInput(new ValidatedTextInput.Props
        {
          ClassName = &quot;content&quot;,
          Disabled = props.Message.IsSaveInProgress,
          Content = props.Message.Content.Text,
          OnChange = newContent =&gt; props.OnChange(new MessageEditState
          {
            Title = props.Message.Title,
            Content = new TextEditState { Text = newContent },
          }),
          ValidationMessage = props.Message.Content.ValidationError
        }),
        DOM.Button(
          new ButtonAttributes
          {
            Disabled = formIsInvalid || props.Message.IsSaveInProgress,
            OnClick = e =&gt; props.OnSave()
          },
          &quot;Save&quot;
        )
      );
    }

    public class Props
    {
      public string ClassName;
      public MessageEditState Message;
      public Action&lt;MessageEditState&gt; OnChange;
      public Action OnSave;
    }
  }
}
</code></pre>
<p>Now the <strong>AppContainer</strong> becomes <em>much</em> simpler -</p>
<pre><code>using System;
using System.Collections.Generic;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.ViewModels;
using BridgeReactTutorial.Stores;

namespace BridgeReactTutorial.Components
{
  public class AppContainer : Component&lt;AppContainer.Props, AppContainer.State&gt;
  {
    public AppContainer(AppContainer.Props props) : base(props) { }

    protected override void ComponentDidMount()
    {
      props.Store.Change += StoreChanged;
    }
    protected override void ComponentWillUnmount()
    {
      props.Store.Change -= StoreChanged;
    }
    private void StoreChanged()
    {
      SetState(new State
      {
        Message = props.Store.Message,
        MessageHistory = props.Store.MessageHistory
      });
    }

    public override ReactElement Render()
    {
      if (state == null)
        return null;

      return DOM.Div(null,
        new MessageEditor(new MessageEditor.Props
        {
          ClassName = &quot;message&quot;,
          Message = state.Message,
          OnChange = newState =&gt; props.Dispatcher.Dispatch(
            new MessageEditStateChanged { NewState = newState }
          ),
          OnSave = () =&gt; props.Dispatcher.Dispatch(
            new MessageSaveRequested
            {
              Message = new MessageDetails
              {
                Title = state.Message.Title.Text,
                Content = state.Message.Content.Text
              }
            }
          )
        }),
        new MessageHistory(new MessageHistory.Props
        {
          ClassName = &quot;history&quot;,
          Messages = state.MessageHistory
        })
      );
    }

    public class Props
    {
      public AppDispatcher Dispatcher;
      public MessageWriterStore Store;
    }

    public class State
    {
      public MessageEditState Message;
      public IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt; MessageHistory;
    }
  }
}
</code></pre>
<p>It is now almost devoid of logic, it only exists to listen to changes from the store (which we'll define in a moment), to render components and to direct events that are passed up from these components to the Dispatcher. Note that it no longer has any dependency upon the <strong>MessageApi</strong>.</p>
<p>A couple of things to note - the Dispatcher and Store are both passed to the component through its props, but when the Store raises a Change event the <strong>AppContainer</strong> copies data references from the Store into its own state, meaning that <em>all</em> of the information that the <strong>AppContainer</strong> requires to render itself is contained within its state. This follows the &quot;Guidelines for Stateful Components&quot; that I wrote <a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">last time</a> -</p>
<ol>
<li>A stateful component's &quot;props&quot; data should <em>only</em> consist of references to external dependencies</li>
<li>A stateful component's &quot;state&quot; data should include <em>everything</em> required to render the component tree, though the props may be required to deal with child components' events</li>
</ol>
<p>The <strong>AppContainer</strong> now uses some React component life cycle methods that it wasn't before - &quot;ComponentDidMount&quot; and &quot;ComponentWillUnmount&quot; - to ensure that the handler attached to the Store's Change event is correctly removed when no longer required. In our example application, the <strong>AppContainer</strong> is never &quot;unmounted&quot; but in a more complicated application then the top-level components may be changed based upon how the user navigates through the application. (A component is &quot;mounted&quot; when it's being added to the component tree and &quot;unmounted&quot; when it's being removed - in an application with a router, the current top-level component may be changed based upon the current route, in which case there would be top-level components being mounted and unmounted as the route changes and it is important that any event handlers that they attached be detached when they're not needed).</p>
<p>One final thing to note before moving on to the Store implementation is that there is no longer a &quot;GetInitialState&quot; implementation in the <strong>AppContainer</strong> and the &quot;Render&quot; method will return null if state doesn't yet have a value. &quot;GetInitialState&quot; was <em>another</em> example of logic that is better placed outside of the component classes - now the <strong>AppContainer</strong> is not responsible for having to know what its initial state should be, it just renders <em>nothing</em> until the Store has raised a Change request that tells the <strong>AppContainer</strong> what to display.</p>
<p>The child components are &quot;dumb&quot; as all they have to do is render according to the props data that they are provided with and now the top-level stateful component is similarly &quot;dumb&quot; as all it does is listen to the Store and pass the information down to dumb stateless components - and then listen for events from the child components, in order to pass the information on to the Dispatcher.</p>
<p>We're almost ready to talk about how to create the Store now, but first we need to adapt the <strong>MessageApi</strong> to work with the Dispatcher, rather than with <strong>Task</strong>s.</p>
<pre><code>using System;
using System.Collections.Generic;
using Bridge;
using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.API
{
  public class MessageApi : IReadAndWriteMessages
  {
    private readonly AppDispatcher _dispatcher;
    private readonly List&lt;Tuple&lt;int, MessageDetails&gt;&gt; _messages;
    public MessageApi(AppDispatcher dispatcher)
    {
      if (dispatcher == null)
        throw new ArgumentException(&quot;dispatcher&quot;);

      _dispatcher = dispatcher;
      _messages = new List&lt;Tuple&lt;int, MessageDetails&gt;&gt;();

      // To further mimic a server-based API (where other people may be recording messages
      // of their own), after a 10s delay a periodic task will be executed to retrieve a
      // new message
      Window.SetTimeout(
        () =&gt; Window.SetInterval(GetChuckNorrisFact, 5000),
        10000
      );
    }

    public RequestId SaveMessage(MessageDetails message)
    {
      return SaveMessage(message, optionalSaveCompletedCallback: null);
    }

    private RequestId SaveMessage(
      MessageDetails message,
      Action optionalSaveCompletedCallback)
    {
      if (message == null)
        throw new ArgumentNullException(&quot;message&quot;);
      if (string.IsNullOrWhiteSpace(message.Title))
        throw new ArgumentException(&quot;A title value must be provided&quot;);
      if (string.IsNullOrWhiteSpace(message.Content))
        throw new ArgumentException(&quot;A content value must be provided&quot;);

      var requestId = new RequestId();
      Window.SetTimeout(
        () =&gt;
        {
          _messages.Add(Tuple.Create(_messages.Count, message));
          _dispatcher.Dispatch(
            new MessageSaveSucceeded { RequestId = requestId }
          );
          if (optionalSaveCompletedCallback != null)
            optionalSaveCompletedCallback();
        },
        1000 // Simulate a roundtrip to the server
      );
      return requestId;
    }

    public RequestId GetMessages()
    {
      // ToArray is used to return a clone of the message set - otherwise, the caller would
      // end up with a list that is updated when the internal reference within this class
      // is updated (which sounds convenient but it's not the behaviour that would be
      // exhibited if this was really persisting messages to a server somewhere)
      var requestId = new RequestId();
      Window.SetTimeout(
        () =&gt; _dispatcher.Dispatch(new MessageHistoryUpdated
        {
          RequestId = requestId,
          Messages = _messages.ToArray()
        }),
        1000 // Simulate a roundtrip to the server
      );
      return requestId;
    }

    private void GetChuckNorrisFact()
    {
      var request = new XMLHttpRequest();
      request.ResponseType = XMLHttpRequestResponseType.Json;
      request.OnReadyStateChange = () =&gt;
      {
        if (request.ReadyState != AjaxReadyState.Done)
          return;

        if ((request.Status == 200) || (request.Status == 304))
        {
          try
          {
            var apiResponse = (ChuckNorrisFactApiResponse)request.Response;
            if ((apiResponse.Type == &quot;success&quot;)
            &amp;&amp; (apiResponse.Value != null)
            &amp;&amp; !string.IsNullOrWhiteSpace(apiResponse.Value.Joke))
            {
              // The Chuck Norris Facts API (http://www.icndb.com/api/) returns strings
              // html-encoded, so they need decoding before be wrapped up in a
              // MessageDetails instance
              // - Note: After the save has been processed, GetMessages is called so
              //   that a MessageHistoryUpdate action is dispatched
              SaveMessage(
                new MessageDetails
                {
                  Title = &quot;Fact&quot;,
                  Content = HtmlDecode(apiResponse.Value.Joke)
                },
                () =&gt; GetMessages()
              );
              return;
            }
          }
          catch
          {
            // Ignore any error and drop through to the fallback message-generator below
          }
        }
        SaveMessage(new MessageDetails
        {
          Title = &quot;Fact&quot;,
          Content = &quot;API call failed when polling for server content :(&quot;
        });
      };
      request.Open(&quot;GET&quot;, &quot;http://api.icndb.com/jokes/random&quot;);
      request.Send();
    }

    private string HtmlDecode(string value)
    {
      if (value == null)
        throw new ArgumentNullException(&quot;value&quot;);

      var wrapper = Document.CreateElement(&quot;div&quot;);
      wrapper.InnerHTML = value;
      return wrapper.TextContent;
    }

    [IgnoreCast]
    private class ChuckNorrisFactApiResponse
    {
      public extern string Type { [Template(&quot;type&quot;)] get; }
      public extern FactDetails Value { [Template(&quot;value&quot;)] get; }

      [IgnoreCast]
      public class FactDetails
      {
        public extern int Id { [Template(&quot;id&quot;)] get; }
        public extern string Joke { [Template(&quot;joke&quot;)]get; }
      }
    }
  }
}
</code></pre>
<p>This means that the <strong>IReadAndWriteMessages</strong> interface no longer returns <strong>Task</strong>s -</p>
<pre><code>using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.API
{
  public interface IReadAndWriteMessages
  {
    RequestId SaveMessage(MessageDetails message);
    RequestId GetMessages();
  }
}
</code></pre>
<p>Each of the two methods now return a &quot;<strong>RequestId</strong>&quot;. This is a unique identifier that will be used to tie future actions back to specific calls to the &quot;GetMessages&quot; or &quot;SaveMessaage&quot; methods. When a user requests that a message be saved in our sample app, the <strong>AppContainer</strong> sends a <strong>MessageSaveRequested</strong> action through the Dispatcher. The store will receive this action from the Dispatcher and use the message data in it to call &quot;SaveMessage&quot;, which will give the Store a unique <strong>RequestId</strong>. After the <strong>MessageApi</strong> has completed the save, it will raise a <strong>MessageSaveSucceeded</strong> action that has a &quot;RequestId&quot; value, the same <strong>RequestId</strong> as &quot;SaveMessage&quot; returned. This is how the Store knows that the save which succeeded was, in fact, the save that it initiated. In the app here, there wouldn't be any doubt since there is only one place where a new message may be saved, but in a more complicated application it's feasible that there may be multiple components that could initiate a save and it would be important to be able to be able to trace any &quot;save succeeded&quot; notification back to where it came from.</p>
<p>The <strong>RequestId</strong> has a nice feature in that two instances may be compared to determine which is most recent - this <em>could</em> be applicable to an application like our example because, shortly, the message history will be updated after a user has created a new message <em>and</em> it will be automatically updated when a new Chuck Norris fact appears. It's not too difficult to imagine that there could be a race condition that occurs when two &quot;new message history&quot; actions are received by the Store (one from the user-saves-message-and-then-fresh-history-is-automatically-retrieved-after-the-save-is-completed process and one from a new Chuck Norris fact arriving). In the real world, with unpredictable server and network times, it's possible for &quot;Server Call A&quot; to start before &quot;Server Call B&quot; but for &quot;Server Call A&quot; to finish <em>after</em> &quot;Server Call B&quot; - in this case we <em>want</em> the &quot;new message history&quot; from &quot;Server Call B&quot;, since it should be more recent, but the data from &quot;Server Call A&quot; arrives <em>after</em> it and we need to know which result is freshest. If each action that relates to &quot;new data arrived from API&quot; has a <strong>RequestId</strong> then we can compare the two values using the &quot;ComesAfter&quot; function, allow us to ignore the stale data.</p>
<p>The <strong>RequestId</strong> implementation is fairly simple (add a new &quot;RequestId.cs&quot; file to the &quot;API&quot; folder and paste in the following) -</p>
<pre><code>using System;

namespace BridgeReactTutorial.API
{
  public class RequestId
  {
    private static DateTime _timeOfLastId = DateTime.MinValue;
    private static int _offsetOfLastId = 0;

    private readonly DateTime _requestTime;
    private readonly int _requestOffset;
    public RequestId()
    {
      _requestTime = DateTime.Now;
      if (_timeOfLastId &lt; _requestTime)
      {
        _offsetOfLastId = 0;
        _timeOfLastId = _requestTime;
      }
      else
        _offsetOfLastId++;
      _requestOffset = _offsetOfLastId;
    }

    public bool ComesAfter(RequestId other)
    {
      if (other == null)
        throw new ArgumentNullException(&quot;other&quot;);

      if (_requestTime == other._requestTime)
        return _requestOffset &gt; other._requestOffset;
      return (_requestTime &gt; other._requestTime);
    }
  }
}
</code></pre>
<p>In the new <strong>MessageApi</strong> code above, two actions were referenced that haven't been defined yet, so add two more classes to the &quot;Actions&quot; folder for the following:</p>
<pre><code>using System;
using System.Collections.Generic;
using Bridge.React;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Actions
{
  public class MessageHistoryUpdated : IDispatcherAction
  {
    public RequestId RequestId;
    public IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt; Messages;
  }
}

using Bridge.React;
using BridgeReactTutorial.API;

namespace BridgeReactTutorial.Actions
{
  public class MessageSaveSucceeded : IDispatcherAction
  {
    public RequestId RequestId;
  }
}
</code></pre>
<p><em>(Note: A <strong>MessageHistoryUpdated</strong> will be emitted after a &quot;GetMessages&quot; call is made but one will also be emitted every time that a new Chuck Norris fact arrives)</em>.</p>
<p>While we're adding actions, we're going to need a <strong>StoreInitialised</strong> action class (I'll talk about this more later on, for now just add the following class to the &quot;Actions&quot; folder):</p>
<pre><code>using Bridge.React;
using BridgeReactTutorial.API;

namespace BridgeReactTutorial.Actions
{
  public class StoreInitialised : IDispatcherAction
  {
    public object Store;
  }
}
</code></pre>
<p>Now, <em>finally</em>, we so create a Store.</p>
<p>Create a new folder in the project root called &quot;Stores&quot; and add a new class file to it; &quot;MessageWriterStore.cs&quot; -</p>
<pre><code>using System;
using System.Collections.Generic;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Stores
{
  public class MessageWriterStore
  {
    private RequestId _saveActionRequestId, _lastDataUpdatedRequestId;
    public MessageWriterStore(IReadAndWriteMessages messageApi, AppDispatcher dispatcher)
    {
      if (messageApi == null)
        throw new ArgumentNullException(&quot;messageApi&quot;);
      if (dispatcher == null)
        throw new ArgumentNullException(&quot;dispatcher&quot;);

      Message = GetInitialMessageEditState();
      MessageHistory = new Tuple&lt;int, MessageDetails&gt;[0];

      dispatcher.Receive(action =&gt;
      {
        if (action is StoreInitialised)
        {
          var storeInitialised = (StoreInitialised)action;
          if (storeInitialised.Store == this)
            OnChange();
        }
        else if (action is MessageEditStateChanged)
        {
          var messageEditStateChanged = (MessageEditStateChanged)action;
          Message = messageEditStateChanged.NewState;
          ValidateMessage(Message);
          OnChange();
        }
        else if (action is MessageSaveRequested)
        {
          var messageSaveRequested = (MessageSaveRequested)action;
          _saveActionRequestId = messageApi.SaveMessage(messageSaveRequested.Message);
          Message.IsSaveInProgress = true;
          OnChange();
        }
        else if (action is MessageSaveSucceeded)
        {
          var messageSaveSucceeded = (MessageSaveSucceeded)action;
          if (messageSaveSucceeded.RequestId == _saveActionRequestId)
          {
            _saveActionRequestId = null;
            Message = GetInitialMessageEditState();
            OnChange();
            _lastDataUpdatedRequestId = messageApi.GetMessages();
          }
        }
        else if (action is MessageHistoryUpdated)
        {
          var messageHistoryUpdated = (MessageHistoryUpdated)action;
          if ((_lastDataUpdatedRequestId == null)
          || (_lastDataUpdatedRequestId == messageHistoryUpdated.RequestId)
          || messageHistoryUpdated.RequestId.ComesAfter(_lastDataUpdatedRequestId))
          {
            _lastDataUpdatedRequestId = messageHistoryUpdated.RequestId;
            MessageHistory = messageHistoryUpdated.Messages;
            OnChange();
          }
        }
      });
    }

    public event Action Change;
    public MessageEditState Message;
    public IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt; MessageHistory;

    private MessageEditState GetInitialMessageEditState()
    {
      // Note: By using the ValidateMessage here, we don't need to duplicate the &quot;Untitled&quot;
      // string that should be used for the Caption value when the UI is first rendered
      // or when the user has entered some Title content but then deleted it again.
      // Similarly, we avoid having to repeat the validation messages that should be
      // displayed when the form is empty, since they will be set by ValidateMessage.
      var blankMessage = new MessageEditState
      {
        Caption = &quot;&quot;,
        Title = new TextEditState { Text = &quot;&quot; },
        Content = new TextEditState { Text = &quot;&quot; },
        IsSaveInProgress = false
      };
      ValidateMessage(blankMessage);
      return blankMessage;
    }

    private void ValidateMessage(MessageEditState message)
    {
      if (message == null)
        throw new ArgumentNullException(&quot;message&quot;);

      message.Caption = string.IsNullOrWhiteSpace(message.Title.Text)
        ? &quot;Untitled&quot;
        : message.Title.Text.Trim();
      message.Title.ValidationError = string.IsNullOrWhiteSpace(message.Title.Text)
        ? &quot;Must enter a title&quot;
        : null;
      message.Content.ValidationError = string.IsNullOrWhiteSpace(message.Content.Text)
        ? &quot;Must enter message content&quot;
        : null;
    }

    private void OnChange()
    {
      if (Change != null)
        Change();
    }
  }
}
</code></pre>
<p>There's really nothing very complicated here at all. What I like is that all of the logic that was previously ensconced within component classes is now in a C# class which has zero UI-based dependencies. What I also like is how clear the logic is, it's very easy to read through how the various actions are matched and to see precisely what state changes will occur. In fact, the <strong>MessageWriterStore</strong> is just a simple state machine where each transition is based upon the action that it receives from the Dispatcher. It's reassuring that the Flux architecture is based upon these time-tested computer science devices; the message bus and <a href="/c-sharp-state-machines">state machine</a> - while it might take a little while to internalise how to write applications based around this &quot;one-way binding&quot; / &quot;one-way message passing&quot; arrangement, once it clicks it feels very natural.</p>
<p>Having the core application logic in classes like this really helps ensure that code will have those two great properties that I will keep repeating through this series - that it's easy to reason about and that it's easy to test. It's easy to reason about as it's easy to see how user (and server) actions flow through the code, there are few surprises. It's easy to test because there are few dependencies - to test anything in the <strong>MessageWriterStore</strong>, each unit test would need to provide an <strong>AppDispatcher</strong> instance and a mock <strong>IReadAndWriteMessages</strong> implementation, it would then push one or more messages through the Dispatcher and confirm that the public <strong>MessageWriterStore</strong> state matches expectations at the end. For example, to test the &quot;Content&quot; text input validation, you would play back a <strong>MessageEditStateChanged</strong> action with a blank &quot;Content&quot; string in the <strong>MessageEditState</strong> and ensure that the expected validation message text was present in the &quot;Message&quot; reference of the <strong>MessageWriterStore</strong> afterwards.</p>
<p>There are a couple of minor things that I'm not so keen about in the code above. Firstly, there's the laborious type-checking and casting that is required when matching the actions. Secondly, there's the duplication on calling &quot;OnChange&quot; whenever an action is matched. Thirdly, the logic around <strong>RequestId</strong> comparison when a <strong>MessageHistoryUpdated</strong> is matched is a bit clumsy.</p>
<p>For that third point, add a new file &quot;RequestIdExtensions.cs&quot; to the &quot;API&quot; folder with the following content -</p>
<pre><code>using System;

namespace BridgeReactTutorial.API
{
  public static class RequestIdExtensions
  {
    public static bool IsEqualToOrComesAfter(this RequestId source, RequestId other)
    {
      if (source == null)
        throw new ArgumentNullException(&quot;source&quot;);

      // If the &quot;other&quot; reference is no-RequestId then the &quot;source&quot; may be considered to
      // come after it
      if (other == null)
        return true;

      return (source == other) || source.ComesAfter(other);
    }
  }
}
</code></pre>
<p>And for the first two points, we can use some extension methods which are included in the Bridge / React bindings -</p>
<pre><code>using System;
using System.Collections.Generic;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Stores
{
  public class MessageWriterStore
  {
    private RequestId _saveActionRequestId, _lastDataUpdatedRequestId;
    public MessageWriterStore(IReadAndWriteMessages messageApi, AppDispatcher dispatcher)
    {
      if (messageApi == null)
        throw new ArgumentNullException(&quot;messageApi&quot;);
      if (dispatcher == null)
        throw new ArgumentNullException(&quot;dispatcher&quot;);

      Message = GetInitialMessageEditState();
      MessageHistory = new Tuple&lt;int, MessageDetails&gt;[0];

      dispatcher.Receive(a =&gt; a
        .If&lt;StoreInitialised&gt;(
          condition: action =&gt; (action.Store == this),
          work: action =&gt; { }
        )
        .Else&lt;MessageEditStateChanged&gt;(action =&gt;
        {
          Message = action.NewState;
          ValidateMessage(Message);
        })
        .Else&lt;MessageSaveRequested&gt;(action =&gt;
        {
          _saveActionRequestId = messageApi.SaveMessage(action.Message);
          Message.IsSaveInProgress = true;
        })
        .Else&lt;MessageSaveSucceeded&gt;(
          condition: action =&gt; (action.RequestId == _saveActionRequestId),
          work: action =&gt;
          {
            _saveActionRequestId = null;
            Message = GetInitialMessageEditState();
            _lastDataUpdatedRequestId = messageApi.GetMessages();
          }
        )
        .Else&lt;MessageHistoryUpdated&gt;(
          condition: action =&gt;
            action.RequestId.IsEqualToOrComesAfter(_lastDataUpdatedRequestId),
          work: action =&gt;
          {
            _lastDataUpdatedRequestId = action.RequestId;
            MessageHistory = action.Messages;
          }
        )
        .IfAnyMatched(OnChange)
      );
    }

    public event Action Change;
    public MessageEditState Message;
    public IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt; MessageHistory;

    private MessageEditState GetInitialMessageEditState()
    {
      // Note: By using the ValidateMessage here, we don't need to duplicate the &quot;Untitled&quot;
      // string that should be used for the Caption value when the UI is first rendered
      // or when the user has entered some Title content but then deleted it again.
      // Similarly, we avoid having to repeat the validation messages that should be
      // displayed when the form is empty, since they will be set by ValidateMessage.
      var blankMessage = new MessageEditState
      {
        Caption = &quot;&quot;,
        Title = new TextEditState { Text = &quot;&quot; },
        Content = new TextEditState { Text = &quot;&quot; },
        IsSaveInProgress = false
      };
      ValidateMessage(blankMessage);
      return blankMessage;
    }

    private void ValidateMessage(MessageEditState message)
    {
      if (message == null)
        throw new ArgumentNullException(&quot;message&quot;);

      message.Caption = string.IsNullOrWhiteSpace(message.Title.Text)
        ? &quot;Untitled&quot;
        : message.Title.Text.Trim();
      message.Title.ValidationError = string.IsNullOrWhiteSpace(message.Title.Text)
        ? &quot;Must enter a title&quot;
        : null;
      message.Content.ValidationError = string.IsNullOrWhiteSpace(message.Content.Text)
        ? &quot;Must enter message content&quot;
        : null;
    }

    private void OnChange()
    {
      if (Change != null)
        Change();
    }
  }
}
</code></pre>
<p>Hopefully it's clear enough how they work. The &quot;If&quot; and the &quot;Else&quot; functions both have a generic type parameter for the kind of action to match and may be called with a single &quot;work&quot; argument (meaning &quot;do this if the action type is matched&quot;) or two arguments; &quot;condition&quot; and &quot;work&quot; (where &quot;condition&quot; looks at the action, typed to match the generic type parameter, and returns true or false depending upon whether the action should be considered or ignored). The &quot;condition&quot; argument is most clearly illustrated by the <strong>MessageHistoryUpdated</strong>, it ensures that any stale <strong>MessageHistoryUpdated</strong> action will be ignored. The &quot;work&quot; implementation for <strong>StoreInitialised</strong> is empty because all that is required when a <strong>StoreInitialised</strong> action is received (that targets the current store) is to call &quot;OnChange&quot; and the &quot;IfAnyMatched&quot; extension method calls &quot;OnChange&quot; if any of the actions are matched.</p>
<p>There's just one final thing to do now in order to make the application compile again, the entry point logic in App.cs needs updating -</p>
<pre><code>using System.Linq;
using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.API;
using BridgeReactTutorial.Components;
using BridgeReactTutorial.Stores;

namespace BridgeReactTutorial
{
  public class App
  {
    [Ready]
    public static void Go()
    {
      var container = Document.GetElementById(&quot;main&quot;);
      container.ClassName = string.Join(
        &quot; &quot;,
        container.ClassName.Split().Where(c =&gt; c != &quot;loading&quot;)
      );

      var dispatcher = new AppDispatcher();
      var messageApi = new MessageApi(dispatcher);
      var store = new MessageWriterStore(messageApi, dispatcher);
      React.Render(
        new AppContainer(new AppContainer.Props
        {
          Dispatcher = dispatcher,
          Store = store
        }),
        container
      );
      dispatcher.Dispatch(new StoreInitialised { Store = store });
    }
  }
}
</code></pre>
<p>Both the <strong>MessageWriterStore</strong> and the <strong>AppContainer</strong> need a reference to a shared Dispatcher, <strong>MessageWriterStore</strong> needs a Message API wrapper to talk to and the <strong>AppContainer</strong> needs a reference to the Store. In a lot of the Flux articles that I read at first, the Dispatcher was a static reference that everything had access to - but I much prefer this arrangement, where the places that explicitly need it (ie. the Stores and the top-level components) have it passed in as a constructor argument or through props. This makes a class' requirements much more explicit - if a class has implicit dependencies then it's more difficult to tell at a glance how it works. And <em>not</em> having a static Dispatcher means that unit testing is simpler, since there is no implicit shared state between elements within an application.</p>
<p>The only part of this code that may not be very intuitive is the need to send a <strong>StoreInitialised</strong> action to the Dispatcher immediately after setting up all of the references. This is required before the <strong>AppContainer</strong> won't render anything until it processes its first &quot;Change&quot; event from the <strong>MessageWriterStore</strong> (because, until that point, the <strong>AppContainer</strong>'s state reference will be null). When the Store receives the <strong>StoreInitialised</strong> action, it will raise its &quot;Change&quot; event and the <strong>AppContainer</strong> will perform its first &quot;real&quot; render. If this was an application with a routing element, with a Store per page / form, then it would seem natural for the router to raise a <strong>StoreInitialised</strong> action for the Store that should be active for the current route (it is just a little odd-looking in a simple application like the example here unless you know why it is necessary).</p>
<h3>Lots of actions?</h3>
<p>With that, the change in architecture is complete. Hopefully it's easy to envisage how further functionality is enabled by adding further specialised components and communicating using different action types. Each action is handled in a very clear way in the Store(s) and so the overall complexity should (approximately) grow linearly with the <a href="http://codebetter.com/markneedham/2010/03/18/essential-and-accidental-complexity/">essential complexity</a>, rather than exponentially (which is what tends to happens a lot with more haphazard architectures, or where you have the &quot;star-shaped event handling&quot; that I described earlier).</p>
<p>The only adjustment that I'd like to make at this point is to the actions themselves - if there's a variation of the <strong>MessageEditStateChanged</strong>, <strong>MessageSaveRequested</strong> and <strong>MessageSaveSucceeded</strong> actions required for every kind of form where a user creates / edits data and tries to save it, then there's going to be a lot of action classes that are basically the same.</p>
<p>This seems like a perfect case for C# generics - a single generic class may be used to represent many types of user edit action without sacrificing type safety. Rename the &quot;MessageEditStateChanged.cs&quot; action class to &quot;UserEditRequested.cs&quot; and replace the content, which is currently:</p>
<pre><code>using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Actions
{
  public class MessageEditStateChanged : IDispatcherAction
  {
    public MessageEditState NewState;
  }
}
</code></pre>
<p>With this:</p>
<pre><code>using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Actions
{
  public class UserEditRequested&lt;T&gt; : IDispatcherAction
  {
    public T NewState;
  }
  public static class UserEditRequested
  {
    public static UserEditRequested&lt;T&gt; For&lt;T&gt;(T newState)
    {
      return new UserEditRequested&lt;T&gt; { NewState = newState };
    }
  }
}
</code></pre>
<p>Now, anywhere that there is a reference to <strong>MessageEditStateChanged</strong>, you will need to change it to be a <strong>UserEditRequested&lt;MessageEditState&gt;</strong>.</p>
<p>The non-generic &quot;For&quot; function is just for convenience, it allows you to create a new <strong>UserEditRequested&lt;T&gt;</strong> instance without writing out the type of &quot;T&quot; - it will be inferred by the type of the &quot;newState&quot; reference passed for it. The &quot;OnChange&quot; lambda set on the <strong>MessageEditor</strong> props was previously</p>
<pre><code>OnChange = newState =&gt; props.Dispatcher.Dispatch(
  new MessageEditStateChanged { NewState = newState }
)
</code></pre>
<p>but should now become</p>
<pre><code>OnChange = newState =&gt; props.Dispatcher.Dispatch(
  UserEditRequested.For(newState)
)
</code></pre>
<p>(Since &quot;newState&quot; is a <strong>MessageEditState</strong> instance, the action that will be raised will be a <strong>UserEditRequested&lt;MessageEditState&gt;</strong>).</p>
<p>Now, the action-matching code in the <strong>MessageWriteStore</strong> needs to change from</p>
<pre><code>.Else&lt;MessageEditStateChanged&gt;(action =&gt;
{
  Message = action.NewState;
  ValidateMessage(Message);
})
</code></pre>
<p>to</p>
<pre><code>.Else&lt;UserEditRequested&lt;MessageEditState&gt;&gt;(action =&gt;
{
  Message = action.NewState;
  ValidateMessage(Message);
})
</code></pre>
<p>Similar changes should be made, so that &quot;MessageSaveRequested.cs&quot; is replaced with</p>
<pre><code>using Bridge.React;

namespace BridgeReactTutorial.Actions
{
  public class SaveRequested&lt;T&gt; : IDispatcherAction
  {
    public T Data;
  }
  public static class SaveRequested
  {
    public static SaveRequested&lt;T&gt; For&lt;T&gt;(T data)
    {
      return new SaveRequested&lt;T&gt; { Data = data };
    }
  }
}
</code></pre>
<p>And &quot;MessageSaveSucceeded.cs&quot; is replaced with</p>
<pre><code>using Bridge.React;
using BridgeReactTutorial.API;

namespace BridgeReactTutorial.Actions
{
  public class SaveSucceeded : IDispatcherAction
  {
    public RequestId RequestId;
  }
}
</code></pre>
<p>And, finally, &quot;MessageHistoryUpdated.cs&quot; replaced with</p>
<pre><code>using Bridge.React;
using BridgeReactTutorial.API;

namespace BridgeReactTutorial.Actions
{
  public class DataUpdated&lt;T&gt; : IDispatcherAction
  {
    public RequestId RequestId;
    public T Data;
  }
  public static class DataUpdated
  {
    public static DataUpdated&lt;T&gt; For&lt;T&gt;(RequestId requestId, T data)
    {
      return new DataUpdated&lt;T&gt; { RequestId = requestId, Data = data };
    }
  }
}
</code></pre>
<p><em>(Note that <strong>SaveSucceeded</strong> is not a generic class because the only information that it contains is the <strong>RequestId</strong> that corresponds to the save operation that it indicates has completed).</em></p>
<p>The action type-matching that occurs in the <strong>MessageWriteStore</strong> now needs to be changed to:</p>
<pre><code>dispatcher.Receive(a =&gt; a
  .If&lt;StoreInitialised&gt;(
    condition: action =&gt; (action.Store == this),
    work: action =&gt; { }
  )
  .Else&lt;UserEditRequested&lt;MessageEditState&gt;&gt;(action =&gt;
  {
    Message = action.NewState;
    ValidateMessage(Message);
  })
  .Else&lt;SaveRequested&lt;MessageDetails&gt;&gt;(action =&gt;
  {
    _saveActionRequestId = messageApi.SaveMessage(action.Data);
    Message.IsSaveInProgress = true;
  })
  .Else&lt;SaveSucceeded&gt;(
    condition: action =&gt; (action.RequestId == _saveActionRequestId),
    work: action =&gt;
    {
      _saveActionRequestId = null;
      Message = GetInitialMessageEditState();
      _lastDataUpdatedRequestId = messageApi.GetMessages();
    }
  )
  .Else&lt;DataUpdated&lt;IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt;&gt;&gt;(
    condition: action =&gt;
      action.RequestId.IsEqualToOrComesAfter(_lastDataUpdatedRequestId),
    work: action =&gt;
    {
      _lastDataUpdatedRequestId = action.RequestId;
      MessageHistory = action.Data;
    }
  )
  .IfAnyMatched(OnChange)
);
</code></pre>
<p>The <strong>AppContainer</strong> now becomes:</p>
<pre><code>using System;
using System.Collections.Generic;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.ViewModels;
using BridgeReactTutorial.Stores;

namespace BridgeReactTutorial.Components
{
  public class AppContainer : Component&lt;AppContainer.Props, AppContainer.State&gt;
  {
    public AppContainer(AppContainer.Props props) : base(props) { }

    protected override void ComponentDidMount()
    {
      props.Store.Change += StoreChanged;
    }
    protected override void ComponentWillUnmount()
    {
      props.Store.Change -= StoreChanged;
    }
    private void StoreChanged()
    {
      SetState(new State
      {
        Message = props.Store.Message,
        MessageHistory = props.Store.MessageHistory
      });
    }

    public override ReactElement Render()
    {
      if (state == null)
        return null;

      return DOM.Div(null,
        new MessageEditor(new MessageEditor.Props
        {
          ClassName = &quot;message&quot;,
          Message = state.Message,
          OnChange = newState =&gt; props.Dispatcher.Dispatch(
            UserEditRequested.For(newState)
          ),
          OnSave = () =&gt; props.Dispatcher.Dispatch(
            SaveRequested.For(new MessageDetails
            {
              Title = state.Message.Title.Text,
              Content = state.Message.Content.Text
            })
          )
        }),
        new MessageHistory(new MessageHistory.Props
        {
          ClassName = &quot;history&quot;,
          Messages = state.MessageHistory
        })
      );
    }

    public class Props
    {
      public AppDispatcher Dispatcher;
      public MessageWriterStore Store;
    }

    public class State
    {
      public MessageEditState Message;
      public IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt; MessageHistory;
    }
  }
}
</code></pre>
<p>And the <strong>MessageApi</strong>:</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using Bridge;
using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.Actions;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.API
{
  public class MessageApi : IReadAndWriteMessages
  {
    private readonly AppDispatcher _dispatcher;
    private readonly List&lt;Tuple&lt;int, MessageDetails&gt;&gt; _messages;
    public MessageApi(AppDispatcher dispatcher)
    {
      if (dispatcher == null)
        throw new ArgumentException(&quot;dispatcher&quot;);

      _dispatcher = dispatcher;
      _messages = new List&lt;Tuple&lt;int, MessageDetails&gt;&gt;();

      // To further mimic a server-based API (where other people may be recording messages
      // of their own), after a 10s delay a periodic task will be executed to retrieve a
      // new message
      Window.SetTimeout(
        () =&gt; Window.SetInterval(GetChuckNorrisFact, 5000),
        10000
      );
    }

    public RequestId SaveMessage(MessageDetails message)
    {
      return SaveMessage(message, optionalSaveCompletedCallback: null);
    }

    private RequestId SaveMessage(MessageDetails message, Action optionalSaveCompletedCallback)
    {
      if (message == null)
        throw new ArgumentNullException(&quot;message&quot;);
      if (string.IsNullOrWhiteSpace(message.Title))
        throw new ArgumentException(&quot;A title value must be provided&quot;);
      if (string.IsNullOrWhiteSpace(message.Content))
        throw new ArgumentException(&quot;A content value must be provided&quot;);

      var requestId = new RequestId();
      Window.SetTimeout(
        () =&gt;
        {
          _messages.Add(Tuple.Create(_messages.Count, message));
          _dispatcher.Dispatch(new SaveSucceeded { RequestId = requestId });
          if (optionalSaveCompletedCallback != null)
            optionalSaveCompletedCallback();
        },
        1000 // Simulate a roundtrip to the server
      );
      return requestId;
    }

    public RequestId GetMessages()
    {
      // ToArray is used to return a clone of the message set - otherwise, the caller would
      // end up with a list that is updated when the internal reference within this class
      // is updated (which sounds convenient but it's not the behaviour that would be
      // exhibited if this was really persisting messages to a server somewhere).. and
      // then AsEnumerable() is required since the store checks for an action of type
      // DataUpdated&lt;IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt;&gt;&gt;
      var requestId = new RequestId();
      Window.SetTimeout(
        () =&gt; _dispatcher.Dispatch(DataUpdated.For(requestId, _messages.ToArray().AsEnumerable())),
        1000 // Simulate a roundtrip to the server
      );
      return requestId;
    }

    private void GetChuckNorrisFact()
    {
      var request = new XMLHttpRequest();
      request.ResponseType = XMLHttpRequestResponseType.Json;
      request.OnReadyStateChange = () =&gt;
      {
        if (request.ReadyState != AjaxReadyState.Done)
          return;

        if ((request.Status == 200) || (request.Status == 304))
        {
          try
          {
            var apiResponse = (ChuckNorrisFactApiResponse)request.Response;
            if ((apiResponse.Type == &quot;success&quot;)
            &amp;&amp; (apiResponse.Value != null)
            &amp;&amp; !string.IsNullOrWhiteSpace(apiResponse.Value.Joke))
            {
              // The Chuck Norris Facts API (http://www.icndb.com/api/) returns strings
              // html-encoded, so they need decoding before be wrapped up in a
              // MessageDetails instance
              // - Note: After the save has been processed, GetMessages is called so
              //   that a MessageHistoryUpdate action is dispatched
              SaveMessage(
                new MessageDetails
                {
                  Title = &quot;Fact&quot;,
                  Content = HtmlDecode(apiResponse.Value.Joke)
                },
                () =&gt; GetMessages()
              );
              return;
            }
          }
          catch
          {
            // Ignore any error and drop through to the fallback message-generator below
          }
        }
        SaveMessage(new MessageDetails
        {
          Title = &quot;Fact&quot;,
          Content = &quot;API call failed when polling for server content :(&quot;
        });
      };
      request.Open(&quot;GET&quot;, &quot;http://api.icndb.com/jokes/random&quot;);
      request.Send();
    }

    private string HtmlDecode(string value)
    {
      if (value == null)
        throw new ArgumentNullException(&quot;value&quot;);

      var wrapper = Document.CreateElement(&quot;div&quot;);
      wrapper.InnerHTML = value;
      return wrapper.TextContent;
    }

    [IgnoreCast]
    private class ChuckNorrisFactApiResponse
    {
      public extern string Type { [Template(&quot;type&quot;)] get; }
      public extern FactDetails Value { [Template(&quot;value&quot;)] get; }

      [IgnoreCast]
      public class FactDetails
      {
        public extern int Id { [Template(&quot;id&quot;)] get; }
        public extern string Joke { [Template(&quot;joke&quot;)]get; }
      }
    }
  }
}
</code></pre>
<p><em>(I contemplated leaving it as an exercise for the reader to change all of the action instantiation code to use the new generic classes, but with so much code in this post already I thought I might as well go whole-hog and include the final version of the everything!)</em></p>
<p>No type-safety has been lost in this refactor but, hopefully, it's clear how action classes can scale with an application's complexity. Needing a lot of new actions every time that a new section is added to an application would be no fun and would just add to the code churn required, so being able to reuse actions like this is a boon.</p>
<h3>The third and final part</h3>
<p>We've covered a lot of ground here, so I'm going to draw things to a close. Flux is a big deal and I've read plenty of articles that make it sound mind-bending and difficult to grasp. Hopefully this has explored <em>why</em> it makes sense as much as how to think in terms of it (and write code in the style of it!).</p>
<p>Next time, now that React and Flux are dealt with, I want to look at how we can go <em>further</em> in the quest to <em>make code easier to reason about and to test</em> - there is a lot more that we can do with the C# type system to really express intent, requirements and limitations and I strongly believe that doing so will lead to higher quality code. As a side benefit, I'll also be showing how to make a simple tweak to components that will offer potentially huge performance benefits to highly-complex / deeply-nested UIs. I really think that using C# and Bridge can be more than just a possibility for writing React applications, it can be one of the <em>best</em> ways to do so!</p>
<p class="PostTime">Posted at 22:50</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/writing-react-apps-using-bridgenet-the-dan-way-part-three">Writing React apps using Bridge.NET - The Dan Way (Part Three)</a></li><li><a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">Writing React apps using Bridge.NET - The Dan Way (from first principles)</a></li><li><a href="/easy-purecomponent-react-performance-boosts-for-bridgenet">Easy &quot;PureComponent&quot; React performance boosts for Bridge.Net</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/React" title="11 Posts">React</a></li></ul></div>
            <p class="Comments">
                <a href="/writing-react-apps-using-bridgenet-the-dan-way-part-two#disqus_thread" data-disqus-identifier="97">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">15 March 2016</p><h2><a id="writing-react-apps-using-bridgenet-the-dan-way-from-first-principles" href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles">Writing React apps using Bridge.NET - The Dan Way (from first principles)</a></h2>
<p><em>(This is part one of a three part series, each post is longer than the last so strap yourself in if you're thinking of playing along - hopefully you'll think that it was worth it by the end! :)</em></p>
<p>I've had a request from someone to write about how I think that someone from a .net background should write a web-based application. The short answer is that I strongly believe that using Bridge.NET with React, using a Flux-like architecture is the way forward. I think that React changed the game by trying to introduce a way to write applications that addressed the big challenges, rather than what many of the other frameworks did, which was to try to make some aspects of development easier but without tackling the underlying problems. We're going to be using these technologies to create some big applications where I work and some resources as to how best to do this will be valuable. I'm going to try to roll this all together into a short series of posts about creating Bridge / React / Flux apps, where I'll try to start from the simplest approach at each point and only introduce something new when I can explain why it's valuable. So, initially, Flux will be nowhere to be seen - but, hopefully, when it <em>is</em> introduced, it will be clear why.</p>
<p>(I'm not going to expel any effort on convincing you that writing C# in Visual Studio is incredibly powerful, and that it's fantastic to be able to do this while writing browser-based applications, nor am I going to try to sell you any more on React - if you're not on board with these ideas already then there's a <em>chance</em> that these posts will sell you on it, but that's not going to be my main focus).</p>
<h3>From the very start</h3>
<p>I'm going to begin from a completely fresh project, so if you've got any experience with Bridge then these steps will be familiar. But I'll go through them quickly and then start building the application itself. It's going to be extremely simple but will illustrate how to work with React and how to deal with user input and Virtual DOM re-rendering, how and where to implement validation and how to make <em>all the things</em> asynchronous so that async is not only used for scary edge cases and can be seen as a valuable tool to decouple code (and, in doing so, async will become a not-at-all-scary thing).</p>
<p>All that the application will do will be to allow the user to write a message, entering  Title and Content strings, and to save this message. There will be a &quot;Message API&quot;, which will emulate reading and writing to a remote endpoint, for data persistence, but the implementation will all be kept in-memory / in the browser, just to make things simple. It will look something like this:</p>
<img alt="The proposed example app" src="/Content/Images/Posts/ReactTutorial1.png" class="NoBorder AlwaysFullWidth" title="The proposed example app" />
<p>As more messages are written, more entries will appear in the &quot;Message History&quot;. Seems simple.</p>
<h3>React components</h3>
<p>Before getting into any React-with-Bridge specifics, I want to talk a little about React components; how to arrange them into a hierarchy and how they should and shouldn't talk to each other.</p>
<p>Almost all of the time, components that you use will be &quot;<a href="https://facebook.github.io/react/docs/forms.html#controlled-components">controlled components</a>&quot; -</p>
<blockquote>
<p>A Controlled component does not maintain its own internal state; the component renders purely based on props.</p>
</blockquote>
<p>This means that when you render a text input, you give it a &quot;value&quot; property and an &quot;onChange&quot; property - when the user tries to change what's in the text box (whether by pressing a number or letter, or by pressing backspace or by pasting something in) then the &quot;onChange&quot; callback is executed. The text box is <em>not</em> updated automatically, all that happens is that a callback is made that indicates that the user has done something that means that the text input probably <em>should</em> be updated.</p>
<p>This seems odd at the very start since you may be used to events being driven by html elements and the updates being broadcast elsewhere; with React, events arise from components that describe the desire for a change to be made, but the change does not happen automatically. This is what is meant in the quote above when it says that a controlled component &quot;does not maintain its own internal state&quot;.</p>
<p>This hints at one of the key aims of React - to make code explicit and easy to reason about. If a component <em>only</em> varies based upon its props, then it's very easy to reason about; given this props data, draw in this manner. (If user-entered changes to a text input were automatically reflected in the text box then the component would <em>not</em> solely vary by its props, it would vary according to its props and whatever else the user has done to it).</p>
<p>The only way for a component to update / re-render itself (and any child components that it may have) is for it to changes its &quot;state&quot;. This is a special concept in React - if &quot;SetState&quot; is called then the component will re-render, but now it may have to consider both its props <em>and</em> its new state. If we really wanted to have a text input that would automatically update its own value as well as raise a change event, we could write a component to do so -</p>
<p><em>(Note: if you're coming into this fresh, don't worry about how to compile this C# code into a React application, I'll be getting to that after I've finished giving my view on React components).</em></p>
<pre><code>public class TextInput : Component&lt;TextInput.Props, TextInput.State&gt;
{
  public TextInput(Props props) : base(props) { }

  public override ReactElement Render()
  {
    return DOM.Input(new InputAttributes
    {
      Type = InputType.Text,
      Value = (state == null) ? props.InitialValue : state.Value,
      OnChange = ev =&gt;
      {
        var newValue = ev.CurrentTarget.Value;
        SetState(new State { Value = newValue });
        props.OnChange(newValue);
      }
    });
  }

  public class Props
  {
    public string InitialValue;
    public Action&lt;string&gt; OnChange;
  }

  public class State
  {
    public string Value;
  }
}
</code></pre>
<p>The problem here is that now the component depends upon two things whenever it has to render - its props <em>and</em> its state. It can change its own state but it can't change its props (React demands that a components props be considered to be immutable).</p>
<p><em>This</em> means that the component becomes more difficult to reason about, it was much easier when it didn't have to worry about state. (Granted, there may have been some question as to who would receive that OnChange callback to get the component to re-render, but we're going to get to that shortly).</p>
<p>Partly for this reason, it's strongly recommended that the vast majority of components be stateless - meaning that they render according to their props and nothing else.</p>
<p>Another reason that it is strongly recommended that components not update themselves (meaning that they are stateless, since the only way for a component to update itself is to change its state) is that it makes the handling of events much clearer. In the example application that I'm going to refer to in this series, the &quot;Title&quot; value that is entered by the user is reflected in the fieldset legend -</p>
<img alt="Fieldset legend mirros the Title input value" src="/Content/Images/Posts/ReactTutorial2.png" class="NoBorder AlwaysFullWidth" title="Fieldset legend mirros the Title input value" />
<p>If the &quot;Title&quot; input box was to maintain its own state and update itself when its contents change, there still needs to be something listening for changes in order to update the fieldset legend text. If it was common for components to maintain their own state then things would quickly get out of hand as more and more components have to listen for (and react to) changes in other components. Just in the example here, there is a validation message that needs to be hidden if the &quot;Title&quot; input has a non-blank value, so that component would need to listen for the change event on the input. (Alternatively, the <strong>TextInput</strong> component could be provided with validation logic and <em>it</em> would be responsible for showing or hiding the validation message - which would complicate the <strong>TextInput</strong> class). On top of this, there is the &quot;Save&quot; button which should be disabled if either of the &quot;Title&quot; or &quot;Content&quot; input boxes have no value - so the Save button component would need to listen to change events from both text inputs and decide whether or not it should be enabled based upon their states. Maybe the input form itself wants to add an &quot;invalid&quot; class to itself for styling purposes if either of the inputs are invalid - now the form component has to listen to changes to the text inputs and add or remove this class. This way lies madness.</p>
<p>In summary, most components should <em>not</em> try to update themselves and so do not need state. The React bindings make it easy to write components that don't use state (again, I'll talk about using these bindings more shortly, I just wanted to point out now that the distinction between stateful and stateless components is an important one and that the bindings reflect this) -</p>
<pre><code>public class TextInput : StatelessComponent&lt;TextInput.Props&gt;
{
  public TextInput(Props props) : base(props) { }

  public override ReactElement Render()
  {
    return DOM.Input(new InputAttributes
    {
      Type = InputType.Text,
      Value = props.Value,
      OnChange = ev =&gt; props.OnChange(ev.CurrentTarget.Value)
    });
  }

  public class Props
  {
    public string Value;
    public Action&lt;string&gt; OnChange;
  }
}
</code></pre>
<p>The component code is much more succinct this way, as well as helping us avoid the nightmare scenario described above.</p>
<p>It does leave one big question, though.. if these components don't update themselves, <em>then what does?</em></p>
<p>Answer: There should be a top-level &quot;Container Component&quot; that maintains state for the application. This should be the only stateful component, all components further down the hierarchy should be stateless.</p>
<p>In the sample application here -</p>
<img alt="The proposed example app" src="/Content/Images/Posts/ReactTutorial1.png" class="NoBorder AlwaysFullWidth" title="The proposed example app" />
<p>The component hierarchy will look something like this:</p>
<pre><code>AppContainer
  MessageEditor
    Span (&quot;Title&quot;)
    ValidatedTextInput
      Input
    Span (&quot;Content&quot;)
    ValidatedTextInput
      Input
    Button
  MessageHistory
    Div
      Span (Message Title)
      Span (Message Content)
    Div
      Span (Message Title)
      Span (Message Content)
</code></pre>
<p>The <strong>MessageHistory</strong> will be a read-only component tree (it just shows saved messages) and so is very simple (there are no callbacks to handle). The <strong>MessageEditor</strong> will render Span labels (&quot;Title&quot; and &quot;Content&quot;), two <strong>ValidatedTextInput</strong> components and a &quot;Save&quot; button. The <strong>ValidatedTextInput</strong> has props for a current text input value, an on-change callback and an optional validation message.</p>
<p>When an input component's on-change callback is executed, it is an action with a single argument; the html element. In the <strong>TextInput</strong> example class above, the new value is extracted from that element (&quot;ev.CurrentTarget.Value&quot;) and then passed into the on-change callback of the <strong>TextInput</strong>, which is an action with a simple string argument. <strong>ValidatedTextInput</strong> will be very similar (it will wrap the <strong>Action&lt;InputElement&gt;</strong> callback that the input raises in a simpler <strong>Action&lt;string&gt;</strong>). The only difference between it and the <strong>TextInput</strong> example class earlier is that it  will also be responsible for rendering a validation message element if its props value has a non-blank validation message to show (and it may apply an &quot;invalid&quot; class name to its wrapper if there is a validation message to show).</p>
<p>When the Title or Content <strong>ValidatedTextInput</strong> raise an on-change event, the <strong>MessageEditor</strong> will execute some code that translates this callback further. The <strong>MessageEditor</strong> will have an on-change props value whose single argument is a <strong>MessageDetails</strong> - this will have have values for the current &quot;Title&quot; and &quot;Content&quot;. Just as an on-change from an input element resulted in an on-change being raised by a <strong>ValidatedTextInput</strong>, an on-change by a <strong>ValidatedTextInput</strong> will result in an on-change from the <strong>MessageEditor</strong>. Each on-change event changes the type of value that the on-change describes (from an input element to a string to a <strong>MessageDetails</strong>). The <strong>MessageEditor</strong>'s on-change will be received by the <strong>AppContainer</strong> Component, which is where the change will result in the component tree being re-rendered.</p>
<p>The <strong>AppContainer</strong> component will re-render by calling &quot;SetState&quot; and creating a new state reference for itself that include the new <strong>MessageDetails</strong> reference (that was passed up in the on-change callback from the <strong>MessageEditor</strong>). The call to &quot;SetState&quot; will result in the component being re-rendered, which will result in it rendering a new version of the <strong>MessageEditor</strong>. When the <strong>MessageEditor</strong> is rendered, the current &quot;Title&quot; value will be used to populate the text input <em>and</em> to set the text in the legend of the fieldset that wraps the editor's input boxes. This is how the &quot;nightmare scenario&quot; described earlier is avoided - instead of having lots of components listen out to events from lots of <em>other</em> components, all components just pass their events up to the top and then the entire UI is re-rendered in React's Virtual DOM.</p>
<p>I'm going to repeat that part about event-handling because it's important; events are passed <em>up</em> from where they occur, up to the top-level component. This will trigger a re-render, which works all the way <em>down</em> through the component tree, so that the requested change is then reflected in the UI.</p>
<p>The Virtual DOM determines what (if anything) needs to change in the browser's DOM and applies those changes - this works well because the Virtual DOM is very fast (and so we can do these &quot;full Virtual DOM re-renders&quot; frequently) and it minimises changes to the browser DOM (which is much slower).</p>
<p><em>(The Facebook tutorial <a href="https://facebook.github.io/react/docs/thinking-in-react.html">Thinking in React</a> talks about how to mentally break down a UI into components and talks about passing state up the tree, but I wanted to try to really drive home how components should be put together and how they should communicate before fobbing you off with a Facebook link)</em>.</p>
<p>I have some more recommendations on how to decide what to put into props and what into state when creating stateful container components, but I'll cover that ground after some more practical work.</p>
<h3>Let's start coding then!</h3>
<p>Open up Visual Studio (the version isn't too important, but if you're using 2015 then bear in mind that Bridge.NET doesn't yet support C# 6 syntax). Create a new &quot;Class Library&quot; project. Using NuGet, add the &quot;Bridge&quot; and the &quot;Bridge.React&quot; packages. This will bring in bindings for React as well as pulling in Bridge itself - the Bridge package removes the usual System, System.Collections, etc.. references and replaces them with a single &quot;Bridge&quot; reference, which re-implements those framework methods in code that has JavaScript translations.</p>
<p>The Bridge package also adds some README files and a bridge.json file (under the Bridge folder in the project), which instructs Bridge how to compile your C# code into JavaScript. Change bridge.json's content to:</p>
<pre><code>{
  &quot;output&quot;: &quot;Bridge/output&quot;,
  &quot;combineScripts&quot;:  true
}
</code></pre>
<p>This will tell it create a single JavaScript file when translating, including the Bridge library content and the React bindings and JavaScript generated from code that you write. The name of the file that it generates is based upon the name of your project. I named mine &quot;BridgeReactTutorial&quot; and so the Bridge compiler will generate &quot;BridgeReactTutorial.js&quot; and &quot;BridgeReactTutorial.min.js&quot; files in the &quot;Bridge/output&quot; folder on each build of the project.</p>
<p>Now create an empty html file in the project root called &quot;demo.html&quot; and paste in the following:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;title&gt;Bridge.React Tutorial&lt;/title&gt;
  &lt;link rel=&quot;Stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot; media=&quot;screen&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;noscript&gt;JavaScript is required&lt;/noscript&gt;
  &lt;div id=&quot;main&quot; class=&quot;loading&quot;&gt;Loading..&lt;/div&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-dom.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;Bridge/output/BridgeReactTutorial.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><em>(If you called your project something other than &quot;BridgeReactTutorial&quot; then you might have to change the filename in that last script tag).</em></p>
<p>This file will load in the latest (0.14.7, as of March 2016) version of the React library along with the Bridge / React-bindings / your-code bundle. All we need to do now is write some &quot;your-code&quot; content.</p>
<p>When you created the class library project, a Class1.cs file will have been added to the project. Change its contents -</p>
<pre><code>using System.Linq;
using Bridge.Html5;
using Bridge.React;

namespace BridgeReactTutorial
{
  public class Class1
  {
    [Ready]
    public static void Main()
    {
      var container = Document.GetElementById(&quot;main&quot;);
      container.ClassName = string.Join(
        &quot; &quot;,
        container.ClassName.Split().Where(c =&gt; c != &quot;loading&quot;)
      );
      React.Render(
        DOM.Div(new Attributes { ClassName = &quot;welcome&quot; }, &quot;Hi!&quot;),
        container
      );
    }
  }
}
</code></pre>
<p>Build the solution and then right-click on the &quot;demo.html&quot; file in the project and click on &quot;View in Browser&quot;. You should see a happy little &quot;Hi!&quot; welcome message, rendered using React by JavaScript that was translated from C# - an excellent start!</p>
<p>There are some subtle touches here, such as the &quot;JavaScript is required&quot; message that is displayed if the browser has JavaScript disabled (just in case you ever turn it off and forget!) and a &quot;loading&quot; message that is displayed while the JavaScript sorts itself out (usually this will be a barely-perceptibe amount of time but if the CDN host that the React library is coming from is being slow then it may not be instantaneous). The &quot;main&quot; div initially has a &quot;loading&quot; class on it, which is removed when the code above executes. Note that the [Ready] attribute on the &quot;Main&quot; function is a Bridge attribute, indicating code that should be called when the page has loaded (similar in principle to on-DOM-ready, frequently used by jQuery code).</p>
<p>To take advantage of the &quot;loading&quot; class' presence / absence, it would be a nice touch to have the &quot;loading&quot; text quite pale initially (it's reassuring to know that the app is, in fact, loading, but it doesn't need to be right in your face). To do so, add a file &quot;styles.css&quot; alongside the &quot;demo.html&quot; file. It's already referenced by the markup we've pasted into &quot;demo.html&quot;, so it will be picked up when you refresh the page. Since we're creating a stylesheet, it makes sense to include some style resets (my go-to for this is by Eric Meyer) -</p>
<pre><code>/* http://meyerweb.com/eric/tools/css/reset/ v2.0b1 | 201101 NOTE: WORK IN PROGRESS
 USE WITH CAUTION AND TEST WITH ABANDON */
html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote,
pre,a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s,
samp, small, strike, strong, sub, sup, tt, var,b, u, i, center, dl, dt, dd, ol, ul,
li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, figcaption, figure, footer, header, hgroup, menu,
nav, section, summary, time, mark, audio, video
{
  margin: 0;
  padding: 0;
  border: 0;
  outline: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav,
section { display: block; }
body { line-height: 1; }
ol, ul { list-style: none; }
blockquote, q { quotes: none; }
blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; }
/* remember to highlight inserts somehow! */ ins { text-decoration: none; }
del { text-decoration: line-through; }
table { border-collapse: collapse; border-spacing: 0; }

div#main.loading { color: #f1f1f1; }
</code></pre>
<p>At this point, I also tend to remove the &quot;App_Readme&quot; folder that the Bridge package adds to my project - if I'm going to write some code and check it into source control somewhere then I don't think there's a lot of point in storing a copy of the Bridge README and LICENSE each time.</p>
<h3>Creating the Message Editor</h3>
<p>That's the theory and the project scaffolding out of the way. Now to create a form that actually does something.</p>
<p>We've already seen how a <strong>TextInput</strong> component is helpful for wrapping a text input and simplifying the &quot;OnChange&quot; callback. So create a &quot;Components&quot; folder with a &quot;TextInput.cs&quot; file and paste in the following content -</p>
<pre><code>using System;
using Bridge.Html5;
using Bridge.React;

namespace BridgeReactTutorial.Components
{
  public class TextInput : StatelessComponent&lt;TextInput.Props&gt;
  {
    public TextInput(Props props) : base(props) { }

    public override ReactElement Render()
    {
      return DOM.Input(new InputAttributes
      {
        Type = InputType.Text,
        ClassName = props.ClassName,
        Value = props.Content,
        OnChange = e =&gt; props.OnChange(e.CurrentTarget.Value)
      });
    }

    public class Props
    {
      public string ClassName;
      public string Content;
      public Action&lt;string&gt; OnChange;
    }
  }
}
</code></pre>
<p><em>(Note: When adding a new &quot;.cs&quot; file to a project, sometimes &quot;System&quot; will sneak back into the list of references in the project - this can confuse Bridge, so ensure that you remove the reference again if it gets added).</em></p>
<p>Now create another folder in the root of the project called &quot;ViewModels&quot;. Add a new file to it; &quot;MessageDetails.cs&quot; and paste in the following content -</p>
<pre><code>namespace BridgeReactTutorial.ViewModels
{
  public class MessageDetails
  {
    public string Title;
    public string Content;
  }
}
</code></pre>
<p>Now add another file to the &quot;Components&quot; folder; &quot;MessageEditor.cs&quot; and paste in this:</p>
<pre><code>using System;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class MessageEditor : StatelessComponent&lt;MessageEditor.Props&gt;
  {
    public MessageEditor(Props props) : base(props) { }

    public override ReactElement Render()
    {
      return DOM.FieldSet(new FieldSetAttributes { ClassName = props.ClassName },
        DOM.Legend(null, string.IsNullOrWhiteSpace(props.Title) ? &quot;Untitled&quot; : props.Title),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Title&quot;),
        new TextInput(new TextInput.Props
        {
          ClassName = &quot;title&quot;,
          Content = props.Title,
          OnChange = newTitle =&gt; props.OnChange(new MessageDetails
          {
            Title = newTitle,
            Content = props.Content
          })
        }),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Content&quot;),
        new TextInput(new TextInput.Props
        {
          ClassName = &quot;content&quot;,
          Content = props.Content,
          OnChange = newContent =&gt; props.OnChange(new MessageDetails
          {
            Title = props.Title,
            Content = newContent
          })
        })
      );
    }

    public class Props
    {
      public string ClassName;
      public string Title;
      public string Content;
      public Action&lt;MessageDetails&gt; OnChange;
    }
  }
}
</code></pre>
<p>Now things are getting interesting!</p>
<p>This is still a stateless component and so what is rendered depends solely and reliably upon its props data. When it renders, the &quot;Title&quot; value from its props is used to populate both the legend of the fieldset that it renders (unless &quot;Title&quot; is null, blank or white-space-only, in which case the legend text will be &quot;Untitled) and it's used to populate the &quot;Title&quot; <strong>TextInput</strong>. When either of its <strong>TextInput</strong>s raises an on-change event, the <strong>MessageEditor</strong> raises its on-change events with a new <strong>MessageDetails</strong> instance.</p>
<p>Note that there's no validation yet. We'll get this rough version working first and then add that later.</p>
<p>There are still a few more steps until we have an application, though. We need a container component to render the form in the first place and to deal with on-change events that bubble up. Create another class file within the &quot;Components&quot; folder named &quot;AppContainer.cs&quot; -</p>
<pre><code>using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class AppContainer : Component&lt;object, AppContainer.State&gt;
  {
    public AppContainer() : base(null) { }

    protected override State GetInitialState()
    {
      return new State
      {
        Message = new MessageDetails { Title = &quot;&quot;, Content = &quot;&quot; }
      };
    }

    public override ReactElement Render()
    {
      return new MessageEditor(new MessageEditor.Props
      {
        ClassName = &quot;message&quot;,
        Title = state.Message.Title,
        Content = state.Message.Content,
        OnChange = newMessage =&gt; SetState(new State { Message = newMessage })
      });
    }

    public class State
    {
      public MessageDetails Message;
    }
  }
}
</code></pre>
<p>This is the <em>stateful</em> component that will trigger re-renders when required. It doesn't actually require any props data at this time, so the &quot;TProps&quot; type parameter specified on the <strong>Component&lt;TProps, TState&gt;</strong> base class is just &quot;object&quot;.</p>
<p>When the <strong>MessageEditor</strong> raises an on-change event, the <strong>AppContainer</strong> will call SetState to replace its current <strong>MessageDetails</strong> instance with the new one. This will trigger a re-render of the <strong>MessageEditor</strong>, which will be given the new <strong>MessageDetails</strong> instance as part of a new props value. It might seem a bit silly to have the <strong>MessageEditor</strong> pass up a new <strong>MessageDetails</strong> instance and then to just pass this back down into another <strong>MessageEditor</strong>, but the idea is to consider the first <strong>MessageEditor</strong> to be dead now and for the new <strong>MessageEditor</strong> (with the new <strong>MessageDetails</strong>) to exist in its place. And each time a stateless component is rendered, it renders simply from its props - there is no data shared between the new instance and the instance it replaces. This, again, makes the components very easy to reason about. And code that is easy to reason about is easy to write and easy to maintain.</p>
<p><em>Note: If you're au fait with React then you might know that components written as ES6 classes - which seems to be the way that is encouraged at the moment - don't support &quot;GetInitialState&quot; and, instead, specify initial state in the constructor. In the Bridge React bindings, &quot;GetInitialState&quot; should be used and the constructor should NOT be used - the way that the components are initialised by React means that constructors on component classes are not actually executed, so it is important that the constructor ONLY be used to pass the props and/or state to the base class.</em></p>
<p>The penultimate step is to change &quot;Class1.cs&quot; to render the <strong>AppContainer</strong> instead of just rendering a &quot;Hi!&quot; div. While we're editing it, let's give it a more official-sounding name. I like the starting point of my application to be called &quot;App&quot; -</p>
<pre><code>using System.Linq;
using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.Components;

namespace BridgeReactTutorial
{
  public class App
  {
    [Ready]
    public static void Go()
    {
      var container = Document.GetElementById(&quot;main&quot;);
      container.ClassName = string.Join(
        &quot; &quot;,
        container.ClassName.Split().Where(c =&gt; c != &quot;loading&quot;)
      );
      React.Render(new AppContainer(), container);
    }
  }
}
</code></pre>
<p>All that's required now is to make it look a little nicer when you view &quot;demo.html&quot;, so add the following to &quot;styles.css&quot; -</p>
<pre><code>body
{
  font-family: 'Segoe UI';
  padding: 8px;
}

fieldset
{
  padding: 8px;
  border: 1px solid #f1f1f1;
  border-radius: 4px;
}
fieldset legend
{
  color: blue;
  padding: 0 8px;
}
fieldset.message span.label { padding: 0 8px; }
</code></pre>
<p>That's the first major milestone reached! A very basic framework for constructing component hierarchies has been demonstrated, along with a way to handle events and re-render as required. There's nothing very radical, it's just what was described earlier; but it's good to see the theory executed in practice.</p>
<p>I'm far from finished for today, though - I want to add a way to persist messages, a message history component and some validation. Best get cracking!</p>
<h3>Message persistence</h3>
<p>While I want to simulate a server-based API, where read / write requests aren't instantaneous and we need to think about how to deal with async calls, I don't want the overhead of needing an endpoint to be configured somewhere. So we'll go with a simple interface that will be implemented in an entirely client-side class, that introduces artifical delays to mimic server-calling time.</p>
<p>Create a new folder in the project root called &quot;API&quot; and add a new .cs file &quot;IReadAndWriteMessages.cs&quot;, the contents of which should be:</p>
<pre><code>using System.Threading.Tasks;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.API
{
  public interface IReadAndWriteMessages
  {
    Task SaveMessage(MessageDetails message);
  }
}
</code></pre>
<p>We'll be using dependency injection to provide the <strong>AppContainer</strong> with an API implementation. In order to enable unit testing (which will come later) we need to be able to work against an interface. For now, the interface only has a &quot;SaveMessage&quot; method, we'll work on reading message history data later.</p>
<p>Add another file into the &quot;API&quot; folder, &quot;MessageApi.cs&quot; -</p>
<pre><code>using System;
using System.Threading.Tasks;
using Bridge.Html5;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.API
{
  public class MessageApi : IReadAndWriteMessages
  {
    public Task SaveMessage(MessageDetails message)
    {
      if (message == null)
        throw new ArgumentNullException(&quot;message&quot;);
      if (string.IsNullOrWhiteSpace(message.Title))
        throw new ArgumentException(&quot;A title value must be provided&quot;);
      if (string.IsNullOrWhiteSpace(message.Content))
        throw new ArgumentException(&quot;A content value must be provided&quot;);

      var task = new Task&lt;object&gt;(null);
      Window.SetTimeout(
        () =&gt; task.Complete(),
        1000 // Simulate a roundtrip to the server
      );
      return task;
    }
  }
}
</code></pre>
<p>Bridge supports the C# &quot;async&quot; keyword and provides its own implementation of Tasks, which are used above to pretend that this class is communicating with a server when a save is requested.</p>
<p>In order to enable saving, the <strong>MessageEditor</strong> needs a &quot;Save&quot; button and it needs an &quot;on-save&quot; callback to be specified on its props. While saving, the form should be disabled, so the <strong>MessageEditor</strong> props need a &quot;Disabled&quot; flag as well.</p>
<p><em>When designing an SPA like this, you need to think about whether you will support &quot;optimistic updates&quot;, where clicking Save clears the form and acts as if the save action was instanteously accepted - but brings it to the user's attention somehow if the save failed or was rejected. I'm going to go for a simpler &quot;pessimistic update&quot; flow, where the form is disabled until the save is acknowledged, at which point the form will be cleared and re-enabled so that a further entry may be written and then saved.</em></p>
<p>The <strong>MessageEditor</strong> should now looks like this:</p>
<pre><code>using System;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class MessageEditor : StatelessComponent&lt;MessageEditor.Props&gt;
  {
    public MessageEditor(Props props) : base(props) { }

    public override ReactElement Render()
    {
      return DOM.FieldSet(new FieldSetAttributes { ClassName = props.ClassName },
        DOM.Legend(null, string.IsNullOrWhiteSpace(props.Title) ? &quot;Untitled&quot; : props.Title),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Title&quot;),
        new TextInput(new TextInput.Props
        {
          ClassName = &quot;title&quot;,
          Disabled = props.Disabled,
          Content = props.Title,
          OnChange = newTitle =&gt; props.OnChange(new MessageDetails
          {
            Title = newTitle,
            Content = props.Content
          })
        }),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Content&quot;),
        new TextInput(new TextInput.Props
        {
          ClassName = &quot;content&quot;,
          Disabled = props.Disabled,
          Content = props.Content,
          OnChange = newContent =&gt; props.OnChange(new MessageDetails
          {
            Title = props.Title,
            Content = newContent
          })
        }),
        DOM.Button(
          new ButtonAttributes { Disabled = props.Disabled, OnClick = e =&gt; props.OnSave() },
          &quot;Save&quot;
        )
      );
    }

    public class Props
    {
      public string ClassName;
      public string Title;
      public string Content;
      public Action&lt;MessageDetails&gt; OnChange;
      public Action OnSave;
      public bool Disabled;
    }
  }
}
</code></pre>
<p>The &quot;Disabled&quot; flag needs to be able to be applied to the <strong>TextInput</strong> components, so <strong>TextInput</strong> needs to look like this:</p>
<pre><code>using System;
using Bridge.Html5;
using Bridge.React;

namespace BridgeReactTutorial.Components
{
  public class TextInput : StatelessComponent&lt;TextInput.Props&gt;
  {
    public TextInput(Props props) : base(props) { }

    public override ReactElement Render()
    {
      return DOM.Input(new InputAttributes
      {
        Type = InputType.Text,
        ClassName = props.ClassName,
        Disabled = props.Disabled,
        Value = props.Content,
        OnChange = e =&gt; props.OnChange(e.CurrentTarget.Value)
      });
    }

    public class Props
    {
      public string ClassName;
      public bool Disabled;
      public string Content;
      public Action&lt;string&gt; OnChange;
    }
  }
}
</code></pre>
<p>This enables the <strong>MessageEditor</strong> to initiate a save request and for a &quot;Message API&quot; to process the request. Now the <strong>AppContainer</strong> needs to tie these two aspects together.</p>
<p><em>Note that the OnSave action on the <strong>MessageEditor</strong> doesn't provide a new <strong>MessageDetails</strong> instance - that is because the Title and Content value that are rendered in the <strong>MessageEditor</strong> could not have been changed since the component was rendered, otherwise an OnChange callback would have been made before OnSave.</em></p>
<p>Now, the <strong>AppContainer</strong> gets a bit more interesting because it requires props <em>and</em> state. Its props will be external dependencies that it requires access to, while its state will be a copy of all data that is required to render the form. This is a good time to introduce my React (stateful) component guidelines -</p>
<ol>
<li>A stateful component's &quot;props&quot; data should <em>only</em> consist of references to external dependencies</li>
<li>A stateful component's &quot;state&quot; data should include <em>everything</em> required to render the component tree, though the props may be required to deal with child components' events</li>
</ol>
<p>At this point, these rules are going to seem very straight-forward. Later, however, things will get a little more nuanced and I'll re-visit them at that point.</p>
<p>The <strong>AppContainer</strong> will now become the following -</p>
<pre><code>using Bridge.React;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class AppContainer : Component&lt;AppContainer.Props, AppContainer.State&gt;
  {
    public AppContainer(AppContainer.Props props) : base(props) { }

    protected override State GetInitialState()
    {
      return new State
      {
        Message = new MessageDetails { Title = &quot;&quot;, Content = &quot;&quot; },
        IsSaveInProgress = false
      };
    }

    public override ReactElement Render()
    {
      return new MessageEditor(new MessageEditor.Props
      {
        ClassName = &quot;message&quot;,
        Title = state.Message.Title,
        Content = state.Message.Content,
        OnChange = newMessage =&gt; SetState(new State
        {
          Message = newMessage,
          IsSaveInProgress = state.IsSaveInProgress
        }),
        OnSave = async () =&gt;
        {
          SetState(new State { Message = state.Message, IsSaveInProgress = true });
          await props.MessageApi.SaveMessage(state.Message);
          SetState(new State
          {
            Message = new MessageDetails { Title = &quot;&quot;, Content = &quot;&quot; },
            IsSaveInProgress = false
          });
        },
        Disabled = state.IsSaveInProgress
      });
    }

    public class Props
    {
      public IReadAndWriteMessages MessageApi;
    }

    public class State
    {
      public MessageDetails Message;
      public bool IsSaveInProgress;
    }
  }
}
</code></pre>
<p>You will need to update App.cs to pass a props reference with a <strong>MessageApi</strong> instance to the <strong>AppContainer</strong> constructor -</p>
<pre><code>using System.Linq;
using Bridge.Html5;
using Bridge.React;
using BridgeReactTutorial.API;
using BridgeReactTutorial.Components;

namespace BridgeReactTutorial
{
  public class App
  {
    [Ready]
    public static void Go()
    {
      var container = Document.GetElementById(&quot;main&quot;);
      container.ClassName = string.Join(
        &quot; &quot;,
        container.ClassName.Split().Where(c =&gt; c != &quot;loading&quot;)
      );
      React.Render(
        new AppContainer(new AppContainer.Props { MessageApi = new MessageApi() }),
        container
      );
    }
  }
}
</code></pre>
<p>With this final piece, we have the outline of a fully functioning application! Granted, its functionality is not particular magnificent, but it <em>has</em> illustrated some important principles. We've seen how a component hierarchy should have a top-level <em>stateful</em> component, with a component tree beneath it of state<em>less</em> components (note that there are no guidelines required regarding what to put into props and what to put into state when writing a stateless component because props is your only option - another reason why stateless components are so much simpler!). We've also seen how we can deal with dependency injection for these top level components, which are the only point at which more complicated logic appears such as &quot;a save request involves disabling the form, calling a method on the API, waiting for the result and then re-enabling the form&quot;. It's worth noting that in the next post, this logic will be moved out of the top-level component in a quest to make components as dumb as possible - but that's jumping ahead, and I want the format of these posts to be that we start simple and then get more complicated only as the benefits of doing so can be made clear.</p>
<p>At this point, however, we have something of a problem. If the &quot;Title&quot; and &quot;Content&quot; text inputs do not both have values, then an exception will be raised by the <strong>MessageApi</strong> when a save is attempted. To avoid this, we need some..</p>
<h3>Validation</h3>
<p>I mentioned in the &quot;React components&quot; section that there would be a <strong>ValidatedTextInput</strong>, but no code had been presented yet. So here we go, nothing in it should be particularly surprising -</p>
<pre><code>using System;
using Bridge.React;

namespace BridgeReactTutorial.Components
{
  public class ValidatedTextInput : StatelessComponent&lt;ValidatedTextInput.Props&gt;
  {
    public ValidatedTextInput(Props props) : base(props) { }

    public override ReactElement Render()
    {
      var className = props.ClassName;
      if (!string.IsNullOrWhiteSpace(props.ValidationMessage))
        className = (className + &quot; invalid&quot;).Trim();

      return DOM.Span(new Attributes { ClassName = className },
        new TextInput(new TextInput.Props
        {
          ClassName = props.ClassName,
          Disabled = props.Disabled,
          Content = props.Content,
          OnChange = props.OnChange
        }),
        string.IsNullOrWhiteSpace(props.ValidationMessage)
          ? null
          : DOM.Span(
            new Attributes { ClassName = &quot;validation-message&quot; },
            props.ValidationMessage
          )
      );
    }

    public class Props
    {
      public string ClassName;
      public bool Disabled;
      public string Content;
      public Action&lt;string&gt; OnChange;
      public string ValidationMessage;
    }
  }
}
</code></pre>
<p>This allows the <strong>MessageEditor</strong> to be changed to use these <strong>ValidatedTextInput</strong>s instead of regular <strong>TextInput</strong>s, setting the &quot;ValidationMessage&quot; values according to whether the &quot;Content&quot; string has a value -</p>
<pre><code>using System;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class MessageEditor : StatelessComponent&lt;MessageEditor.Props&gt;
  {
    public MessageEditor(Props props) : base(props) { }

    public override ReactElement Render()
    {
      var formIsInvalid =
        string.IsNullOrWhiteSpace(props.Title) ||
        string.IsNullOrWhiteSpace(props.Content);

      return DOM.FieldSet(new FieldSetAttributes { ClassName = props.ClassName },
        DOM.Legend(null, string.IsNullOrWhiteSpace(props.Title) ? &quot;Untitled&quot; : props.Title),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Title&quot;),
        new ValidatedTextInput(new ValidatedTextInput.Props
        {
          ClassName = &quot;title&quot;,
          Disabled = props.Disabled,
          Content = props.Title,
          OnChange = newTitle =&gt; props.OnChange(new MessageDetails
          {
            Title = newTitle,
            Content = props.Content
          }),
          ValidationMessage = string.IsNullOrWhiteSpace(props.Title)
            ? &quot;Must enter a title&quot;
            : null
        }),
        DOM.Span(new Attributes { ClassName = &quot;label&quot; }, &quot;Content&quot;),
        new ValidatedTextInput(new ValidatedTextInput.Props
        {
          ClassName = &quot;content&quot;,
          Disabled = props.Disabled,
          Content = props.Content,
          OnChange = newContent =&gt; props.OnChange(new MessageDetails
          {
            Title = props.Title,
            Content = newContent
          }),
          ValidationMessage = string.IsNullOrWhiteSpace(props.Content)
            ? &quot;Must enter message content&quot;
            : null
        }),
        DOM.Button(
          new ButtonAttributes
          {
            Disabled = props.Disabled || formIsInvalid,
            OnClick = e =&gt; props.OnSave()
          },
          &quot;Save&quot;
        )
      );
    }

    public class Props
    {
      public string ClassName;
      public string Title;
      public string Content;
      public Action&lt;MessageDetails&gt; OnChange;
      public Action OnSave;
      public bool Disabled;
    }
  }
}
</code></pre>
<p>Now, the &quot;Save&quot; button is disabled if the <strong>MessageEditor</strong> is disabled (according to its props flag) <em>or</em> if the form entry is invalid. Now, it's not possible for the user to attempt a save that we will know will fail!</p>
<p><em>(Moving validation logic out of the components is another thing that will come in the move towards dumb-as-possible components, but that's for part two).</em></p>
<p>To keep things looking pretty, adding the following to &quot;styles.css&quot; -</p>
<pre><code>fieldset.message span.title, fieldset.message span.content { position: relative; }
fieldset.message span.validation-message
{
  position: absolute;
  top: -6px;
  right: 2px;
  padding: 2px 4px;
  font-size: 70%;
  background: #FFF9D8;
  border: 1px solid #EFE9CB;
  border-radius: 2px;
  color: #A8A390;
}
fieldset.message button { margin-left: 8px; }
</code></pre>
<h3>Message History</h3>
<p>What's the point in saving messages if we can't read them back out again? To enable this, the <strong>IReadAndWriteMessages</strong> needs a &quot;GetMessages&quot; method to accompany &quot;SaveMessage&quot; -</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.API
{
  public interface IReadAndWriteMessages
  {
    Task SaveMessage(MessageDetails message);
    Task&lt;IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt;&gt; GetMessages();
  }
}
</code></pre>
<p>This needs implementing in <strong>MessageApi</strong> -</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Bridge.Html5;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.API
{
  public class MessageApi : IReadAndWriteMessages
  {
    private readonly List&lt;Tuple&lt;int, MessageDetails&gt;&gt; _messages;
    public MessageApi()
    {
      _messages = new List&lt;Tuple&lt;int, MessageDetails&gt;&gt;();
    }

    public Task SaveMessage(MessageDetails message)
    {
      if (message == null)
        throw new ArgumentNullException(&quot;message&quot;);
      if (string.IsNullOrWhiteSpace(message.Title))
        throw new ArgumentException(&quot;A title value must be provided&quot;);
      if (string.IsNullOrWhiteSpace(message.Content))
        throw new ArgumentException(&quot;A content value must be provided&quot;);

      var task = new Task&lt;object&gt;(null);
      Window.SetTimeout(
        () =&gt;
        {
          _messages.Add(Tuple.Create(_messages.Count, message));
          task.Complete();
        },
        1000 // Simulate a roundtrip to the server
      );
      return task;
    }

    public Task&lt;IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt;&gt; GetMessages()
    {
      // ToArray is used to return a clone of the message set - otherwise, the caller would
      // end up with a list that is updated when the internal reference within this class
      // is updated (which sounds convenient but it's not the behaviour that would be
      // exhibited if this was really persisting messages to a server somewhere)
      var task = new Task&lt;IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt;&gt;(null);
      Window.SetTimeout(
        () =&gt; task.Complete(_messages.ToArray()),
        1000 // Simulate a roundtrip to the server
      );
      return task;
    }
  }
}
</code></pre>
<p>Now, we'll need a way to render this information -</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using Bridge.React;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class MessageHistory : StatelessComponent&lt;MessageHistory.Props&gt;
  {
    public MessageHistory(Props props) : base(props) { }

    public override ReactElement Render()
    {
      var className = props.ClassName;
      if (!props.Messages.Any())
        className = (className + &quot; zero-messages&quot;).Trim();

      // Any time a set of child components is dynamically-created (meaning that the
      // numbers of items may vary from one render to another), each must have a unique
      // &quot;Key&quot; property set (this may be a int or a string). Here, this is simple as
      // each message tuple is a unique id and the contents of that message (and the
      // unique id is ideal for use as a unique &quot;Key&quot; property).
      var messageElements = props.Messages
        .Select(idAndMessage =&gt; DOM.Div(new Attributes { Key = idAndMessage.Item1 },
          DOM.Span(new Attributes { ClassName = &quot;title&quot; }, idAndMessage.Item2.Title),
          DOM.Span(new Attributes { ClassName = &quot;content&quot; }, idAndMessage.Item2.Content)
        ));

      return DOM.FieldSet(new FieldSetAttributes { ClassName = className },
        DOM.Legend(null, &quot;Message History&quot;),
        DOM.Div(null, messageElements)
      );
    }

    public class Props
    {
      public string ClassName;
      public IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt; Messages;
    }
  }
}
</code></pre>
<p>This highlights an important React principle - where there are sets of dynamic child components, each must be provided a unique key. In the component above, we take &quot;props.Messages&quot; and map the data onto a set of Div elements. It's very possible that different messages will be rendered each time and so this is precisely what is meant by &quot;dynamic child components&quot;.</p>
<p>There are two reasons why it's important to provide unique keys - the first is performance; the task of React's Virtual DOM is to take the last component tree and the new component tree and work out what changed, so that the minimum changes may be applied to the browser DOM. In order to do this, it is very helpful for React to be able to track components as they move around within a dynamic set - it can allow it to reuse data internally instead of having to throw away representations of components and recreate them:</p>
<blockquote>
<p>When React reconciles the keyed children, it will ensure that any child with key will be reordered (instead of clobbered) or destroyed (instead of reused).</p>
</blockquote>
<p>The quote above is from <a href="https://facebook.github.io/react/docs/multiple-components.html#dynamic-children">Facebook's docs about Dynamic Children</a> - and so &quot;clobbered&quot; must be an official term!</p>
<p>The second reason why it's important is that component state can only be tracked with a component if the component itself can be tracked by React when dynamic elements move around. I'm not going to dwell too long on this because it's only applicable if you are relying on dynamic components having state, which you shouldn't be since only the top-level component should be stateful (and any component that may be created as a dynamic child component should be stateless).</p>
<p>For our purposes here, providing a unique key for each <strong>MessageHistory</strong> row is easy because the &quot;GetMessages&quot; method in the API returns a set of tuples, where each pair is a combination of id for the message and the message itself. This was easy to implement with the in-memory message store that we're using for this sample app, but it's also often easy when persisting by sending the data over the wire to a database somewhere; it's common for the database to generate unique ids for each record, and this would be returned in the data from &quot;GetMessages&quot;.</p>
<p>Now we have to return to the <strong>AppContainer</strong> to tie everything together; we need to add the message history data to the <strong>AppContainer</strong>'s state, we need to read the message history after we save and we need to render the message history -</p>
<pre><code>using System;
using System.Collections.Generic;
using Bridge.React;
using BridgeReactTutorial.API;
using BridgeReactTutorial.ViewModels;

namespace BridgeReactTutorial.Components
{
  public class AppContainer : Component&lt;AppContainer.Props, AppContainer.State&gt;
  {
    public AppContainer(AppContainer.Props props) : base(props) { }

    protected override State GetInitialState()
    {
      return new State
      {
        Message = new MessageDetails { Title = &quot;&quot;, Content = &quot;&quot; },
        IsSaveInProgress = false,
        MessageHistory = new Tuple&lt;int, MessageDetails&gt;[0]
      };
    }

    public override ReactElement Render()
    {
      return DOM.Div(null,
        new MessageEditor(new MessageEditor.Props
        {
          ClassName = &quot;message&quot;,
          Title = state.Message.Title,
          Content = state.Message.Content,
          OnChange = newMessage =&gt; SetState(new State
          {
            Message = newMessage,
            IsSaveInProgress = state.IsSaveInProgress,
            MessageHistory = state.MessageHistory
          }),
          OnSave = async () =&gt;
          {
            // Set SaveInProgress to true while the save operation is requested
            SetState(new State {
              Message = state.Message,
              IsSaveInProgress = true,
              MessageHistory = state.MessageHistory
            });
            await props.MessageApi.SaveMessage(state.Message);

            // After the save has completed, clear the message entry form and reset
            // SaveInProgress to false
            SetState(new State {
              Message = new MessageDetails { Title = &quot;&quot;, Content = &quot;&quot; },
              IsSaveInProgress = false,
              MessageHistory = state.MessageHistory
            });

            // Then re-load the message history state and re-render when that data arrives
            var allMessages = await props.MessageApi.GetMessages();
            SetState(new State {
              Message = state.Message,
              IsSaveInProgress = state.IsSaveInProgress,
              MessageHistory = allMessages
            });
          },
          Disabled = state.IsSaveInProgress
        }),
        new MessageHistory(new MessageHistory.Props
        {
          ClassName = &quot;history&quot;,
          Messages = state.MessageHistory
        })
      );
    }

    public class Props
    {
      public IReadAndWriteMessages MessageApi;
    }

    public class State
    {
      public MessageDetails Message;
      public bool IsSaveInProgress;
      public IEnumerable&lt;Tuple&lt;int, MessageDetails&gt;&gt; MessageHistory;
    }
  }
}
</code></pre>
<p>The logic in this component is getting more complicated now, which is down to the event-handling; what needs to happen when this happens and then this happens and then this happens (eg. the user clicks save, we initiate a save request, the API completes the request, we update the UI to clear the form and then start loading the updated message history, then we update the UI with the new message content).</p>
<p>One of the goals going forward will be to separate out this logic, away from the React components. The reason that I've made a couple of mentions of moving towards &quot;dumb components&quot; is that it makes unit testing much easier - everything outside of the React components will be simple C# / JavaScript code, which is always easier to test than UI elements, even when the UI is created using the React library. Another benefit of separating application logic from the UI components is that it makes both sides easier to reason about - and this is another theme that I'll be re-visiting during this mini-series.</p>
<p>It's worth mentioning that, even though it's gotten more complicated, the <strong>AppContainer</strong> (the only stateful component in the application) still adheres to the stateful component guidelines:</p>
<ol>
<li>A stateful component's &quot;props&quot; data should <em>only</em> consist of references to external dependencies</li>
<li>A stateful component's &quot;state&quot; data should include <em>everything</em> required to render the component tree, though the props may be required to deal with child components' events</li>
</ol>
<p><em>All</em> of the data required to render the UI is present in the state. The props data is only required within &quot;Render&quot; in order to process some of the callbacks from the child components. Any changes that must then be reflected in the UI come through a call to SetState - at the point of the SetState-triggered re-render, all of the data required to generate the child components will, once again, be present entirely within the state data.</p>
<p>To keep things look nice, add the following to &quot;styles.css&quot; -</p>
<pre><code>fieldset.history
{
  opacity: 1;
  transition: opacity .5s ease-in-out;
}
fieldset.history.zero-messages { opacity: 0; }
fieldset.history span.title
{
  padding: 0 8px;
  font-weight: bold;
}
</code></pre>
<p>This will have the <strong>MessageHistory</strong> invisible to begin with, fading in when the first message is available to display.</p>
<h3>Coming in Part Two..</h3>
<p>I think this makes a good point at which to draw the first part of this series to a close. To be honest, we haven't got very close at all yet to the &quot;The Dan Way&quot; of writing React applications - so far, it's been fairly straight-forward and in-line with the basic React guidelines from Facebook.</p>
<p>Which isn't to save that we haven't covered a lot of good ground! This will serve as a good base from which we can improve things. But we haven't seen the &quot;Flux architecture&quot; at all yet, and have only hinted at why we would want it. I'm not happy with how many of the properties on the various props, state and other data types are presented - one of my pet peeves with APIs is not knowing what can and can't be null; on the <strong>TextInput</strong>'s <strong>Props</strong> class, the &quot;ClassName&quot; string <em>may</em> be null but the &quot;OnChange&quot; callback must not be. These facts are not clear from just looking at the class. Similarly, it would be nice to know whether or not there are any guarantees about the &quot;Title&quot; and &quot;Content&quot; strings on the <strong>MessageDetails</strong> class (is it ever really acceptable for them to be null?). Finally, the reading and writing of messages through the <strong>MessageApi</strong> implementation we have here works fine for one person doing all the writing, but how could we deal with it if the <strong>MessageApi</strong> simulated a server-based API that received new messages from <em>other</em> uses, either through some sort of polling or through a push mechanism? This is an important question for systems that have to support multiple users.</p>
<p>All of these questions will be answered in later posts, along with further advice to try to help you do what I think React does best - write code that is easier to reason about, and thus easier to read, maintain and extend.</p>
<p class="PostTime">Posted at 23:55</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/writing-react-apps-using-bridgenet-the-dan-way-part-three">Writing React apps using Bridge.NET - The Dan Way (Part Three)</a></li><li><a href="/writing-react-apps-using-bridgenet-the-dan-way-part-two">Writing React apps using Bridge.NET - The Dan Way (Part Two)</a></li><li><a href="/easy-purecomponent-react-performance-boosts-for-bridgenet">Easy &quot;PureComponent&quot; React performance boosts for Bridge.Net</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/React" title="11 Posts">React</a></li></ul></div>
            <p class="Comments">
                <a href="/writing-react-apps-using-bridgenet-the-dan-way-from-first-principles#disqus_thread" data-disqus-identifier="96">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">11 February 2016</p><h2><a id="easy-purecomponent-react-performance-boosts-for-bridgenet" href="/easy-purecomponent-react-performance-boosts-for-bridgenet">Easy &quot;PureComponent&quot; React performance boosts for Bridge.Net</a></h2>
<p>React's great strength is that it makes creating UIs simple(r) because you can treat the view as a pure function - often, you essentially give a props reference into a top level component and it works out what to draw. Then, when something changes, you do the same again; trigger a full re-draw and rely upon React's Virtual DOM to work out what changed in an efficient manner and apply those changes to the browser DOM. The browser DOM is slow, which is why interactions with it should be minimised. The Virtual DOM is fast.</p>
<p>The common pre-React way to deal with UIs was to have some code to render the UI in an initial state and then further code that would change the UI based upon user interactions. React reduces these two types of state-handling (initial-display and update-for-specific-interaction) into one (full re-render).</p>
<p>And a lot of the time, the fast Virtual DOM performs quickly enough that you don't have to worry about what it's doing. But sometimes, you may have a UI that is so complicated that it's a lot of work for the Virtual DOM to calculate the diffs to apply to the browser DOM. Or you might have particularly demanding performance requirements, such as achieving 60 fps animations on mobile.</p>
<p>Handily, React has a way for you to give it hints - namely the <a href="https://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate">ShouldComponentUpdate</a> method that components may implement. This method can look at the component's current props and state values and the <em>next</em> props and state values and let React know if any changes are required. The method returns a boolean - false meaning &quot;no, I don't need to redraw, this data looks the same&quot; and true meaning &quot;yes, I need to redraw for this new data&quot;. The method is optional, if a component doesn't implement it then it's equivalent to it always returning true. Remember, if a component returns true for &quot;do I need to be redrawn?&quot;, the Virtual DOM is still what is responsible for dealing with the update - and it usually deals with it in a very fast and efficient manner. Returning true is not something to necessarily be worried about. However, if you <em>can</em> identify cases where ShouldComponentUpdate can return false then you can save the Virtual DOM from working out whether that component <em>or any of its child components</em> need to be redrawn. If this can be done high up in a deeply-nested component tree then it could save the Virtual DOM a lot of work.</p>
<p>The problem is, though, that coming up with a mechanism to reliably and efficiently compare object references (ie. props and / or state) to determine whether they describe the same data is difficult to do in the general case.</p>
<p>Let me paint a picture by describing a very simple example React application..</p>
<h3>The Message Editor Example</h3>
<p>Imagine an app that can read a list of messages from an API and allow the user of the app to edit these messages. Each message has &quot;Content&quot; and &quot;Author&quot; properties that are strings. Either of these values may be edited in the app. These messages are part of a message group that has a title - this also may be edited in the app.</p>
<p><em>(I didn't say that it was a useful or realistic app, it's just one to illustrate a point :)</em></p>
<p>The way that I like to create React apps is to categorise components as one of two things; a &quot;Container Component&quot; or a &quot;Presentation Component&quot;. Presentation Components should be state-less, they should just be handed a props reference and then go off and draw themselves. Any interactions that the user makes with this component or any of its child components are effectively passed up (via change handlers on the props reference) until it reaches a Container Component. The Container Component will translate these interaction into actions to send to the Dispatcher. Actions will be handled by a store (that will be listening out for Dispatcher actions that it's interested in). When a store handles an action, it emits a change event. The Container Component will be listening out for change events on stores that it is interested in - when this happens, the Container Component will trigger a re-render of itself by updating its state based upon data now available in the store(s) it cares about. This is a fairly standard Flux architecture and, I believe, the terms &quot;Container Component&quot; / &quot;Presentation Component are in reasonably common use (I didn't make them up, I just like the principle - one of the articles that I've read that uses these descriptions is <a href="https://medium.com/making-internets/component-brick-and-mortar-8bde51899b00#.6yi3i9hou">Component Brick and Mortar: The React documentation I wish I had a year ago</a>).</p>
<p>So, for my example app, I might have a component hierarchy that looks this:</p>
<pre><code>AppContainer
  Title
    TextInput
      Input
  MessageList
    MessageRow
      TextInput
        Input
      TextInput
        Input
    MessageRow
      TextInput
        Input
      TextInput
        Input
</code></pre>
<p>There will be as many &quot;MessageRow&quot; components as there are messages to edit. <strong>Input</strong> is a standard React-rendered element and all of the others (<strong>AppContainer</strong>, <strong>Title</strong>, <strong>MessageList</strong>, <strong>MessageRow</strong> and <strong>TextInput</strong>) are custom components.</p>
<p>(Note: This is <em>not</em> a sufficiently deeply-nested hierarchy that React would have any problems with rendering performance, it's intended to be <em>just</em> complicated enough to demonstrate the point that I'm working up to).</p>
<p>The <strong>AppContainer</strong> is the only &quot;Container Component&quot; and so is the only component that has a React state reference as well as props. A state reference is, essentially, what prevents a component from being what you might consider a &quot;pure function&quot; - where the props that are passed in are all that affects what is rendered out. React &quot;state&quot; is required to trigger a re-draw of the UI, but it should be present in as few places as possible - ie. there should only be one, or a small number of, top level component(s) that have state. Components that render <em>only</em> according to their props data are much easier to reason about (and hence easier to write, extend and maintain).</p>
<p>My <a href="https://www.nuget.org/packages/Bridge.React">Bridge.NET React bindings</a> NuGet package makes it simple to differentiate between stateful (ie. Container) components and stateless (ie. Presentation) components as it has both a <strong>Component&lt;TProps, TState&gt;</strong> base class and a <strong>StatelessComponent&lt;TProps&gt;</strong> base class - you derive from the appropriate one when you create custom components (for more details, see <a href="/react-and-flux-with-bridgenet-redux">React (and Flux) with Bridge.net - Redux</a>).</p>
<p>To start with the simplest example, below is the <strong>TextInput</strong> component. This just renders a text Input with a specified value and communicates up any requests to change that string value via an &quot;OnChange&quot; callback -</p>
<pre><code>public class TextInput : StatelessComponent&lt;TextInput.Props&gt;
{
  public TextInput(Props props) : base(props) { }

  public override ReactElement Render()
  {
    return DOM.Input(new InputAttributes
    {
      Type = InputType.Text,
      Value = props.Content,
      OnChange = OnTextChange
    });
  }

  private void OnTextChange(FormEvent&lt;InputElement&gt; e)
  {
    props.OnChange(e.CurrentTarget.Value);
  }

  public class Props
  {
    public string Content { get; set; }
    public Action&lt;string&gt; OnChange { get; set; }
  }
}
</code></pre>
<p>It is fairly easy to envisage how you might try to implement &quot;ShouldComponentUpdate&quot; here - given a &quot;this is the new props value&quot; reference (which gets passed into ShouldComponentUpdate as an argument called &quot;nextProps&quot;) and the current props reference, you need only  look at the &quot;Content&quot; and &quot;OnChange&quot; references on the current and next props and, if both Content/Content and OnChange/OnChange references are the same, then we can return false (meaning &quot;no, we do not need to re-draw this TextInput&quot;).</p>
<p><em>(Two things to note here: Firstly, it is not usually possible to directly compare the current props reference with the &quot;nextProps&quot; reference because it is common for the parent component to create a new props instance for each proposed re-render of a child component, rather than re-use a previous props instance - so the individual property values within the props references may all be consistent between the current props and nextProps, but the actual props references will usually be distinct. Secondly, the Bridge.NET React bindings only support React component life cycle method implementations on custom components derived from <strong>Component&lt;TProps, TState&gt;</strong> classes and not those derived from <strong>StatelessComponent&lt;TProps&gt;</strong>, so you couldn't actually write your own &quot;ShouldComponentUpdate&quot; for a <strong>StatelessComponent</strong> - but that's not important here, we're just working through a thought experiment).</em></p>
<p>Now let's move on to the <strong>MessageList</strong> and <strong>MessageRow</strong> components, since things get more complicated there -</p>
<pre><code>public class MessageList : StatelessComponent&lt;MessageList.Props&gt;
{
  public MessageList(Props props) : base(props) { }

  public override ReactElement Render()
  {
    var messageRows = props.IdsAndMessages
      .Select(idAndMessage =&gt; new MessageRow(new MessageRow.Props
      {
        Key = idAndMessage.Item1,
        Message = idAndMessage.Item2,
        OnChange = newMessage =&gt; props.OnChange(idAndMessage.Item1, newMessage)
      }));
    return DOM.Div(
      new Attributes { ClassName = &quot;message-list&quot; },
      messageRows
    );
  }

  public class Props
  {
    public Tuple&lt;int, MessageEditState&gt;[] IdsAndMessages;
    public Action&lt;int, MessageEditState&gt; OnChange;
  }
}

public class MessageRow : StatelessComponent&lt;MessageRow.Props&gt;
{
  public MessageRow(Props props) : base(props) { }

  public override ReactElement Render()
  {
    // Note that the &quot;Key&quot; value from the props reference does not explicitly need
    // to be mentioned here, the React bindings will deal with it (it is important
    // to give dynamic children components unique key values, but it is handled by
    // the bindings and the React library so long as a &quot;Key&quot; property is present
    // on the props)
    // - See https://facebook.github.io/react/docs/multiple-components.html for
    //   more details
    return DOM.Div(new Attributes { ClassName = &quot;message-row&quot; },
      new TextInput(new TextInput.Props
      {
        Content = props.Message.Content,
        OnChange = OnContentChange
      }),
      new TextInput(new TextInput.Props
      {
        Content = props.Message.Author,
        OnChange = OnAuthorChange
      })
    );
  }

  private void OnContentChange(string newContent)
  {
    props.OnChange(new MessageEditState
    {
      Content = newContent,
      Author = props.Message.Author
    });
  }
  private void OnAuthorChange(string newAuthor)
  {
    props.OnChange(new MessageEditState
    {
      Content = props.Message.Content,
      Author = newAuthor
    });
  }

  public class Props
  {
    public int Key;
    public MessageEditState Message;
    public Action&lt;MessageEditState&gt; OnChange;
  }
}

public class MessageEditState
{
  public string Content;
  public string Author;
}
</code></pre>
<p>If the <strong>MessageList</strong> component wanted to implement &quot;ShouldComponentUpdate&quot; then its job is more difficult as it has an array of message data to check. It could do one of several things - the first, and most obviously accurate, would be to perform a &quot;deep compare&quot; of the arrays from the current props and the &quot;nextProps&quot;; ensuring firstly that there are the same number of items in both and then comparing each &quot;Content&quot; and &quot;Author&quot; value in each item of the arrays. If everything matches up then the two arrays contain the same data and (so long as the &quot;OnChange&quot; callback hasn't changed) the component doesn't need to re-render. Avoiding re-rendering this component (and, subsequently, any of its child components) would be a big win because it accounts for a large portion of the total UI. Not re-rendering it would give the Virtual DOM much less work to do. But would a deep comparison of this type actually be any cheaper than letting the Virtual DOM do what it's designed to do?</p>
<p>The second option is to presume that whoever created the props references would have re-used any <strong>MessageEditState</strong> instances that haven't changed. So the array comparison could be reduced to ensuring that the current and next props references both have the same number of elements and then performing reference equality checks on each item.</p>
<p>The third option is to presume that whoever created the props reference would have re-used the array itself if the data hadn't changed, meaning that a simple reference equality check could be performed on the current and next props' arrays.</p>
<p>The second and third options are both much cheaper than a full &quot;deep compare&quot; but they both rely upon the caller following some conventions. This is why I say that this is a difficult problem to solve for the general case.</p>
<h3>Immutability to the rescue</h3>
<p>There is actually another option to consider, the object models for the props data could be rewritten to use immutable types. These have the advantage that if you find that two references are equal then they are guaranteed to contain the same data. They also have the advantage that it's much more common to re-use instances to describe the same data - partly because there is some overhead to initialising immutable types and partly because there is no fear that &quot;if I give this reference to this function, I want to be sure that it can't change the data in <em>my</em> reference while doing its work&quot; because it is <em>impossible</em> to change an immutable reference's data. (I've seen defensively-written code that clones mutable references that it passes into other functions, to be sure that no other code can change the data in the original reference - this is never required with immutable types).</p>
<p>Conveniently, I've recently written a library to use with Bridge.NET which I think makes creating and working with immutable types easier than C# makes it on its own. I wrote about it in &quot;<a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a>&quot; but the gist is that you re-write <strong>MessageEditState</strong> as:</p>
<pre><code>// You need to pull in the &quot;ProductiveRage.Immutable&quot; NuGet package to use IAmImmutable
public class MessageEditState : IAmImmutable
{
  public MessageEditState(string content, string author)
  {
    this.CtorSet(_ =&gt; _.Content, content);
    this.CtorSet(_ =&gt; _.Author, author);
  }
  public string Content { get; private set; }
  public string Author { get; private set; }
}
</code></pre>
<p>It's still a little more verbose than the mutable version, admittedly, but I'm hoping to convince you that it's worth it (if you need convincing!) for the benefits that we'll get.</p>
<p>When you have an instance of this new <strong>MessageEditState</strong> class, if you need to change one of the properties, you don't have to call the constructor each time to get a new instance, you can use the &quot;With&quot; extension methods that may be called on any <strong>IAmImmutable</strong> instance - eg.</p>
<pre><code>var updatedMessage = message.With(_ =&gt; _.Content, &quot;New information&quot;);
</code></pre>
<p>This would mean that the change handlers from <strong>MessageRow</strong> could be altered from:</p>
<pre><code>private void OnContentChange(string newContent)
{
  props.OnChange(new MessageEditState
  {
    Content = newContent,
    Author = props.Message.Author
  });
}
private void OnAuthorChange(string newAuthor)
{
  props.OnChange(new MessageEditState
  {
    Content = props.Message.Content,
    Author = newAuthor
  });
}
</code></pre>
<p>and replaced with:</p>
<pre><code>private void OnContentChange(string newContent)
{
  props.OnChange(props.Message.With(_ =&gt; _.Content, newContent));
}
private void OnAuthorChange(string newAuthor)
{
  props.OnChange(props.Message.With(_ =&gt; _.Author, newAuthor));
}
</code></pre>
<p>Immediately, the verbosity added to <strong>MessageEditState</strong> is being offset with tidier code! (And it's nice not having to set both &quot;Content&quot; <em>and</em> &quot;Author&quot; when only changing <em>one</em> of them).</p>
<p>The &quot;With&quot; method also has a small trick up its sleeve in that it won't return a new instance if the new property value is the same as the old property value. This is an eventuality that <em>could</em> happen in the code above as an &quot;Input&quot; element rendered by React will raise an &quot;OnChange&quot; event for any action that <em>might</em> have altered the text input's content. For example, if you had a text box with the value &quot;Hello&quot; in it and you selected all of that text and then pasted in text from the clipboard over the top of it, if the clipboard text was also &quot;Hello&quot; then the &quot;OnChange&quot; event will be raised, even though the actual value has not changed (it was &quot;Hello&quot; before and it's still &quot;Hello&quot; now). The &quot;With&quot; method will deal with this, though, and just pass the same instance straight back out. This is an illustration of the &quot;reuse of instances for unchanged data&quot; theme that I alluded to above.</p>
<p>The next step would be to change the array type in the <strong>MessageList.Props</strong> type from</p>
<pre><code>public Tuple&lt;int, MessageEditState&gt;[] IdsAndMessages;
</code></pre>
<p>to</p>
<pre><code>public NonNullList&lt;Tuple&lt;int, MessageEditState&gt;&gt; IdsAndMessages;
</code></pre>
<p>The <strong>NonNullList</strong> class is also in the <a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a> NuGet package. It's basically an immutable <strong>IEnumerable</strong> that may be used in Bridge.NET projects. A simple example of it in use is:</p>
<pre><code>// Create a new set of values (the static &quot;Of&quot; method uses type inference to determine
// the type of &quot;T&quot; in the returned &quot;NonNullList&lt;T&gt;&quot; - since 1, 2 and 3 are all ints, the
// &quot;numbers&quot; reference will be of type &quot;NonNullList&lt;int&gt;&quot;)
var numbers = NonNullList.Of(1, 2, 3);

// SetValue takes an index and a new value, so calling SetValue(2, 4) on a set
// containing 1, 2, 3 will return a new set containing the values 1, 2, 4
numbers = numbers.SetValue(2, 4);

// Calling SetValue(2, 4) on a set containing values 1, 2, 4 does not require any
// changes, so the input reference is passed straight back out
numbers = numbers.SetValue(2, 4);
</code></pre>
<p>As with <strong>IAmImmutable</strong> instances we get two big benefits - we can rely on reference equality comparisons more often, since the data with any given reference can never change, and references will be reused in many cases if operations are requested that would not actually change the data. (It's worth noting that the guarantees fall apart if any property on an <strong>IAmImmutable</strong> reference is a of a mutable type, similarly if a <strong>NonNullList</strong> has elements that are a mutable type, or that have nested properties that are of a mutable type.. but so long as immutability is used &quot;all the way down&quot; then all will be well).</p>
<p>If this philosophy was followed, then suddenly the &quot;ShouldComponentUpdate&quot; implementation for the <strong>MessageList</strong> component would be very easy to write - just perform reference equality comparisons on the &quot;IdsAndMessages&quot; and &quot;OnChange&quot; values on the current props and on the nextProps. While solving the problem for the general case is very difficult, solving it when you introduce some constraints (such as the use of immutable and persistent data types) can be very easy!</p>
<p>If we <em>did</em> implement this <strong>MessageList</strong> &quot;ShouldComponentUpdate&quot; method, then we could be confident that when a user makes changes to the &quot;Title&quot; text input that the Virtual DOM would not have to work out whether the <strong>MessageList</strong> or any of its child components had changed - because we'd have told the Virtual DOM that they hadn't (because the &quot;IdsAndMessages&quot; and &quot;OnChange&quot; property references wouldn't have changed).</p>
<p>We could take this a step further, though, and consider the idea of implementing &quot;ShouldComponentUpdate&quot; on other components - such as <strong>MessageRow</strong>. If the user edits a text value within one row, then the <strong>MessageList</strong> will have to perform some re-rendering work, since one of its child components needs to be re-rendered. But there's no need for any of the other rows to re-render, it could be <em>just</em> the single row in which the change was requested by the user.</p>
<p>So the <strong>MessageRow</strong> could look at its props values and, if they haven't changed between the current props and the nextProps, then inform React (via &quot;ShouldComponentUpdate&quot;) that no re-render is required.</p>
<p>And why not go even further and just do this on <em>all</em> Presentation Components? The <strong>TextInput</strong> could avoid the re-render of its child Input if the props' &quot;Content&quot; and &quot;OnChange&quot; reference are not being updated.</p>
<h3>Introducing the Bridge.React &quot;PureComponent&quot;</h3>
<p>To make this easy, I've added a new base class to the React bindings (available in 1.4 of <a href="https://www.nuget.org/packages/Bridge.React">Bridge.React</a>); the <strong>PureComponent&lt;TProps&gt;</strong>.</p>
<p>This, like the <strong>StatelessComponent&lt;TProps&gt;</strong>, is very simple and does not support state and only allows the &quot;Render&quot; method to be implemented - no other React lifecycle functions (such &quot;ComponentWillMount&quot;, &quot;ShouldComponentUpdate&quot;, etc..) may be defined on components deriving from this class.</p>
<p>The key difference is that it has its own &quot;ShouldComponentUpdate&quot; implementation that presumes that the props data is immutable and basically does what I've been describing above automatically - when React checks &quot;ShouldComponentUpdate&quot;, it will look at the &quot;props&quot; and &quot;nextProps&quot; instances and compare their property values. (It also deals with the cases where one or both of them are null, in case you want components whose props reference is optional).</p>
<p>This is not an original idea, by a long shot. I first became aware of people doing this in 2013 when I read <a href="http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/">The Future of JavaScript MVC Frameworks</a>, which was talking about using <a href="https://github.com/clojure/clojurescript">ClojureScript</a> and its React interface &quot;<a href="https://github.com/omcljs/om">Om</a>&quot;. More recently, I was reading <a href="http://benchling.engineering/performance-engineering-with-react/">Performance Engineering with React (Part 1)</a>, which talks about roughly the same subject but with vanilla JavaScript. And, of course, Facebook has long had its <a href="https://facebook.github.io/react/docs/pure-render-mixin.html">PureRenderMixin</a> - though mixins can't be used with ES6 components (which seems to be the approach to writing components that Facebook is pushing at the moment).</p>
<p>So, this is largely just making it easy it when writing React applications with <em>Bridge</em>. However, using Bridge to do this <em>does</em> give us some extra advantages (on top of the joy of being able to write React apps in C#!). In the code earlier (from the <strong>MessageRow</strong> Render method) -</p>
<pre><code>new TextInput(new TextInput.Props
{
  Content = props.Message.Content,
  OnChange = OnContentChange
})
</code></pre>
<p>Bridge will bind the &quot;OnContentChange&quot; method to the current <strong>MessageRow</strong> instance so that when it is called by the <strong>TextInput</strong>'s &quot;OnChange&quot; event, &quot;this&quot; is the <strong>MessageRow</strong> and not the <strong>TextInput</strong> (which is important because OnContentChange needs to access the &quot;props&quot; reference scoped to the <strong>MessageRow</strong>).</p>
<p>This introduces a potential wrinkle in our plan, though, as this binding process creates a new JavaScript method each time and means that each time the <strong>TextInput</strong> is rendered, the &quot;OnChange&quot; reference is new. So if we try to perform simple reference equality checks on props values, then we won't find the current &quot;OnChange&quot; and the new &quot;OnChange&quot; to be the same.</p>
<p>This problem is mentioned in the &quot;Performance Engineering&quot; article I linked above:</p>
<blockquote>
<p>Unfortunately, each call to Function.bind produces a new function.. No amount of prop checking will help, and your component will always re-render.</p>
</blockquote>
<blockquote>
<p>..</p>
</blockquote>
<blockquote>
<p>The simplest solution we've found is to pass the unbound function.</p>
</blockquote>
<p>When using Bridge, we don't have the option of using an unbound function since the function-binding is automatically introduced by the C#-to-JavaScript translation process. And it's very convenient, so it's not something that I'd ideally <em>like</em> to have to workaround.</p>
<p>Having a dig through Bridge's source code, though, revealed some useful information. When Bridge.fn.bind is called, it returns a new function (as just discussed).. but with some metadata attached to it. When it returns a new function, it sets two properties on it &quot;$scope&quot; and &quot;$method&quot;. The $scope reference is what &quot;this&quot; will be set to when the bound function is called and the $method reference is the original function that is being bound. This means that, when the props value comparisons are performed, if a value is a function and it the reference equality comparison fails, a fallback approach may be attempted - if both functions have $scope and $method references defined then compare them and, if they are both consistent between the function value on the current props and the function value on the nextProps, then consider the value to be unchanged.</p>
<p>The <strong>PureComponent</strong>'s &quot;ShouldComponentUpdate&quot; implementation deals with this automatically, so you don't have to worry about it.</p>
<p>It's possibly worth noting that the &quot;Performance Engineering&quot; post did briefly consider something similar -</p>
<blockquote>
<p>Another possibility we've explored is using a custom bind function that stores metadata on the function itself, which in combination with a more advanced check function, could detect bound functions that haven't actually changed.</p>
</blockquote>
<p>Considering that Bridge automatically includes this additional metadata, it seemed to me to be sensible to use it.</p>
<p>There's one other equality comparison that is supported; as well as simple referential equality and the function equality gymnastics described above, if both of the values are non-null and the first has an &quot;Equals&quot; function then this function will be considered. This means that any custom &quot;Equals&quot; implementations that you define on classes will be automatically taken into consideration by the <strong>PureComponent</strong>'s logic.</p>
<h3>Another Bridge.NET bonus: Lambda support</h3>
<p>When I started writing this post, there was going to be a section here with a warning about using lambdas as functions in props instances, rather than using named functions (which the examples thus far have done).</p>
<p>As with bound functions, anywhere that an anonymous function is present in JavaScript, it will result in a new function value being created. If, for example, we change the <strong>MessageRow</strong> class from:</p>
<pre><code>public class MessageRow : PureComponent&lt;MessageRow.Props&gt;
{
  public MessageRow(Props props) : base(props) { }

  public override ReactElement Render()
  {
    return DOM.Div(new Attributes { ClassName = &quot;message-row&quot; },
      new TextInput(new TextInput.Props
      {
        Content = props.Message.Content,
        OnChange = OnContentChange
      }),
      new TextInput(new TextInput.Props
      {
        Content = props.Message.Author,
        OnChange = OnAuthorChange
      })
    );
  }

  private void OnContentChange(string newContent)
  {
    props.OnChange(props.Message.With(_ =&gt; _.Content, newContent));
  }
  private void OnAuthorChange(string newAuthor)
  {
    props.OnChange(props.Message.With(_ =&gt; _.Author, newAuthor));
  }

  public class Props
  {
    public int Key;
    public MessageEditState Message;
    public Action&lt;MessageEditState&gt; OnChange;
  }
}
</code></pre>
<p>to:</p>
<pre><code>public class MessageRow : PureComponent&lt;MessageRow.Props&gt;
{
  public MessageRow(Props props) : base(props) { }

  public override ReactElement Render()
  {
    return DOM.Div(new Attributes { ClassName = &quot;message-row&quot; },
      new TextInput(new TextInput.Props
      {
        Content = props.Message.Content,
        OnChange = newContent =&gt;
          props.OnChange(props.Message.With(_ =&gt; _.Content, newContent))
      }),
      new TextInput(new TextInput.Props
      {
        Content = props.Message.Author,
        OnChange = newAuthor =&gt;
          props.OnChange(props.Message.With(_ =&gt; _.Author, newAuthor))
      })
    );
  }

  public class Props
  {
    public int Key;
    public MessageEditState Message;
    public Action&lt;MessageEditState&gt; OnChange;
  }
}
</code></pre>
<p>then there would be problems with the &quot;OnChange&quot; props values specified because each new lambda - eg..</p>
<pre><code>OnChange = newContent =&gt;
  props.OnChange(props.Message.With(_ =&gt; _.Content, newContent))
</code></pre>
<p>would result in a new JavaScript function being passed to Bridge.fn.bind every time that it was called:</p>
<pre><code>onChange: Bridge.fn.bind(this, function (newContent) {
  this.getprops().onChange(
    ProductiveRage.Immutable.ImmutabilityHelpers.$with(
       this.getprops().message,
      function (_) { return _.getContent(); },
      newContent
    )
  );
})
</code></pre>
<p>And this would prevent the <strong>PureComponent</strong>'s &quot;ShouldComponentUpdate&quot; logic from being effective, since the $method values from the current props &quot;OnChange&quot; and the nextProps &quot;OnChange&quot; bound functions would always be different.</p>
<p>I was quite disappointed when I realised this and was considering trying to come up with some sort of workaround - maybe calling &quot;toString&quot; on both $method values and comparing their implementations.. but I couldn't find definitive information about the performance implications of this and I wasn't looking forward to constructing my own suite of tests to investigate any potential performance impact of this across different browsers and different browser versions.</p>
<p>My disappointment was two-fold: firstly, using the lambdas allows for more succinct code and less syntactic noise - since the types of the lambda's argument(s) and return value (if any) are inferred, rather than having to be explicitly typed out.</p>
<pre><code>newContent =&gt; props.OnChange(props.Message.With(_ =&gt; _.Content, newContent))
</code></pre>
<p>is clearly shorter than</p>
<pre><code>private void OnContentChange(string newContent)
{
  props.OnChange(props.Message.With(_ =&gt; _.Content, newContent));
}
</code></pre>
<p>The other reason that I was deflated upon realising this was that it meant that the &quot;ShouldComponentUpdate&quot; implementation would, essentially, silently fail for components that used lambdas - &quot;ShouldComponentUpdate&quot; would return true in cases where I would like it to return false. There would be no compiler error and the UI code would still function, but it wouldn't be as efficient as it could be (the Virtual DOM would have to do more work than necessary).</p>
<p>Instead, I had a bit of a crazy thought.. lambdas like this, that only need to access their own arguments and the &quot;this&quot; reference, could be &quot;lifted&quot; into named functions quite easily. Essentially, I'm doing this manually by writing methods such as &quot;OnContentChange&quot;. But could the Bridge translator do something like this automatically - take those C# lambdas and convert them into named functions in JavaScript? That way, I would get the benefit of the succinct lambda format in C# <em>and</em> the <strong>PureComponent</strong> optimisations would work.</p>
<p>Well, once again the Bridge.NET Team came through for me! I raised a <a href="http://forums.bridge.net/forum/general/feature-requests/1515-open-921-lift-simple-anonymous-functions-into-named-functions-for-performance-wins">Feature Request</a> about this, explained what I'd like in an ideal world (and why) and five days later there was a branch on GitHub where I could preview changes that did precisely what I wanted!</p>
<p>This is not just an example of fantastic support from the Bridge Team, it is also, I believe, an incredible feature for Bridge and a triumph for writing front-end code in C#! Having this &quot;translation step&quot; from C# to JavaScript provides the opportunity for handy features to be included for free - earlier we saw how the insertion of Bridge.fn.bind calls by the translator meant that we had access to $method and $scope metadata (which side-steps one of the problems that were had by the author of <a href="http://benchling.engineering/performance-engineering-with-react/">Performance Engineering with React</a>) but, here, the translation step can remove the performance overhead that anonymous functions were going to cause for our &quot;ShouldComponentUpdate&quot; implementation, without there being <em>any</em> burden on the developer writing the C# code.</p>
<p>It's also worth considering the fact that every allocation made in JavaScript is a reference that needs to be tidied up by the browser's garbage collector at some point. A big reason why judicious use of &quot;ShouldComponentUpdate&quot; can make UIs faster is that there is less work for the Virtual DOM to do, but it <em>also</em> eases the load on the garbage collector because none of the memory allocations need to be made for child components of components that do not need to be re-rendered. Since anonymous JavaScript functions are created over and over again (every time that the section of code that declares the anonymous function is executed), lifting them into named functions means that there will be fewer allocations in your SPA and hence even less work for the garbage collector to do.</p>
<p><em>Note: As of the 11th of February 2016, this Bridge.NET improvement has not yet been made live - but their release cycles tend to be fairly short and so I don't imagine that it will be very long until it is included in an official release. If you were desperate to write any code with <strong>PureComponent</strong> before then, you could either avoid lambdas in your C# code or you could use lambdas now, knowing that the <strong>PureComponent</strong> won't be giving you the full benefit immediately - but that you WILL get the full benefit when the Bridge Team release the update.</em></p>
<h3>So it's an unequivocable success then??</h3>
<p>Well, until it transpired that the Bridge translator would be altered to convert these sorts of lambdas into named functions, I was going to say &quot;this is good, but..&quot;. However, <em>with</em> that change in sight, I'm just going to say outright &quot;yes, and I'm going to change all classes that derive from <strong>StatelessComponent</strong> in my projects to derive from <strong>PureComponent</strong>&quot;. This will work fine, so long as your props references are all immutable (meaning that they are immutable <em>all the way down</em> - you shouldn't have, say, a props property that is an immutable <strong>NonNullList</strong> of references, but where those references have mutable properties).</p>
<p>And, if you're not using immutable props types - sort yourself out! While a component is being rendered (according to the <a href="https://facebook.github.io/react/docs/tutorial.html">Facebook React Tutorial</a>):</p>
<blockquote>
<p>props are immutable: they are passed from the parent and are &quot;owned&quot; by the parent</p>
</blockquote>
<p>So, rather than having props only be immutable during component renders (by a convention that the React library enforces), why not go whole-hog and use fully immutable classes to describe your props types - that way props are <em>fully</em> immutable and you can use the <a href="https://www.nuget.org/packages/Bridge.React">Bridge.React</a>'s <strong>PureComponent</strong> to get performance boosts for free!</p>
<p><em>(Now seems like a good time to remind you of my post &quot;<a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a>&quot;, which illustrates how to use the <a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a> NuGet package to make defining immutable classes just that bit easier).</em></p>
<p class="PostTime">Posted at 20:11</p><div class="Related"><h3>You may also be interested in:</h3><ul><li><a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a></li><li><a href="/react-and-flux-with-bridgenet-redux">React (and Flux) with Bridge.net - Redux</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/React" title="11 Posts">React</a></li><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/easy-purecomponent-react-performance-boosts-for-bridgenet#disqus_thread" data-disqus-identifier="95">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">16 December 2015</p><h2><a id="frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications" href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications">Friction-less immutable objects in Bridge (C# / JavaScript) applications</a></h2>
<p>One of the posts that I've written that got the most &quot;audience participation*&quot; was one from last year &quot;<a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Implementing F#-inspired 'with' updates for immutable classes in C#</a>&quot;, where I spoke about trying to ease the burden in C# or representing data with immutable classes by reducing the repetitive typing involved.</p>
<p>* <em>(I'd mis-remembered receiving more criticism about this than I actually did - now that I looking back at the comments left on the <a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">post</a> and on <a href="https://www.reddit.com/r/programming/comments/2gqx9u/implementing_finspired_with_updates_for_immutable/">reddit</a>, the conversations and observations are pretty interesting and largely constructive!)</em></p>
<p>The gist was that if I wanted to have a class that represented, for the sake of a convoluted example, an employee that had a name, a start-of-employment date and some notes (which are optional and so may not be populated) then we might have something like the following:</p>
<pre><code>public class EmployeeDetails
{
  public EmployeeDetails(string name, DateTime startDate, string notesIfAny)
  {
    if (string.IsNullOrWhiteSpace(name))
      throw new ArgumentException(&quot;name&quot;);

    Name = name.Trim();
    StartDate = startDate;
    NotesIfAny = (notesIfAny == null) ? null : notesIfAny.Trim();
  }

  /// &lt;summary&gt;
  /// This will never be null or blank, it will not have any leading or trailing whitespace
  /// &lt;/summary&gt;
  public string Name { get; private set; }

  public DateTime StartDate { get; private set; }

  /// &lt;summary&gt;
  /// This will be null if it has not value, otherwise it will be a non-blank string with no
  /// leading or trailing whitespace
  /// &lt;/summary&gt;
  public string NotesIfAny { get; private set; }
}
</code></pre>
<p>If we wanted to update a record with some notes where previously it had none then we'd need to create a new instance, something like:</p>
<pre><code>var updatedEmployee = new EmployeeDetails(
  employee.Name,
  employee.StartDate,
  &quot;Awesome attitude!&quot;
);
</code></pre>
<p>This sort of thing (calling the constructor explicitly) gets old quickly, particularly if the class gets extended in the future since then anywhere that did something like this would have to add more arguements to the constructor call.</p>
<p>So an alternative is to include &quot;With&quot; functions in the class -</p>
<pre><code>public class EmployeeDetails
{
  public EmployeeDetails(string name, DateTime startDate, string notesIfAny)
  {
    if (string.IsNullOrWhiteSpace(name))
      throw new ArgumentException(&quot;name&quot;);

    Name = name.Trim();
    StartDate = startDate;
    NotesIfAny = (notesIfAny == null) ? null : notesIfAny.Trim();
  }

  /// &lt;summary&gt;
  /// This will never be null or blank, it will not have any leading or trailing whitespace
  /// &lt;/summary&gt;
  public string Name { get; private set; }

  public DateTime StartDate { get; private set; }

  /// &lt;summary&gt;
  /// This will be null if it has not value, otherwise it will be a non-blank string with no
  /// leading or trailing whitespace
  /// &lt;/summary&gt;
  public string NotesIfAny { get; private set; }

  public EmployeeDetails WithName(string value)
  {
      return (value == Name) ? this : new EmployeeDetails(value, StartDate, NotesIfAny);
  }
  public EmployeeDetails WithStartDate(DateTime value)
  {
      return (value == StartDate) ? this : new EmployeeDetails(Name, value, NotesIfAny);
  }
  public EmployeeDetails WithNotesIfAny(string value)
  {
      return (value == NotesIfAny) ? this : new EmployeeDetails(Name, StartDate, value);
  }
}
</code></pre>
<p>Now the update code is more succinct -</p>
<pre><code>var updatedEmployee = employee.WithNotesIfAny(&quot;Awesome attitude!&quot;);
</code></pre>
<p>Another benefit of this approach is that the With functions can include a quick check to ensure that the new value is not the same as the current value - if it is then there's no need to generate a new instance, the current instance can be returned straight back out. This saves generating a new object reference and it makes it easier to rely upon simple reference equality tests when determining whether data has changed - eg.</p>
<pre><code>var updatedEmployee = employee.WithNotesIfAny(&quot;Awesome attitude!&quot;);
var didEmployeeAlreadyHaveAwesomeAttitude = (updatedEmployee == employee);
</code></pre>
<p><a href="/implementing-f-sharp-inspired-with-updates-for-immutable-classes-in-c-sharp">Last year's post</a> went off on a few wild tangents but basically was about allowing something like the following to be written:</p>
<pre><code>public class EmployeeDetails
{
  public EmployeeDetails(string name, DateTime startDate, string notesIfAny)
  {
    if (string.IsNullOrWhiteSpace(name))
      throw new ArgumentException(&quot;name&quot;);

    Name = name.Trim();
    StartDate = startDate;
    NotesIfAny = (notesIfAny == null) ? null : notesIfAny.Trim();
  }

  /// &lt;summary&gt;
  /// This will never be null or blank, it will not have any leading or trailing whitespace
  /// &lt;/summary&gt;
  public string Name { get; private set; }

  public DateTime StartDate { get; private set; }

  /// &lt;summary&gt;
  /// This will be null if it has not value, otherwise it will be a non-blank string with no
  /// leading or trailing whitespace
  /// &lt;/summary&gt;
  public string NotesIfAny { get; private set; }

  public EmployeeDetails With(
    Optional&lt;string&gt; name = new Optional&lt;string&gt;(),
    Optional&lt;DateTime&gt; startDate = new Optional&lt;DateTime&gt;(),
    Optional&lt;Optional&lt;string&gt;&gt; notesIfAny = new Optional&lt;Optional&lt;string&gt;&gt;())
  {
    return DefaultUpdateWithHelper.GetGenerator&lt;EmployeeDetails&gt;()(
      this, name, startDate, notesIfAny
    );
  }
}
</code></pre>
<p>It allowed you to include a single &quot;With&quot; function that could change one or more of the properties in a single call like this:</p>
<pre><code>var updatedEmployee = employee.With(name: &quot;Jimbo&quot;, notesIfAny: &quot;So lazy!&quot;);
</code></pre>
<p><em>And</em> it would do it with magic, so you wouldn't have to write all of the &quot;return-same-instance-if-no-values-changed&quot; logic and it would.. erm.. well, to be honest, I've forgotten some of the finer details! But I remember that it was fun messing around with, getting my hands dirty with reflection, compiled LINQ expressions, stack-trace-sniffing (and some required JIT-method-inlining-disabling).</p>
<p>A couple of weeks later I wrote a follow-up, taking on board some of the feedback and criticisms in the comments and doing some performance testing. One of the ways I came up with to create the &quot;magic With method&quot; was only twice as slow as writing it by hand.. which, now, doesn't sound all that <em>awesome</em> - <em>twice</em> as slow is often a bad thing, but I was quite proud of it at the time!</p>
<h3>Immutable Classes in 2015</h3>
<p>Recently, I've been making <a href="http://bridge.net/">Bridge.NET</a> applications and I've been favouring writing immutable types for the messages passed around the system. And, again, I've gotten a bit bored of writing the same lines of code over and over -</p>
<pre><code>if (value == null)
  throw new ArgumentNullException(&quot;value&quot;);
</code></pre>
<p>and</p>
<pre><code>/// &lt;summary&gt;
/// This will never be null
/// &lt;/summary&gt;
</code></pre>
<p>and</p>
<pre><code>/// &lt;summary&gt;
/// This will never be null, nor blank, nor have any leading or trailing whitespace
/// &lt;/summary&gt;
</code></pre>
<p><em>Never mind</em> contemplating writing all of those &quot;WithName&quot;, &quot;WithStartDate&quot; methods (checking in them that the values have actually changed and returning the same instance back out if not). I love the benefits of having these immutable types (reducing places where it's possible for state to change makes reasoning about code soooooooo much easier) but I'm getting tired of banging out the same constructs and sentences! follows a</p>
<p>So I've started on a new tack. I want to find those places where repetition is getting me down and I want to reduce it as much as possible. <em>But</em> I don't want to sacrifice my validation checks or the guarantess of immutability. And, again, to put this into context - I'm going to be concentrating on the classes that I write in C# but that Bridge.NET then translates into JavaScript, so there are different considerations to take into account. First of which being that Bridge doesn't support reflection and so none of the crazy stuff I was doing in &quot;pure&quot; C# will be possible! Not in the same way that I wrote it last time, at least..</p>
<p>Before I get into any silly stuff, though, I want to talk about a couple of techniques that hopefully aren't <em>too</em> controversial and that I think have improved my code as well as requiring me to type less.</p>
<p>First off is a variation of the &quot;<strong>Optional</strong>&quot; struct that I used in my C# library last time. Previously, as illustrated in the code at the top of this post, I was relying on argument names and comments to indicate when values may and may not be null. The &quot;Name&quot; property has a comment saying that it will not be null while the &quot;NotesIfAny&quot; property has a comment saying that it <em>might</em> be null - and it follows a convention of having an &quot;IfAny&quot; suffix, which suggests that it <em>might not</em> always have a value.</p>
<p>Instead, I want to move to assuming that all references are non-null and that values that <em>may</em> be null have their type wrapped in an <strong>Optional</strong> struct.</p>
<p>This would change the <strong>EmployeeDetails</strong> example to look like this:</p>
<pre><code>public class EmployeeDetails
{
  public EmployeeDetails(string name, DateTime startDate, Optional&lt;string&gt; notes)
  {
    if (string.IsNullOrWhiteSpace(name))
      throw new ArgumentException(&quot;name&quot;);
    Name = name.Trim();
    StartDate = startDate;
    Notes = !notes.IsDefined || (notes.Value.Trim() == &quot;&quot;) ? null : notes.Value.Trim();
  }
  public string Name { get; private set; }
  public DateTime StartDate { get; private set; }
  public Optional&lt;string&gt; Notes { get; private set; }
}
</code></pre>
<p>The &quot;IfAny&quot; suffix is gone, along with all of the comments about null / non-null. Now the type system indicates whether a value may be null (in which case it will be wrapped in an Optional) or not.</p>
<p><em>(Note: I'll talk more about <strong>Optional</strong> later in this post - there's nothing too revolutionary or surprising in there, but it will distract from what I'm trying to build up to here).</em></p>
<p>We have lost something, though, because in the earlier code the Name and Notes fields had comments that stated that the values (if non-null, in the case of Notes) would <em>not</em> be blank and would <em>not</em> have any leading or trailing whitespace. This information is no longer included in comments, because I want to lose the comments. But, if I've solved the null / non-null problem by leveraging the type system, why not do the same with the non-blank-trimmed strings?</p>
<p>Introducing..</p>
<pre><code>public class NonBlankTrimmedString
{
  public NonBlankTrimmedString(string value)
  {
    if (string.IsNullOrWhiteSpace(value))
      throw new ArgumentException(&quot;Must be non-null and have some non-whitespace content&quot;);
    Value = value.Trim();
  }

  /// &lt;summary&gt;
  /// This will never have any leading or trailing whitespace, it will never be blank
  /// &lt;/summary&gt;
  public string Value { get; private set; }

  public static implicit operator NonBlankTrimmedString(string value)
  {
    return new NonBlankTrimmedString(value);
  }
  public static implicit operator string(NonBlankTrimmedString value)
  {
    return value.Value;
  }
}
</code></pre>
<p>Ok, so it looks like the comments are back.. but the idea is that the &quot;will never have any leading or trailing whitespace, it will never be blank&quot; need only appear <em>once</em> (in this class) and <em>not</em> for every property that should be non-null and non-blank and not-have-any-leading-or-trailing-whitespace.</p>
<p>Now the <strong>EmployeeDetails</strong> class can become:</p>
<pre><code>public class EmployeeDetails
{
  public EmployeeDetails(
      NonBlankTrimmedString name,
    DateTime startDate,
    Optional&lt;NonBlankTrimmedString&gt; notes)
  {
    if (name == null)
      throw new ArgumentNullException(&quot;name&quot;);
    Name = name;
    StartDate = startDate;
    Notes = notes;
  }
  public NonBlankTrimmedString Name { get; private set; }
  public DateTime StartDate { get; private set; }
  public Optional&lt;NonBlankTrimmedString&gt; Notes { get; private set; }
}
</code></pre>
<p>This looks a lot better. Not only is there less to read, there was less repetitive code (and comments) to write but the same information is still available for someone reading / using the code. In fact, I think that it's better on that front now because the constructor signature and the property types themselves communicate this information - which makes it harder to ignore than a comment does. And the type system is the primary reason that I want to write my front-end applications in C# rather than JavaScript!</p>
<p>However, there are <em>still</em> a couple of things that I'm not happy with. Firstly, in an ideal world, the constructors would magically have if-null-then-throw conditions injected for every argument - there are <em>no</em> arguments that should be null now; <strong>Optional</strong> is a struct and so can never be null, while any references that <em>could</em> be null should be wrapped in an <strong>Optional</strong>. One way to achieve that this in regular C# is with <a href="http://haacked.com/archive/2013/01/05/mitigate-the-billion-dollar-mistake-with-aspects.aspx/">IL rewriting</a> but I'm not a huge fan of that because I have suspicions about PostSharp (that I should probably revisit one day because I'm no longer completely sure what grounds they're based on). But, aside from that, it would be use when writing C# for Bridge, since IL doesn't come into the process - C# source code is translated into JavaScript and IL isn't involved!</p>
<p>Secondly, I need to tackle the &quot;With&quot; function(s) and I'd like to make that as painless as possible, really. Writing them all by hand is tedious.</p>
<h3>Get to the point, already!</h3>
<p>So.. I've been playing around and I've written a Bridge.NET library that allows me to write something like this:</p>
<pre><code>public class EmployeeDetails : IAmImmutable
{
  public EmployeeDetails(
    NonBlankTrimmedString name,
    DateTime startDate,
    Optional&lt;NonBlankTrimmedString&gt; notes)
  {
    this.CtorSet(_ =&gt; _.Name, name);
    this.CtorSet(_ =&gt; _.StartDate, startDate);
    this.CtorSet(_ =&gt; _.Notes, notes);
  }
  public NonBlankTrimmedString Name { get; private set; }
  public DateTime StartDate { get; private set; }
  public Optional&lt;NonBlankTrimmedString&gt; Notes { get; private set; }
}
</code></pre>
<p>Which is not too bad! Unfortunately, yes, there is <em>some</em> duplication still - there are <em>three</em> places that each of the properties are mentioned; in the constructor argument list, in the constructor body and as public properties. However, I think that this is the bare minimum number of times that they <em>could</em> be repeated without sacrificing any type guarantees. The constructor has to accept a typed argument list and it has to somehow map them onto properties. The properties have to repeat the types so that any one accessing those property values know what they're getting.</p>
<p>But let's talk about the positive things, rather than the negative (such as the fact that while the format shown above is fairly minimal, it's <em>still</em> marginally more complicated in appearance than a simple mutable type). Actually.. maybe we should first talk about the <em>weird</em> things - like what is this &quot;CtorSet&quot; method?</p>
<p>&quot;CtorSet&quot; is an extension method that sets a specified property on the target instance to a particular value. It has the following signature:</p>
<pre><code>public static void CtorSet&lt;T, TPropertyValue&gt;(
  this T source,
  Func&lt;T, TPropertyValue&gt; propertyIdentifier,
  TPropertyValue value)
    with T : IAmImmutable
</code></pre>
<p>It doesn't <em>just</em> set it, though, it ensures that the value is not null first and throws an <strong>ArgumentNullException</strong> if it is. This allows me to avoid the repetitive and boring if-null-then-throw statements. I don't need to worry about cases where I <em>do</em> want to allow nulls, though, because I would use an <strong>Optional</strong> type in that case, which is a struct and so never can be null!</p>
<p>The method signature ensures that the type of the value is consistent with the type of the target property. If not, then the code won't compile. I <em>always</em> favour static type checking where possible, it means that there's no chance that a mistake you make will only reveal itself when a particular set of condition are met (ie. when a particular code path is executed) at runtime - instead the error is right in your face in the IDE, not even letting you <em>try</em> to run it!</p>
<p>Which makes the next part somewhat unfortunate. The &quot;propertyIdentifier&quot; must be:</p>
<ol>
<li>A simple lambda expression..</li>
<li>.. that identifies a property getter which has a corresponding setter (though it's fine for that setter to be private)..</li>
<li>.. where neither the getter nor setter have a Bridge [Name] / [Template] / [Ignore] / etc.. attribute on it..</li>
</ol>
<p>If any of these conditions are not met then the &quot;CtorSet&quot; method will throw an exception. But you might not find out until runtime because C#'s type system is not strong enough to describe all of these requirements.</p>
<p>The good news, though, is that while the C# type system itself isn't powerful enough, with Visual Studio 2015 it's possible to write a <a href="https://msdn.microsoft.com/en-us/magazine/dn879356.aspx">Roslyn Analyser</a> that <em>can</em> pick up any invalid propertRetriever before run time, so that errors <em>will</em> be thrown right in your face without you ever executing the code. The even better news is that such an analyser is included in the NuGet package! But let's not get ahead of ourselves, let me finish describing what this new method actually does first..</p>
<p>If it's not apparent from looking at the example code above, &quot;CtorSet&quot; is doing some magic. It's doing some basic sort of reflection in JavaScript to work out <em>how</em> to identify and set the target property. Bridge won't support reflection until v2 but my code does an approximation where it sniffs about in the JavaScript representation of the &quot;propertyIdentifier&quot; and gets a hold of the setter. Once it has done the work to identify the setter for a given &quot;T&quot; and &quot;propertyIdentifier&quot; combination, it saves it away in an internal cache - while we can't control and performance-tune JavaScript in quite the same way that we can with the CLR, it doesn't mean that we should do the same potentially-complicated work over and over again if we don't need to!</p>
<p>Another thing to note, if you haven't already spotted it: &quot;CtorSet&quot; will call <em>private</em> setters. This has the potential to be disastrous, if it could be called without restrictions, since it could change the data on types that <em>should</em> be able to give the appearance of immutability (ie. classes that set their state in their constructor and have private-only setters.. the pedantic may wish to argue that classes with private setters should not be considered strictly immutable because private functions <em>could</em> change those property values, but it's entirely possible to have classes that have the attribute of being <a href="https://blogs.msdn.microsoft.com/ericlippert/2007/11/13/immutability-in-c-part-one-kinds-of-immutability/">Observational Immutability</a> in this manner, and that's all I'm really interested in).</p>
<p>So there are two fail-safes built in. Firstly, the type constraint on &quot;CtorSet&quot; means that the target must implement the <strong>IAmImmutable</strong> interface. This is completely empty and so there is no burden on the class that implements it, it merely exists as an identifier that the current type should be allowed to work with &quot;CtorSet&quot;.</p>
<p>The second protection is that once &quot;CtorSet&quot; has been called for a particular target instance and a particular property, that property's value is &quot;locked&quot; - meaning that a subsequent call to &quot;CtorSet&quot; for the same instance and property will result in an exception being thrown. This prevents the situation from occurring where an <strong>EmployeeDetails</strong> is initialised using &quot;CtorSet&quot; in its constructor but then gets manipulated externally via further calls to &quot;CtorSet&quot;. Since the <strong>EmployeeDetails</strong> properties are all set in its constructor using &quot;CtorSet&quot;, no-one can change them later with another call to &quot;CtorSet&quot;. (This is actually something else that is picked up by the analyser - &quot;CtorSet&quot; may <em>only</em> be called from within constructor - so if you're using this library within Visual Studio 2015 then you wouldn't have to worry about &quot;CtorSet&quot; being called from elsewhere, but if you're <em>not</em> using VS 2015 then this extra runtime protection may be reassuring).</p>
<p>Now that &quot;CtorSet&quot; is explained, I can get to the next good bit. I have <em>another</em> extension method:</p>
<pre><code>public T With&lt;T, TPropertyValue&gt;(
  this T source,
  Func&lt;T, TPropertyValue&gt; propertyIdentifier,
  TPropertyValue value)
    with T : IAmImmutable
</code></pre>
<p>This works in a similar manner to &quot;CtorSet&quot; but, instead of setting a property value on the current instance, it will clone the target instance then update the property on <em>that</em> instance and then return that instance. Unless the new property value is the same as the current one, in which case this work will be bypassed and the current instance will be returned unaltered. As with &quot;CtorSet&quot;, null values are not allowed and will return in an <strong>ArgumentNullException</strong> being thrown.</p>
<p>With this method, having specific &quot;With&quot; methods on classes is not required. Continuing with the <strong>EmployeeDetails</strong> class from the example above, if we have:</p>
<pre><code>var employee = new EmployeeDetails(
  &quot;John Smith&quot;,
  new DateTime(2014, 9, 3),
  null
);
</code></pre>
<p>.. and we then discover that his start date was recorded incorrectly, then this instance of the record could be replaced by calling:</p>
<pre><code>employee = employee.With(_ =&gt; _.StartDate, new DateTime(2014, 9, 2));
</code></pre>
<p>And, just to illustrate that if-value-is-the-same-return-instance-immediately logic, if we <em>then</em> did the following:</p>
<pre><code>var employeeUpdatedAgain= employee.With(_ =&gt; _.StartDate, new DateTime(2014, 9, 2));
</code></pre>
<p>.. then we could use referential equality to determine whether any change was made -</p>
<pre><code>// This will be false because the &quot;With&quot; call specified a StartDate value that was
// the same as the StartDate value that the employee reference already had
var wasAnyChangeMade = (employeeUpdatedAgain != employee);
</code></pre>
<h3>Bonus features</h3>
<p>So, in this library, there are the &quot;CtorSet&quot; and &quot;With&quot; extensions methods and there is an <strong>Optional</strong> type -</p>
<pre><code>public struct Optional&lt;T&gt; : IEquatable&lt;Optional&lt;T&gt;&gt;
{
  public static Optional&lt;T&gt; Missing { get; }

  public bool IsDefined { get; }
  public T Value { get { return this.value; } }
  public T GetValueOrDefault(T defaultValue);

  public static implicit operator Optional&lt;T&gt;(T value);
}
</code></pre>
<p>This has a convenience static function -</p>
<pre><code>public static class Optional
{
  public static Optional&lt;T&gt; For&lt;T&gt;(T value)
  {
    return value;
  }
}
</code></pre>
<p>.. which makes it easier any time that you explicitly need to create an <strong>Optional&lt;&gt;</strong> wrapper for a value. It lets you take advantage of C#'s type inference to save yourself from having to write out the type name yourself. For example, instead of writing something like</p>
<pre><code>DoSomething(new Optional&lt;string&gt;(&quot;Hello!&quot;));
</code></pre>
<p>.. you could just write</p>
<pre><code>DoSomething(Optional.For(&quot;Hello!&quot;));
</code></pre>
<p>.. and type inference will know that the <strong>Optional</strong>'s type is a string.</p>
<p>However, this is often unnecessary due to <strong>Optional</strong>'s implicit operator from &quot;<strong>T</strong>&quot; to <strong>Optional&lt;T&gt;</strong>. If you have a function</p>
<pre><code>public void DoSomething(Optional&lt;string&gt; value)
{
  // Do.. SOMETHING
</code></pre>
<p>.. then you can call it with <em>any</em> of the following:</p>
<pre><code>// The really-explicit way
DoSomething(new Optional&lt;string&gt;(&quot;Hello!&quot;));

// The rely-on-type-inference way
DoSomething(Optional.For(&quot;Hello!&quot;));

// The rely-on-Optional's-implicit-operator way
DoSomething(&quot;Hello!&quot;);
</code></pre>
<p>There is also an immutable collection type; the <strong>NonNullList&lt;T&gt;</strong>. This has a very basic interface -</p>
<pre><code>public sealed class NonNullList&lt;T&gt; : IEnumerable&lt;T&gt;
{
  public static NonNullList&lt;T&gt; Empty { get; }

  public int Count { get; }
  public T this[int index] { get; }
  public NonNullList&lt;T&gt; SetValue(int index, T value);
  public NonNullList&lt;T&gt; Insert(T item);
}
</code></pre>
<p>.. and it comes with a similar convenience static function -</p>
<pre><code>public static class NonNullList
{
    public static NonNullList&lt;T&gt; Of&lt;T&gt;(params T[] values);
}
</code></pre>
<p>The reason for this type is that it's so common to need collections of values but there is nothing immediately available in Bridge that allows me to do this while maintaining guarantees about non-null values and immutability.</p>
<p>I thought about using the <a href="https://facebook.github.io/immutable-js/">Facebook Immutable-Js</a> library but..</p>
<ol>
<li>It's a further dependency</li>
<li>I <em>really</em> wanted to continue the do-not-allow-null philosophy that I use with &quot;CtorSet&quot; and &quot;With&quot;</li>
</ol>
<p>I actually considered calling the &quot;<strong>NonNullList</strong>&quot; type the &quot;<strong>NonNullImmutableList</strong>&quot; but &quot;NonNull&quot; felt redundant when I was trying to encourage non-null-by-default and &quot;Immutable&quot; felt redundant since immutability is what this library is for. So that left my with <strong>List&lt;T&gt;</strong> and that's already used! So I went with simply <strong>NonNullList&lt;T&gt;</strong>.</p>
<p>Immutable lists like this are commonly written using linked lists since, if the nodes are immutable, then sections of the list can often be shared between multiple lists - so, if you have a list with three items in it and you call &quot;Insert&quot; to create a new list with four items that has the new item as the new first first item in the linked list then the following three items will be the same three node instances that existed in the original list. This reuse of data is a way to make immutable types more efficient than the naive copy-the-entire-list-and-then-manipulate-the-new-version approach would be. I'm 99% sure that this is what the Facebook library uses for the simple list type and it's something I wrote about doing in C# a few years ago if you want to read more (see &quot;<a href="/persistent-immutable-lists">Persistent Immutable Lists</a>&quot;).</p>
<p>The reason that I mention this is to try to explain why the <strong>NonNullList</strong> interface is so minimal - there are no Add, InsertAt, etc.. functions. The cheapest operations to do to this structure are to add a new item at the start of the list and to iterate through the items from the start, so I started off with only those facilities initially. Then I added a getter (which is an O(n) operation, rather than the O(1) that you get with a standard array) and a setter (which is similarly O(n) in cost, compared to O(1) for an array) because they are useful in many situations. In the future I might expand this class to include more List-like functions, but I haven't for now.</p>
<p>Just to make this point clear one more time: <strong>NonNullList&lt;T&gt;</strong> functions will throw exceptions if null values are ever specified - all values should be non-null and the type of &quot;T&quot; should be an <strong>Optional</strong> if null values <em>are</em> required (in which case none of the actual elements of the set will be null since they will all be <strong>Optional</strong> instances and <strong>Optional</strong> is a struct).</p>
<p>To make it easier to work with properties that are collections of items, there is another &quot;With&quot; method signature:</p>
<pre><code>public T With&lt;T, TPropertyElement&gt;(
  this T source,
  Func&lt;T, NonNullList&lt;TPropertyElement&gt;&gt; propertyIdentifier,
  int index,
  TPropertyElement value)
</code></pre>
<p>So, if you had a class like this -</p>
<pre><code>public class Something : IAmImmutable
{
  public Something(int id, NonNullList&lt;string&gt; items)
  {
    this.CtorSet(_ =&gt; _.Id, id);
    this.CtorSet(_ =&gt; _.Items, items);
  }
  public int Id { get; private set; }
  public NonNullList&lt;string&gt; Items { get; private set; }
}
</code></pre>
<p>.. and an instance of one created with:</p>
<pre><code>var s = new Something(1, NonNullList.Of(&quot;ZERO&quot;, &quot;One&quot;));
</code></pre>
<p>.. and you then wanted to change the casing of that second item, then you could do so with:</p>
<pre><code>s = s.With(_ =&gt; _.Items, 1, &quot;ONE&quot;);
</code></pre>
<p>If you specified an invalid index then it would fail at runtime, as it would if you tried to pass a null value. If you tried to specify a value that was of an incompatible type then you would get a compile error as the method signature ensures that the specified value matches the <strong>NonNullList&lt;T&gt;</strong>'s item type.</p>
<h3>Getting hold of the library</h3>
<p>If this has piqued your interest then you can get the library from NuGet - it's called &quot;<a href="https://www.nuget.org/packages/ProductiveRage.Immutable">ProductiveRage.Immutable</a>&quot;. It should work fine with Visual Studio 2013 but I would recommend that you use 2015, since then the analysers that are part of the NuGet package will be installed and enabled as well. The analysers confirm that every &quot;property retriever&quot; argument is <em>always</em> a simple lambda, such as</p>
<pre><code>_ =&gt; _.Name
</code></pre>
<p>.. and ensures that &quot;Name&quot; is a property that both &quot;CtorSet&quot; and &quot;With&quot; are able to use in their manipulations*. If this is not the case, then you will get a descriptive error message explaining why.</p>
<p>* <em>(For example, properties may not be used whose getter or setter has a Bridge [Name], [Template] or [Ignore] attribute attached to it).</em></p>
<p>One think to be aware of with using Visual Studio 2015 with Bridge.Net, though, is that Bridge does not yet support C# 6 syntax. So don't get carried away with the wonderful new capabilities (like my beloved <a href="https://msdn.microsoft.com/en-us/library/dn986596.aspx">nameof</a>). Support for this new syntax is, I believe, coming in Bridge v2..</p>
<p>If you want to look at the actual code then feel free to check it out at <a href="https://github.com/ProductiveRage/Bridge.Immutable">github.com/ProductiveRage/Bridge.Immutable</a>. That's got the library code itself as well as the analysers and the unit tests <em>for</em> the analysers. It's the first time that I've tried to produce a full, polished analyser and I had fun! As well as a few speed bumps.. (possibly a topic for another day).</p>
<p>While the library, as delivered through the NuGet package, should work fine for both VS 2013 and VS 2015, building the solution yourself requires VS 2015 <em>Update 1</em>.</p>
<h3>Is this proven and battle-hardened?</h3>
<p>No.</p>
<p>At this point in time, this is mostly still a concept that I wanted to try out. I think that what I've got is reliable and quite nicely rounded - I've <em>tried</em> to break it and haven't been able to yet. And I intend to use it in some projects that I'm working on. However, at this moment in time, you might want to consider it somewhat experimental. Or you could just be brave and starting using it all over the place to see if it fits in with your world view regarding how you should write C# :)</p>
<h3>Is &quot;IAmImmutable&quot; really necessary?</h3>
<p>If you've <em>really</em> been paying attention to all this, you might have noticed that I said earlier that the <strong>IAmImmutable</strong> interface is used to identify types that have been designed to work with &quot;CtorSet&quot;, to ensure that you can't call &quot;CtorSet&quot; on references that weren't expecting it and whose should-be-private internals you could then meddle with. Well, it would be a reasonable question to ask:</p>
<blockquote>
<p>Since there is an analyser to ensure that &quot;CtorSet&quot; is only called from within a constructor, surely <strong>IAmImmutable</strong> is unnecessary because it would not be possible to call &quot;CtorSet&quot; from places where it shouldn't be?</p>
</blockquote>
<p>I have given this some thought and have decided (for now, at least) to stick with the <strong>IAmImmutable</strong> marker interface for two reasons:</p>
<ol>
<li>If you're writing code where the analyser is not being used (such as in Visual Studio versions before 2015) then it makes it harder to write code that could change private state where it should not be possible</li>
<li>It avoids polluting the auto-complete matches by only allowing &quot;CtorSet&quot; and &quot;With&quot; to be called against <em>any</em> type, even where it's not applicable (such as on the <strong>string</strong> class, for example)</li>
</ol>
<p>The first point refers to the fallback defense mechanism that will not allow properties to have their value set more than once using &quot;CtorSet&quot;, attempting to do so will result in a runtime error. If a class has all of its properties set using &quot;CtorSet&quot; within its constructor then any external, subsequent &quot;CtorSet&quot; call will fail. Having to implement the <strong>IAmImmutable</strong> interface when writing immutable types hopefully acts as a reminder to do this. Without this extra protection (and without the analyser), your code could contain &quot;CtorSet&quot; calls that manipulate private state in classes that have no idea what's hit them!</p>
<p>Meanwhile, the second just <em>feels</em> like a good practice so that &quot;CtorSet&quot; and &quot;With&quot; don't crop up over and over again on types that you would not want to use them with.</p>
<p>If anyone really wanted the <strong>IAmImmutable</strong>-requirement to be relaxed (which would allow the immutable types to be written in an even more succinct manner, since they wouldn't need to implement that interface) then I would definitely be up for a debate.</p>
<p class="PostTime">Posted at 22:22</p><div class="Related"><h3>You may also be interested in:</h3><ul><li><a href="/using-roslyn-code-fixes-to-make-the-frictionless-immutable-objects-in-bridge-even-easier">Using Roslyn code fixes to make the &quot;Friction-less immutable objects in Bridge&quot; even easier</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/Immutability" title="12 Posts">Immutability</a></li></ul></div>
            <p class="Comments">
                <a href="/frictionless-immutable-objects-in-bridge-c-sharp-javascript-applications#disqus_thread" data-disqus-identifier="93">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">26 November 2015</p><h2><a id="react-and-flux-with-bridgenet-redux" href="/react-and-flux-with-bridgenet-redux">React (and Flux) with Bridge.net - Redux</a></h2>
<p>Earlier in the year I wrote about using <a href="http://bridge.net">Bridge.net</a> to write browser-based applications using <a href="https://facebook.github.io/react/">React</a>. Well, now, I'd like to present an update to that. I've changed how the base <strong>Component</strong> class ties into the React library (this is a class that may be derived from in order to create custom React components) - it now supports &quot;SetState&quot; - and I've added an alternative base class; the <strong>StatelessComponent</strong>, which will allow the writing of component classes that will operate as <a href="https://facebook.github.io/react/blog/2015/09/10/react-v0.14-rc1.html#stateless-function-components">stateless components</a>, as introduced by React 0.14. I've also improved how the components appear when viewed in the React Dev Tools browser extension and I've tied it into the latest, just-released version of Bridge (1.10) that has fixed a lot of bugs.</p>
<p>If you're the sort of person who likes to jump straight to the end of a book to see how it ends, then you can find the code on in my <a href="https://github.com/ProductiveRage/Bridge.React">GitHub &quot;Bridge.React&quot; repo</a> or you can add it to a Bridge project through NuGet (<a href="https://www.nuget.org/packages/Bridge.React">Bridge.React</a>). But if you want to find out more of the details then keep reading! I'm not going to presume any prior knowledge from my previous post - so if you've read that, then I'm afraid I'm going to re-tread some of the same ground - however, I imagine that I don't have <em>that</em> many dedicated followers, so figure it makes more sense to make this entry nicely self-contained :)</p>
<h3>As simple as could be</h3>
<p>In the past, I've also written about writing <a href="/typescript-es6-classes-for-react-components-without-the-hacks">bindings for TypeScript</a> (which is a language I liked.. but not as much as C#) and <a href="/react-and-flux-with-duocode">bindings for DuoCode</a> (which is a project that seemed to have promise until they spent so longer thinking about their pricing model that I gave up on them) as well as a couple of posts about Bridge - and, often, I've got quite technical about how the bindings work under the hood. Today, though, I'm just going to deal with how to <em>use</em> the bindings. I'm happy that they're finally fully-populated and I've tried to make an effort to make them easy to consume, so let's just stick to getting Bridge apps talking to React and not worry about the magic behind the scenes!</p>
<p>I'm going to assume that you're familiar with React - though I won't be going into too much depth on it, so if you're not an expert then it shouldn't be any problem. I'm <em>not</em> going to assume that you have tried out Bridge yet, because it's so easy to presume that you haven't that it won't take us long to start from scratch!</p>
<h3>Hello world</h3>
<p>So, let's <em>really</em> start from the basics. You need to create a new solution in Visual Studio - choose a C# Class Library. Now go to References / Manage NuGet Packages, search for &quot;Bridge.React&quot; online and install the package. This will automatically pull in the Bridge package as a dependency, and this sets up a &quot;demo.html&quot; file under the &quot;Bridge/www&quot; folder to make getting started as frictionless as possible. That file has the following content:</p>
<pre><code>&lt;!DOCTYPE html&gt;

&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;Bridge BridgeReactBlogPost&lt;/title&gt;
    &lt;script src=&quot;../output/bridge.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../output/BridgeReactBlogPost.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--
        Right-Click on this file
        and select &quot;View in Browser&quot;
    --&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Note that the title and the JavaScript filename are taken from the project name. So the file above mentions &quot;BridgeReactBlogPost&quot; because that's the name of the project that I'm creating myself alongside writing this post (just to ensure that I don't miss any steps or present any dodgy demonstration code!).</p>
<p>We need to add a few more items now - the React library JavaScript, the Bridge.React JavaScript and an element for React to render inside. So change demo.html to something like the following:</p>
<pre><code>&lt;!DOCTYPE html&gt;

&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;Bridge BridgeReactBlogPost&lt;/title&gt;
    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../output/bridge.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../output/bridge.react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../output/BridgeReactBlogPost.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;main&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><em>(Aside: If you want to, then you can add the line</em></p>
<blockquote>
<p>&quot;combineScripts&quot;: true</p>
</blockquote>
<p><em>to your bridge.json file, which will cause ALL of the project JavaScript files to be built into a single file - including &quot;bridge.js&quot; and &quot;bridge.react.js&quot; - so, if you used this option, you would only need to include a single JavaScript file. In this example, it would be just &quot;../output/BridgeReactBlogPost.js&quot;).</em></p>
<p>Now change the &quot;Class1.cs&quot; file (that was created automatically when you requested the new &quot;Class Library&quot; project) thusly:</p>
<pre><code>using Bridge.Html5;
using Bridge.React;

namespace BridgeReactBlogPost
{
  public class Class1
  {
    [Ready]
    public static void Main()
    {
      React.Render(
        DOM.Div(
          new Attributes { ClassName = &quot;wrapper&quot; },
          &quot;Hiya!&quot;
        ),
        Document.GetElementById(&quot;main&quot;)
      );
    }
  }
}
</code></pre>
<p>.. and then right-click on demo.html, click &quot;View in Browser&quot; and you should be greeted by some React-rendered content. Good start!</p>
<p><em><strong>Update (2nd December 2015):</strong> I originally showed a non-static method above with a [Ready] attribute on it - this worked in earlier versions of Bridge but does not work any longer. In the examples in this post, using an instance method with the [Ready] attribute will result in the method NOT being called at DOM ready (it will appear to fail silently by doing no work but showing no warnings). Don't make my mistake, make [Ready] methods static!</em></p>
<p>Now, let's be slightly more ambitious -</p>
<pre><code>[Ready]
public static void Main()
{
  React.Render(
    DOM.Div(new Attributes { ClassName = &quot;wrapper&quot; },
      DOM.Input(new InputAttributes
      {
        OnChange = e =&gt; Window.Alert(e.CurrentTarget.Value),
        MaxLength = 3
      })
    ),
    Document.GetElementById(&quot;main&quot;)
  );
}
</code></pre>
<p>Re-build then use &quot;View in Browser&quot; again. Now each change to the input box is thrown back in your face in an alert. The type of &quot;e.CurrentTarget&quot; is &quot;InputElement&quot; and so there is a string &quot;Value&quot; property available. And the &quot;InputAttributes&quot; class allows the setting of all of the properties that are specific to an InputElement, such as &quot;MaxLength&quot;. This is one of the great things about using a type system to document your API - you use types (such as requiring an InputAttributes instance when DOM.Input is called) to inform the user of the API; what can and can't be done. And, while I've got a lot of respect for the people maintaining the <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> TypeScript type definitions, you don't get as much detail in their React bindings as are available here!</p>
<p>In fairness, I should really give credit where it's due here - the &quot;InputElement&quot; type comes from the Bridge.Html5 namespace, so I haven't had to write all of those definitions myself. And the &quot;InputAttributes&quot; class was based upon the InputElement's source code; I only had to remove read-only properties (for example, the html &quot;input&quot; element has a &quot;valueAsNumber&quot; property - only applicable to input elements with type &quot;number&quot; - that is read-only and so it would not make sense for this to be settable as a React attribute). I also had to remove some unsupported functionality (for example, checkbox input elements support an &quot;<a href="https://css-tricks.com/indeterminate-checkboxes/">indeterminate</a>&quot; flag in browsers but <a href="https://github.com/facebook/react/issues/1798">this is not supported by React</a>).</p>
<p>All of the element factory methods in React (&quot;div&quot;, &quot;span&quot;, &quot;input&quot;, etc..) have corresponding methods in the bindings, with types that express any additional properties that should be available - eg. we have</p>
<pre><code>ReactElement TD(
  TableCellAttributes properties,
  params Any&lt;ReactElement, string&gt;[] children
);
</code></pre>
<p>where the &quot;TableCellAttributes&quot; introduces additional properties such as &quot;int ColSpan&quot; and &quot;int RowSpan&quot; (note that the bindings all use pascal-cased function and type names since this is what is more commonly seen in C# code - where the functions are translated into JavaScript they will automatically use the camel-cased JavaScript names, so &quot;Div&quot; becomes &quot;div&quot;, for example).</p>
<h3>Creating your own components</h3>
<p>But this is the boring stuff - as soon as you start using React, you want to create your own components!</p>
<p>React 0.14 introduced a concept, the &quot;<a href="https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components">Stateless Component</a>&quot;. In native JavaScript, this is just a function that takes a props reference and returns a React element. But to make it feel more natural in C#, the bindings have a base class which can effectively become a Stateless Component - eg.</p>
<pre><code>public class MyLabel : StatelessComponent&lt;MyLabel.Props&gt;
{
  public MyLabel(Props props) : base(props) { }

  public override ReactElement Render()
  {
    return DOM.Label(
      new LabelAttributes { ClassName = props.ClassName },
      props.Value
    );
  }

  public class Props
  {
    public string Value;
    public string ClassName;
  }
}
</code></pre>
<p>The &quot;<strong>StatelessComponent</strong>&quot; base class takes a generic type parameter that describe the &quot;props&quot; reference type. Then, when &quot;Render&quot; is called, the &quot;props&quot; reference will be populated and ready to use <em>within</em> Render. If any other functions are declared within the class, they may be called from Render as you might expect (see further down). So we are able to write very simple custom components that React will treat as these special Stateless Components - about which, Facebook say:</p>
<blockquote>
<p>In the future, we'll also be able to make performance optimizations specific to these components</p>
</blockquote>
<p>Creating one of these components is as easy as:</p>
<pre><code>React.Render(
  new MyLabel(new MyLabel.Props { ClassName = &quot;wrapper&quot;, Value = &quot;Hi!&quot; }),
  Document.GetElementById(&quot;main&quot;)
);
</code></pre>
<p>It is important to note, however, that - due to the way that React creates components - the constructor of these classes must always be a no-op (it won't actually be called when React prepares the component) and the <em>only</em> data that the class can have passed in must be described in the props data. If you tried to do something like the following then it won't work -</p>
<pre><code>public class MyLabel : StatelessComponent&lt;MyLabel.Props&gt;
{
  private readonly int _index;
  public MyLabel(Props props, int index) : base(props)
  {
    // THIS WON'T WORK - the constructor is not processed
    _index = index;
  }

  public override ReactElement Render()
  {
    return DOM.Label(
      new LabelAttributes { ClassName = props.ClassName },
      props.Value + &quot; (index: &quot; + _index + &quot;)&quot;
    );
  }

  public class Props
  {
    public string Value;
    public string ClassName;
  }
}
</code></pre>
<p>You <em>can</em> use instance members if you want to, you just can't rely on them being set in the constructor because the constructor is never called. <em>Side note: I'm thinking about trying to write a <a href="https://msdn.microsoft.com/en-us/magazine/dn879356.aspx">C# Analyser</a> to accompany these bindings so that any rules like this can be pointed out by the compiler, rather than you just having to remember them.</em></p>
<pre><code>public class MyLabel : StatelessComponent&lt;MyLabel.Props&gt;
{
  private int _index;
  public MyLabel(Props props) : base(props) { }

  public override ReactElement Render()
  {
    // Accessing instance fields and methods is fine, so long as it
    // isn't done in the constructor
    SetIndex();
    return DOM.Label(
      new LabelAttributes { ClassName = props.ClassName },
      props.Value + &quot; (index: &quot; + _index + &quot;)&quot;
    );
  }

  private void SetIndex()
  {
      _index = MagicStaticIndexGenerator.GetNext();
  }

  public class Props
  {
    public string Value;
    public string ClassName;
  }
}
</code></pre>
<p>You can also create custom components that have child elements. Just like &quot;DOM.Div&quot; takes an attributes reference (its &quot;Props&quot;, essentially) and then an array of child elements, the <strong>StatelessComponent</strong> class takes a params array after that first &quot;props&quot; argument.</p>
<p>This array has elements of type &quot;<strong>Any&lt;ReactElement, string&gt;</strong>&quot;, which means that it can be the result of a React factory method (such as &quot;Div&quot;) or it can be a string, so that text elements can be easily rendered. Or it can be any class that derives from <strong>StatelessComponent</strong> as <strong>StatelessComponent</strong> has an implicit cast operator to <strong>ReactElement</strong>.</p>
<p><em>(Note: There used to be a <strong>ReactElementOrText</strong> class mentioned here but it didn't offer any benefit over Bridge's generic <strong>Any&lt;,&gt;</strong> class, so I've changed the NuGet package - as of 1.3.0 / 27th September 2015 - and have updated this post accordingly).</em></p>
<p>So, we could create a simple &quot;wrapper&quot; component that renders a Div with a class and some children -</p>
<pre><code>public class MyWrapper : StatelessComponent&lt;MyWrapper.Props&gt;
{
  public MyWrapper(Props props, params Any&lt;ReactElement, string&gt;[] children)
    : base(props, children) { }

  public override ReactElement Render()
  {
    return DOM.Div(
      new Attributes { ClassName = props.ClassName },
      Children
    );
  }

  public class Props
  {
    public string ClassName;
  }
}
</code></pre>
<p>And render it like this:</p>
<pre><code>React.Render(
  new MyWrapper(new MyWrapper.Props { ClassName = &quot;wrapper&quot; },
    DOM.Span(null, &quot;Child1&quot;),
    DOM.Span(null, &quot;Child2&quot;),
    DOM.Span(null, &quot;Child3&quot;)
  ),
  Document.GetElementById(&quot;main&quot;)
);
</code></pre>
<p>or even just like:</p>
<pre><code>React.Render(
  new MyWrapper(new MyWrapper.Props { ClassName = &quot;wrapper&quot; },
    &quot;Child1&quot;,
    &quot;Child2&quot;,
    &quot;Child3&quot;
  ),
  Document.GetElementById(&quot;main&quot;)
);
</code></pre>
<p>The &quot;Children&quot; property accessed within <strong>MyWrapper</strong> is exposed through <strong>StatelessComponent</strong> and will echo back the child elements passed into the constructor when the component instance was declared. If there were no children specified then it will be an empty array.</p>
<p>This brings us on to the next topic - Keys for dynamic children. To aid React's reconciliation process in cases where dynamic children elements are specified, you should specify Key values for each item. Each Key should be consistent and unique within the parent component (for more details, read the &quot;<a href="https://facebook.github.io/react/docs/reconciliation.html#keys">Keys / Reconciliation</a>&quot; section from the Facebook docs).</p>
<p>If you were declaring React components in vanilla JavaScript, then this would be as easy as including a &quot;key&quot; value in the props object. Using these Bridge bindings, it's <em>almost</em> as simple - if your component needs to support an optional &quot;Key&quot; property then its Props class should include a &quot;Key&quot; property. And that's all that's required! You don't need to <em>set</em> anything to that Key inside your component, you merely need to allow it to be set on the props. React will accept numeric or string keys, so I would recommend that you declare the &quot;Key&quot; property as either an <strong>int</strong> or a <strong>string</strong> or as an <strong>Any&lt;int, string&gt;</strong>, which is built-in Bridge class that allows <em>either</em> of the value types to be used. To illustrate:</p>
<pre><code>public class MyListItem : StatelessComponent&lt;MyListItem.Props&gt;
{
  public MyListItem(Props props) : base(props) { }

  public override ReactElement Render()
  {
    return DOM.Li(null, props.Value);
  }

  public class Props
  {
    public Any&lt;int, string&gt; Key;
    public string Value;
  }
}
</code></pre>
<p><em>Note: In the earlier examples, the &quot;Child{x}&quot; elements were fixed at compile time and so didn't need Key properties to be set, but if you were displaying a list of search results that were based on data from an api call, for example, then these elements would NOT be fixed at compile time and so you should specify unique Key values for them</em>.</p>
<h3>&quot;Full&quot; Components</h3>
<p>So far, I've only talked about stateless components, which are like a slimmed-down version of full React components. But sometimes you need a state<em>ful</em> component, or one that supports the full React lifecycle.</p>
<p>For these times, there is another base class - simply called <strong>Component</strong>. This has <em>two</em> generic type parameters, one for the &quot;props&quot; data and for &quot;state&quot;. However, the constructor signature is the same as the <strong>StatelessComponent</strong>; it takes a props reference and then any children element that the component instance has. The state reference is controlled by the two React component lifecycle functions &quot;GetInitialState&quot; and &quot;SetState&quot;. &quot;GetInitialState&quot; is called when the component is first created and &quot;SetState&quot; can be used to not only update the internal &quot;state&quot; reference but also request that the component re-render.</p>
<p>The most basic example would be something like this:</p>
<pre><code>// Note: I've not even declared a class fortthe State, I've just used
// &quot;string&quot; since the state in this class is just a string value. But
// that's because I'm lazy, the state was more complicated then it
// could be a separate class, just like Props.
public class StatefulControlledTextInput
  : Component&lt;StatefulControlledTextInput.Props, string&gt;
{
  public StatefulControlledTextInput(Props props) : base(props) { }

  protected override string GetInitialState() { return &quot;&quot;; }

  public override ReactElement Render()
  {
    return DOM.Input(new InputAttributes
    {
      ClassName = props.ClassName,
      Type = InputType.Text,
      Value = state,
      OnChange = ev =&gt; SetState(ev.CurrentTarget.Value)
    });
  }

  public class Props
  {
    public string ClassName;
  }
}
</code></pre>
<p>Each time the input's value is changed, the component calls its own SetState function so that it can re-render with the new value (there's a <a href="https://facebook.github.io/react/docs/forms.html">good Facebook summary article</a> if you've forgotten the difference between &quot;controlled&quot; and &quot;uncontrolled&quot; components; the gist is the controlled components only raise events when the user requests that their values change, they <em>won't be redrawn</em> unless React cause them to redraw).</p>
<p>This isn't <em>all</em> that the <strong>Component</strong> class allows, though, it has support for the other React component lifecycle methods - for example, sometimes the &quot;OnChange&quot; event of a text input is raised when the content hasn't <em>really</em> changed (if you put focus in a text input and [Ctrl]-[C] / copy whatever value is in it and then [Ctrl]-[V] / paste that value straight back in, the OnChange event will be raised even though the new value is exactly the same as the old value). You might consider this redraw to be unacceptable. In which case, you could take advantage of the &quot;ShouldComponentUpdate&quot; function like this:</p>
<pre><code>public class StatefulControlledTextInput
  : Component&lt;StatefulControlledTextInput.Props, string&gt;
{
  public StatefulControlledTextInput(Props props) : base(props) { }

  protected override string GetInitialState() { return &quot;&quot;; }

  protected override bool ShouldComponentUpdate(
    StatefulControlledTextInput.Props nextProps,
    string nextState)
  {
    return (props != nextProps) || (state != nextState);
  }

  public override ReactElement Render()
  {
    return DOM.Input(new InputAttributes
    {
      ClassName = props.ClassName,
      Type = InputType.Text,
      Value = state,
      OnChange = ev =&gt; SetState(ev.CurrentTarget.Value)
    });
  }

  public class Props
  {
    public string ClassName;
  }
}
</code></pre>
<p>Now, in the cases where the input's value doesn't <em>really</em> change, the component's &quot;update&quot; will be bypassed.</p>
<p>Clearly, this is a trival example, but it demonstrates how you could do something more complicated along these lines. All of the other functions &quot;ComponentDidMount&quot;, &quot;ComponentDidUpdate&quot;, &quot;ComponentWillMount&quot;, &quot;ComponentWillReceiveProps&quot;, &quot;ComponentWillUnmount&quot; and &quot;ComponentWillUpdate&quot; are also supported.</p>
<p>And, of course, the <strong>Component</strong> base class has the same &quot;Children&quot; integration that <strong>StatelessComponent</strong> has and the same support for specifying a &quot;Key&quot; props value.</p>
<p>There is <em>one</em> little oddity to be aware of, though: In React, &quot;setState&quot; has (in my opinion) a slightly odd behaviour in that it will accept a &quot;partial state value&quot; that it will then merge with the current state reference. So if you had a <strong>MyComponentState</strong> class with properties &quot;Value1&quot; and &quot;Value2&quot; then you could, in vanilla JavaScript React, call setState({ Value1: whatever }) and it would take that &quot;Value1&quot; and overwrite the current &quot;Value1&quot; in the current state reference, leaving any existing &quot;Value2&quot; untouched. In these bindings, you must specify an entire State reference and this merging does not occur - the old State reference is replaced entirely by the new. This is largely because the &quot;SetState&quot; function in the bindings takes a full &quot;State&quot; class reference (C# doesn't really have a concept of a part-of-this-class representation) but it's also because I think that it's clearer this way; I think that you should be explicit about what you're setting State to and having it be a-bit-of-what-was-there-before and a-bit-of-something-new is not as clear (if you ask me) as a complete here-is-the-new-state reference.</p>
<h3>More to come</h3>
<p>In React, it is strongly recommended that props and state be considered to be immutable references. In the examples here I've used immutability-by-convention; the &quot;props&quot; classes have not actually been immutable types. I'm intending to write a follow-up article or two because there is more that I want to explore, such as how to use these bindings to write React apps in a &quot;Flux&quot;-like manner and how to take more advantage of genuinely immutable types. But, hopefully, this has been a nice enough introduction into the bindings and got you thinking about trying to use C# to write some React apps! Because, if you're aiming to write a web application in a &quot;Single Page Application&quot; style, if your application is of any serious complexity then you're going to end up with quite a lot of code - and, while I have a real soft spot for JavaScript, if it comes to maintaining a large app that's written in JavaScript or that's written in C# then I know which way <em>I</em> would lean! Thank goodness <a href="http://bridge.net">Bridge.net</a> has come along and let us combine JavaScript frameworks <em>with</em> C# :)</p>
<p class="PostTime">Posted at 23:29</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/react-and-flux-with-bridgenet">React (and Flux) with Bridge.net</a></li><li><a href="/react-and-flux-with-duocode">React and Flux with DuoCode</a></li><li><a href="/typescript-classes-for-react-flux-actions">TypeScript classes for (React) Flux actions</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/React" title="11 Posts">React</a></li></ul></div>
            <p class="Comments">
                <a href="/react-and-flux-with-bridgenet-redux#disqus_thread" data-disqus-identifier="92">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">19 August 2015</p><h2><a id="stronglytyped-react-with-bridgenet" href="/stronglytyped-react-with-bridgenet">Strongly-typed React (with Bridge.net)</a></h2>
<p>A few weeks ago, I wrote about using <a href="/react-and-flux-with-bridgenet">React with Bridge.net</a>. I described that I'd only written the bare minimum of bindings required to get my samples working - so, while I had a function for React.DOM.div -</p>
<pre><code>[Name(&quot;div&quot;)]
public extern static ReactElement Div(
  HTMLAttributes properties,
  params ReactElementOrText[] children
);
</code></pre>
<p>The <strong>HTMLAttributes</strong> class I had written really was the <em>bare</em> minimum:</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class HTMLAttributes
{
  public string className;
}
</code></pre>
<p>It's time to revisit this and build up my bindings library!</p>
<h3>A starting point</h3>
<p>An obvious resource to work from initially is the &quot;<a href="https://github.com/borisyankov/DefinitelyTyped/blob/master/react/react.d.ts">DefinitelyTyped</a>&quot; bindings that allow you to use React from TypeScript. But I'd identified a pattern that I didn't like with them in my earlier post - the type system isn't being used to as full effect as it could be. For example, in the declaration of &quot;input&quot; elements. Let me explain (and please bear with me, I need to go through a few steps to get to the point)..</p>
<p>The TypeScript bindings describe a function for creating input elements:</p>
<pre><code>React.DOM.input(props: HTMLAttributes, ...children: ReactNode[]): DOMElement
</code></pre>
<p>For any non-TypeScripters, this is a function that takes an argument named &quot;props&quot; that is of type <strong>HTMLAttributes</strong>, and then 0, 1, .. n arguments of type <strong>ReactNode</strong> that are wrapped up into an array (the same principle as &quot;params&quot; arguments in C#). It returns a <strong>DOMElement</strong> instance.</p>
<p><strong>HTMLAttributes</strong> has 115 of its own properties (such as &quot;className&quot;, &quot;disabled&quot; and &quot;itemScope&quot; - to take three at random) and extends <strong>DOMAttributes</strong>, which has 34 more properties (such as &quot;onChange&quot; and &quot;onDragStart&quot;).</p>
<p>The &quot;onChange&quot; property is a <strong>FormEventHandler</strong>, which is derived from <strong>EventHandler&lt;FormEvent&gt;</strong>, where <strong>EventHandler&lt;E&gt;</strong> is a delegate which has a single &quot;event&quot; argument of type &quot;E&quot; which returns no value. It's a callback, in other words.</p>
<p>This looks promising and is, on the whole, a good use of TypeScript's generics system.</p>
<p>However, I don't think it uses this system <em>enough</em>. The <strong>FormEvent</strong> (that the &quot;onChange&quot; property passes in the callback) is a specialisation of a <strong>SyntheticEvent</strong> type:</p>
<pre><code>interface FormEvent extends SyntheticEvent { }

interface SyntheticEvent {
  bubbles: boolean;
  cancelable: boolean;
  currentTarget: EventTarget;
  defaultPrevented: boolean;
  eventPhase: number;
  isTrusted: boolean;
  nativeEvent: Event;
  preventDefault(): void;
  stopPropagation(): void;
  target: EventTarget;
  timeStamp: Date;
  type: string;
}
</code></pre>
<p><em>(The <strong>EventTarget</strong>, which is what the &quot;target&quot; property is an instance of, is a DOM concept and is not a type defined by the React bindings, it just means that it is one of the DOM elements that are able to raise events).</em></p>
<p>The problem I have is that if we write code such as</p>
<pre><code>React.DOM.input({
  value: &quot;hi&quot;
  onChange: e =&gt; { alert(e.target.value); }
})
</code></pre>
<p>Then we'll get a TypeScript compile error because &quot;e.target&quot; is only known to be of type <strong>EventTarget</strong>, it is <em>not</em> known to be an input element and so it is <em>not</em> known to have a &quot;value&quot; property. But we're specifying this &quot;onChange&quot; property <em>while declaring an input element</em>.. the type system <em>should</em> know that the &quot;e.target&quot; reference will be an input!</p>
<p>In fact, in TypeScript, we actually have to skirt around the type system to make it work:</p>
<pre><code>// &quot;&lt;any&gt;&quot; means cast the &quot;e.target&quot; reference to the magic type &quot;any&quot;, which
// is like &quot;dynamic&quot; in C# - you can specify any property or method and the
// compiler will assume you know what you're doing and allow it (resulting
// in a runtime exception if you get it wrong)
React.DOM.input({
  value: &quot;hi&quot;
  onChange: e =&gt; { alert((&lt;any&gt;e.target).value); }
})
</code></pre>
<p>In my React bindings for <a href="http://bridge.net/">Bridge</a> I improved this by defining an <strong>InputAttributes</strong> type:</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class InputAttributes : HTMLAttributes
{
  public Action&lt;FormEvent&lt;InputEventTarget&gt;&gt; onChange;
  public string value;
}
</code></pre>
<p>And having a generic <strong>FormEvent&lt;T&gt;</strong> which inherits from <strong>FormEvent</strong> -</p>
<pre><code>[Ignore]
public class FormEvent&lt;T&gt; : FormEvent where T : EventTarget
{
  public new T target;
}
</code></pre>
<p>This means that the &quot;target&quot; property can be typed more specifically. And so, when you're writing this sort of code in C# with Bridge.net, you <em>can</em> write things like:</p>
<pre><code>// No nasty casts required! The type system knows that &quot;e.target&quot; is an
// &quot;InputEventTarget&quot; and therefore knows that it has a &quot;value&quot; property
// that is a string.
DOM.Input(new InputAttributes
{
  value = &quot;hi&quot;,
  onChange = e =&gt; Global.Alert(e.target.value)
})
</code></pre>
<p>This is great stuff! And I'm not changing how React works in any way, I'm just changing how we interpret the data that React is communicating; the event reference in the input's &quot;onChange&quot; callback has always had a &quot;target&quot; which had a &quot;value&quot; property, it's just that the TypeScript bindings don't tell us this through the type system.</p>
<p>So that's all good.. but it did require me to write more code for the bindings. The <strong>InputEventTarget</strong> class, for example, is one I had to define:</p>
<pre><code>[Ignore]
public class InputEventTarget : EventTarget
{
  public string value;
}
</code></pre>
<p>And I've already mentioned having to define the <strong>FormEvent&lt;T&gt;</strong> and <strong>InputAttributes</strong> classes..</p>
<p>What I'm saying is that these improvements do not come for free, they required some analysis and some further effort putting into the bindings (which is not to take anything away from DefinitelyTyped, by the way - I'm a big fan of the work in that repository and I'm very glad that it's available, both for TypeScript / React work I've done in the past <em>and</em> to use as a starting point for Bridge bindings).</p>
<p>Seeing how these more focussed / specific classes can improve things, I come to my second problem with the TypeScript bindings..</p>
<h3>Why must the HTMLAttributes have almost 150 properties??</h3>
<p>The place that I wanted to start in extending my (very minimal) bindings was in fleshing out the <strong>HTMLAttributes</strong> class. Considering that it had only a single property (&quot;className&quot;) so far, and that it would be used by so many element types, that seemed like a reasonable plan. But looking at the TypeScript binding, I felt like I was drowning in properties.. I realised that I wasn't familiar with <em>everything</em> that appeared in html5, but I was astonished by how many options there were - and convinced that they couldn't <em>all</em> be applicable to <em>all</em> elements types. So I picked one at random, of those that stood out as being completely unfamiliar to me: &quot;download&quot;.</p>
<p>w3schools has this to say about the <a href="http://www.w3schools.com/tags/att_a_download.asp">HTML &lt;a&gt; download Attribute</a>:</p>
<blockquote>
<p>The download attribute is new for the &lt;a&gt; tag in HTML5.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>The download attribute specifies that the target will be downloaded when a user clicks on the hyperlink.<br />
This attribute is only used if the href attribute is set.<br />
The value of the attribute will be the name of the downloaded file. There are no restrictions on allowed values, and the browser will automatically detect the correct file extension and add it to the file (.img, .pdf, .txt, .html, etc.).</p>
</blockquote>
<p>So it appears that this attribute is only applicable to anchor tags. Therefore, it would make more sense to <em>not</em> have a &quot;React.DOM.a&quot; function such as:</p>
<pre><code>[Name(&quot;a&quot;)]
public extern static ReactElement A(
  HTMLAttributes properties,
  params ReactElementOrText[] children
);
</code></pre>
<p>and, like the &quot;input&quot; function, to be more specific and create a new &quot;attributes&quot; type. So the function would be better as:</p>
<pre><code>[Name(&quot;a&quot;)]
public extern static ReactElement A(
  AnchorAttributes properties,
  params ReactElementOrText[] children
);
</code></pre>
<p>and the new type would be something like:</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class AnchorAttributes : HTMLAttributes
{
  public string download;
}
</code></pre>
<p>This would allow the &quot;download&quot; property to be pulled out of <strong>HTMLAttributes</strong> (so that it couldn't be a applied to a &quot;div&quot;, for example, where it has no meaning).</p>
<p>So one down! Many, many more to go..</p>
<p>Some properties are applicable to multiple element types, but these elements may not have anything else in common. As such, I think it would be more sensible to duplicate some properties in multiple attributes classes, rather than trying to come up with a complicated inheritance tree that tries to avoid any repeating of properties, at the cost of the complexities that inheritance can bring. For example, &quot;href&quot; is a valid attribute for both &quot;a&quot; and &quot;link&quot; tags, but these elements do not otherwise have much in common - so it might be better to have completely distinct classes</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class AnchorAttributes : HTMLAttributes
{
  public string href;
  public string download;
  // .. and other attributes specified to anchor tags
}

[Ignore]
[ObjectLiteral]
public class LinkAttributes : HTMLAttributes
{
  public string href;
  // .. and other attributes specified to link tags
}
</code></pre>
<p>than to try to create a base class</p>
<pre><code>[Ignore]
[ObjectLiteral]
public abstract class HasHrefAttribute : HTMLAttributes
{
  public string href;
}
</code></pre>
<p>which <strong>AnchorAttributes</strong> and <strong>LinkAttributes</strong> could be derived from. While it might <em>appear</em> initially to make sense, I imagine that it will all come unstuck quite quickly and you'll end up finding yourself wanting to inherit from multiple base classes and all sorts of things that C# doesn't like. I think this is a KISS over DRY scenario (I'd rather repeat &quot;public string href;&quot; in a few distinct places than try to tie the classes together in some convoluted manner).</p>
<h3>More type shenanigans</h3>
<p>So, with more thought and planning, I think a reduced <strong>HTMLAttributes</strong> class could be written <em>and</em> a range of attribute classes produced that make the type system work for us. I should probably admit that I haven't actually <em>done</em> any of that further thought or planning yet! I feel like I've spent this month coming up with grandiose schemes and then writing about doing them rather than actually getting them done! :D</p>
<p>Anyway, enough about my shortcomings, there's <em>another</em> issue I found while looking into this &quot;download&quot; attribute. Thankfully, it's a minor problem that can easily be solved with the way that bindings may be written for Bridge..</p>
<p>There was an issue on React's GitHub repo: &quot;<a href="https://github.com/facebook/react/issues/1337">Improve handling of download attribute</a>&quot; which says the following:</p>
<blockquote>
<p>Currently, the &quot;download&quot; attribute is handled as a normal attribute. It would be nice if it could be treated as a boolean value attribute when its value is a boolean. ... For example,</p>
<p>a({href: 'thing', download: true}, 'clickme'); // =&gt; &lt;a href=&quot;thing&quot; download&gt;clickme&lt;/a&gt;</p>
<p>a({href: 'thing', download: 'File.pdf'}, 'clickme'); // =&gt; &lt;a href=&quot;thing&quot; download=&quot;File.pdf&quot;&gt;</p>
</blockquote>
<p>This indicates that</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class AnchorAttributes : HTMLAttributes
{
  public string href;
  public string download;
  // .. and other attributes specified to anchor tags
}
</code></pre>
<p>is not good enough and that &quot;download&quot; needs to be allowed to be a string <em>or</em> a boolean.</p>
<p>This can be worked around by introducing a new class</p>
<pre><code>[Ignore]
public sealed class StringOrBoolean
{
  private StringOrBoolean() { }

  public static implicit operator StringOrBoolean(bool value)
    =&gt; new StringOrBoolean();

  public static implicit operator StringOrBoolean(string value)
    =&gt; new StringOrBoolean();
}
</code></pre>
<p>This looks a bit strange at first glance. But it is <em>only</em> be used to describe a way to pass information in a binding, that's why it's got the &quot;Ignore&quot; attribute on it - that means that this class will <em>not</em> be translated into any JavaScript by Bridge, it exists <em>solely</em> to tell the type system how one thing talks to another (my <a href="/react-and-flux-with-bridgenet">React with Bridge.net</a> post talked a little bit about this attribute, and others similar to it, that are used in creating Bridge bindings - so if you want to know more, that's a good place to start).</p>
<p>This explains why the &quot;value&quot; argument used in either of the implicit operators is thrown away - it's because it's never used by the binding code! It is <em>only</em> so that we can use this type in the attribute class:</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class AnchorAttributes : HTMLAttributes
{
  public string href;
  public StringOrBoolean download;
  // .. and other attributes specified to anchor tags
}
</code></pre>
<p>And this allows to then write code like</p>
<pre><code>DOM.a(new AnchorAttributes
{
  href: &quot;/instructions.pdf&quot;,
  download: &quot;My Site's Instructions.pdf&quot;
})
</code></pre>
<p><em>or</em></p>
<pre><code>DOM.a(new AnchorAttributes
{
  href: &quot;/instructions.pdf&quot;,
  download: true
})
</code></pre>
<p>We <em>only</em> require this class to exist so that we can tell the type system that React is cool with us giving a string value for &quot;download&quot; or a boolean value.</p>
<p>The &quot;ObjectLiteral&quot; attribute on these classes means that the code</p>
<pre><code>DOM.a(new AnchorAttributes
{
  href: &quot;/instructions.pdf&quot;,
  download: true
})
</code></pre>
<p>is not even translated into an instantiation of a class called &quot;<strong>AnchorAttributes</strong>&quot;, it is instead translated into a simple object literal -</p>
<pre><code>// It is NOT translated into this
React.DOM.a(
  Bridge.merge(
    new Bridge.React.AnchorAttributes(),
    { name: &quot;/instructions.pdf&quot;, download: true }
  )
)

// It IS just translated into this
React.DOM.a({ name: &quot;/instructions.pdf&quot;, download: true })
</code></pre>
<p>Again, this illustrates why the &quot;value&quot; argument was thrown away in the <strong>StringOrBoolean</strong> implicit operator calls - because those calls do not exist in the translated JavaScript.</p>
<h3>A nice bonus</h3>
<p>Another thing that I like about the &quot;ObjectLiteral&quot; attribute that I've used on these <strong>{Whatever}Attributes</strong> classes is that the translated code only includes the properties that have been explicitly set.</p>
<p>This means that, unlike in the TypeScript definitions, we don't have to declare all value types as nullable. If, for example, we have an attributes class for table cells - like:</p>
<pre><code>[Ignore]
[ObjectLiteral]
public class TableCellAttributes : HTMLAttributes
{
  public int colSpan;
  public int rowSpan;
}
</code></pre>
<p>and we have C# code like this:</p>
<pre><code>DOM.td(new TableCellAttributes { colSpan = 2 }, &quot;Hello!&quot;)
</code></pre>
<p>Then the resulting JavaScript is simply:</p>
<pre><code>React.DOM.td({ colSpan = 2 }, &quot;Hello!&quot;)
</code></pre>
<p>Note that the unspecified &quot;rowSpan&quot; property does <em>not</em> appear in the JavaScript.</p>
<p>If we <em>want</em> it to appear, then we can specify a value in the C# code -</p>
<pre><code>DOM.td(new TableCellAttributes { colSpan = 2, rowSpan = 1 }, &quot;Hello!&quot;)
</code></pre>
<p>That will be translated as you would expect:</p>
<pre><code>React.DOM.td({ colSpan = 2, rowSpan = 1 }, &quot;Hello!&quot;)
</code></pre>
<p>This has <em>two</em> benefits, actually, because not only do we not have to mark all of the properties as nullable (while that wouldn't be the end of the world, it's nicer - I think - to have the attribute classes have properties that match the html values as closely as possible and using simple value types does so) but it also keeps the generated JavaScript succint. Imagine the alternative, where <em>every</em> property was included in the JavaScript.. every time a div element was declared it would have 150 properties listed along with it. The JavaScript code would get huge, very quickly!*</p>
<p>* <em>(Ok, ok, it shouldn't be 150 properties for every div since half the point of this post is that it will be much better to create attribute classes that are as specific as possible - but there would still be a lot of properties that appear in element initialisations in the JavaScript which were not present in the C# code, it's much better only having the explicitly-specified values wind up in the translated output).</em></p>
<h4>A change in Bridge 1.8</h4>
<p>I was part way through writing about how pleased I was that unspecified properties in an [ObjectLiteral]-decorated class do not appear in the generated JavaScript when I decided to upgrade to Bridge 1.8 (which was just released two days ago).. and things stopped doing what I wanted.</p>
<p>With version 1.8, it seems like if you have an [ObjectLiteral] class then all of the properties <em>will</em> be included in the JavaScript - with default values if you did not specify them explicitly. So the example above:</p>
<pre><code>DOM.td(new TableCellAttributes { colSpan = 2 }, &quot;Hello!&quot;)
</code></pre>
<p>would result in something like:</p>
<pre><code>React.DOM.td({
    colSpan = 2,
    rowSpan = 0,
    id = null,
    className = null,
    // .. every other HTMLAttribute value here with a default value
  },
  &quot;Hello!&quot;
)
</code></pre>
<p>Which is a real pity.</p>
<p>The good news is that it appears to be as easy as <em>also</em> including an [Ignore] attribute on the type - doing so re-enables the behaviour that only includes explicitly-specifed properties in the JavaScript. However, I have been unable to find authoritative information on how [ObjectLiteral] <em>should</em> behave and how it should behave with or without [Ignore]. I had a quick flick through the 1.8 release notes and couldn't see any mention of this being an explicit change from 1.7 to 1.8 (but, I will admit, I wasn't <em>super</em> thorough in that investigation).</p>
<p>I only came across the idea of combining [Ignore] with [ObjectLiteral] when I was looking through their source code on <a href="https://github.com/bridgedotnet/">GitHub</a> (open source software, ftw!) and found a few places where there are checks for one of those attributes or <em>both</em> of them in some places.</p>
<p><em>(I've updated the code samples in this post to illustrate what I mean - now anywhere that has [ObjectLiteral] also has [Ignore]).</em></p>
<p>I'm a little bit concerned that this may change again in the future or that I'm not using these options correctly, but I've raised a bug in their forums and they've been very good at responding to these in the past - <a href="http://forums.bridge.net/forum/bridge-net-pro/bugs/495-objectliteral-classes-generate-values-for-all-properties-in-1-8-changed-from-1-7">ObjectLiteral classes generate values for all properties in 1.8 (changed from 1.7)</a>.</p>
<h3>What's next</h3>
<p>So.. how am I intending to progress this? Or am I going to just leave it as an interesting initial investigation, something that I've looked briefly into and then blogged about??</p>
<p>Well, no. Because I <em>am</em> actually planning to do some useful work on this! :) I'm a big fan of both React and Bridge and hope to be doing work with both of them, so moving this along is going to be a necessity as much as a nice idea to play around with. It's just a case of <em>how</em> to proceed - as the I-have-never-heard-of-this-new-download-attribute story goes to show, I'm not intimately familiar with every single tag and every single attribute, particular in regards to some of the less well-known html5 combinations.</p>
<p>Having done some research while writing this post, I think the best resource that I've found has been <a href="https://developer.mozilla.org/en-US/">MDN</a> (the Mozilla Developer Network). It seems like you can look up any tag - eg.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a</a></p>
<p>And then find details of every attribute that it has, along with compatibility information. For example, the <code>td</code> table cell documentation..</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td</a></p>
<p>.. mentions &quot;colSpan&quot; and &quot;rowSpan&quot;, with no particular mentions of compatibility (these have existed from day one, surely, and I don't think they're going to disappear any time soon) but also mentions attributes such as &quot;align&quot; and &quot;valign&quot; and highlights them as deprecated in html 4.01 and obsolete in html 5.</p>
<p>I'm strongly considering scraping these MDN pages and trying to parse out the attribute names and compatibility information (probably only supporting html5, since what's the point in supporting anything older when Bridge and React are new and and so I will be using them for writing new code and taking advantage of current standards). It doesn't provide type information (like &quot;colSpan&quot; is numeric or &quot;download&quot; may be a string or a boolean), but the <a href="https://github.com/borisyankov/DefinitelyTyped/blob/master/react/react.d.ts">DefinitelyTyped</a> definitions will go some way in helping out with that. And MDN says that its <a href="https://developer.mozilla.org/en-US/docs/MDN/About#Copyrights_and_licenses">wiki documents are available under the creative commons license</a>, so I believe that this would acceptable use of the data, so long as they are given the appropriate credit in the bindings code that I will eventually generate (which only seems fair!).</p>
<p>So I think that that is what will come next - trying to glean all of the information I need about the attributes specific to particular tags and then using this to produce bindings that take as much advantage of the C# type system as possible!</p>
<p>Unless I'm missing something and someone else can think of a better way? Anyone??</p>
<p><strong>Update (8th October 2015):</strong> I've had some suggestions from a member of the Bridge.net Team on how to reuse some of their work on html5 element definitions to make this a <em>lot</em> easier - so hopefully I'll have an update before too long based upon this. Before I can do so, the Bridge Team are looking into some improvements, such as allowing the &quot;CurrentTarget&quot; property of elements to be more strongly-typed (see <a href="http://forums.bridge.net/forum/general/feature-requests/630-open-461-generic-html5-element-and-event-classes">http://forums.bridge.net/forum/general/feature-requests/630-open-461-generic-html5-element-and-event-classes</a>), but hopefully we'll all have an update before too long!</p>
<p class="PostTime">Posted at 23:07</p><div class="Related"><h3>You may also be interested in:</h3><ul><li><a href="/react-and-flux-with-bridgenet">React (and Flux) with Bridge.net</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/React" title="11 Posts">React</a></li></ul></div>
            <p class="Comments">
                <a href="/stronglytyped-react-with-bridgenet#disqus_thread" data-disqus-identifier="90">Comments</a>
            </p>
    </div>
    <div class="Content ArchiveByTag">
        <p class="PostDate">23 July 2015</p><h2><a id="react-and-flux-with-bridgenet" href="/react-and-flux-with-bridgenet">React (and Flux) with Bridge.net</a></h2>
<p>A couple of months ago I talked about using <a href="/react-and-flux-with-duocode">DuoCode to write React applications in C#</a>. Since then I've been waiting for DuoCode to release information about their licensing and it's been a case of &quot;in a few days&quot; for weeks now, so I've been looking around to if there are any alternatives. A few weeks ago I tried out <a href="http://bridge.net/">Bridge.net</a> which is an open source C#-to-JavaScript translator. It's been public for about the same length of time as DuoCode and releases have been about one a month, similar to DuoCode.</p>
<p>Its integration with Visual Studio doesn't have a dedicated project type option and it doesn't support the debug-in-VS-when-running-in-IE facility that DuoCode has. The compiler doesn't seem to be quite as mature as DuoCode's, I've found a few bugs with it.. but I've reported them on their forum and they've addressed them all! I reported <a href="http://forums.bridge.net/forum/bridge-net-pro/bugs/310-name-conflicts-for-implemented-interface-method-with-multiple-signatures-present">one bug</a> in their forum and got a reply 14 minutes later saying that a fix had been pushed to GitHub - not bad service, that! :D</p>
<p>It currently uses something called NRefactory to parse C# but it's moving over to Roslyn soon*. It has recently acquired <a href="http://saltarelle-compiler.com/">Saltarelle</a>, another open source C#-to-JavaScript translator, so now has even more resources working on it. Enough introduction, though, you can find out more on <a href="http://bridge.net/">their website</a> if you want to!</p>
<p>* <em>(It seems that with the release of Visual Studio 2015 and with Roslyn hitting the mainstream, Mono is another project moving over from using NRefactory to Roslyn for its C# parsing, read more from Miguel de Icaza at <a href="http://tirania.org/blog/archive/2015/Jul-21.html">Roslyn and Mono</a> - I'm excited by this since I think Roslyn is really going to open some doors for C#'s extensibility in the future; Bridge, Mono and DuoCode are all examples of this.. I've also used it for some simple code analysis in the past, see <a href="/locating-todo-comments-with-roslyn">Locating TODO comments with Roslyn</a>).</em></p>
<h3>Getting started with Bridge.net</h3>
<p>One of the nice things about DuoCode is that it made it <em>extremely</em> easy to get started - you can create a new DuoCode project and run it directly. I believe that the Visual Studio project system has historically been a bit of a mess so there must have been a lot of work gone into this to make it so seamless.</p>
<p>Bridge is a bit different, though. The simplest way to get started is to create a new Class Library project and add the Bridge.net NuGet package. This will not make it directly executable but it does add a demo.html file (under &quot;Bridge/www&quot;) that you can browse to (either by locating it in the file system or by just right-clicking on it and selecting &quot;View in Browser&quot;).</p>
<p>With DuoCode, you have the option of splitting your work over multiple projects - the &quot;runnable&quot; project can reference one or more other DuoCode projects and everything will still work just fine. The problem may come, however, if you want your main project to also host some .net code - you might want to create  a <a href="http://www.asp.net/web-api">Web API</a> interface, for example, for the client-side code to call. But it's not possible to have a single project that translates <em>some</em> of its C# into JavaScript but also leaves some of it running as .net on the server.</p>
<p>In Bridge, I would recommend creating a standard ASP.net MVC web project and then adding one or more Bridge class libraries that copy their generated JavaScript into a location in the front end project. Bridge makes this easy as each project that pulls in the NuGet package creates a file &quot;Brige/bridge.json&quot; which allows you to specify where the output JavaScript should go. (Currently, adding the NuGet package <em>always</em> pulls in the &quot;getting started&quot; folders, such as &quot;Bridge/www&quot;, but I'm hopeful that a just-the-basics package will be available before too long - there's a forum thread I started about it on their site: <a href="http://forums.bridge.net/forum/community/help/311-disable-re-pulling-of-nuget-package-files-such-as-deploy-bat-when-updating">Refining the NuGet package</a>).</p>
<h3>Working with React</h3>
<p>I'm going to assume that you're familar with <a href="https://facebook.github.io/react/">React</a> and, to make my life easier in writing this article as much as anything, I'm going to assume no knowledge of my <a href="/react-and-flux-with-duocode">DuoCode/React post</a>. I've written before about writing <a href="/typescript-es6-classes-for-react-components-without-the-hacks">React components in TypeScript</a> and the same sort of concepts will be covered here - but, again, I'm going to assume you haven't read that and I'll start from scratch.</p>
<p>I'll start from the &quot;React.render&quot; method and work out from there. So first we need to write a binding to it. A binding is essentially a way to tell your C# at compile time about something that will be present at runtime.</p>
<p>To define &quot;React.render&quot; I'll create a class with an &quot;Ignore&quot; attribute on it - this instructs the translator that it does not need to generate any JavaScript from this C# class, it will be tied up to JavaScript already loaded in the browser (the assumption here, of course, is that the page that will execute the JavaScript translated from C# will also include the &quot;React.js&quot; library).</p>
<pre><code>using Bridge.Html5;

namespace Bridge.React
{
  [Name(&quot;React&quot;)]
  [Ignore]
  public static class React
  {
    [Name(&quot;render&quot;)]
    public extern static void Render(ReactElement element, Element container);
  }
}
</code></pre>
<p>Any references in the C# code to this class will try to access it within the &quot;Bridge.React&quot; namespace, so the C# compiler thinks its fully qualified class name is &quot;Bridge.React.React&quot;; in the JavaScript, though, this is <em>not</em> the case, the class is just called &quot;React&quot;. The Bridge.net attribute &quot;Name&quot; allows us to tell the translator this - so when the C# code is translated into JavaScript, any references to &quot;Bridge.React.React&quot; will be rewritten to simply &quot;React&quot;.</p>
<p>The same is applied to the method &quot;Render&quot; - in my C# code, I stick to the convention of pascal-casing function names, but the React library (like much other modern JavaScript) uses camel-cased function names.</p>
<p>Also note that the &quot;Render&quot; method does not have an implementation, it is marked as &quot;extern&quot;. This is more commonly used in C# code to access unmanaged DLL functions but the bindings to JavaScript that we're describing are a similar mechanism - no body for this method needs to be included since the method itself is implemented elsewhere (in the React library, in this case). In order to be marked as &quot;extern&quot;, a function must be decorated with an attribute (otherwise the compiler generates warnings). It doesn't matter <em>what</em> attribute is used, so the presence of the &quot;Name&quot; attribute is good enough.</p>
<p>For the function's arguments, the <strong>Element</strong> type is a Bridge.net class that represents DOM elements while the <strong>ReactElement</strong> is one that we must define as a binding -</p>
<pre><code>namespace Bridge.React
{
  [Ignore]
  public sealed class ReactElement
  {
    private ReactElement() { }
  }
}
</code></pre>
<p>This will never be explicitly instantiated, so it's a sealed class with a private constructor. It also does not need to be directly represented in the generated JavaScript, so it has an &quot;Ignore&quot; attribute on it too.</p>
<p>But, if <strong>ReactElement</strong> is never directly instantiated, how do we get instances of it? Well, there's the builtin React element creator functions (eg. &quot;React.DOM.div&quot;, &quot;React.DOM.span&quot;, etc..) and there are custom components. The builtin functions are nice and simple to writing bindings for, so I'll talk about them later and get to the interesting stuff..</p>
<h3>Creating React components in Bridge.net</h3>
<p>Since React 0.13 was released earlier this year, it has been possible to write JavaScript &quot;classes&quot; that may be used as React components. I write &quot;classes&quot; in quotes because a class is an ES6 concept but the code that transpilers emit (that take ES6 JavaScript and create equivalent code that will work on browsers that don't support ES6) is similar enough to the code generated by Bridge.net (and DuoCode) that we can use classes written in C# and rely upon the emitted JavaScript working nicely with React.. so long as a couple of rules are followed:</p>
<ol>
<li>These component classes will never be directly instantiated in code, so there should be no public constructor defined since it will never be called</li>
<li>The way that they <em>will</em> be initialised is by the React library, via a &quot;React.createElement&quot; call - this will take the type of the component and will create some form of object <em>based upon</em> the component but according to its own rules (these are implementation details of the React library and should just be considered to be magic; trying to take advantage of any particular implementation detail is a good way to write a component that will break in a future version of React)</li>
<li>The &quot;createElement&quot; call will also take a &quot;props&quot; reference, which will be set on the resulting React element - this is how a component is configured, rather than via the constructor (this &quot;props&quot; reference is private to the component and is guaranteed to be set as soon as the instance is created, so it's much more like &quot;constructor dependency injection&quot; than &quot;property setter dependency injection&quot;)</li>
<li>The components require a &quot;render&quot; method that returns a <strong>ReactElement</strong></li>
</ol>
<p>The surgery that React carries out to create components based upon classes is quite invasive, not only in how it new's-up an instance but also in how it investigates the &quot;props&quot; data. For each initialisation, it tears apart the provided props reference and creates a new object of its own devising, copying over the object properties from the original reference onto its own version.</p>
<p>This is problematic if the props reference you give is a class translated from C# since any methods (including property getters / setters) will be ignored by this process (React only copies properties that report true for &quot;hasOwnProperty&quot; and so ignores any class methods since these will be declared on the prototype of the class, not on the instance itself). The way to get around this is to wrap the props data in another object, one that has only a single field &quot;Props&quot;, which is a reference back to the original props data - then, when React copies the properties around, this value will be migrated over without issue. The only annoyance is that this data must be unwrapped again before you can use it.</p>
<p>However, because I'm so good to you, I've pulled most of this together into an abstract class that you may use to derive custom component classes from -</p>
<pre><code>using System;

namespace Bridge.React
{
  public abstract class Component&lt;TProps&gt;
  {
    public static ReactElement New&lt;TComponent&gt;(TProps props)
      where TComponent : Component&lt;TProps&gt;
    {
      if (props == null)
        throw new ArgumentNullException(&quot;props&quot;);

      return Script.Call&lt;ReactElement&gt;(
        &quot;React.createElement&quot;,
        typeof(TComponent),
        new PropsWrapper { Props = props }
      );
    }

    [Name(&quot;render&quot;)]
    public abstract ReactElement Render();

    [Name(&quot;unwrappedProps&quot;)]
    protected TProps props
    {
      get { return wrappedProps.Props; }
    }

    [Name(&quot;props&quot;)]
    private readonly PropsWrapper wrappedProps = null;

    [ObjectLiteral]
    private class PropsWrapper
    {
      public TProps Props;
    }
  }
}
</code></pre>
<p>There is a static &quot;New&quot; method that is used to create a <strong>ReactElement</strong> instance based upon the derived component class' type (using the &quot;React.createElement&quot; function). In the C# code, you call &quot;New&quot; with a &quot;props&quot; reference of the appropriate type and you get a <strong>ReactElement</strong> back. The &quot;appropriate type&quot; is the <strong>TProps</strong> generic type parameter of this base class. Making this a generic class means that calling code knows what data is required to create a new element instance (ie. a <strong>TProps</strong> instance) and the derived component class has a strongly-typed (again, <strong>TProps</strong>) reference to that props data.</p>
<p>There is a &quot;Render&quot; method that must be implemented on the derived class. It has a &quot;Name&quot; attribute to map my C# naming convention (of pascal-cased function names) onto React's convention (of camel-cased function names).</p>
<p>You can also see some messing about with the props data - the call to &quot;React.createElement&quot; uses a <strong>PropsWrapper</strong> which puts the &quot;props&quot; reference into a single property, as I described above. This will not be torn to shreds by React when it creates a new element. This data is then readable via the private &quot;wrappedProps&quot; property - since this is <em>private</em> to this base class, derived classes can not access it. They <em>have</em> to retrieve props data through the &quot;props&quot; property (which has type <strong>TProps</strong>, rather than <strong>PropsWrapper</strong>).</p>
<p>Now, there is some jiggery-pokery here, since the &quot;wrappedProps&quot; property has a &quot;Name&quot; attribute which indicates that this maps to a property called &quot;props&quot; in the JavaScript - but, as just described, this is a wrapper that keeps the real data safe from React's meddling. Similarly, the &quot;props&quot; property (which has &quot;protected&quot; accessibility and so is accessible by the derived type) has a &quot;Name&quot; attribute which maps it onto a property named &quot;unwrappedProps&quot; - this is <em>not</em> something that React has anything to do with, it's only to avoid clashing with the <em>real</em> &quot;props&quot; reference in the output JavaScript, while allowing C# code to be written that accesses a &quot;props&quot; property that is an <em>unwrapped</em> version of the props data.</p>
<p>Wow, that all sounds really confusing! But the upshot is that you can create a component as easily as:</p>
<pre><code>using Bridge.React;

namespace BridgeExamples
{
  public class WelcomeComponent : Component&lt;WelcomeComponent.Props&gt;
  {
    public static ReactElement New(Props props)
    {
      return New&lt;WelcomeComponent&gt;(props);
    }
    private WelcomeComponent() { }

    public override ReactElement Render()
    {
      return DOM.Div(null, &quot;Hi &quot; + props.Name);
    }

    public class Props
    {
      public Props(string name)
      {
        Name = name;
      }
      public string Name { get; private set; }
    }
  }
}
</code></pre>
<p>Note that the &quot;Render&quot; method accesses &quot;props.Name&quot; directly - all of the wrapping / unwrapping is hidden away in the base class, the derived class is happily oblivious to all that <strong>PropsWrapper</strong> madness.</p>
<p>Also note that the constructor has been declared as private, which is important since these components should never be instantiated directly - they should <em>only</em> be brought into existence via that &quot;React.createElement&quot; function. To this end, a static &quot;New&quot; function is present (which calls the static &quot;New&quot; function on the base class).</p>
<p>(One <em>more</em> note - there's an attribute used by the <strong>Component</strong> base class that I haven't explained: &quot;ObjectLiteral&quot;, I'll come back to this later..)</p>
<p>Bringing all this together, we could use this component in code such as:</p>
<pre><code>React.Render(
  WelcomeComponent.New(new WelcomeComponent.Props(name: &quot;Ted&quot;)),
  Document.GetElementById(&quot;main&quot;)
);
</code></pre>
<p>But before doing so, we'd better get back to the builtin React element creation functions..</p>
<p><em>Warning (July 2015): The code above will actually fail at runtime with the current version of Bridge (1.7) because of <a href="http://forums.bridge.net/forum/bridge-net-pro/bugs/314-closed-306-failure-to-identify-generic-static-method-on-derived-class-as-call-targeti">a bug I reported in their forums</a> - however this has been fixed and will be included in the next release. I'm being optimistic and hoping that this article will be relevant in the future when this bug is just a distant memory :) Until the version after 1.7 is released, replace the line</em></p>
<pre><code>return New&lt;WelcomeComponent&gt;(props);
</code></pre>
<p><em>with</em></p>
<pre><code>return Component&lt;WelcomeComponent.Props&gt;.New&lt;WelcomeComponent&gt;(props);
</code></pre>
<p><em>and it will work fine. But in the future the less verbose version shown in the <strong>WelcomeComponent</strong> example will be safe.</em></p>
<h3>Bindings for the regular DOM element functions</h3>
<p>I skirted around the DOM functions such as React.DOM.div, React.DOM.span, etc.. earlier, so let's deal with them now.</p>
<p>In order to do so, I need to teach the type system a little trick. A component's &quot;Render&quot; method must always return a genuine <strong>ReactElement</strong>, but when specifying child elements for use in a component we must be able to provide <em>either</em> a <strong>ReactElement</strong> <em>or</em> a simple string. This is what was happening in the line from the <strong>WelcomeComponent</strong>:</p>
<pre><code>return DOM.Div(null, &quot;Hi &quot; + props.Name);
</code></pre>
<p>The null value is for the attributes of the div (and is interpreted as &quot;this div does not need any html attributes&quot;), while the second argument is a string that is the sole child element of that div.</p>
<p>So we need a way to say that the child element argument value(s) for a DOM.div call may be either a <strong>ReactElement</strong> or a string. In some languages (such as TypeScript and F#), we could consider a union type, but here I'll cheat a bit and declare the &quot;React.DOM.Div&quot; function as:</p>
<pre><code>namespace Bridge.React
{
  [Name(&quot;React.DOM&quot;)]
  [Ignore]
  public static class DOM
  {
    [Name(&quot;div&quot;)]
    public extern static ReactElement Div(
      HTMLAttributes properties,
      params ReactElementOrText[] children
    );
</code></pre>
<p>and then define a new <strong>ReactElementOrText</strong> type -</p>
<pre><code>namespace Bridge.React
{
  [Ignore]
  public sealed class ReactElementOrText
  {
    private ReactElementOrText() { }
    [Ignore]
    public extern static implicit operator ReactElementOrText(string text);
    [Ignore]
    public extern static implicit operator ReactElementOrText(ReactElement element);
  }
</code></pre>
<p>This is another class with an &quot;Ignore&quot; attribute since it does not require any JavaScript to be generated for it, it's just to provide information to the C# compiler. It means that anywhere that a <strong>ReactElementOrText</strong> type is specified as an argument type, it is valid to provide either a <strong>ReactElement</strong> or a string. (The &quot;Ignore&quot; attributes on the functions are only present so that they may be identified as &quot;extern&quot; - as described earlier, an &quot;extern&quot; function <em>must</em> be decorated with an attribute of some kind).</p>
<p>The <strong>DOM</strong> class makes further of the &quot;Name&quot; attribute, ensuring that any accesses in C# to &quot;Bridge.React.DOM&quot; are replaced with just &quot;React.DOM&quot; in the generated JavaScript.</p>
<p>The final piece of the puzzle is the <strong>HTMLAttributes</strong> class -</p>
<pre><code>using Bridge;

namespace Bridge.React
{
  [ObjectLiteral]
  public class HTMLAttributes
  {
    public string className;
  }
}
</code></pre>
<p>As you can probably tell, this is <em>not</em> the full-featured React interface (&quot;className&quot; is <em>not</em> the only attribute that you can add to a div!) - at this point in time, it's still early days for the bindings that I'm writing for Bridge.net / React, so I've cut some corners. You'll see further down that I've not done all of the bindings for the DOM elements either! But hopefully this article is enough to get you up and running, then you can add to it yourself as you need more. (I'll also link to a repo at the end of the post..)</p>
<p><strong>HTMLAttributes</strong> is another type that we don't directly want to include in the generated JavaScript. If we have the C# line -</p>
<pre><code>return DOM.Div(new HTMLAttributes { className = &quot;welcome&quot; }, &quot;Hello!&quot;);
</code></pre>
<p>we want this to be translated into the following:</p>
<pre><code>return React.DOM.div({ className = &quot;welcome&quot; }, &quot;Hello!&quot;);
</code></pre>
<p>This is idiomatic React-calling code.</p>
<p>Bridge.net has support to instruct the compiler to interpret class constructors in this way; through use of the &quot;ObjectLiteral&quot; attribute. When a class that is decorated with this attribute has its constructor called in C#, the generated JavaScript will just use the object literal notation rather than actually creating a full class instance. Note that this means that no JavaScript will be generated for that class, so the <strong>HTMLAttributes</strong> class does not appear in the JavaScript at any point.</p>
<p>We saw this &quot;ObjectLiteral&quot; attribute used earlier, on the <strong>Component</strong> base class - it was used for the wrapper around the props data. That wrapper is only used to nest the real &quot;props&quot; reference inside a property so that React's internals don't try to mess with it. It would be unnecessary to wrap that reference up inside a full class instance, it is more sensible for the generated JavaScript to be simply -</p>
<pre><code>return React.createElement(TComponent, { props: props });
</code></pre>
<p>as opposed to something like</p>
<pre><code>return React.createElement(
  TComponent,
  Bridge.merge(
    new Bridge.React.Component.PropsWrapper$1(TProps)(),
    { props: props }
  )
);
</code></pre>
<p>(which is what Bridge would emit if the <strong>PropsWrapper</strong> type did <em>not</em> have the &quot;ObjectLiteral&quot; attribute on it).</p>
<h3>More DOM bindings..</h3>
<p>As with the poorly-populated <strong>HTMLAttributes</strong> class, I also haven't written too many DOM element bindings yet. All I've got so far is &quot;div&quot;, &quot;h1&quot;, &quot;input&quot; and &quot;span&quot; - these have been enough for the sample projects I've started to experiment with integrating Bridge and React. However, the good news is that these few bindings illustrate enough principles that it should be clear how to write more as you need them.</p>
<p>The element creation functions that I have are as such:</p>
<pre><code>using Bridge;

namespace Bridge.React
{
  [Name(&quot;React.DOM&quot;)]
  [Ignore]
  public static class DOM
  {
    [Name(&quot;div&quot;)]
    public extern static ReactElement Div(
      HTMLAttributes properties,
      params ReactElementOrText[] children
    );
    [Name(&quot;h1&quot;)]
    public extern static ReactElement H1(
      HTMLAttributes properties,
      params ReactElementOrText[] children
    );
    [Name(&quot;input&quot;)]
    public extern static ReactElement Input(
      InputAttributes properties,
      params ReactElementOrText[] children
    );
    [Name(&quot;span&quot;)]
    public extern static ReactElement Span(
      HTMLAttributes properties,
      params ReactElementOrText[] children
    );
  }
}
</code></pre>
<p>&quot;Span&quot; and &quot;H1&quot; are just the same as &quot;Div&quot;.</p>
<p>&quot;Input&quot; is interesting, though..</p>
<p>I started by following the same basic pattern for the <strong>InputAttribute</strong> type as you would find in the <a href="https://github.com/borisyankov/DefinitelyTyped/tree/master/react">React bindings for TypeScript</a> - there is an &quot;onChange&quot; callback which provides a <strong>FormEvent</strong> instance, which is a type that is derived from <strong>SyntheticEvent</strong> (names taken directly from the TypeScript binding).</p>
<p>The big difference is that the TypeScript bindings do not expose a &quot;target&quot; property on <strong>FormEvent</strong> to tie the event back to the element that it relates to, even though this information is available on the React event. I've exposed this information as the &quot;target&quot; property on <strong>FormEvent</strong> <em>and</em> exposed it as a known-type using the generic <strong>FormEvent</strong> class - the <strong>InputAttributes</strong> has an &quot;onChange&quot; type of <strong>Action&lt;FormEvent&lt;InputEventTarget&gt;&gt;</strong> which means that the type of &quot;target&quot; on the <strong>FormEvent</strong> will be an <strong>InputEventTarget</strong>. This allows us to query the input's value in the onChange callback, something that is a bit awkward with the TypeScript bindings.</p>
<p>(This is only possible because the React model exposes this information - bindings do not include their own logic, they <em>only</em> describe to the Bridge compiler how to interact with an existing library).</p>
<pre><code>using Bridge;

namespace Bridge.React
{
  [ObjectLiteral]
  public class InputAttributes : HTMLAttributes
  {
    public Action&lt;FormEvent&lt;InputEventTarget&gt;&gt; onChange;
    public string value;
  }

  [Ignore]
  public class FormEvent&lt;T&gt; : FormEvent where T : EventTarget
  {
    public new T target;
  }

  [Ignore]
  public class FormEvent : SyntheticEvent
  {
    public EventTarget target;
  }

  [Ignore]
  public class SyntheticEvent
  {
    public bool bubbles;
    public bool cancelable;
    public bool defaultPrevented;
    public Action preventDefault;
    public Action stopPropagation;
    public string type;
  }

  [Ignore]
  public class InputEventTarget : EventTarget
  {
    public string value;
  }

  [Ignore]
  public class EventTarget { }
}
</code></pre>
<p>There are obviously more properties that belong on the <strong>InputAttribute</strong> type (such as &quot;onKeyDown&quot;, &quot;onKeyPress&quot;, &quot;onKeyUp&quot; and many others) but for now I just wanted to write enough to prove the concept.</p>
<h3>Flux</h3>
<p>There's nothing that requires that you use the Flux architecture when you're using React, but I think it makes a huge amount of sense. When I was getting to grips with the React library, I found myself moving towards a similar solution before I'd read up on Flux - so when I <em>did</em> read about it, it was like someone had taken the vague ideas I'd had, tightened them all up and hammmered out the rough edges.</p>
<p>The thing with it is, it really is just a set of architectural guidelines, it's <em>not</em> an actual library like React. It explains that you have &quot;Stores&quot; that manage state for the application - these Stores listen out for events that may require that they change their current state. This state is displayed using React, basically. The events that the Stores listen out for may be the result of a user interacting with the React elements or they may be raised by an API, informing the application that data that the user requested has arrived.</p>
<p>The piece in the middle is the &quot;Dispatcher&quot; and is effectively a queue that events can be pushed on (by user interactions or whatever else) and listened out for by the Stores - any events that a Store is not interested in, it ignores.</p>
<p><em>Asynchronous processes are quite easily handled in this arrangement because you can fire off an event as soon as an async request starts (in case some sort of loading spinner is desired) and then fire off another event when the data arrives (or when it times out or errors in some other way). Whatever happens, it's just events being raised and then received by interested Stores; Stores which alter their state and get React to re-render (if state changes were, in fact, required).</em></p>
<p>Using C# to write such a Dispatcher queue is really easy. Internally, it uses a C# event to make it easy to register (and then to call) as many listeners as required.</p>
<p><em>When compiled for the <a href="https://msdn.microsoft.com/en-us/library/8bs2ecf4(v=vs.110).aspx">CLR</a>, events are translated into IL that does all sorts of clever magic to behave well (and efficiently) in a multi-threaded environment. But here, it will be translated into JavaScript for the browser, which is single-threaded! So everything's very simple in the generated JavaScript</em> and <em>the C#.</em></p>
<pre><code>using System;

namespace Bridge.React
{
  public class AppDispatcher
  {
    private event Action&lt;DispatcherMessage&gt; _dispatcher;

    public void Register(Action&lt;DispatcherMessage&gt; callback)
    {
      _dispatcher += callback;
    }

    public void HandleViewAction(IDispatcherAction action)
    {
      if (action == null)
        throw new ArgumentNullException(&quot;action&quot;);

      _dispatcher(new DispatcherMessage(MessageSourceOptions.View, action));
    }

    public void HandleServerAction(IDispatcherAction action)
    {
      if (action == null)
        throw new ArgumentNullException(&quot;action&quot;);

      _dispatcher(new DispatcherMessage(MessageSourceOptions.Server, action));
    }
  }

  public class DispatcherMessage
  {
    public DispatcherMessage(MessageSourceOptions source, IDispatcherAction action)
    {
      if ((source != MessageSourceOptions.Server) &amp;&amp; (source != MessageSourceOptions.View))
        throw new ArgumentOutOfRangeException(&quot;source&quot;);
      if (action == null)
        throw new ArgumentNullException(&quot;action&quot;);

      Source = source;
      Action = action;
    }

    public MessageSourceOptions Source { get; private set; }
    public IDispatcherAction Action { get; private set; }
  }

  public enum MessageSourceOptions { Server, View }

  public interface IDispatcherAction { }
}
</code></pre>
<p>When you read about Flux events in JavaScript-based tutorials, you will see mention of &quot;Actions&quot; and &quot;Action Creators&quot;. Actions will be JavaScript objects with some particular properties that describe what happened. Action Creators tend to be functions that take some arguments and generate these objects. In C#, I think it makes much more sense for Actions to be classes - that way the Action Creators are effectively just the Actions' constructors!</p>
<p><img src="/Content/Images/Posts/FluxDiagram.png" alt="The Flux Architecture" title="The Flux Architecture" /></p>
<p>The <strong>AppDispatcher</strong> I've included code for above expects actions to be classes that share a common interface: <strong>IDispatcherAction</strong>. This is an &quot;empty interface&quot; and is just used to identify a class as being an action (you might want to search a solution for all Dispatcher actions, for example - you could do this by locating all implementations of <strong>IDispatcherAction</strong>). I wrote about this in terms of TypeScript earlier in the year and much of the same holds true here - so read more at <a href="/typescript-classes-for-react-flux-actions">TypeScript classes for (React) Flux actions</a> if this sounds interesting (or confusing).</p>
<p><em>(Each action is wrapped in a <strong>DispatcherMessage</strong>, which describes it as being either a &quot;Server&quot; or &quot;View&quot; action. A Server action would tend to be a callback from an API event, as opposed to a key press that alters a particular editable field - which would be a View action. Differentiating between the two is a common practice but is optional, so you could drop the <strong>DispatcherMessage</strong> entirely if you wanted to and have the Dispatcher only deal with <strong>IDispatcherAction</strong> implementations. The only really compelling reasons I've encountered for differentiating between the two is that you might want to skip some forms of validation for Server actions since it may be presumed that data from the server is already known to be good).</em></p>
<h3>A complete example</h3>
<p>If you want to try any of this out (particularly if you don't feel like trying to piece it all together from the various code samples in this post!) then you can find a complete sample in a Bitbucket repo: <a href="https://bitbucket.org/DanRoberts/reactbridgedotnet/">ReactBridgeDotNet</a>.</p>
<p>It's a web project that follows the structure I outlined at the top of this post - an MVC project to &quot;host&quot; and then Bridge projects to generate JavaScript from C#; one for the React bindings and another for the logic of the app.</p>
<p>The app itself is very, very simple - it's just a text box that doesn't want to be empty. If you clear it then you get a validation message. Any changes that you make to the input box are communicated to the app as Dispatcher actions, each of which results in a full re-render (in a complex app, React's virtual DOM ensures that this is done in an efficient manner, but in such a small example as this it's probably impossible to tell). Meanwhile, a label alongside the input box is updated with the current time - this is done to illustrate how non-user events (such as API data-retrieved events, for example) may be dealth with in exactly the same way as user events; they go through the Dispatcher and a Store deals with applying these channels to its internal state. Have fun!</p>
<p class="PostTime">Posted at 21:17</p><div class="Related"><h3>You may also be interested in (see <a href="/automating-suggested-related-posts-links-for-my-blog-posts">here</a> for information about how these are generated):</h3><ul><li><a href="/react-and-flux-with-bridgenet-redux">React (and Flux) with Bridge.net - Redux</a></li><li><a href="/react-and-flux-with-duocode">React and Flux with DuoCode</a></li><li><a href="/typescript-classes-for-react-flux-actions">TypeScript classes for (React) Flux actions</a></li></ul></div><div class="Tags"><label>Tags:</label><ul><li><a href="/Archive/Tag/Bridge" title="12 Posts">Bridge</a></li><li><a href="/Archive/Tag/React" title="11 Posts">React</a></li></ul></div>
            <p class="Comments">
                <a href="/react-and-flux-with-bridgenet#disqus_thread" data-disqus-identifier="87">Comments</a>
            </p>
    </div>

        <script type="text/javascript">
            (function () {
                var s = document.createElement("script");
                s.type = "text/javascript";
                s.async = true;
                s.src = "https://" + disqus_shortname + ".disqus.com/count.js";
                (document.getElementsByTagName("HEAD")[0] || document.getElementsByTagName("BODY")[0]).appendChild(s);
            }());
        </script>

				<div class="Footer">
					 Productive Rage 2011 - 2022
				</div>
			</div>

			<div class="SideBar">
				<div class="About">
					<h2>About</h2>
					<p>Dan is a big geek who likes making stuff with computers! He can be quite outspoken so clearly needs a blog :)</p>
					<p>In the last few minutes he seems to have taken to referring to himself in the third person. He's quite enjoying it.</p>
					<p><a href="mailto:dangger36@gmail.com" class="Email">dangger36@gmail.com</a></p>
				</div>
				<div class="Search">
<form action="/Search" autocomplete="off" class="Search" method="get">						<div>
							<label class="SearchField">
								<span class="text">Site Search</span>
								<input type="text" class="SiteSearch" name="term" value="" />
							</label>
							<input type="submit" class="SiteSearchSubmit" value="Search" />
						</div>
</form>				</div>
				<div class="Recent"><h2>Recent Posts</h2><ul><li><a href="/so-what-is-machine-learning-nocodeintro">So.. what is machine learning? (#NoCodeIntro)</a></li><li><a href="/parallelising-linq-work-in-c-sharp">Parallelising (LINQ) work in C#</a></li><li><a href="/automating-suggested-related-posts-links-for-my-blog-posts-part-2">Automating &quot;suggested / related posts&quot; links for my blog posts - Part 2</a></li><li><a href="/automating-suggested-related-posts-links-for-my-blog-posts">Automating &quot;suggested / related posts&quot; links for my blog posts</a></li><li><a href="/language-detection-and-wordsinsentence-classification-in-c-sharp">Language detection and words-in-sentence classification in C#</a></li></ul><div class="RSSFeedLink"><a href="https://www.productiverage.com/feed">RSS Feed</a></div></div>
				<div class="Featured"><h2>Highlights</h2><ul><li><a href="/face-or-no-face-finding-faces-in-photos-using-c-sharp-and-accordnet">Face or no face (finding faces in photos using C# and Accord.NET)</a></li><li><a href="/when-a-disk-cache-performs-better-than-an-inmemory-cache-befriending-the-net-gc">When a disk cache performs better than an in-memory cache (befriending the .NET GC)</a></li><li><a href="/performance-tuning-a-bridgenet-react-app">Performance tuning a Bridge.NET / React app</a></li><li><a href="/creating-a-c-sharp-roslyn-analyser-for-beginners-by-a-beginner">Creating a C# (&quot;Roslyn&quot;) Analyser - For beginners by a beginner</a></li><li><a href="/translating-vbscript-into-c-sharp">Translating VBScript into C#</a></li><li><a href="/entity-framework-projections-to-immutable-types-ienumerable-vs-iqueryable">Entity Framework projections to Immutable Types (IEnumerable vs IQueryable)</a></li></ul></div>
				<div class="History"><h2>Archives</h2><ul><li><a href="/Archive/2/2022">February 2022 (1)</a></li><li><a href="/Archive/8/2021">August 2021 (1)</a></li><li><a href="/Archive/4/2021">April 2021 (2)</a></li><li><a href="/Archive/3/2021">March 2021 (1)</a></li><li><a href="/Archive/8/2020">August 2020 (3)</a></li><li><a href="/Archive/7/2019">July 2019 (2)</a></li><li><a href="/Archive/9/2018">September 2018 (1)</a></li><li><a href="/Archive/4/2018">April 2018 (1)</a></li><li><a href="/Archive/3/2018">March 2018 (1)</a></li><li><a href="/Archive/7/2017">July 2017 (1)</a></li><li><a href="/Archive/6/2017">June 2017 (1)</a></li><li><a href="/Archive/2/2017">February 2017 (1)</a></li><li><a href="/Archive/11/2016">November 2016 (1)</a></li><li><a href="/Archive/9/2016">September 2016 (2)</a></li><li><a href="/Archive/8/2016">August 2016 (1)</a></li><li><a href="/Archive/7/2016">July 2016 (1)</a></li><li><a href="/Archive/6/2016">June 2016 (1)</a></li><li><a href="/Archive/5/2016">May 2016 (3)</a></li><li><a href="/Archive/3/2016">March 2016 (3)</a></li><li><a href="/Archive/2/2016">February 2016 (2)</a></li><li><a href="/Archive/12/2015">December 2015 (1)</a></li><li><a href="/Archive/11/2015">November 2015 (2)</a></li><li><a href="/Archive/8/2015">August 2015 (3)</a></li><li><a href="/Archive/7/2015">July 2015 (1)</a></li><li><a href="/Archive/6/2015">June 2015 (1)</a></li><li><a href="/Archive/5/2015">May 2015 (2)</a></li><li><a href="/Archive/4/2015">April 2015 (1)</a></li><li><a href="/Archive/3/2015">March 2015 (1)</a></li><li><a href="/Archive/1/2015">January 2015 (2)</a></li><li><a href="/Archive/12/2014">December 2014 (1)</a></li><li><a href="/Archive/11/2014">November 2014 (1)</a></li><li><a href="/Archive/10/2014">October 2014 (2)</a></li><li><a href="/Archive/9/2014">September 2014 (2)</a></li><li><a href="/Archive/8/2014">August 2014 (1)</a></li><li><a href="/Archive/7/2014">July 2014 (1)</a></li><li><a href="/Archive/6/2014">June 2014 (1)</a></li><li><a href="/Archive/5/2014">May 2014 (2)</a></li><li><a href="/Archive/2/2014">February 2014 (1)</a></li><li><a href="/Archive/1/2014">January 2014 (1)</a></li><li><a href="/Archive/12/2013">December 2013 (1)</a></li><li><a href="/Archive/11/2013">November 2013 (1)</a></li><li><a href="/Archive/10/2013">October 2013 (1)</a></li><li><a href="/Archive/8/2013">August 2013 (3)</a></li><li><a href="/Archive/7/2013">July 2013 (3)</a></li><li><a href="/Archive/6/2013">June 2013 (1)</a></li><li><a href="/Archive/5/2013">May 2013 (2)</a></li><li><a href="/Archive/4/2013">April 2013 (1)</a></li><li><a href="/Archive/3/2013">March 2013 (8)</a></li><li><a href="/Archive/2/2013">February 2013 (2)</a></li><li><a href="/Archive/1/2013">January 2013 (2)</a></li><li><a href="/Archive/12/2012">December 2012 (3)</a></li><li><a href="/Archive/11/2012">November 2012 (4)</a></li><li><a href="/Archive/9/2012">September 2012 (1)</a></li><li><a href="/Archive/8/2012">August 2012 (1)</a></li><li><a href="/Archive/7/2012">July 2012 (3)</a></li><li><a href="/Archive/6/2012">June 2012 (3)</a></li><li><a href="/Archive/5/2012">May 2012 (2)</a></li><li><a href="/Archive/2/2012">February 2012 (3)</a></li><li><a href="/Archive/1/2012">January 2012 (4)</a></li><li><a href="/Archive/12/2011">December 2011 (7)</a></li><li><a href="/Archive/8/2011">August 2011 (2)</a></li><li><a href="/Archive/7/2011">July 2011 (1)</a></li><li><a href="/Archive/5/2011">May 2011 (1)</a></li><li><a href="/Archive/4/2011">April 2011 (2)</a></li><li><a href="/Archive/3/2011">March 2011 (3)</a></li></ul><div class="EveryTitle"><a href="/Archive/All">Every Post Title</a></div></div>
			</div>

		</div>
	</div>

	<script type="text/javascript" src="/Scripts/autocomplete.js"></script>
	<script type="text/javascript" src="/Scripts/prettify.js"></script>
	<script type="text/javascript" src="/Scripts/Site.js"></script>
	<script type="text/javascript" src="/Scripts/IndexSearchGenerator.js"></script>
	<script type="text/javascript" src="/Scripts/SearchTermHighlighter.js"></script>
	<script type="text/javascript" src="/Scripts/SearchPage.js"></script>
	<script type="text/javascript" src="/Scripts/LZString.js"></script>

</body>
</html>
